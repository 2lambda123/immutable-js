{"version":3,"sources":["../../../node_modules/browser-pack/_prelude.js","../../../dist/immutable.js","../../../node_modules/base64-js/index.js","../../../node_modules/buffer/index.js","../../../node_modules/ieee754/index.js","../../../node_modules/marked/lib/marked.js","../../../node_modules/process/browser.js","../../../node_modules/react-router/modules/actions/LocationActions.js","../../../node_modules/react-router/modules/behaviors/ImitateBrowserBehavior.js","../../../node_modules/react-router/modules/behaviors/ScrollToTopBehavior.js","../../../node_modules/react-router/modules/components/DefaultRoute.js","../../../node_modules/react-router/modules/components/Link.js","../../../node_modules/react-router/modules/components/NotFoundRoute.js","../../../node_modules/react-router/modules/components/Redirect.js","../../../node_modules/react-router/modules/components/Route.js","../../../node_modules/react-router/modules/components/RouteHandler.js","../../../node_modules/react-router/modules/index.js","../../../node_modules/react-router/modules/locations/HashLocation.js","../../../node_modules/react-router/modules/locations/HistoryLocation.js","../../../node_modules/react-router/modules/locations/RefreshLocation.js","../../../node_modules/react-router/modules/mixins/FakeNode.js","../../../node_modules/react-router/modules/mixins/Navigation.js","../../../node_modules/react-router/modules/mixins/NavigationContext.js","../../../node_modules/react-router/modules/mixins/RouteHandler.js","../../../node_modules/react-router/modules/mixins/Scrolling.js","../../../node_modules/react-router/modules/mixins/State.js","../../../node_modules/react-router/modules/mixins/StateContext.js","../../../node_modules/react-router/modules/utils/Cancellation.js","../../../node_modules/react-router/modules/utils/History.js","../../../node_modules/react-router/modules/utils/Path.js","../../../node_modules/react-router/modules/utils/Promise.js","../../../node_modules/react-router/modules/utils/PropTypes.js","../../../node_modules/react-router/modules/utils/Redirect.js","../../../node_modules/react-router/modules/utils/Transition.js","../../../node_modules/react-router/modules/utils/createRouter.js","../../../node_modules/react-router/modules/utils/createRoutesFromChildren.js","../../../node_modules/react-router/modules/utils/getWindowScrollPosition.js","../../../node_modules/react-router/modules/utils/reversedArray.js","../../../node_modules/react-router/modules/utils/runRouter.js","../../../node_modules/react-router/modules/utils/supportsHistory.js","../../../node_modules/react-router/node_modules/qs/index.js","../../../node_modules/react-router/node_modules/qs/lib/index.js","../../../node_modules/react-router/node_modules/qs/lib/parse.js","../../../node_modules/react-router/node_modules/qs/lib/stringify.js","../../../node_modules/react-router/node_modules/qs/lib/utils.js","../../../node_modules/react-router/node_modules/when/lib/Promise.js","../../../node_modules/react-router/node_modules/when/lib/Queue.js","../../../node_modules/react-router/node_modules/when/lib/Scheduler.js","../../../node_modules/react-router/node_modules/when/lib/async.js","../../../node_modules/react-router/node_modules/when/lib/makePromise.js","../../../node_modules/react/lib/CSSCore.js","../../../node_modules/react/lib/ExecutionEnvironment.js","../../../node_modules/react/lib/Object.assign.js","../../../node_modules/react/lib/ReactTransitionEvents.js","../../../node_modules/react/lib/cx.js","../../../node_modules/react/lib/emptyFunction.js","../../../node_modules/react/lib/invariant.js","../../../node_modules/react/lib/warning.js","../../../package.json","../../generated/immutable.d.json","../../lib/TypeKind.js","../../lib/collectMemberGroups.js","../../lib/getTypeDefs.js","../../lib/markdown.js","../../lib/markdownDocs.js","../../lib/prism.js","../../lib/runkit-embed.js","src/Defs.js","src/DocHeader.js","src/DocOverview.js","src/DocSearch.js","src/MarkDown.js","src/MemberDoc.js","src/PageDataMixin.js","src/SideBar.js","src/TypeDocumentation.js","src/index.js","src/isMobile.js","../src/Logo.js","../src/SVGSet.js","../../../resources/immutable-global.js","../../../resources/react-global.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/tLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5xBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvIA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/rBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9IA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACbA;AACA;;;;;ACDA;AACA","file":"../bundle.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/**\n * MIT License\n * \n * Copyright (c) 2014-present, Lee Byron and other contributors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Immutable = {}));\n}(this, (function (exports) { 'use strict';\n\n  var DELETE = 'delete';\n\n  // Constants describing the size of trie nodes.\n  var SHIFT = 5; // Resulted in best performance after ______?\n  var SIZE = 1 << SHIFT;\n  var MASK = SIZE - 1;\n\n  // A consistent shared value representing \"not set\" which equals nothing other\n  // than itself, and nothing that could be provided externally.\n  var NOT_SET = {};\n\n  // Boolean references, Rough equivalent of `bool &`.\n  function MakeRef() {\n    return { value: false };\n  }\n\n  function SetRef(ref) {\n    if (ref) {\n      ref.value = true;\n    }\n  }\n\n  // A function which returns a value representing an \"owner\" for transient writes\n  // to tries. The return value will only ever equal itself, and will not equal\n  // the return of any subsequent call of this function.\n  function OwnerID() {}\n\n  function ensureSize(iter) {\n    if (iter.size === undefined) {\n      iter.size = iter.__iterate(returnTrue);\n    }\n    return iter.size;\n  }\n\n  function wrapIndex(iter, index) {\n    // This implements \"is array index\" which the ECMAString spec defines as:\n    //\n    //     A String property name P is an array index if and only if\n    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n    //     to 2^32−1.\n    //\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n    if (typeof index !== 'number') {\n      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n      if ('' + uint32Index !== index || uint32Index === 4294967295) {\n        return NaN;\n      }\n      index = uint32Index;\n    }\n    return index < 0 ? ensureSize(iter) + index : index;\n  }\n\n  function returnTrue() {\n    return true;\n  }\n\n  function wholeSlice(begin, end, size) {\n    return (\n      ((begin === 0 && !isNeg(begin)) ||\n        (size !== undefined && begin <= -size)) &&\n      (end === undefined || (size !== undefined && end >= size))\n    );\n  }\n\n  function resolveBegin(begin, size) {\n    return resolveIndex(begin, size, 0);\n  }\n\n  function resolveEnd(end, size) {\n    return resolveIndex(end, size, size);\n  }\n\n  function resolveIndex(index, size, defaultIndex) {\n    // Sanitize indices using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    return index === undefined\n      ? defaultIndex\n      : isNeg(index)\n      ? size === Infinity\n        ? size\n        : Math.max(0, size + index) | 0\n      : size === undefined || size === index\n      ? index\n      : Math.min(size, index) | 0;\n  }\n\n  function isNeg(value) {\n    // Account for -0 which is negative, but not less than 0.\n    return value < 0 || (value === 0 && 1 / value === -Infinity);\n  }\n\n  var IS_COLLECTION_SYMBOL = '@@__IMMUTABLE_ITERABLE__@@';\n\n  function isCollection(maybeCollection) {\n    return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);\n  }\n\n  var IS_KEYED_SYMBOL = '@@__IMMUTABLE_KEYED__@@';\n\n  function isKeyed(maybeKeyed) {\n    return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);\n  }\n\n  var IS_INDEXED_SYMBOL = '@@__IMMUTABLE_INDEXED__@@';\n\n  function isIndexed(maybeIndexed) {\n    return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);\n  }\n\n  function isAssociative(maybeAssociative) {\n    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n  }\n\n  var Collection = function Collection(value) {\n    return isCollection(value) ? value : Seq(value);\n  };\n\n  var KeyedCollection = /*@__PURE__*/(function (Collection) {\n    function KeyedCollection(value) {\n      return isKeyed(value) ? value : KeyedSeq(value);\n    }\n\n    if ( Collection ) KeyedCollection.__proto__ = Collection;\n    KeyedCollection.prototype = Object.create( Collection && Collection.prototype );\n    KeyedCollection.prototype.constructor = KeyedCollection;\n\n    return KeyedCollection;\n  }(Collection));\n\n  var IndexedCollection = /*@__PURE__*/(function (Collection) {\n    function IndexedCollection(value) {\n      return isIndexed(value) ? value : IndexedSeq(value);\n    }\n\n    if ( Collection ) IndexedCollection.__proto__ = Collection;\n    IndexedCollection.prototype = Object.create( Collection && Collection.prototype );\n    IndexedCollection.prototype.constructor = IndexedCollection;\n\n    return IndexedCollection;\n  }(Collection));\n\n  var SetCollection = /*@__PURE__*/(function (Collection) {\n    function SetCollection(value) {\n      return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);\n    }\n\n    if ( Collection ) SetCollection.__proto__ = Collection;\n    SetCollection.prototype = Object.create( Collection && Collection.prototype );\n    SetCollection.prototype.constructor = SetCollection;\n\n    return SetCollection;\n  }(Collection));\n\n  Collection.Keyed = KeyedCollection;\n  Collection.Indexed = IndexedCollection;\n  Collection.Set = SetCollection;\n\n  var IS_SEQ_SYMBOL = '@@__IMMUTABLE_SEQ__@@';\n\n  function isSeq(maybeSeq) {\n    return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);\n  }\n\n  var IS_RECORD_SYMBOL = '@@__IMMUTABLE_RECORD__@@';\n\n  function isRecord(maybeRecord) {\n    return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);\n  }\n\n  function isImmutable(maybeImmutable) {\n    return isCollection(maybeImmutable) || isRecord(maybeImmutable);\n  }\n\n  var IS_ORDERED_SYMBOL = '@@__IMMUTABLE_ORDERED__@@';\n\n  function isOrdered(maybeOrdered) {\n    return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);\n  }\n\n  var ITERATE_KEYS = 0;\n  var ITERATE_VALUES = 1;\n  var ITERATE_ENTRIES = 2;\n\n  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\n  var Iterator = function Iterator(next) {\n    this.next = next;\n  };\n\n  Iterator.prototype.toString = function toString () {\n    return '[Iterator]';\n  };\n\n  Iterator.KEYS = ITERATE_KEYS;\n  Iterator.VALUES = ITERATE_VALUES;\n  Iterator.ENTRIES = ITERATE_ENTRIES;\n\n  Iterator.prototype.inspect = Iterator.prototype.toSource = function () {\n    return this.toString();\n  };\n  Iterator.prototype[ITERATOR_SYMBOL] = function () {\n    return this;\n  };\n\n  function iteratorValue(type, k, v, iteratorResult) {\n    var value = type === 0 ? k : type === 1 ? v : [k, v];\n    iteratorResult\n      ? (iteratorResult.value = value)\n      : (iteratorResult = {\n          value: value,\n          done: false,\n        });\n    return iteratorResult;\n  }\n\n  function iteratorDone() {\n    return { value: undefined, done: true };\n  }\n\n  function hasIterator(maybeIterable) {\n    return !!getIteratorFn(maybeIterable);\n  }\n\n  function isIterator(maybeIterator) {\n    return maybeIterator && typeof maybeIterator.next === 'function';\n  }\n\n  function getIterator(iterable) {\n    var iteratorFn = getIteratorFn(iterable);\n    return iteratorFn && iteratorFn.call(iterable);\n  }\n\n  function getIteratorFn(iterable) {\n    var iteratorFn =\n      iterable &&\n      ((REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n        iterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  function isArrayLike(value) {\n    if (Array.isArray(value) || typeof value === 'string') {\n      return true;\n    }\n\n    return (\n      value &&\n      typeof value === 'object' &&\n      Number.isInteger(value.length) &&\n      value.length >= 0 &&\n      (value.length === 0\n        ? // Only {length: 0} is considered Array-like.\n          Object.keys(value).length === 1\n        : // An object is only Array-like if it has a property where the last value\n          // in the array-like may be found (which could be undefined).\n          value.hasOwnProperty(value.length - 1))\n    );\n  }\n\n  var Seq = /*@__PURE__*/(function (Collection) {\n    function Seq(value) {\n      return value === null || value === undefined\n        ? emptySequence()\n        : isImmutable(value)\n        ? value.toSeq()\n        : seqFromValue(value);\n    }\n\n    if ( Collection ) Seq.__proto__ = Collection;\n    Seq.prototype = Object.create( Collection && Collection.prototype );\n    Seq.prototype.constructor = Seq;\n\n    Seq.prototype.toSeq = function toSeq () {\n      return this;\n    };\n\n    Seq.prototype.toString = function toString () {\n      return this.__toString('Seq {', '}');\n    };\n\n    Seq.prototype.cacheResult = function cacheResult () {\n      if (!this._cache && this.__iterateUncached) {\n        this._cache = this.entrySeq().toArray();\n        this.size = this._cache.length;\n      }\n      return this;\n    };\n\n    // abstract __iterateUncached(fn, reverse)\n\n    Seq.prototype.__iterate = function __iterate (fn, reverse) {\n      var cache = this._cache;\n      if (cache) {\n        var size = cache.length;\n        var i = 0;\n        while (i !== size) {\n          var entry = cache[reverse ? size - ++i : i++];\n          if (fn(entry[1], entry[0], this) === false) {\n            break;\n          }\n        }\n        return i;\n      }\n      return this.__iterateUncached(fn, reverse);\n    };\n\n    // abstract __iteratorUncached(type, reverse)\n\n    Seq.prototype.__iterator = function __iterator (type, reverse) {\n      var cache = this._cache;\n      if (cache) {\n        var size = cache.length;\n        var i = 0;\n        return new Iterator(function () {\n          if (i === size) {\n            return iteratorDone();\n          }\n          var entry = cache[reverse ? size - ++i : i++];\n          return iteratorValue(type, entry[0], entry[1]);\n        });\n      }\n      return this.__iteratorUncached(type, reverse);\n    };\n\n    return Seq;\n  }(Collection));\n\n  var KeyedSeq = /*@__PURE__*/(function (Seq) {\n    function KeyedSeq(value) {\n      return value === null || value === undefined\n        ? emptySequence().toKeyedSeq()\n        : isCollection(value)\n        ? isKeyed(value)\n          ? value.toSeq()\n          : value.fromEntrySeq()\n        : isRecord(value)\n        ? value.toSeq()\n        : keyedSeqFromValue(value);\n    }\n\n    if ( Seq ) KeyedSeq.__proto__ = Seq;\n    KeyedSeq.prototype = Object.create( Seq && Seq.prototype );\n    KeyedSeq.prototype.constructor = KeyedSeq;\n\n    KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq () {\n      return this;\n    };\n\n    return KeyedSeq;\n  }(Seq));\n\n  var IndexedSeq = /*@__PURE__*/(function (Seq) {\n    function IndexedSeq(value) {\n      return value === null || value === undefined\n        ? emptySequence()\n        : isCollection(value)\n        ? isKeyed(value)\n          ? value.entrySeq()\n          : value.toIndexedSeq()\n        : isRecord(value)\n        ? value.toSeq().entrySeq()\n        : indexedSeqFromValue(value);\n    }\n\n    if ( Seq ) IndexedSeq.__proto__ = Seq;\n    IndexedSeq.prototype = Object.create( Seq && Seq.prototype );\n    IndexedSeq.prototype.constructor = IndexedSeq;\n\n    IndexedSeq.of = function of (/*...values*/) {\n      return IndexedSeq(arguments);\n    };\n\n    IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq () {\n      return this;\n    };\n\n    IndexedSeq.prototype.toString = function toString () {\n      return this.__toString('Seq [', ']');\n    };\n\n    return IndexedSeq;\n  }(Seq));\n\n  var SetSeq = /*@__PURE__*/(function (Seq) {\n    function SetSeq(value) {\n      return (\n        isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)\n      ).toSetSeq();\n    }\n\n    if ( Seq ) SetSeq.__proto__ = Seq;\n    SetSeq.prototype = Object.create( Seq && Seq.prototype );\n    SetSeq.prototype.constructor = SetSeq;\n\n    SetSeq.of = function of (/*...values*/) {\n      return SetSeq(arguments);\n    };\n\n    SetSeq.prototype.toSetSeq = function toSetSeq () {\n      return this;\n    };\n\n    return SetSeq;\n  }(Seq));\n\n  Seq.isSeq = isSeq;\n  Seq.Keyed = KeyedSeq;\n  Seq.Set = SetSeq;\n  Seq.Indexed = IndexedSeq;\n\n  Seq.prototype[IS_SEQ_SYMBOL] = true;\n\n  // #pragma Root Sequences\n\n  var ArraySeq = /*@__PURE__*/(function (IndexedSeq) {\n    function ArraySeq(array) {\n      this._array = array;\n      this.size = array.length;\n    }\n\n    if ( IndexedSeq ) ArraySeq.__proto__ = IndexedSeq;\n    ArraySeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n    ArraySeq.prototype.constructor = ArraySeq;\n\n    ArraySeq.prototype.get = function get (index, notSetValue) {\n      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n    };\n\n    ArraySeq.prototype.__iterate = function __iterate (fn, reverse) {\n      var array = this._array;\n      var size = array.length;\n      var i = 0;\n      while (i !== size) {\n        var ii = reverse ? size - ++i : i++;\n        if (fn(array[ii], ii, this) === false) {\n          break;\n        }\n      }\n      return i;\n    };\n\n    ArraySeq.prototype.__iterator = function __iterator (type, reverse) {\n      var array = this._array;\n      var size = array.length;\n      var i = 0;\n      return new Iterator(function () {\n        if (i === size) {\n          return iteratorDone();\n        }\n        var ii = reverse ? size - ++i : i++;\n        return iteratorValue(type, ii, array[ii]);\n      });\n    };\n\n    return ArraySeq;\n  }(IndexedSeq));\n\n  var ObjectSeq = /*@__PURE__*/(function (KeyedSeq) {\n    function ObjectSeq(object) {\n      var keys = Object.keys(object);\n      this._object = object;\n      this._keys = keys;\n      this.size = keys.length;\n    }\n\n    if ( KeyedSeq ) ObjectSeq.__proto__ = KeyedSeq;\n    ObjectSeq.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );\n    ObjectSeq.prototype.constructor = ObjectSeq;\n\n    ObjectSeq.prototype.get = function get (key, notSetValue) {\n      if (notSetValue !== undefined && !this.has(key)) {\n        return notSetValue;\n      }\n      return this._object[key];\n    };\n\n    ObjectSeq.prototype.has = function has (key) {\n      return hasOwnProperty.call(this._object, key);\n    };\n\n    ObjectSeq.prototype.__iterate = function __iterate (fn, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var size = keys.length;\n      var i = 0;\n      while (i !== size) {\n        var key = keys[reverse ? size - ++i : i++];\n        if (fn(object[key], key, this) === false) {\n          break;\n        }\n      }\n      return i;\n    };\n\n    ObjectSeq.prototype.__iterator = function __iterator (type, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var size = keys.length;\n      var i = 0;\n      return new Iterator(function () {\n        if (i === size) {\n          return iteratorDone();\n        }\n        var key = keys[reverse ? size - ++i : i++];\n        return iteratorValue(type, key, object[key]);\n      });\n    };\n\n    return ObjectSeq;\n  }(KeyedSeq));\n  ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;\n\n  var CollectionSeq = /*@__PURE__*/(function (IndexedSeq) {\n    function CollectionSeq(collection) {\n      this._collection = collection;\n      this.size = collection.length || collection.size;\n    }\n\n    if ( IndexedSeq ) CollectionSeq.__proto__ = IndexedSeq;\n    CollectionSeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n    CollectionSeq.prototype.constructor = CollectionSeq;\n\n    CollectionSeq.prototype.__iterateUncached = function __iterateUncached (fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var collection = this._collection;\n      var iterator = getIterator(collection);\n      var iterations = 0;\n      if (isIterator(iterator)) {\n        var step;\n        while (!(step = iterator.next()).done) {\n          if (fn(step.value, iterations++, this) === false) {\n            break;\n          }\n        }\n      }\n      return iterations;\n    };\n\n    CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached (type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var collection = this._collection;\n      var iterator = getIterator(collection);\n      if (!isIterator(iterator)) {\n        return new Iterator(iteratorDone);\n      }\n      var iterations = 0;\n      return new Iterator(function () {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, iterations++, step.value);\n      });\n    };\n\n    return CollectionSeq;\n  }(IndexedSeq));\n\n  // # pragma Helper functions\n\n  var EMPTY_SEQ;\n\n  function emptySequence() {\n    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n  }\n\n  function keyedSeqFromValue(value) {\n    var seq = Array.isArray(value)\n      ? new ArraySeq(value)\n      : hasIterator(value)\n      ? new CollectionSeq(value)\n      : undefined;\n    if (seq) {\n      return seq.fromEntrySeq();\n    }\n    if (typeof value === 'object') {\n      return new ObjectSeq(value);\n    }\n    throw new TypeError(\n      'Expected Array or collection object of [k, v] entries, or keyed object: ' +\n        value\n    );\n  }\n\n  function indexedSeqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (seq) {\n      return seq;\n    }\n    throw new TypeError(\n      'Expected Array or collection object of values: ' + value\n    );\n  }\n\n  function seqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (seq) {\n      return seq;\n    }\n    if (typeof value === 'object') {\n      return new ObjectSeq(value);\n    }\n    throw new TypeError(\n      'Expected Array or collection object of values, or keyed object: ' + value\n    );\n  }\n\n  function maybeIndexedSeqFromValue(value) {\n    return isArrayLike(value)\n      ? new ArraySeq(value)\n      : hasIterator(value)\n      ? new CollectionSeq(value)\n      : undefined;\n  }\n\n  var IS_MAP_SYMBOL = '@@__IMMUTABLE_MAP__@@';\n\n  function isMap(maybeMap) {\n    return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);\n  }\n\n  function isOrderedMap(maybeOrderedMap) {\n    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n  }\n\n  function isValueObject(maybeValue) {\n    return Boolean(\n      maybeValue &&\n        typeof maybeValue.equals === 'function' &&\n        typeof maybeValue.hashCode === 'function'\n    );\n  }\n\n  /**\n   * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n   *\n   * NaN is considered the same as NaN, however -0 and 0 are considered the same\n   * value, which is different from the algorithm described by\n   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n   *\n   * This is extended further to allow Objects to describe the values they\n   * represent, by way of `valueOf` or `equals` (and `hashCode`).\n   *\n   * Note: because of this extension, the key equality of Immutable.Map and the\n   * value equality of Immutable.Set will differ from ES6 Map and Set.\n   *\n   * ### Defining custom values\n   *\n   * The easiest way to describe the value an object represents is by implementing\n   * `valueOf`. For example, `Date` represents a value by returning a unix\n   * timestamp for `valueOf`:\n   *\n   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n   *     var date2 = new Date(1234567890000);\n   *     date1.valueOf(); // 1234567890000\n   *     assert( date1 !== date2 );\n   *     assert( Immutable.is( date1, date2 ) );\n   *\n   * Note: overriding `valueOf` may have other implications if you use this object\n   * where JavaScript expects a primitive, such as implicit string coercion.\n   *\n   * For more complex types, especially collections, implementing `valueOf` may\n   * not be performant. An alternative is to implement `equals` and `hashCode`.\n   *\n   * `equals` takes another object, presumably of similar type, and returns true\n   * if it is equal. Equality is symmetrical, so the same result should be\n   * returned if this and the argument are flipped.\n   *\n   *     assert( a.equals(b) === b.equals(a) );\n   *\n   * `hashCode` returns a 32bit integer number representing the object which will\n   * be used to determine how to store the value object in a Map or Set. You must\n   * provide both or neither methods, one must not exist without the other.\n   *\n   * Also, an important relationship between these methods must be upheld: if two\n   * values are equal, they *must* return the same hashCode. If the values are not\n   * equal, they might have the same hashCode; this is called a hash collision,\n   * and while undesirable for performance reasons, it is acceptable.\n   *\n   *     if (a.equals(b)) {\n   *       assert( a.hashCode() === b.hashCode() );\n   *     }\n   *\n   * All Immutable collections are Value Objects: they implement `equals()`\n   * and `hashCode()`.\n   */\n  function is(valueA, valueB) {\n    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n    if (\n      typeof valueA.valueOf === 'function' &&\n      typeof valueB.valueOf === 'function'\n    ) {\n      valueA = valueA.valueOf();\n      valueB = valueB.valueOf();\n      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n        return true;\n      }\n      if (!valueA || !valueB) {\n        return false;\n      }\n    }\n    return !!(\n      isValueObject(valueA) &&\n      isValueObject(valueB) &&\n      valueA.equals(valueB)\n    );\n  }\n\n  var imul =\n    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2\n      ? Math.imul\n      : function imul(a, b) {\n          a |= 0; // int\n          b |= 0; // int\n          var c = a & 0xffff;\n          var d = b & 0xffff;\n          // Shift by 0 fixes the sign on the high part.\n          return (c * d + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0)) | 0; // int\n        };\n\n  // v8 has an optimization for storing 31-bit signed numbers.\n  // Values which have either 00 or 11 as the high order bits qualify.\n  // This function drops the highest order bit in a signed number, maintaining\n  // the sign bit.\n  function smi(i32) {\n    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xbfffffff);\n  }\n\n  var defaultValueOf = Object.prototype.valueOf;\n\n  function hash(o) {\n    switch (typeof o) {\n      case 'boolean':\n        // The hash values for built-in constants are a 1 value for each 5-byte\n        // shift region expect for the first, which encodes the value. This\n        // reduces the odds of a hash collision for these common values.\n        return o ? 0x42108421 : 0x42108420;\n      case 'number':\n        return hashNumber(o);\n      case 'string':\n        return o.length > STRING_HASH_CACHE_MIN_STRLEN\n          ? cachedHashString(o)\n          : hashString(o);\n      case 'object':\n      case 'function':\n        if (o === null) {\n          return 0x42108422;\n        }\n        if (typeof o.hashCode === 'function') {\n          // Drop any high bits from accidentally long hash codes.\n          return smi(o.hashCode(o));\n        }\n        if (o.valueOf !== defaultValueOf && typeof o.valueOf === 'function') {\n          o = o.valueOf(o);\n        }\n        return hashJSObj(o);\n      case 'undefined':\n        return 0x42108423;\n      default:\n        if (typeof o.toString === 'function') {\n          return hashString(o.toString());\n        }\n        throw new Error('Value type ' + typeof o + ' cannot be hashed.');\n    }\n  }\n\n  // Compress arbitrarily large numbers into smi hashes.\n  function hashNumber(n) {\n    if (n !== n || n === Infinity) {\n      return 0;\n    }\n    var hash = n | 0;\n    if (hash !== n) {\n      hash ^= n * 0xffffffff;\n    }\n    while (n > 0xffffffff) {\n      n /= 0xffffffff;\n      hash ^= n;\n    }\n    return smi(hash);\n  }\n\n  function cachedHashString(string) {\n    var hashed = stringHashCache[string];\n    if (hashed === undefined) {\n      hashed = hashString(string);\n      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n        STRING_HASH_CACHE_SIZE = 0;\n        stringHashCache = {};\n      }\n      STRING_HASH_CACHE_SIZE++;\n      stringHashCache[string] = hashed;\n    }\n    return hashed;\n  }\n\n  // http://jsperf.com/hashing-strings\n  function hashString(string) {\n    // This is the hash from JVM\n    // The hash code for a string is computed as\n    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n    // where s[i] is the ith character of the string and n is the length of\n    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n    // (exclusive) by dropping high bits.\n    var hashed = 0;\n    for (var ii = 0; ii < string.length; ii++) {\n      hashed = (31 * hashed + string.charCodeAt(ii)) | 0;\n    }\n    return smi(hashed);\n  }\n\n  function hashJSObj(obj) {\n    var hashed;\n    if (usingWeakMap) {\n      hashed = weakMap.get(obj);\n      if (hashed !== undefined) {\n        return hashed;\n      }\n    }\n\n    hashed = obj[UID_HASH_KEY];\n    if (hashed !== undefined) {\n      return hashed;\n    }\n\n    if (!canDefineProperty) {\n      hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n      if (hashed !== undefined) {\n        return hashed;\n      }\n\n      hashed = getIENodeHash(obj);\n      if (hashed !== undefined) {\n        return hashed;\n      }\n    }\n\n    hashed = ++objHashUID;\n    if (objHashUID & 0x40000000) {\n      objHashUID = 0;\n    }\n\n    if (usingWeakMap) {\n      weakMap.set(obj, hashed);\n    } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n      throw new Error('Non-extensible objects are not allowed as keys.');\n    } else if (canDefineProperty) {\n      Object.defineProperty(obj, UID_HASH_KEY, {\n        enumerable: false,\n        configurable: false,\n        writable: false,\n        value: hashed,\n      });\n    } else if (\n      obj.propertyIsEnumerable !== undefined &&\n      obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable\n    ) {\n      // Since we can't define a non-enumerable property on the object\n      // we'll hijack one of the less-used non-enumerable properties to\n      // save our hash on it. Since this is a function it will not show up in\n      // `JSON.stringify` which is what we want.\n      obj.propertyIsEnumerable = function () {\n        return this.constructor.prototype.propertyIsEnumerable.apply(\n          this,\n          arguments\n        );\n      };\n      obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;\n    } else if (obj.nodeType !== undefined) {\n      // At this point we couldn't get the IE `uniqueID` to use as a hash\n      // and we couldn't use a non-enumerable property to exploit the\n      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n      // itself.\n      obj[UID_HASH_KEY] = hashed;\n    } else {\n      throw new Error('Unable to set a non-enumerable property on object.');\n    }\n\n    return hashed;\n  }\n\n  // Get references to ES5 object methods.\n  var isExtensible = Object.isExtensible;\n\n  // True if Object.defineProperty works as expected. IE8 fails this test.\n  var canDefineProperty = (function () {\n    try {\n      Object.defineProperty({}, '@', {});\n      return true;\n    } catch (e) {\n      return false;\n    }\n  })();\n\n  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n  // and avoid memory leaks from the IE cloneNode bug.\n  function getIENodeHash(node) {\n    if (node && node.nodeType > 0) {\n      switch (node.nodeType) {\n        case 1: // Element\n          return node.uniqueID;\n        case 9: // Document\n          return node.documentElement && node.documentElement.uniqueID;\n      }\n    }\n  }\n\n  // If possible, use a WeakMap.\n  var usingWeakMap = typeof WeakMap === 'function';\n  var weakMap;\n  if (usingWeakMap) {\n    weakMap = new WeakMap();\n  }\n\n  var objHashUID = 0;\n\n  var UID_HASH_KEY = '__immutablehash__';\n  if (typeof Symbol === 'function') {\n    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n  }\n\n  var STRING_HASH_CACHE_MIN_STRLEN = 16;\n  var STRING_HASH_CACHE_MAX_SIZE = 255;\n  var STRING_HASH_CACHE_SIZE = 0;\n  var stringHashCache = {};\n\n  var ToKeyedSequence = /*@__PURE__*/(function (KeyedSeq) {\n    function ToKeyedSequence(indexed, useKeys) {\n      this._iter = indexed;\n      this._useKeys = useKeys;\n      this.size = indexed.size;\n    }\n\n    if ( KeyedSeq ) ToKeyedSequence.__proto__ = KeyedSeq;\n    ToKeyedSequence.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );\n    ToKeyedSequence.prototype.constructor = ToKeyedSequence;\n\n    ToKeyedSequence.prototype.get = function get (key, notSetValue) {\n      return this._iter.get(key, notSetValue);\n    };\n\n    ToKeyedSequence.prototype.has = function has (key) {\n      return this._iter.has(key);\n    };\n\n    ToKeyedSequence.prototype.valueSeq = function valueSeq () {\n      return this._iter.valueSeq();\n    };\n\n    ToKeyedSequence.prototype.reverse = function reverse () {\n      var this$1 = this;\n\n      var reversedSequence = reverseFactory(this, true);\n      if (!this._useKeys) {\n        reversedSequence.valueSeq = function () { return this$1._iter.toSeq().reverse(); };\n      }\n      return reversedSequence;\n    };\n\n    ToKeyedSequence.prototype.map = function map (mapper, context) {\n      var this$1 = this;\n\n      var mappedSequence = mapFactory(this, mapper, context);\n      if (!this._useKeys) {\n        mappedSequence.valueSeq = function () { return this$1._iter.toSeq().map(mapper, context); };\n      }\n      return mappedSequence;\n    };\n\n    ToKeyedSequence.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      return this._iter.__iterate(function (v, k) { return fn(v, k, this$1); }, reverse);\n    };\n\n    ToKeyedSequence.prototype.__iterator = function __iterator (type, reverse) {\n      return this._iter.__iterator(type, reverse);\n    };\n\n    return ToKeyedSequence;\n  }(KeyedSeq));\n  ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;\n\n  var ToIndexedSequence = /*@__PURE__*/(function (IndexedSeq) {\n    function ToIndexedSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    if ( IndexedSeq ) ToIndexedSequence.__proto__ = IndexedSeq;\n    ToIndexedSequence.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n    ToIndexedSequence.prototype.constructor = ToIndexedSequence;\n\n    ToIndexedSequence.prototype.includes = function includes (value) {\n      return this._iter.includes(value);\n    };\n\n    ToIndexedSequence.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      var i = 0;\n      reverse && ensureSize(this);\n      return this._iter.__iterate(\n        function (v) { return fn(v, reverse ? this$1.size - ++i : i++, this$1); },\n        reverse\n      );\n    };\n\n    ToIndexedSequence.prototype.__iterator = function __iterator (type, reverse) {\n      var this$1 = this;\n\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var i = 0;\n      reverse && ensureSize(this);\n      return new Iterator(function () {\n        var step = iterator.next();\n        return step.done\n          ? step\n          : iteratorValue(\n              type,\n              reverse ? this$1.size - ++i : i++,\n              step.value,\n              step\n            );\n      });\n    };\n\n    return ToIndexedSequence;\n  }(IndexedSeq));\n\n  var ToSetSequence = /*@__PURE__*/(function (SetSeq) {\n    function ToSetSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    if ( SetSeq ) ToSetSequence.__proto__ = SetSeq;\n    ToSetSequence.prototype = Object.create( SetSeq && SetSeq.prototype );\n    ToSetSequence.prototype.constructor = ToSetSequence;\n\n    ToSetSequence.prototype.has = function has (key) {\n      return this._iter.includes(key);\n    };\n\n    ToSetSequence.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      return this._iter.__iterate(function (v) { return fn(v, v, this$1); }, reverse);\n    };\n\n    ToSetSequence.prototype.__iterator = function __iterator (type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function () {\n        var step = iterator.next();\n        return step.done\n          ? step\n          : iteratorValue(type, step.value, step.value, step);\n      });\n    };\n\n    return ToSetSequence;\n  }(SetSeq));\n\n  var FromEntriesSequence = /*@__PURE__*/(function (KeyedSeq) {\n    function FromEntriesSequence(entries) {\n      this._iter = entries;\n      this.size = entries.size;\n    }\n\n    if ( KeyedSeq ) FromEntriesSequence.__proto__ = KeyedSeq;\n    FromEntriesSequence.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );\n    FromEntriesSequence.prototype.constructor = FromEntriesSequence;\n\n    FromEntriesSequence.prototype.entrySeq = function entrySeq () {\n      return this._iter.toSeq();\n    };\n\n    FromEntriesSequence.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      return this._iter.__iterate(function (entry) {\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedCollection = isCollection(entry);\n          return fn(\n            indexedCollection ? entry.get(1) : entry[1],\n            indexedCollection ? entry.get(0) : entry[0],\n            this$1\n          );\n        }\n      }, reverse);\n    };\n\n    FromEntriesSequence.prototype.__iterator = function __iterator (type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function () {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          // Check if entry exists first so array access doesn't throw for holes\n          // in the parent iteration.\n          if (entry) {\n            validateEntry(entry);\n            var indexedCollection = isCollection(entry);\n            return iteratorValue(\n              type,\n              indexedCollection ? entry.get(0) : entry[0],\n              indexedCollection ? entry.get(1) : entry[1],\n              step\n            );\n          }\n        }\n      });\n    };\n\n    return FromEntriesSequence;\n  }(KeyedSeq));\n\n  ToIndexedSequence.prototype.cacheResult =\n    ToKeyedSequence.prototype.cacheResult =\n    ToSetSequence.prototype.cacheResult =\n    FromEntriesSequence.prototype.cacheResult =\n      cacheResultThrough;\n\n  function flipFactory(collection) {\n    var flipSequence = makeSequence(collection);\n    flipSequence._iter = collection;\n    flipSequence.size = collection.size;\n    flipSequence.flip = function () { return collection; };\n    flipSequence.reverse = function () {\n      var reversedSequence = collection.reverse.apply(this); // super.reverse()\n      reversedSequence.flip = function () { return collection.reverse(); };\n      return reversedSequence;\n    };\n    flipSequence.has = function (key) { return collection.includes(key); };\n    flipSequence.includes = function (key) { return collection.has(key); };\n    flipSequence.cacheResult = cacheResultThrough;\n    flipSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      return collection.__iterate(function (v, k) { return fn(k, v, this$1) !== false; }, reverse);\n    };\n    flipSequence.__iteratorUncached = function (type, reverse) {\n      if (type === ITERATE_ENTRIES) {\n        var iterator = collection.__iterator(type, reverse);\n        return new Iterator(function () {\n          var step = iterator.next();\n          if (!step.done) {\n            var k = step.value[0];\n            step.value[0] = step.value[1];\n            step.value[1] = k;\n          }\n          return step;\n        });\n      }\n      return collection.__iterator(\n        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n        reverse\n      );\n    };\n    return flipSequence;\n  }\n\n  function mapFactory(collection, mapper, context) {\n    var mappedSequence = makeSequence(collection);\n    mappedSequence.size = collection.size;\n    mappedSequence.has = function (key) { return collection.has(key); };\n    mappedSequence.get = function (key, notSetValue) {\n      var v = collection.get(key, NOT_SET);\n      return v === NOT_SET\n        ? notSetValue\n        : mapper.call(context, v, key, collection);\n    };\n    mappedSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      return collection.__iterate(\n        function (v, k, c) { return fn(mapper.call(context, v, k, c), k, this$1) !== false; },\n        reverse\n      );\n    };\n    mappedSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n      return new Iterator(function () {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var key = entry[0];\n        return iteratorValue(\n          type,\n          key,\n          mapper.call(context, entry[1], key, collection),\n          step\n        );\n      });\n    };\n    return mappedSequence;\n  }\n\n  function reverseFactory(collection, useKeys) {\n    var this$1 = this;\n\n    var reversedSequence = makeSequence(collection);\n    reversedSequence._iter = collection;\n    reversedSequence.size = collection.size;\n    reversedSequence.reverse = function () { return collection; };\n    if (collection.flip) {\n      reversedSequence.flip = function () {\n        var flipSequence = flipFactory(collection);\n        flipSequence.reverse = function () { return collection.flip(); };\n        return flipSequence;\n      };\n    }\n    reversedSequence.get = function (key, notSetValue) { return collection.get(useKeys ? key : -1 - key, notSetValue); };\n    reversedSequence.has = function (key) { return collection.has(useKeys ? key : -1 - key); };\n    reversedSequence.includes = function (value) { return collection.includes(value); };\n    reversedSequence.cacheResult = cacheResultThrough;\n    reversedSequence.__iterate = function (fn, reverse) {\n      var this$1 = this;\n\n      var i = 0;\n      reverse && ensureSize(collection);\n      return collection.__iterate(\n        function (v, k) { return fn(v, useKeys ? k : reverse ? this$1.size - ++i : i++, this$1); },\n        !reverse\n      );\n    };\n    reversedSequence.__iterator = function (type, reverse) {\n      var i = 0;\n      reverse && ensureSize(collection);\n      var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);\n      return new Iterator(function () {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        return iteratorValue(\n          type,\n          useKeys ? entry[0] : reverse ? this$1.size - ++i : i++,\n          entry[1],\n          step\n        );\n      });\n    };\n    return reversedSequence;\n  }\n\n  function filterFactory(collection, predicate, context, useKeys) {\n    var filterSequence = makeSequence(collection);\n    if (useKeys) {\n      filterSequence.has = function (key) {\n        var v = collection.get(key, NOT_SET);\n        return v !== NOT_SET && !!predicate.call(context, v, key, collection);\n      };\n      filterSequence.get = function (key, notSetValue) {\n        var v = collection.get(key, NOT_SET);\n        return v !== NOT_SET && predicate.call(context, v, key, collection)\n          ? v\n          : notSetValue;\n      };\n    }\n    filterSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      var iterations = 0;\n      collection.__iterate(function (v, k, c) {\n        if (predicate.call(context, v, k, c)) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$1);\n        }\n      }, reverse);\n      return iterations;\n    };\n    filterSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n      var iterations = 0;\n      return new Iterator(function () {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          var key = entry[0];\n          var value = entry[1];\n          if (predicate.call(context, value, key, collection)) {\n            return iteratorValue(type, useKeys ? key : iterations++, value, step);\n          }\n        }\n      });\n    };\n    return filterSequence;\n  }\n\n  function countByFactory(collection, grouper, context) {\n    var groups = Map().asMutable();\n    collection.__iterate(function (v, k) {\n      groups.update(grouper.call(context, v, k, collection), 0, function (a) { return a + 1; });\n    });\n    return groups.asImmutable();\n  }\n\n  function groupByFactory(collection, grouper, context) {\n    var isKeyedIter = isKeyed(collection);\n    var groups = (isOrdered(collection) ? OrderedMap() : Map()).asMutable();\n    collection.__iterate(function (v, k) {\n      groups.update(\n        grouper.call(context, v, k, collection),\n        function (a) { return ((a = a || []), a.push(isKeyedIter ? [k, v] : v), a); }\n      );\n    });\n    var coerce = collectionClass(collection);\n    return groups.map(function (arr) { return reify(collection, coerce(arr)); }).asImmutable();\n  }\n\n  function sliceFactory(collection, begin, end, useKeys) {\n    var originalSize = collection.size;\n\n    if (wholeSlice(begin, end, originalSize)) {\n      return collection;\n    }\n\n    var resolvedBegin = resolveBegin(begin, originalSize);\n    var resolvedEnd = resolveEnd(end, originalSize);\n\n    // begin or end will be NaN if they were provided as negative numbers and\n    // this collection's size is unknown. In that case, cache first so there is\n    // a known size and these do not resolve to NaN.\n    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n      return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);\n    }\n\n    // Note: resolvedEnd is undefined when the original sequence's length is\n    // unknown and this slice did not supply an end and should contain all\n    // elements after resolvedBegin.\n    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n    var resolvedSize = resolvedEnd - resolvedBegin;\n    var sliceSize;\n    if (resolvedSize === resolvedSize) {\n      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n    }\n\n    var sliceSeq = makeSequence(collection);\n\n    // If collection.size is undefined, the size of the realized sliceSeq is\n    // unknown at this point unless the number of items to slice is 0\n    sliceSeq.size =\n      sliceSize === 0 ? sliceSize : (collection.size && sliceSize) || undefined;\n\n    if (!useKeys && isSeq(collection) && sliceSize >= 0) {\n      sliceSeq.get = function (index, notSetValue) {\n        index = wrapIndex(this, index);\n        return index >= 0 && index < sliceSize\n          ? collection.get(index + resolvedBegin, notSetValue)\n          : notSetValue;\n      };\n    }\n\n    sliceSeq.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      if (sliceSize === 0) {\n        return 0;\n      }\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var skipped = 0;\n      var isSkipping = true;\n      var iterations = 0;\n      collection.__iterate(function (v, k) {\n        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n          iterations++;\n          return (\n            fn(v, useKeys ? k : iterations - 1, this$1) !== false &&\n            iterations !== sliceSize\n          );\n        }\n      });\n      return iterations;\n    };\n\n    sliceSeq.__iteratorUncached = function (type, reverse) {\n      if (sliceSize !== 0 && reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      // Don't bother instantiating parent iterator if taking 0.\n      if (sliceSize === 0) {\n        return new Iterator(iteratorDone);\n      }\n      var iterator = collection.__iterator(type, reverse);\n      var skipped = 0;\n      var iterations = 0;\n      return new Iterator(function () {\n        while (skipped++ < resolvedBegin) {\n          iterator.next();\n        }\n        if (++iterations > sliceSize) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (useKeys || type === ITERATE_VALUES || step.done) {\n          return step;\n        }\n        if (type === ITERATE_KEYS) {\n          return iteratorValue(type, iterations - 1, undefined, step);\n        }\n        return iteratorValue(type, iterations - 1, step.value[1], step);\n      });\n    };\n\n    return sliceSeq;\n  }\n\n  function takeWhileFactory(collection, predicate, context) {\n    var takeSequence = makeSequence(collection);\n    takeSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterations = 0;\n      collection.__iterate(\n        function (v, k, c) { return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1); }\n      );\n      return iterations;\n    };\n    takeSequence.__iteratorUncached = function (type, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n      var iterating = true;\n      return new Iterator(function () {\n        if (!iterating) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var k = entry[0];\n        var v = entry[1];\n        if (!predicate.call(context, v, k, this$1)) {\n          iterating = false;\n          return iteratorDone();\n        }\n        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n      });\n    };\n    return takeSequence;\n  }\n\n  function skipWhileFactory(collection, predicate, context, useKeys) {\n    var skipSequence = makeSequence(collection);\n    skipSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var isSkipping = true;\n      var iterations = 0;\n      collection.__iterate(function (v, k, c) {\n        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$1);\n        }\n      });\n      return iterations;\n    };\n    skipSequence.__iteratorUncached = function (type, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);\n      var skipping = true;\n      var iterations = 0;\n      return new Iterator(function () {\n        var step;\n        var k;\n        var v;\n        do {\n          step = iterator.next();\n          if (step.done) {\n            if (useKeys || type === ITERATE_VALUES) {\n              return step;\n            }\n            if (type === ITERATE_KEYS) {\n              return iteratorValue(type, iterations++, undefined, step);\n            }\n            return iteratorValue(type, iterations++, step.value[1], step);\n          }\n          var entry = step.value;\n          k = entry[0];\n          v = entry[1];\n          skipping && (skipping = predicate.call(context, v, k, this$1));\n        } while (skipping);\n        return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);\n      });\n    };\n    return skipSequence;\n  }\n\n  function concatFactory(collection, values) {\n    var isKeyedCollection = isKeyed(collection);\n    var iters = [collection]\n      .concat(values)\n      .map(function (v) {\n        if (!isCollection(v)) {\n          v = isKeyedCollection\n            ? keyedSeqFromValue(v)\n            : indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n        } else if (isKeyedCollection) {\n          v = KeyedCollection(v);\n        }\n        return v;\n      })\n      .filter(function (v) { return v.size !== 0; });\n\n    if (iters.length === 0) {\n      return collection;\n    }\n\n    if (iters.length === 1) {\n      var singleton = iters[0];\n      if (\n        singleton === collection ||\n        (isKeyedCollection && isKeyed(singleton)) ||\n        (isIndexed(collection) && isIndexed(singleton))\n      ) {\n        return singleton;\n      }\n    }\n\n    var concatSeq = new ArraySeq(iters);\n    if (isKeyedCollection) {\n      concatSeq = concatSeq.toKeyedSeq();\n    } else if (!isIndexed(collection)) {\n      concatSeq = concatSeq.toSetSeq();\n    }\n    concatSeq = concatSeq.flatten(true);\n    concatSeq.size = iters.reduce(function (sum, seq) {\n      if (sum !== undefined) {\n        var size = seq.size;\n        if (size !== undefined) {\n          return sum + size;\n        }\n      }\n    }, 0);\n    return concatSeq;\n  }\n\n  function flattenFactory(collection, depth, useKeys) {\n    var flatSequence = makeSequence(collection);\n    flatSequence.__iterateUncached = function (fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterations = 0;\n      var stopped = false;\n      function flatDeep(iter, currentDepth) {\n        iter.__iterate(function (v, k) {\n          if ((!depth || currentDepth < depth) && isCollection(v)) {\n            flatDeep(v, currentDepth + 1);\n          } else {\n            iterations++;\n            if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {\n              stopped = true;\n            }\n          }\n          return !stopped;\n        }, reverse);\n      }\n      flatDeep(collection, 0);\n      return iterations;\n    };\n    flatSequence.__iteratorUncached = function (type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = collection.__iterator(type, reverse);\n      var stack = [];\n      var iterations = 0;\n      return new Iterator(function () {\n        while (iterator) {\n          var step = iterator.next();\n          if (step.done !== false) {\n            iterator = stack.pop();\n            continue;\n          }\n          var v = step.value;\n          if (type === ITERATE_ENTRIES) {\n            v = v[1];\n          }\n          if ((!depth || stack.length < depth) && isCollection(v)) {\n            stack.push(iterator);\n            iterator = v.__iterator(type, reverse);\n          } else {\n            return useKeys ? step : iteratorValue(type, iterations++, v, step);\n          }\n        }\n        return iteratorDone();\n      });\n    };\n    return flatSequence;\n  }\n\n  function flatMapFactory(collection, mapper, context) {\n    var coerce = collectionClass(collection);\n    return collection\n      .toSeq()\n      .map(function (v, k) { return coerce(mapper.call(context, v, k, collection)); })\n      .flatten(true);\n  }\n\n  function interposeFactory(collection, separator) {\n    var interposedSequence = makeSequence(collection);\n    interposedSequence.size = collection.size && collection.size * 2 - 1;\n    interposedSequence.__iterateUncached = function (fn, reverse) {\n      var this$1 = this;\n\n      var iterations = 0;\n      collection.__iterate(\n        function (v) { return (!iterations || fn(separator, iterations++, this$1) !== false) &&\n          fn(v, iterations++, this$1) !== false; },\n        reverse\n      );\n      return iterations;\n    };\n    interposedSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = collection.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      var step;\n      return new Iterator(function () {\n        if (!step || iterations % 2) {\n          step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n        }\n        return iterations % 2\n          ? iteratorValue(type, iterations++, separator)\n          : iteratorValue(type, iterations++, step.value, step);\n      });\n    };\n    return interposedSequence;\n  }\n\n  function sortFactory(collection, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    var isKeyedCollection = isKeyed(collection);\n    var index = 0;\n    var entries = collection\n      .toSeq()\n      .map(function (v, k) { return [k, v, index++, mapper ? mapper(v, k, collection) : v]; })\n      .valueSeq()\n      .toArray();\n    entries\n      .sort(function (a, b) { return comparator(a[3], b[3]) || a[2] - b[2]; })\n      .forEach(\n        isKeyedCollection\n          ? function (v, i) {\n              entries[i].length = 2;\n            }\n          : function (v, i) {\n              entries[i] = v[1];\n            }\n      );\n    return isKeyedCollection\n      ? KeyedSeq(entries)\n      : isIndexed(collection)\n      ? IndexedSeq(entries)\n      : SetSeq(entries);\n  }\n\n  function maxFactory(collection, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    if (mapper) {\n      var entry = collection\n        .toSeq()\n        .map(function (v, k) { return [v, mapper(v, k, collection)]; })\n        .reduce(function (a, b) { return (maxCompare(comparator, a[1], b[1]) ? b : a); });\n      return entry && entry[0];\n    }\n    return collection.reduce(function (a, b) { return (maxCompare(comparator, a, b) ? b : a); });\n  }\n\n  function maxCompare(comparator, a, b) {\n    var comp = comparator(b, a);\n    // b is considered the new max if the comparator declares them equal, but\n    // they are not equal and b is in fact a nullish value.\n    return (\n      (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) ||\n      comp > 0\n    );\n  }\n\n  function zipWithFactory(keyIter, zipper, iters, zipAll) {\n    var zipSequence = makeSequence(keyIter);\n    var sizes = new ArraySeq(iters).map(function (i) { return i.size; });\n    zipSequence.size = zipAll ? sizes.max() : sizes.min();\n    // Note: this a generic base implementation of __iterate in terms of\n    // __iterator which may be more generically useful in the future.\n    zipSequence.__iterate = function (fn, reverse) {\n      /* generic:\n      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        iterations++;\n        if (fn(step.value[1], step.value[0], this) === false) {\n          break;\n        }\n      }\n      return iterations;\n      */\n      // indexed:\n      var iterator = this.__iterator(ITERATE_VALUES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n    zipSequence.__iteratorUncached = function (type, reverse) {\n      var iterators = iters.map(\n        function (i) { return ((i = Collection(i)), getIterator(reverse ? i.reverse() : i)); }\n      );\n      var iterations = 0;\n      var isDone = false;\n      return new Iterator(function () {\n        var steps;\n        if (!isDone) {\n          steps = iterators.map(function (i) { return i.next(); });\n          isDone = zipAll ? steps.every(function (s) { return s.done; }) : steps.some(function (s) { return s.done; });\n        }\n        if (isDone) {\n          return iteratorDone();\n        }\n        return iteratorValue(\n          type,\n          iterations++,\n          zipper.apply(\n            null,\n            steps.map(function (s) { return s.value; })\n          )\n        );\n      });\n    };\n    return zipSequence;\n  }\n\n  // #pragma Helper Functions\n\n  function reify(iter, seq) {\n    return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);\n  }\n\n  function validateEntry(entry) {\n    if (entry !== Object(entry)) {\n      throw new TypeError('Expected [K, V] tuple: ' + entry);\n    }\n  }\n\n  function collectionClass(collection) {\n    return isKeyed(collection)\n      ? KeyedCollection\n      : isIndexed(collection)\n      ? IndexedCollection\n      : SetCollection;\n  }\n\n  function makeSequence(collection) {\n    return Object.create(\n      (isKeyed(collection)\n        ? KeyedSeq\n        : isIndexed(collection)\n        ? IndexedSeq\n        : SetSeq\n      ).prototype\n    );\n  }\n\n  function cacheResultThrough() {\n    if (this._iter.cacheResult) {\n      this._iter.cacheResult();\n      this.size = this._iter.size;\n      return this;\n    }\n    return Seq.prototype.cacheResult.call(this);\n  }\n\n  function defaultComparator(a, b) {\n    if (a === undefined && b === undefined) {\n      return 0;\n    }\n\n    if (a === undefined) {\n      return 1;\n    }\n\n    if (b === undefined) {\n      return -1;\n    }\n\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n\n  function arrCopy(arr, offset) {\n    offset = offset || 0;\n    var len = Math.max(0, arr.length - offset);\n    var newArr = new Array(len);\n    for (var ii = 0; ii < len; ii++) {\n      newArr[ii] = arr[ii + offset];\n    }\n    return newArr;\n  }\n\n  function invariant(condition, error) {\n    if (!condition) { throw new Error(error); }\n  }\n\n  function assertNotInfinite(size) {\n    invariant(\n      size !== Infinity,\n      'Cannot perform this action with an infinite size.'\n    );\n  }\n\n  function coerceKeyPath(keyPath) {\n    if (isArrayLike(keyPath) && typeof keyPath !== 'string') {\n      return keyPath;\n    }\n    if (isOrdered(keyPath)) {\n      return keyPath.toArray();\n    }\n    throw new TypeError(\n      'Invalid keyPath: expected Ordered Collection or Array: ' + keyPath\n    );\n  }\n\n  function isPlainObj(value) {\n    return (\n      value &&\n      (typeof value.constructor !== 'function' ||\n        value.constructor.name === 'Object')\n    );\n  }\n\n  /**\n   * Returns true if the value is a potentially-persistent data structure, either\n   * provided by Immutable.js or a plain Array or Object.\n   */\n  function isDataStructure(value) {\n    return (\n      typeof value === 'object' &&\n      (isImmutable(value) || Array.isArray(value) || isPlainObj(value))\n    );\n  }\n\n  function quoteString(value) {\n    try {\n      return typeof value === 'string' ? JSON.stringify(value) : String(value);\n    } catch (_ignoreError) {\n      return JSON.stringify(value);\n    }\n  }\n\n  function has(collection, key) {\n    return isImmutable(collection)\n      ? collection.has(key)\n      : isDataStructure(collection) && hasOwnProperty.call(collection, key);\n  }\n\n  function get(collection, key, notSetValue) {\n    return isImmutable(collection)\n      ? collection.get(key, notSetValue)\n      : !has(collection, key)\n      ? notSetValue\n      : typeof collection.get === 'function'\n      ? collection.get(key)\n      : collection[key];\n  }\n\n  function shallowCopy(from) {\n    if (Array.isArray(from)) {\n      return arrCopy(from);\n    }\n    var to = {};\n    for (var key in from) {\n      if (hasOwnProperty.call(from, key)) {\n        to[key] = from[key];\n      }\n    }\n    return to;\n  }\n\n  function remove(collection, key) {\n    if (!isDataStructure(collection)) {\n      throw new TypeError(\n        'Cannot update non-data-structure value: ' + collection\n      );\n    }\n    if (isImmutable(collection)) {\n      if (!collection.remove) {\n        throw new TypeError(\n          'Cannot update immutable value without .remove() method: ' + collection\n        );\n      }\n      return collection.remove(key);\n    }\n    if (!hasOwnProperty.call(collection, key)) {\n      return collection;\n    }\n    var collectionCopy = shallowCopy(collection);\n    if (Array.isArray(collectionCopy)) {\n      collectionCopy.splice(key, 1);\n    } else {\n      delete collectionCopy[key];\n    }\n    return collectionCopy;\n  }\n\n  function set(collection, key, value) {\n    if (!isDataStructure(collection)) {\n      throw new TypeError(\n        'Cannot update non-data-structure value: ' + collection\n      );\n    }\n    if (isImmutable(collection)) {\n      if (!collection.set) {\n        throw new TypeError(\n          'Cannot update immutable value without .set() method: ' + collection\n        );\n      }\n      return collection.set(key, value);\n    }\n    if (hasOwnProperty.call(collection, key) && value === collection[key]) {\n      return collection;\n    }\n    var collectionCopy = shallowCopy(collection);\n    collectionCopy[key] = value;\n    return collectionCopy;\n  }\n\n  function updateIn(collection, keyPath, notSetValue, updater) {\n    if (!updater) {\n      updater = notSetValue;\n      notSetValue = undefined;\n    }\n    var updatedValue = updateInDeeply(\n      isImmutable(collection),\n      collection,\n      coerceKeyPath(keyPath),\n      0,\n      notSetValue,\n      updater\n    );\n    return updatedValue === NOT_SET ? notSetValue : updatedValue;\n  }\n\n  function updateInDeeply(\n    inImmutable,\n    existing,\n    keyPath,\n    i,\n    notSetValue,\n    updater\n  ) {\n    var wasNotSet = existing === NOT_SET;\n    if (i === keyPath.length) {\n      var existingValue = wasNotSet ? notSetValue : existing;\n      var newValue = updater(existingValue);\n      return newValue === existingValue ? existing : newValue;\n    }\n    if (!wasNotSet && !isDataStructure(existing)) {\n      throw new TypeError(\n        'Cannot update within non-data-structure value in path [' +\n          keyPath.slice(0, i).map(quoteString) +\n          ']: ' +\n          existing\n      );\n    }\n    var key = keyPath[i];\n    var nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);\n    var nextUpdated = updateInDeeply(\n      nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting),\n      nextExisting,\n      keyPath,\n      i + 1,\n      notSetValue,\n      updater\n    );\n    return nextUpdated === nextExisting\n      ? existing\n      : nextUpdated === NOT_SET\n      ? remove(existing, key)\n      : set(\n          wasNotSet ? (inImmutable ? emptyMap() : {}) : existing,\n          key,\n          nextUpdated\n        );\n  }\n\n  function setIn(collection, keyPath, value) {\n    return updateIn(collection, keyPath, NOT_SET, function () { return value; });\n  }\n\n  function setIn$1(keyPath, v) {\n    return setIn(this, keyPath, v);\n  }\n\n  function removeIn(collection, keyPath) {\n    return updateIn(collection, keyPath, function () { return NOT_SET; });\n  }\n\n  function deleteIn(keyPath) {\n    return removeIn(this, keyPath);\n  }\n\n  function update(collection, key, notSetValue, updater) {\n    return updateIn(collection, [key], notSetValue, updater);\n  }\n\n  function update$1(key, notSetValue, updater) {\n    return arguments.length === 1\n      ? key(this)\n      : update(this, key, notSetValue, updater);\n  }\n\n  function updateIn$1(keyPath, notSetValue, updater) {\n    return updateIn(this, keyPath, notSetValue, updater);\n  }\n\n  function merge() {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    return mergeIntoKeyedWith(this, iters);\n  }\n\n  function mergeWith(merger) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    if (typeof merger !== 'function') {\n      throw new TypeError('Invalid merger function: ' + merger);\n    }\n    return mergeIntoKeyedWith(this, iters, merger);\n  }\n\n  function mergeIntoKeyedWith(collection, collections, merger) {\n    var iters = [];\n    for (var ii = 0; ii < collections.length; ii++) {\n      var collection$1 = KeyedCollection(collections[ii]);\n      if (collection$1.size !== 0) {\n        iters.push(collection$1);\n      }\n    }\n    if (iters.length === 0) {\n      return collection;\n    }\n    if (\n      collection.toSeq().size === 0 &&\n      !collection.__ownerID &&\n      iters.length === 1\n    ) {\n      return collection.constructor(iters[0]);\n    }\n    return collection.withMutations(function (collection) {\n      var mergeIntoCollection = merger\n        ? function (value, key) {\n            update(collection, key, NOT_SET, function (oldVal) { return oldVal === NOT_SET ? value : merger(oldVal, value, key); }\n            );\n          }\n        : function (value, key) {\n            collection.set(key, value);\n          };\n      for (var ii = 0; ii < iters.length; ii++) {\n        iters[ii].forEach(mergeIntoCollection);\n      }\n    });\n  }\n\n  function merge$1(collection) {\n    var sources = [], len = arguments.length - 1;\n    while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n    return mergeWithSources(collection, sources);\n  }\n\n  function mergeWith$1(merger, collection) {\n    var sources = [], len = arguments.length - 2;\n    while ( len-- > 0 ) sources[ len ] = arguments[ len + 2 ];\n\n    return mergeWithSources(collection, sources, merger);\n  }\n\n  function mergeDeep(collection) {\n    var sources = [], len = arguments.length - 1;\n    while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n    return mergeDeepWithSources(collection, sources);\n  }\n\n  function mergeDeepWith(merger, collection) {\n    var sources = [], len = arguments.length - 2;\n    while ( len-- > 0 ) sources[ len ] = arguments[ len + 2 ];\n\n    return mergeDeepWithSources(collection, sources, merger);\n  }\n\n  function mergeDeepWithSources(collection, sources, merger) {\n    return mergeWithSources(collection, sources, deepMergerWith(merger));\n  }\n\n  function mergeWithSources(collection, sources, merger) {\n    if (!isDataStructure(collection)) {\n      throw new TypeError(\n        'Cannot merge into non-data-structure value: ' + collection\n      );\n    }\n    if (isImmutable(collection)) {\n      return typeof merger === 'function' && collection.mergeWith\n        ? collection.mergeWith.apply(collection, [ merger ].concat( sources ))\n        : collection.merge\n        ? collection.merge.apply(collection, sources)\n        : collection.concat.apply(collection, sources);\n    }\n    var isArray = Array.isArray(collection);\n    var merged = collection;\n    var Collection = isArray ? IndexedCollection : KeyedCollection;\n    var mergeItem = isArray\n      ? function (value) {\n          // Copy on write\n          if (merged === collection) {\n            merged = shallowCopy(merged);\n          }\n          merged.push(value);\n        }\n      : function (value, key) {\n          var hasVal = hasOwnProperty.call(merged, key);\n          var nextVal =\n            hasVal && merger ? merger(merged[key], value, key) : value;\n          if (!hasVal || nextVal !== merged[key]) {\n            // Copy on write\n            if (merged === collection) {\n              merged = shallowCopy(merged);\n            }\n            merged[key] = nextVal;\n          }\n        };\n    for (var i = 0; i < sources.length; i++) {\n      Collection(sources[i]).forEach(mergeItem);\n    }\n    return merged;\n  }\n\n  function deepMergerWith(merger) {\n    function deepMerger(oldValue, newValue, key) {\n      return isDataStructure(oldValue) && isDataStructure(newValue)\n        ? mergeWithSources(oldValue, [newValue], deepMerger)\n        : merger\n        ? merger(oldValue, newValue, key)\n        : newValue;\n    }\n    return deepMerger;\n  }\n\n  function mergeDeep$1() {\n    var iters = [], len = arguments.length;\n    while ( len-- ) iters[ len ] = arguments[ len ];\n\n    return mergeDeepWithSources(this, iters);\n  }\n\n  function mergeDeepWith$1(merger) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return mergeDeepWithSources(this, iters, merger);\n  }\n\n  function mergeIn(keyPath) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return updateIn(this, keyPath, emptyMap(), function (m) { return mergeWithSources(m, iters); });\n  }\n\n  function mergeDeepIn(keyPath) {\n    var iters = [], len = arguments.length - 1;\n    while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];\n\n    return updateIn(this, keyPath, emptyMap(), function (m) { return mergeDeepWithSources(m, iters); }\n    );\n  }\n\n  function withMutations(fn) {\n    var mutable = this.asMutable();\n    fn(mutable);\n    return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n  }\n\n  function asMutable() {\n    return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n  }\n\n  function asImmutable() {\n    return this.__ensureOwner();\n  }\n\n  function wasAltered() {\n    return this.__altered;\n  }\n\n  var Map = /*@__PURE__*/(function (KeyedCollection) {\n    function Map(value) {\n      return value === null || value === undefined\n        ? emptyMap()\n        : isMap(value) && !isOrdered(value)\n        ? value\n        : emptyMap().withMutations(function (map) {\n            var iter = KeyedCollection(value);\n            assertNotInfinite(iter.size);\n            iter.forEach(function (v, k) { return map.set(k, v); });\n          });\n    }\n\n    if ( KeyedCollection ) Map.__proto__ = KeyedCollection;\n    Map.prototype = Object.create( KeyedCollection && KeyedCollection.prototype );\n    Map.prototype.constructor = Map;\n\n    Map.of = function of () {\n      var keyValues = [], len = arguments.length;\n      while ( len-- ) keyValues[ len ] = arguments[ len ];\n\n      return emptyMap().withMutations(function (map) {\n        for (var i = 0; i < keyValues.length; i += 2) {\n          if (i + 1 >= keyValues.length) {\n            throw new Error('Missing value for key: ' + keyValues[i]);\n          }\n          map.set(keyValues[i], keyValues[i + 1]);\n        }\n      });\n    };\n\n    Map.prototype.toString = function toString () {\n      return this.__toString('Map {', '}');\n    };\n\n    // @pragma Access\n\n    Map.prototype.get = function get (k, notSetValue) {\n      return this._root\n        ? this._root.get(0, undefined, k, notSetValue)\n        : notSetValue;\n    };\n\n    // @pragma Modification\n\n    Map.prototype.set = function set (k, v) {\n      return updateMap(this, k, v);\n    };\n\n    Map.prototype.remove = function remove (k) {\n      return updateMap(this, k, NOT_SET);\n    };\n\n    Map.prototype.deleteAll = function deleteAll (keys) {\n      var collection = Collection(keys);\n\n      if (collection.size === 0) {\n        return this;\n      }\n\n      return this.withMutations(function (map) {\n        collection.forEach(function (key) { return map.remove(key); });\n      });\n    };\n\n    Map.prototype.clear = function clear () {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._root = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyMap();\n    };\n\n    // @pragma Composition\n\n    Map.prototype.sort = function sort (comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator));\n    };\n\n    Map.prototype.sortBy = function sortBy (mapper, comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator, mapper));\n    };\n\n    Map.prototype.map = function map (mapper, context) {\n      return this.withMutations(function (map) {\n        map.forEach(function (value, key) {\n          map.set(key, mapper.call(context, value, key, map));\n        });\n      });\n    };\n\n    // @pragma Mutability\n\n    Map.prototype.__iterator = function __iterator (type, reverse) {\n      return new MapIterator(this, type, reverse);\n    };\n\n    Map.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      var iterations = 0;\n      this._root &&\n        this._root.iterate(function (entry) {\n          iterations++;\n          return fn(entry[1], entry[0], this$1);\n        }, reverse);\n      return iterations;\n    };\n\n    Map.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        if (this.size === 0) {\n          return emptyMap();\n        }\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeMap(this.size, this._root, ownerID, this.__hash);\n    };\n\n    return Map;\n  }(KeyedCollection));\n\n  Map.isMap = isMap;\n\n  var MapPrototype = Map.prototype;\n  MapPrototype[IS_MAP_SYMBOL] = true;\n  MapPrototype[DELETE] = MapPrototype.remove;\n  MapPrototype.removeAll = MapPrototype.deleteAll;\n  MapPrototype.setIn = setIn$1;\n  MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;\n  MapPrototype.update = update$1;\n  MapPrototype.updateIn = updateIn$1;\n  MapPrototype.merge = MapPrototype.concat = merge;\n  MapPrototype.mergeWith = mergeWith;\n  MapPrototype.mergeDeep = mergeDeep$1;\n  MapPrototype.mergeDeepWith = mergeDeepWith$1;\n  MapPrototype.mergeIn = mergeIn;\n  MapPrototype.mergeDeepIn = mergeDeepIn;\n  MapPrototype.withMutations = withMutations;\n  MapPrototype.wasAltered = wasAltered;\n  MapPrototype.asImmutable = asImmutable;\n  MapPrototype['@@transducer/init'] = MapPrototype.asMutable = asMutable;\n  MapPrototype['@@transducer/step'] = function (result, arr) {\n    return result.set(arr[0], arr[1]);\n  };\n  MapPrototype['@@transducer/result'] = function (obj) {\n    return obj.asImmutable();\n  };\n\n  // #pragma Trie Nodes\n\n  var ArrayMapNode = function ArrayMapNode(ownerID, entries) {\n    this.ownerID = ownerID;\n    this.entries = entries;\n  };\n\n  ArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n    var entries = this.entries;\n    for (var ii = 0, len = entries.length; ii < len; ii++) {\n      if (is(key, entries[ii][0])) {\n        return entries[ii][1];\n      }\n    }\n    return notSetValue;\n  };\n\n  ArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    var removed = value === NOT_SET;\n\n    var entries = this.entries;\n    var idx = 0;\n    var len = entries.length;\n    for (; idx < len; idx++) {\n      if (is(key, entries[idx][0])) {\n        break;\n      }\n    }\n    var exists = idx < len;\n\n    if (exists ? entries[idx][1] === value : removed) {\n      return this;\n    }\n\n    SetRef(didAlter);\n    (removed || !exists) && SetRef(didChangeSize);\n\n    if (removed && entries.length === 1) {\n      return; // undefined\n    }\n\n    if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n      return createNodes(ownerID, entries, key, value);\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newEntries = isEditable ? entries : arrCopy(entries);\n\n    if (exists) {\n      if (removed) {\n        idx === len - 1\n          ? newEntries.pop()\n          : (newEntries[idx] = newEntries.pop());\n      } else {\n        newEntries[idx] = [key, value];\n      }\n    } else {\n      newEntries.push([key, value]);\n    }\n\n    if (isEditable) {\n      this.entries = newEntries;\n      return this;\n    }\n\n    return new ArrayMapNode(ownerID, newEntries);\n  };\n\n  var BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {\n    this.ownerID = ownerID;\n    this.bitmap = bitmap;\n    this.nodes = nodes;\n  };\n\n  BitmapIndexedNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n    var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);\n    var bitmap = this.bitmap;\n    return (bitmap & bit) === 0\n      ? notSetValue\n      : this.nodes[popCount(bitmap & (bit - 1))].get(\n          shift + SHIFT,\n          keyHash,\n          key,\n          notSetValue\n        );\n  };\n\n  BitmapIndexedNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n    var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var bit = 1 << keyHashFrag;\n    var bitmap = this.bitmap;\n    var exists = (bitmap & bit) !== 0;\n\n    if (!exists && value === NOT_SET) {\n      return this;\n    }\n\n    var idx = popCount(bitmap & (bit - 1));\n    var nodes = this.nodes;\n    var node = exists ? nodes[idx] : undefined;\n    var newNode = updateNode(\n      node,\n      ownerID,\n      shift + SHIFT,\n      keyHash,\n      key,\n      value,\n      didChangeSize,\n      didAlter\n    );\n\n    if (newNode === node) {\n      return this;\n    }\n\n    if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n      return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n    }\n\n    if (\n      exists &&\n      !newNode &&\n      nodes.length === 2 &&\n      isLeafNode(nodes[idx ^ 1])\n    ) {\n      return nodes[idx ^ 1];\n    }\n\n    if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n      return newNode;\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newBitmap = exists ? (newNode ? bitmap : bitmap ^ bit) : bitmap | bit;\n    var newNodes = exists\n      ? newNode\n        ? setAt(nodes, idx, newNode, isEditable)\n        : spliceOut(nodes, idx, isEditable)\n      : spliceIn(nodes, idx, newNode, isEditable);\n\n    if (isEditable) {\n      this.bitmap = newBitmap;\n      this.nodes = newNodes;\n      return this;\n    }\n\n    return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n  };\n\n  var HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {\n    this.ownerID = ownerID;\n    this.count = count;\n    this.nodes = nodes;\n  };\n\n  HashArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var node = this.nodes[idx];\n    return node\n      ? node.get(shift + SHIFT, keyHash, key, notSetValue)\n      : notSetValue;\n  };\n\n  HashArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n    var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n    var removed = value === NOT_SET;\n    var nodes = this.nodes;\n    var node = nodes[idx];\n\n    if (removed && !node) {\n      return this;\n    }\n\n    var newNode = updateNode(\n      node,\n      ownerID,\n      shift + SHIFT,\n      keyHash,\n      key,\n      value,\n      didChangeSize,\n      didAlter\n    );\n    if (newNode === node) {\n      return this;\n    }\n\n    var newCount = this.count;\n    if (!node) {\n      newCount++;\n    } else if (!newNode) {\n      newCount--;\n      if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n        return packNodes(ownerID, nodes, newCount, idx);\n      }\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newNodes = setAt(nodes, idx, newNode, isEditable);\n\n    if (isEditable) {\n      this.count = newCount;\n      this.nodes = newNodes;\n      return this;\n    }\n\n    return new HashArrayMapNode(ownerID, newCount, newNodes);\n  };\n\n  var HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {\n    this.ownerID = ownerID;\n    this.keyHash = keyHash;\n    this.entries = entries;\n  };\n\n  HashCollisionNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n    var entries = this.entries;\n    for (var ii = 0, len = entries.length; ii < len; ii++) {\n      if (is(key, entries[ii][0])) {\n        return entries[ii][1];\n      }\n    }\n    return notSetValue;\n  };\n\n  HashCollisionNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (keyHash === undefined) {\n      keyHash = hash(key);\n    }\n\n    var removed = value === NOT_SET;\n\n    if (keyHash !== this.keyHash) {\n      if (removed) {\n        return this;\n      }\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n    }\n\n    var entries = this.entries;\n    var idx = 0;\n    var len = entries.length;\n    for (; idx < len; idx++) {\n      if (is(key, entries[idx][0])) {\n        break;\n      }\n    }\n    var exists = idx < len;\n\n    if (exists ? entries[idx][1] === value : removed) {\n      return this;\n    }\n\n    SetRef(didAlter);\n    (removed || !exists) && SetRef(didChangeSize);\n\n    if (removed && len === 2) {\n      return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n    }\n\n    var isEditable = ownerID && ownerID === this.ownerID;\n    var newEntries = isEditable ? entries : arrCopy(entries);\n\n    if (exists) {\n      if (removed) {\n        idx === len - 1\n          ? newEntries.pop()\n          : (newEntries[idx] = newEntries.pop());\n      } else {\n        newEntries[idx] = [key, value];\n      }\n    } else {\n      newEntries.push([key, value]);\n    }\n\n    if (isEditable) {\n      this.entries = newEntries;\n      return this;\n    }\n\n    return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n  };\n\n  var ValueNode = function ValueNode(ownerID, keyHash, entry) {\n    this.ownerID = ownerID;\n    this.keyHash = keyHash;\n    this.entry = entry;\n  };\n\n  ValueNode.prototype.get = function get (shift, keyHash, key, notSetValue) {\n    return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n  };\n\n  ValueNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    var removed = value === NOT_SET;\n    var keyMatch = is(key, this.entry[0]);\n    if (keyMatch ? value === this.entry[1] : removed) {\n      return this;\n    }\n\n    SetRef(didAlter);\n\n    if (removed) {\n      SetRef(didChangeSize);\n      return; // undefined\n    }\n\n    if (keyMatch) {\n      if (ownerID && ownerID === this.ownerID) {\n        this.entry[1] = value;\n        return this;\n      }\n      return new ValueNode(ownerID, this.keyHash, [key, value]);\n    }\n\n    SetRef(didChangeSize);\n    return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n  };\n\n  // #pragma Iterators\n\n  ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate =\n    function (fn, reverse) {\n      var entries = this.entries;\n      for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n        if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n          return false;\n        }\n      }\n    };\n\n  BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate =\n    function (fn, reverse) {\n      var nodes = this.nodes;\n      for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n        var node = nodes[reverse ? maxIndex - ii : ii];\n        if (node && node.iterate(fn, reverse) === false) {\n          return false;\n        }\n      }\n    };\n\n  // eslint-disable-next-line no-unused-vars\n  ValueNode.prototype.iterate = function (fn, reverse) {\n    return fn(this.entry);\n  };\n\n  var MapIterator = /*@__PURE__*/(function (Iterator) {\n    function MapIterator(map, type, reverse) {\n      this._type = type;\n      this._reverse = reverse;\n      this._stack = map._root && mapIteratorFrame(map._root);\n    }\n\n    if ( Iterator ) MapIterator.__proto__ = Iterator;\n    MapIterator.prototype = Object.create( Iterator && Iterator.prototype );\n    MapIterator.prototype.constructor = MapIterator;\n\n    MapIterator.prototype.next = function next () {\n      var type = this._type;\n      var stack = this._stack;\n      while (stack) {\n        var node = stack.node;\n        var index = stack.index++;\n        var maxIndex = (void 0);\n        if (node.entry) {\n          if (index === 0) {\n            return mapIteratorValue(type, node.entry);\n          }\n        } else if (node.entries) {\n          maxIndex = node.entries.length - 1;\n          if (index <= maxIndex) {\n            return mapIteratorValue(\n              type,\n              node.entries[this._reverse ? maxIndex - index : index]\n            );\n          }\n        } else {\n          maxIndex = node.nodes.length - 1;\n          if (index <= maxIndex) {\n            var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n            if (subNode) {\n              if (subNode.entry) {\n                return mapIteratorValue(type, subNode.entry);\n              }\n              stack = this._stack = mapIteratorFrame(subNode, stack);\n            }\n            continue;\n          }\n        }\n        stack = this._stack = this._stack.__prev;\n      }\n      return iteratorDone();\n    };\n\n    return MapIterator;\n  }(Iterator));\n\n  function mapIteratorValue(type, entry) {\n    return iteratorValue(type, entry[0], entry[1]);\n  }\n\n  function mapIteratorFrame(node, prev) {\n    return {\n      node: node,\n      index: 0,\n      __prev: prev,\n    };\n  }\n\n  function makeMap(size, root, ownerID, hash) {\n    var map = Object.create(MapPrototype);\n    map.size = size;\n    map._root = root;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_MAP;\n  function emptyMap() {\n    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n  }\n\n  function updateMap(map, k, v) {\n    var newRoot;\n    var newSize;\n    if (!map._root) {\n      if (v === NOT_SET) {\n        return map;\n      }\n      newSize = 1;\n      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n    } else {\n      var didChangeSize = MakeRef();\n      var didAlter = MakeRef();\n      newRoot = updateNode(\n        map._root,\n        map.__ownerID,\n        0,\n        undefined,\n        k,\n        v,\n        didChangeSize,\n        didAlter\n      );\n      if (!didAlter.value) {\n        return map;\n      }\n      newSize = map.size + (didChangeSize.value ? (v === NOT_SET ? -1 : 1) : 0);\n    }\n    if (map.__ownerID) {\n      map.size = newSize;\n      map._root = newRoot;\n      map.__hash = undefined;\n      map.__altered = true;\n      return map;\n    }\n    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n  }\n\n  function updateNode(\n    node,\n    ownerID,\n    shift,\n    keyHash,\n    key,\n    value,\n    didChangeSize,\n    didAlter\n  ) {\n    if (!node) {\n      if (value === NOT_SET) {\n        return node;\n      }\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return new ValueNode(ownerID, keyHash, [key, value]);\n    }\n    return node.update(\n      ownerID,\n      shift,\n      keyHash,\n      key,\n      value,\n      didChangeSize,\n      didAlter\n    );\n  }\n\n  function isLeafNode(node) {\n    return (\n      node.constructor === ValueNode || node.constructor === HashCollisionNode\n    );\n  }\n\n  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n    if (node.keyHash === keyHash) {\n      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n    }\n\n    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\n    var newNode;\n    var nodes =\n      idx1 === idx2\n        ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)]\n        : ((newNode = new ValueNode(ownerID, keyHash, entry)),\n          idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\n    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n  }\n\n  function createNodes(ownerID, entries, key, value) {\n    if (!ownerID) {\n      ownerID = new OwnerID();\n    }\n    var node = new ValueNode(ownerID, hash(key), [key, value]);\n    for (var ii = 0; ii < entries.length; ii++) {\n      var entry = entries[ii];\n      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n    }\n    return node;\n  }\n\n  function packNodes(ownerID, nodes, count, excluding) {\n    var bitmap = 0;\n    var packedII = 0;\n    var packedNodes = new Array(count);\n    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n      var node = nodes[ii];\n      if (node !== undefined && ii !== excluding) {\n        bitmap |= bit;\n        packedNodes[packedII++] = node;\n      }\n    }\n    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n  }\n\n  function expandNodes(ownerID, nodes, bitmap, including, node) {\n    var count = 0;\n    var expandedNodes = new Array(SIZE);\n    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n    }\n    expandedNodes[including] = node;\n    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n  }\n\n  function popCount(x) {\n    x -= (x >> 1) & 0x55555555;\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    x = (x + (x >> 4)) & 0x0f0f0f0f;\n    x += x >> 8;\n    x += x >> 16;\n    return x & 0x7f;\n  }\n\n  function setAt(array, idx, val, canEdit) {\n    var newArray = canEdit ? array : arrCopy(array);\n    newArray[idx] = val;\n    return newArray;\n  }\n\n  function spliceIn(array, idx, val, canEdit) {\n    var newLen = array.length + 1;\n    if (canEdit && idx + 1 === newLen) {\n      array[idx] = val;\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        newArray[ii] = val;\n        after = -1;\n      } else {\n        newArray[ii] = array[ii + after];\n      }\n    }\n    return newArray;\n  }\n\n  function spliceOut(array, idx, canEdit) {\n    var newLen = array.length - 1;\n    if (canEdit && idx === newLen) {\n      array.pop();\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        after = 1;\n      }\n      newArray[ii] = array[ii + after];\n    }\n    return newArray;\n  }\n\n  var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\n  var IS_LIST_SYMBOL = '@@__IMMUTABLE_LIST__@@';\n\n  function isList(maybeList) {\n    return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);\n  }\n\n  var List = /*@__PURE__*/(function (IndexedCollection) {\n    function List(value) {\n      var empty = emptyList();\n      if (value === null || value === undefined) {\n        return empty;\n      }\n      if (isList(value)) {\n        return value;\n      }\n      var iter = IndexedCollection(value);\n      var size = iter.size;\n      if (size === 0) {\n        return empty;\n      }\n      assertNotInfinite(size);\n      if (size > 0 && size < SIZE) {\n        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n      }\n      return empty.withMutations(function (list) {\n        list.setSize(size);\n        iter.forEach(function (v, i) { return list.set(i, v); });\n      });\n    }\n\n    if ( IndexedCollection ) List.__proto__ = IndexedCollection;\n    List.prototype = Object.create( IndexedCollection && IndexedCollection.prototype );\n    List.prototype.constructor = List;\n\n    List.of = function of (/*...values*/) {\n      return this(arguments);\n    };\n\n    List.prototype.toString = function toString () {\n      return this.__toString('List [', ']');\n    };\n\n    // @pragma Access\n\n    List.prototype.get = function get (index, notSetValue) {\n      index = wrapIndex(this, index);\n      if (index >= 0 && index < this.size) {\n        index += this._origin;\n        var node = listNodeFor(this, index);\n        return node && node.array[index & MASK];\n      }\n      return notSetValue;\n    };\n\n    // @pragma Modification\n\n    List.prototype.set = function set (index, value) {\n      return updateList(this, index, value);\n    };\n\n    List.prototype.remove = function remove (index) {\n      return !this.has(index)\n        ? this\n        : index === 0\n        ? this.shift()\n        : index === this.size - 1\n        ? this.pop()\n        : this.splice(index, 1);\n    };\n\n    List.prototype.insert = function insert (index, value) {\n      return this.splice(index, 0, value);\n    };\n\n    List.prototype.clear = function clear () {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = this._origin = this._capacity = 0;\n        this._level = SHIFT;\n        this._root = this._tail = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyList();\n    };\n\n    List.prototype.push = function push (/*...values*/) {\n      var values = arguments;\n      var oldSize = this.size;\n      return this.withMutations(function (list) {\n        setListBounds(list, 0, oldSize + values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(oldSize + ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.pop = function pop () {\n      return setListBounds(this, 0, -1);\n    };\n\n    List.prototype.unshift = function unshift (/*...values*/) {\n      var values = arguments;\n      return this.withMutations(function (list) {\n        setListBounds(list, -values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.shift = function shift () {\n      return setListBounds(this, 1);\n    };\n\n    // @pragma Composition\n\n    List.prototype.concat = function concat (/*...collections*/) {\n      var arguments$1 = arguments;\n\n      var seqs = [];\n      for (var i = 0; i < arguments.length; i++) {\n        var argument = arguments$1[i];\n        var seq = IndexedCollection(\n          typeof argument !== 'string' && hasIterator(argument)\n            ? argument\n            : [argument]\n        );\n        if (seq.size !== 0) {\n          seqs.push(seq);\n        }\n      }\n      if (seqs.length === 0) {\n        return this;\n      }\n      if (this.size === 0 && !this.__ownerID && seqs.length === 1) {\n        return this.constructor(seqs[0]);\n      }\n      return this.withMutations(function (list) {\n        seqs.forEach(function (seq) { return seq.forEach(function (value) { return list.push(value); }); });\n      });\n    };\n\n    List.prototype.setSize = function setSize (size) {\n      return setListBounds(this, 0, size);\n    };\n\n    List.prototype.map = function map (mapper, context) {\n      var this$1 = this;\n\n      return this.withMutations(function (list) {\n        for (var i = 0; i < this$1.size; i++) {\n          list.set(i, mapper.call(context, list.get(i), i, list));\n        }\n      });\n    };\n\n    // @pragma Iteration\n\n    List.prototype.slice = function slice (begin, end) {\n      var size = this.size;\n      if (wholeSlice(begin, end, size)) {\n        return this;\n      }\n      return setListBounds(\n        this,\n        resolveBegin(begin, size),\n        resolveEnd(end, size)\n      );\n    };\n\n    List.prototype.__iterator = function __iterator (type, reverse) {\n      var index = reverse ? this.size : 0;\n      var values = iterateList(this, reverse);\n      return new Iterator(function () {\n        var value = values();\n        return value === DONE\n          ? iteratorDone()\n          : iteratorValue(type, reverse ? --index : index++, value);\n      });\n    };\n\n    List.prototype.__iterate = function __iterate (fn, reverse) {\n      var index = reverse ? this.size : 0;\n      var values = iterateList(this, reverse);\n      var value;\n      while ((value = values()) !== DONE) {\n        if (fn(value, reverse ? --index : index++, this) === false) {\n          break;\n        }\n      }\n      return index;\n    };\n\n    List.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        if (this.size === 0) {\n          return emptyList();\n        }\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeList(\n        this._origin,\n        this._capacity,\n        this._level,\n        this._root,\n        this._tail,\n        ownerID,\n        this.__hash\n      );\n    };\n\n    return List;\n  }(IndexedCollection));\n\n  List.isList = isList;\n\n  var ListPrototype = List.prototype;\n  ListPrototype[IS_LIST_SYMBOL] = true;\n  ListPrototype[DELETE] = ListPrototype.remove;\n  ListPrototype.merge = ListPrototype.concat;\n  ListPrototype.setIn = setIn$1;\n  ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;\n  ListPrototype.update = update$1;\n  ListPrototype.updateIn = updateIn$1;\n  ListPrototype.mergeIn = mergeIn;\n  ListPrototype.mergeDeepIn = mergeDeepIn;\n  ListPrototype.withMutations = withMutations;\n  ListPrototype.wasAltered = wasAltered;\n  ListPrototype.asImmutable = asImmutable;\n  ListPrototype['@@transducer/init'] = ListPrototype.asMutable = asMutable;\n  ListPrototype['@@transducer/step'] = function (result, arr) {\n    return result.push(arr);\n  };\n  ListPrototype['@@transducer/result'] = function (obj) {\n    return obj.asImmutable();\n  };\n\n  var VNode = function VNode(array, ownerID) {\n    this.array = array;\n    this.ownerID = ownerID;\n  };\n\n  // TODO: seems like these methods are very similar\n\n  VNode.prototype.removeBefore = function removeBefore (ownerID, level, index) {\n    if (index === level ? 1 << level :  this.array.length === 0) {\n      return this;\n    }\n    var originIndex = (index >>> level) & MASK;\n    if (originIndex >= this.array.length) {\n      return new VNode([], ownerID);\n    }\n    var removingFirst = originIndex === 0;\n    var newChild;\n    if (level > 0) {\n      var oldChild = this.array[originIndex];\n      newChild =\n        oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n      if (newChild === oldChild && removingFirst) {\n        return this;\n      }\n    }\n    if (removingFirst && !newChild) {\n      return this;\n    }\n    var editable = editableVNode(this, ownerID);\n    if (!removingFirst) {\n      for (var ii = 0; ii < originIndex; ii++) {\n        editable.array[ii] = undefined;\n      }\n    }\n    if (newChild) {\n      editable.array[originIndex] = newChild;\n    }\n    return editable;\n  };\n\n  VNode.prototype.removeAfter = function removeAfter (ownerID, level, index) {\n    if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n      return this;\n    }\n    var sizeIndex = ((index - 1) >>> level) & MASK;\n    if (sizeIndex >= this.array.length) {\n      return this;\n    }\n\n    var newChild;\n    if (level > 0) {\n      var oldChild = this.array[sizeIndex];\n      newChild =\n        oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n      if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n        return this;\n      }\n    }\n\n    var editable = editableVNode(this, ownerID);\n    editable.array.splice(sizeIndex + 1);\n    if (newChild) {\n      editable.array[sizeIndex] = newChild;\n    }\n    return editable;\n  };\n\n  var DONE = {};\n\n  function iterateList(list, reverse) {\n    var left = list._origin;\n    var right = list._capacity;\n    var tailPos = getTailOffset(right);\n    var tail = list._tail;\n\n    return iterateNodeOrLeaf(list._root, list._level, 0);\n\n    function iterateNodeOrLeaf(node, level, offset) {\n      return level === 0\n        ? iterateLeaf(node, offset)\n        : iterateNode(node, level, offset);\n    }\n\n    function iterateLeaf(node, offset) {\n      var array = offset === tailPos ? tail && tail.array : node && node.array;\n      var from = offset > left ? 0 : left - offset;\n      var to = right - offset;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function () {\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        return array && array[idx];\n      };\n    }\n\n    function iterateNode(node, level, offset) {\n      var values;\n      var array = node && node.array;\n      var from = offset > left ? 0 : (left - offset) >> level;\n      var to = ((right - offset) >> level) + 1;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function () {\n        while (true) {\n          if (values) {\n            var value = values();\n            if (value !== DONE) {\n              return value;\n            }\n            values = null;\n          }\n          if (from === to) {\n            return DONE;\n          }\n          var idx = reverse ? --to : from++;\n          values = iterateNodeOrLeaf(\n            array && array[idx],\n            level - SHIFT,\n            offset + (idx << level)\n          );\n        }\n      };\n    }\n  }\n\n  function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n    var list = Object.create(ListPrototype);\n    list.size = capacity - origin;\n    list._origin = origin;\n    list._capacity = capacity;\n    list._level = level;\n    list._root = root;\n    list._tail = tail;\n    list.__ownerID = ownerID;\n    list.__hash = hash;\n    list.__altered = false;\n    return list;\n  }\n\n  var EMPTY_LIST;\n  function emptyList() {\n    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n  }\n\n  function updateList(list, index, value) {\n    index = wrapIndex(list, index);\n\n    if (index !== index) {\n      return list;\n    }\n\n    if (index >= list.size || index < 0) {\n      return list.withMutations(function (list) {\n        index < 0\n          ? setListBounds(list, index).set(0, value)\n          : setListBounds(list, 0, index + 1).set(index, value);\n      });\n    }\n\n    index += list._origin;\n\n    var newTail = list._tail;\n    var newRoot = list._root;\n    var didAlter = MakeRef();\n    if (index >= getTailOffset(list._capacity)) {\n      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n    } else {\n      newRoot = updateVNode(\n        newRoot,\n        list.__ownerID,\n        list._level,\n        index,\n        value,\n        didAlter\n      );\n    }\n\n    if (!didAlter.value) {\n      return list;\n    }\n\n    if (list.__ownerID) {\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n  }\n\n  function updateVNode(node, ownerID, level, index, value, didAlter) {\n    var idx = (index >>> level) & MASK;\n    var nodeHas = node && idx < node.array.length;\n    if (!nodeHas && value === undefined) {\n      return node;\n    }\n\n    var newNode;\n\n    if (level > 0) {\n      var lowerNode = node && node.array[idx];\n      var newLowerNode = updateVNode(\n        lowerNode,\n        ownerID,\n        level - SHIFT,\n        index,\n        value,\n        didAlter\n      );\n      if (newLowerNode === lowerNode) {\n        return node;\n      }\n      newNode = editableVNode(node, ownerID);\n      newNode.array[idx] = newLowerNode;\n      return newNode;\n    }\n\n    if (nodeHas && node.array[idx] === value) {\n      return node;\n    }\n\n    if (didAlter) {\n      SetRef(didAlter);\n    }\n\n    newNode = editableVNode(node, ownerID);\n    if (value === undefined && idx === newNode.array.length - 1) {\n      newNode.array.pop();\n    } else {\n      newNode.array[idx] = value;\n    }\n    return newNode;\n  }\n\n  function editableVNode(node, ownerID) {\n    if (ownerID && node && ownerID === node.ownerID) {\n      return node;\n    }\n    return new VNode(node ? node.array.slice() : [], ownerID);\n  }\n\n  function listNodeFor(list, rawIndex) {\n    if (rawIndex >= getTailOffset(list._capacity)) {\n      return list._tail;\n    }\n    if (rawIndex < 1 << (list._level + SHIFT)) {\n      var node = list._root;\n      var level = list._level;\n      while (node && level > 0) {\n        node = node.array[(rawIndex >>> level) & MASK];\n        level -= SHIFT;\n      }\n      return node;\n    }\n  }\n\n  function setListBounds(list, begin, end) {\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin |= 0;\n    }\n    if (end !== undefined) {\n      end |= 0;\n    }\n    var owner = list.__ownerID || new OwnerID();\n    var oldOrigin = list._origin;\n    var oldCapacity = list._capacity;\n    var newOrigin = oldOrigin + begin;\n    var newCapacity =\n      end === undefined\n        ? oldCapacity\n        : end < 0\n        ? oldCapacity + end\n        : oldOrigin + end;\n    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n      return list;\n    }\n\n    // If it's going to end after it starts, it's empty.\n    if (newOrigin >= newCapacity) {\n      return list.clear();\n    }\n\n    var newLevel = list._level;\n    var newRoot = list._root;\n\n    // New origin might need creating a higher root.\n    var offsetShift = 0;\n    while (newOrigin + offsetShift < 0) {\n      newRoot = new VNode(\n        newRoot && newRoot.array.length ? [undefined, newRoot] : [],\n        owner\n      );\n      newLevel += SHIFT;\n      offsetShift += 1 << newLevel;\n    }\n    if (offsetShift) {\n      newOrigin += offsetShift;\n      oldOrigin += offsetShift;\n      newCapacity += offsetShift;\n      oldCapacity += offsetShift;\n    }\n\n    var oldTailOffset = getTailOffset(oldCapacity);\n    var newTailOffset = getTailOffset(newCapacity);\n\n    // New size might need creating a higher root.\n    while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n      newRoot = new VNode(\n        newRoot && newRoot.array.length ? [newRoot] : [],\n        owner\n      );\n      newLevel += SHIFT;\n    }\n\n    // Locate or create the new tail.\n    var oldTail = list._tail;\n    var newTail =\n      newTailOffset < oldTailOffset\n        ? listNodeFor(list, newCapacity - 1)\n        : newTailOffset > oldTailOffset\n        ? new VNode([], owner)\n        : oldTail;\n\n    // Merge Tail into tree.\n    if (\n      oldTail &&\n      newTailOffset > oldTailOffset &&\n      newOrigin < oldCapacity &&\n      oldTail.array.length\n    ) {\n      newRoot = editableVNode(newRoot, owner);\n      var node = newRoot;\n      for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n        var idx = (oldTailOffset >>> level) & MASK;\n        node = node.array[idx] = editableVNode(node.array[idx], owner);\n      }\n      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n    }\n\n    // If the size has been reduced, there's a chance the tail needs to be trimmed.\n    if (newCapacity < oldCapacity) {\n      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n    }\n\n    // If the new origin is within the tail, then we do not need a root.\n    if (newOrigin >= newTailOffset) {\n      newOrigin -= newTailOffset;\n      newCapacity -= newTailOffset;\n      newLevel = SHIFT;\n      newRoot = null;\n      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n      // Otherwise, if the root has been trimmed, garbage collect.\n    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n      offsetShift = 0;\n\n      // Identify the new top root node of the subtree of the old root.\n      while (newRoot) {\n        var beginIndex = (newOrigin >>> newLevel) & MASK;\n        if ((beginIndex !== newTailOffset >>> newLevel) & MASK) {\n          break;\n        }\n        if (beginIndex) {\n          offsetShift += (1 << newLevel) * beginIndex;\n        }\n        newLevel -= SHIFT;\n        newRoot = newRoot.array[beginIndex];\n      }\n\n      // Trim the new sides of the new root.\n      if (newRoot && newOrigin > oldOrigin) {\n        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n      }\n      if (newRoot && newTailOffset < oldTailOffset) {\n        newRoot = newRoot.removeAfter(\n          owner,\n          newLevel,\n          newTailOffset - offsetShift\n        );\n      }\n      if (offsetShift) {\n        newOrigin -= offsetShift;\n        newCapacity -= offsetShift;\n      }\n    }\n\n    if (list.__ownerID) {\n      list.size = newCapacity - newOrigin;\n      list._origin = newOrigin;\n      list._capacity = newCapacity;\n      list._level = newLevel;\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n  }\n\n  function getTailOffset(size) {\n    return size < SIZE ? 0 : ((size - 1) >>> SHIFT) << SHIFT;\n  }\n\n  var OrderedMap = /*@__PURE__*/(function (Map) {\n    function OrderedMap(value) {\n      return value === null || value === undefined\n        ? emptyOrderedMap()\n        : isOrderedMap(value)\n        ? value\n        : emptyOrderedMap().withMutations(function (map) {\n            var iter = KeyedCollection(value);\n            assertNotInfinite(iter.size);\n            iter.forEach(function (v, k) { return map.set(k, v); });\n          });\n    }\n\n    if ( Map ) OrderedMap.__proto__ = Map;\n    OrderedMap.prototype = Object.create( Map && Map.prototype );\n    OrderedMap.prototype.constructor = OrderedMap;\n\n    OrderedMap.of = function of (/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedMap.prototype.toString = function toString () {\n      return this.__toString('OrderedMap {', '}');\n    };\n\n    // @pragma Access\n\n    OrderedMap.prototype.get = function get (k, notSetValue) {\n      var index = this._map.get(k);\n      return index !== undefined ? this._list.get(index)[1] : notSetValue;\n    };\n\n    // @pragma Modification\n\n    OrderedMap.prototype.clear = function clear () {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._map.clear();\n        this._list.clear();\n        return this;\n      }\n      return emptyOrderedMap();\n    };\n\n    OrderedMap.prototype.set = function set (k, v) {\n      return updateOrderedMap(this, k, v);\n    };\n\n    OrderedMap.prototype.remove = function remove (k) {\n      return updateOrderedMap(this, k, NOT_SET);\n    };\n\n    OrderedMap.prototype.wasAltered = function wasAltered () {\n      return this._map.wasAltered() || this._list.wasAltered();\n    };\n\n    OrderedMap.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      return this._list.__iterate(\n        function (entry) { return entry && fn(entry[1], entry[0], this$1); },\n        reverse\n      );\n    };\n\n    OrderedMap.prototype.__iterator = function __iterator (type, reverse) {\n      return this._list.fromEntrySeq().__iterator(type, reverse);\n    };\n\n    OrderedMap.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      var newList = this._list.__ensureOwner(ownerID);\n      if (!ownerID) {\n        if (this.size === 0) {\n          return emptyOrderedMap();\n        }\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        this._list = newList;\n        return this;\n      }\n      return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n    };\n\n    return OrderedMap;\n  }(Map));\n\n  OrderedMap.isOrderedMap = isOrderedMap;\n\n  OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;\n  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\n  function makeOrderedMap(map, list, ownerID, hash) {\n    var omap = Object.create(OrderedMap.prototype);\n    omap.size = map ? map.size : 0;\n    omap._map = map;\n    omap._list = list;\n    omap.__ownerID = ownerID;\n    omap.__hash = hash;\n    return omap;\n  }\n\n  var EMPTY_ORDERED_MAP;\n  function emptyOrderedMap() {\n    return (\n      EMPTY_ORDERED_MAP ||\n      (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()))\n    );\n  }\n\n  function updateOrderedMap(omap, k, v) {\n    var map = omap._map;\n    var list = omap._list;\n    var i = map.get(k);\n    var has = i !== undefined;\n    var newMap;\n    var newList;\n    if (v === NOT_SET) {\n      // removed\n      if (!has) {\n        return omap;\n      }\n      if (list.size >= SIZE && list.size >= map.size * 2) {\n        newList = list.filter(function (entry, idx) { return entry !== undefined && i !== idx; });\n        newMap = newList\n          .toKeyedSeq()\n          .map(function (entry) { return entry[0]; })\n          .flip()\n          .toMap();\n        if (omap.__ownerID) {\n          newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n        }\n      } else {\n        newMap = map.remove(k);\n        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n      }\n    } else if (has) {\n      if (v === list.get(i)[1]) {\n        return omap;\n      }\n      newMap = map;\n      newList = list.set(i, [k, v]);\n    } else {\n      newMap = map.set(k, list.size);\n      newList = list.set(list.size, [k, v]);\n    }\n    if (omap.__ownerID) {\n      omap.size = newMap.size;\n      omap._map = newMap;\n      omap._list = newList;\n      omap.__hash = undefined;\n      return omap;\n    }\n    return makeOrderedMap(newMap, newList);\n  }\n\n  var IS_STACK_SYMBOL = '@@__IMMUTABLE_STACK__@@';\n\n  function isStack(maybeStack) {\n    return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);\n  }\n\n  var Stack = /*@__PURE__*/(function (IndexedCollection) {\n    function Stack(value) {\n      return value === null || value === undefined\n        ? emptyStack()\n        : isStack(value)\n        ? value\n        : emptyStack().pushAll(value);\n    }\n\n    if ( IndexedCollection ) Stack.__proto__ = IndexedCollection;\n    Stack.prototype = Object.create( IndexedCollection && IndexedCollection.prototype );\n    Stack.prototype.constructor = Stack;\n\n    Stack.of = function of (/*...values*/) {\n      return this(arguments);\n    };\n\n    Stack.prototype.toString = function toString () {\n      return this.__toString('Stack [', ']');\n    };\n\n    // @pragma Access\n\n    Stack.prototype.get = function get (index, notSetValue) {\n      var head = this._head;\n      index = wrapIndex(this, index);\n      while (head && index--) {\n        head = head.next;\n      }\n      return head ? head.value : notSetValue;\n    };\n\n    Stack.prototype.peek = function peek () {\n      return this._head && this._head.value;\n    };\n\n    // @pragma Modification\n\n    Stack.prototype.push = function push (/*...values*/) {\n      var arguments$1 = arguments;\n\n      if (arguments.length === 0) {\n        return this;\n      }\n      var newSize = this.size + arguments.length;\n      var head = this._head;\n      for (var ii = arguments.length - 1; ii >= 0; ii--) {\n        head = {\n          value: arguments$1[ii],\n          next: head,\n        };\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pushAll = function pushAll (iter) {\n      iter = IndexedCollection(iter);\n      if (iter.size === 0) {\n        return this;\n      }\n      if (this.size === 0 && isStack(iter)) {\n        return iter;\n      }\n      assertNotInfinite(iter.size);\n      var newSize = this.size;\n      var head = this._head;\n      iter.__iterate(function (value) {\n        newSize++;\n        head = {\n          value: value,\n          next: head,\n        };\n      }, /* reverse */ true);\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pop = function pop () {\n      return this.slice(1);\n    };\n\n    Stack.prototype.clear = function clear () {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._head = undefined;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyStack();\n    };\n\n    Stack.prototype.slice = function slice (begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      var resolvedBegin = resolveBegin(begin, this.size);\n      var resolvedEnd = resolveEnd(end, this.size);\n      if (resolvedEnd !== this.size) {\n        // super.slice(begin, end);\n        return IndexedCollection.prototype.slice.call(this, begin, end);\n      }\n      var newSize = this.size - resolvedBegin;\n      var head = this._head;\n      while (resolvedBegin--) {\n        head = head.next;\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    // @pragma Mutability\n\n    Stack.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        if (this.size === 0) {\n          return emptyStack();\n        }\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeStack(this.size, this._head, ownerID, this.__hash);\n    };\n\n    // @pragma Iteration\n\n    Stack.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      if (reverse) {\n        return new ArraySeq(this.toArray()).__iterate(\n          function (v, k) { return fn(v, k, this$1); },\n          reverse\n        );\n      }\n      var iterations = 0;\n      var node = this._head;\n      while (node) {\n        if (fn(node.value, iterations++, this) === false) {\n          break;\n        }\n        node = node.next;\n      }\n      return iterations;\n    };\n\n    Stack.prototype.__iterator = function __iterator (type, reverse) {\n      if (reverse) {\n        return new ArraySeq(this.toArray()).__iterator(type, reverse);\n      }\n      var iterations = 0;\n      var node = this._head;\n      return new Iterator(function () {\n        if (node) {\n          var value = node.value;\n          node = node.next;\n          return iteratorValue(type, iterations++, value);\n        }\n        return iteratorDone();\n      });\n    };\n\n    return Stack;\n  }(IndexedCollection));\n\n  Stack.isStack = isStack;\n\n  var StackPrototype = Stack.prototype;\n  StackPrototype[IS_STACK_SYMBOL] = true;\n  StackPrototype.shift = StackPrototype.pop;\n  StackPrototype.unshift = StackPrototype.push;\n  StackPrototype.unshiftAll = StackPrototype.pushAll;\n  StackPrototype.withMutations = withMutations;\n  StackPrototype.wasAltered = wasAltered;\n  StackPrototype.asImmutable = asImmutable;\n  StackPrototype['@@transducer/init'] = StackPrototype.asMutable = asMutable;\n  StackPrototype['@@transducer/step'] = function (result, arr) {\n    return result.unshift(arr);\n  };\n  StackPrototype['@@transducer/result'] = function (obj) {\n    return obj.asImmutable();\n  };\n\n  function makeStack(size, head, ownerID, hash) {\n    var map = Object.create(StackPrototype);\n    map.size = size;\n    map._head = head;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_STACK;\n  function emptyStack() {\n    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n  }\n\n  var IS_SET_SYMBOL = '@@__IMMUTABLE_SET__@@';\n\n  function isSet(maybeSet) {\n    return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);\n  }\n\n  function isOrderedSet(maybeOrderedSet) {\n    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n  }\n\n  function deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    if (\n      !isCollection(b) ||\n      (a.size !== undefined && b.size !== undefined && a.size !== b.size) ||\n      (a.__hash !== undefined &&\n        b.__hash !== undefined &&\n        a.__hash !== b.__hash) ||\n      isKeyed(a) !== isKeyed(b) ||\n      isIndexed(a) !== isIndexed(b) ||\n      isOrdered(a) !== isOrdered(b)\n    ) {\n      return false;\n    }\n\n    if (a.size === 0 && b.size === 0) {\n      return true;\n    }\n\n    var notAssociative = !isAssociative(a);\n\n    if (isOrdered(a)) {\n      var entries = a.entries();\n      return (\n        b.every(function (v, k) {\n          var entry = entries.next().value;\n          return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n        }) && entries.next().done\n      );\n    }\n\n    var flipped = false;\n\n    if (a.size === undefined) {\n      if (b.size === undefined) {\n        if (typeof a.cacheResult === 'function') {\n          a.cacheResult();\n        }\n      } else {\n        flipped = true;\n        var _ = a;\n        a = b;\n        b = _;\n      }\n    }\n\n    var allEqual = true;\n    var bSize = b.__iterate(function (v, k) {\n      if (\n        notAssociative\n          ? !a.has(v)\n          : flipped\n          ? !is(v, a.get(k, NOT_SET))\n          : !is(a.get(k, NOT_SET), v)\n      ) {\n        allEqual = false;\n        return false;\n      }\n    });\n\n    return allEqual && a.size === bSize;\n  }\n\n  function mixin(ctor, methods) {\n    var keyCopier = function (key) {\n      ctor.prototype[key] = methods[key];\n    };\n    Object.keys(methods).forEach(keyCopier);\n    Object.getOwnPropertySymbols &&\n      Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n    return ctor;\n  }\n\n  function toJS(value) {\n    if (!value || typeof value !== 'object') {\n      return value;\n    }\n    if (!isCollection(value)) {\n      if (!isDataStructure(value)) {\n        return value;\n      }\n      value = Seq(value);\n    }\n    if (isKeyed(value)) {\n      var result$1 = {};\n      value.__iterate(function (v, k) {\n        result$1[k] = toJS(v);\n      });\n      return result$1;\n    }\n    var result = [];\n    value.__iterate(function (v) {\n      result.push(toJS(v));\n    });\n    return result;\n  }\n\n  var Set = /*@__PURE__*/(function (SetCollection) {\n    function Set(value) {\n      return value === null || value === undefined\n        ? emptySet()\n        : isSet(value) && !isOrdered(value)\n        ? value\n        : emptySet().withMutations(function (set) {\n            var iter = SetCollection(value);\n            assertNotInfinite(iter.size);\n            iter.forEach(function (v) { return set.add(v); });\n          });\n    }\n\n    if ( SetCollection ) Set.__proto__ = SetCollection;\n    Set.prototype = Object.create( SetCollection && SetCollection.prototype );\n    Set.prototype.constructor = Set;\n\n    Set.of = function of (/*...values*/) {\n      return this(arguments);\n    };\n\n    Set.fromKeys = function fromKeys (value) {\n      return this(KeyedCollection(value).keySeq());\n    };\n\n    Set.intersect = function intersect (sets) {\n      sets = Collection(sets).toArray();\n      return sets.length\n        ? SetPrototype.intersect.apply(Set(sets.pop()), sets)\n        : emptySet();\n    };\n\n    Set.union = function union (sets) {\n      sets = Collection(sets).toArray();\n      return sets.length\n        ? SetPrototype.union.apply(Set(sets.pop()), sets)\n        : emptySet();\n    };\n\n    Set.prototype.toString = function toString () {\n      return this.__toString('Set {', '}');\n    };\n\n    // @pragma Access\n\n    Set.prototype.has = function has (value) {\n      return this._map.has(value);\n    };\n\n    // @pragma Modification\n\n    Set.prototype.add = function add (value) {\n      return updateSet(this, this._map.set(value, value));\n    };\n\n    Set.prototype.remove = function remove (value) {\n      return updateSet(this, this._map.remove(value));\n    };\n\n    Set.prototype.clear = function clear () {\n      return updateSet(this, this._map.clear());\n    };\n\n    // @pragma Composition\n\n    Set.prototype.map = function map (mapper, context) {\n      var this$1 = this;\n\n      var removes = [];\n      var adds = [];\n      this.forEach(function (value) {\n        var mapped = mapper.call(context, value, value, this$1);\n        if (mapped !== value) {\n          removes.push(value);\n          adds.push(mapped);\n        }\n      });\n      return this.withMutations(function (set) {\n        removes.forEach(function (value) { return set.remove(value); });\n        adds.forEach(function (value) { return set.add(value); });\n      });\n    };\n\n    Set.prototype.union = function union () {\n      var iters = [], len = arguments.length;\n      while ( len-- ) iters[ len ] = arguments[ len ];\n\n      iters = iters.filter(function (x) { return x.size !== 0; });\n      if (iters.length === 0) {\n        return this;\n      }\n      if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n        return this.constructor(iters[0]);\n      }\n      return this.withMutations(function (set) {\n        for (var ii = 0; ii < iters.length; ii++) {\n          SetCollection(iters[ii]).forEach(function (value) { return set.add(value); });\n        }\n      });\n    };\n\n    Set.prototype.intersect = function intersect () {\n      var iters = [], len = arguments.length;\n      while ( len-- ) iters[ len ] = arguments[ len ];\n\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function (iter) { return SetCollection(iter); });\n      var toRemove = [];\n      this.forEach(function (value) {\n        if (!iters.every(function (iter) { return iter.includes(value); })) {\n          toRemove.push(value);\n        }\n      });\n      return this.withMutations(function (set) {\n        toRemove.forEach(function (value) {\n          set.remove(value);\n        });\n      });\n    };\n\n    Set.prototype.subtract = function subtract () {\n      var iters = [], len = arguments.length;\n      while ( len-- ) iters[ len ] = arguments[ len ];\n\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function (iter) { return SetCollection(iter); });\n      var toRemove = [];\n      this.forEach(function (value) {\n        if (iters.some(function (iter) { return iter.includes(value); })) {\n          toRemove.push(value);\n        }\n      });\n      return this.withMutations(function (set) {\n        toRemove.forEach(function (value) {\n          set.remove(value);\n        });\n      });\n    };\n\n    Set.prototype.sort = function sort (comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator));\n    };\n\n    Set.prototype.sortBy = function sortBy (mapper, comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator, mapper));\n    };\n\n    Set.prototype.wasAltered = function wasAltered () {\n      return this._map.wasAltered();\n    };\n\n    Set.prototype.__iterate = function __iterate (fn, reverse) {\n      var this$1 = this;\n\n      return this._map.__iterate(function (k) { return fn(k, k, this$1); }, reverse);\n    };\n\n    Set.prototype.__iterator = function __iterator (type, reverse) {\n      return this._map.__iterator(type, reverse);\n    };\n\n    Set.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        if (this.size === 0) {\n          return this.__empty();\n        }\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return this.__make(newMap, ownerID);\n    };\n\n    return Set;\n  }(SetCollection));\n\n  Set.isSet = isSet;\n\n  var SetPrototype = Set.prototype;\n  SetPrototype[IS_SET_SYMBOL] = true;\n  SetPrototype[DELETE] = SetPrototype.remove;\n  SetPrototype.merge = SetPrototype.concat = SetPrototype.union;\n  SetPrototype.withMutations = withMutations;\n  SetPrototype.asImmutable = asImmutable;\n  SetPrototype['@@transducer/init'] = SetPrototype.asMutable = asMutable;\n  SetPrototype['@@transducer/step'] = function (result, arr) {\n    return result.add(arr);\n  };\n  SetPrototype['@@transducer/result'] = function (obj) {\n    return obj.asImmutable();\n  };\n\n  SetPrototype.__empty = emptySet;\n  SetPrototype.__make = makeSet;\n\n  function updateSet(set, newMap) {\n    if (set.__ownerID) {\n      set.size = newMap.size;\n      set._map = newMap;\n      return set;\n    }\n    return newMap === set._map\n      ? set\n      : newMap.size === 0\n      ? set.__empty()\n      : set.__make(newMap);\n  }\n\n  function makeSet(map, ownerID) {\n    var set = Object.create(SetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_SET;\n  function emptySet() {\n    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n  }\n\n  /**\n   * Returns a lazy seq of nums from start (inclusive) to end\n   * (exclusive), by step, where start defaults to 0, step to 1, and end to\n   * infinity. When start is equal to end, returns empty list.\n   */\n  var Range = /*@__PURE__*/(function (IndexedSeq) {\n    function Range(start, end, step) {\n      if (!(this instanceof Range)) {\n        return new Range(start, end, step);\n      }\n      invariant(step !== 0, 'Cannot step a Range by 0');\n      start = start || 0;\n      if (end === undefined) {\n        end = Infinity;\n      }\n      step = step === undefined ? 1 : Math.abs(step);\n      if (end < start) {\n        step = -step;\n      }\n      this._start = start;\n      this._end = end;\n      this._step = step;\n      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n      if (this.size === 0) {\n        if (EMPTY_RANGE) {\n          return EMPTY_RANGE;\n        }\n        EMPTY_RANGE = this;\n      }\n    }\n\n    if ( IndexedSeq ) Range.__proto__ = IndexedSeq;\n    Range.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n    Range.prototype.constructor = Range;\n\n    Range.prototype.toString = function toString () {\n      if (this.size === 0) {\n        return 'Range []';\n      }\n      return (\n        'Range [ ' +\n        this._start +\n        '...' +\n        this._end +\n        (this._step !== 1 ? ' by ' + this._step : '') +\n        ' ]'\n      );\n    };\n\n    Range.prototype.get = function get (index, notSetValue) {\n      return this.has(index)\n        ? this._start + wrapIndex(this, index) * this._step\n        : notSetValue;\n    };\n\n    Range.prototype.includes = function includes (searchValue) {\n      var possibleIndex = (searchValue - this._start) / this._step;\n      return (\n        possibleIndex >= 0 &&\n        possibleIndex < this.size &&\n        possibleIndex === Math.floor(possibleIndex)\n      );\n    };\n\n    Range.prototype.slice = function slice (begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      begin = resolveBegin(begin, this.size);\n      end = resolveEnd(end, this.size);\n      if (end <= begin) {\n        return new Range(0, 0);\n      }\n      return new Range(\n        this.get(begin, this._end),\n        this.get(end, this._end),\n        this._step\n      );\n    };\n\n    Range.prototype.indexOf = function indexOf (searchValue) {\n      var offsetValue = searchValue - this._start;\n      if (offsetValue % this._step === 0) {\n        var index = offsetValue / this._step;\n        if (index >= 0 && index < this.size) {\n          return index;\n        }\n      }\n      return -1;\n    };\n\n    Range.prototype.lastIndexOf = function lastIndexOf (searchValue) {\n      return this.indexOf(searchValue);\n    };\n\n    Range.prototype.__iterate = function __iterate (fn, reverse) {\n      var size = this.size;\n      var step = this._step;\n      var value = reverse ? this._start + (size - 1) * step : this._start;\n      var i = 0;\n      while (i !== size) {\n        if (fn(value, reverse ? size - ++i : i++, this) === false) {\n          break;\n        }\n        value += reverse ? -step : step;\n      }\n      return i;\n    };\n\n    Range.prototype.__iterator = function __iterator (type, reverse) {\n      var size = this.size;\n      var step = this._step;\n      var value = reverse ? this._start + (size - 1) * step : this._start;\n      var i = 0;\n      return new Iterator(function () {\n        if (i === size) {\n          return iteratorDone();\n        }\n        var v = value;\n        value += reverse ? -step : step;\n        return iteratorValue(type, reverse ? size - ++i : i++, v);\n      });\n    };\n\n    Range.prototype.equals = function equals (other) {\n      return other instanceof Range\n        ? this._start === other._start &&\n            this._end === other._end &&\n            this._step === other._step\n        : deepEqual(this, other);\n    };\n\n    return Range;\n  }(IndexedSeq));\n\n  var EMPTY_RANGE;\n\n  function getIn(collection, searchKeyPath, notSetValue) {\n    var keyPath = coerceKeyPath(searchKeyPath);\n    var i = 0;\n    while (i !== keyPath.length) {\n      collection = get(collection, keyPath[i++], NOT_SET);\n      if (collection === NOT_SET) {\n        return notSetValue;\n      }\n    }\n    return collection;\n  }\n\n  function getIn$1(searchKeyPath, notSetValue) {\n    return getIn(this, searchKeyPath, notSetValue);\n  }\n\n  function hasIn(collection, keyPath) {\n    return getIn(collection, keyPath, NOT_SET) !== NOT_SET;\n  }\n\n  function hasIn$1(searchKeyPath) {\n    return hasIn(this, searchKeyPath);\n  }\n\n  function toObject() {\n    assertNotInfinite(this.size);\n    var object = {};\n    this.__iterate(function (v, k) {\n      object[k] = v;\n    });\n    return object;\n  }\n\n  // Note: all of these methods are deprecated.\n  Collection.isIterable = isCollection;\n  Collection.isKeyed = isKeyed;\n  Collection.isIndexed = isIndexed;\n  Collection.isAssociative = isAssociative;\n  Collection.isOrdered = isOrdered;\n\n  Collection.Iterator = Iterator;\n\n  mixin(Collection, {\n    // ### Conversion to other types\n\n    toArray: function toArray() {\n      assertNotInfinite(this.size);\n      var array = new Array(this.size || 0);\n      var useTuples = isKeyed(this);\n      var i = 0;\n      this.__iterate(function (v, k) {\n        // Keyed collections produce an array of tuples.\n        array[i++] = useTuples ? [k, v] : v;\n      });\n      return array;\n    },\n\n    toIndexedSeq: function toIndexedSeq() {\n      return new ToIndexedSequence(this);\n    },\n\n    toJS: function toJS$1() {\n      return toJS(this);\n    },\n\n    toKeyedSeq: function toKeyedSeq() {\n      return new ToKeyedSequence(this, true);\n    },\n\n    toMap: function toMap() {\n      // Use Late Binding here to solve the circular dependency.\n      return Map(this.toKeyedSeq());\n    },\n\n    toObject: toObject,\n\n    toOrderedMap: function toOrderedMap() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedMap(this.toKeyedSeq());\n    },\n\n    toOrderedSet: function toOrderedSet() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSet: function toSet() {\n      // Use Late Binding here to solve the circular dependency.\n      return Set(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSetSeq: function toSetSeq() {\n      return new ToSetSequence(this);\n    },\n\n    toSeq: function toSeq() {\n      return isIndexed(this)\n        ? this.toIndexedSeq()\n        : isKeyed(this)\n        ? this.toKeyedSeq()\n        : this.toSetSeq();\n    },\n\n    toStack: function toStack() {\n      // Use Late Binding here to solve the circular dependency.\n      return Stack(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toList: function toList() {\n      // Use Late Binding here to solve the circular dependency.\n      return List(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    // ### Common JavaScript methods and properties\n\n    toString: function toString() {\n      return '[Collection]';\n    },\n\n    __toString: function __toString(head, tail) {\n      if (this.size === 0) {\n        return head + tail;\n      }\n      return (\n        head +\n        ' ' +\n        this.toSeq().map(this.__toStringMapper).join(', ') +\n        ' ' +\n        tail\n      );\n    },\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    concat: function concat() {\n      var values = [], len = arguments.length;\n      while ( len-- ) values[ len ] = arguments[ len ];\n\n      return reify(this, concatFactory(this, values));\n    },\n\n    includes: function includes(searchValue) {\n      return this.some(function (value) { return is(value, searchValue); });\n    },\n\n    entries: function entries() {\n      return this.__iterator(ITERATE_ENTRIES);\n    },\n\n    every: function every(predicate, context) {\n      assertNotInfinite(this.size);\n      var returnValue = true;\n      this.__iterate(function (v, k, c) {\n        if (!predicate.call(context, v, k, c)) {\n          returnValue = false;\n          return false;\n        }\n      });\n      return returnValue;\n    },\n\n    filter: function filter(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, true));\n    },\n\n    find: function find(predicate, context, notSetValue) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[1] : notSetValue;\n    },\n\n    forEach: function forEach(sideEffect, context) {\n      assertNotInfinite(this.size);\n      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n    },\n\n    join: function join(separator) {\n      assertNotInfinite(this.size);\n      separator = separator !== undefined ? '' + separator : ',';\n      var joined = '';\n      var isFirst = true;\n      this.__iterate(function (v) {\n        isFirst ? (isFirst = false) : (joined += separator);\n        joined += v !== null && v !== undefined ? v.toString() : '';\n      });\n      return joined;\n    },\n\n    keys: function keys() {\n      return this.__iterator(ITERATE_KEYS);\n    },\n\n    map: function map(mapper, context) {\n      return reify(this, mapFactory(this, mapper, context));\n    },\n\n    reduce: function reduce$1(reducer, initialReduction, context) {\n      return reduce(\n        this,\n        reducer,\n        initialReduction,\n        context,\n        arguments.length < 2,\n        false\n      );\n    },\n\n    reduceRight: function reduceRight(reducer, initialReduction, context) {\n      return reduce(\n        this,\n        reducer,\n        initialReduction,\n        context,\n        arguments.length < 2,\n        true\n      );\n    },\n\n    reverse: function reverse() {\n      return reify(this, reverseFactory(this, true));\n    },\n\n    slice: function slice(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, true));\n    },\n\n    some: function some(predicate, context) {\n      return !this.every(not(predicate), context);\n    },\n\n    sort: function sort(comparator) {\n      return reify(this, sortFactory(this, comparator));\n    },\n\n    values: function values() {\n      return this.__iterator(ITERATE_VALUES);\n    },\n\n    // ### More sequential methods\n\n    butLast: function butLast() {\n      return this.slice(0, -1);\n    },\n\n    isEmpty: function isEmpty() {\n      return this.size !== undefined ? this.size === 0 : !this.some(function () { return true; });\n    },\n\n    count: function count(predicate, context) {\n      return ensureSize(\n        predicate ? this.toSeq().filter(predicate, context) : this\n      );\n    },\n\n    countBy: function countBy(grouper, context) {\n      return countByFactory(this, grouper, context);\n    },\n\n    equals: function equals(other) {\n      return deepEqual(this, other);\n    },\n\n    entrySeq: function entrySeq() {\n      var collection = this;\n      if (collection._cache) {\n        // We cache as an entries array, so we can just return the cache!\n        return new ArraySeq(collection._cache);\n      }\n      var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();\n      entriesSequence.fromEntrySeq = function () { return collection.toSeq(); };\n      return entriesSequence;\n    },\n\n    filterNot: function filterNot(predicate, context) {\n      return this.filter(not(predicate), context);\n    },\n\n    findEntry: function findEntry(predicate, context, notSetValue) {\n      var found = notSetValue;\n      this.__iterate(function (v, k, c) {\n        if (predicate.call(context, v, k, c)) {\n          found = [k, v];\n          return false;\n        }\n      });\n      return found;\n    },\n\n    findKey: function findKey(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry && entry[0];\n    },\n\n    findLast: function findLast(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n    },\n\n    findLastEntry: function findLastEntry(predicate, context, notSetValue) {\n      return this.toKeyedSeq()\n        .reverse()\n        .findEntry(predicate, context, notSetValue);\n    },\n\n    findLastKey: function findLastKey(predicate, context) {\n      return this.toKeyedSeq().reverse().findKey(predicate, context);\n    },\n\n    first: function first(notSetValue) {\n      return this.find(returnTrue, null, notSetValue);\n    },\n\n    flatMap: function flatMap(mapper, context) {\n      return reify(this, flatMapFactory(this, mapper, context));\n    },\n\n    flatten: function flatten(depth) {\n      return reify(this, flattenFactory(this, depth, true));\n    },\n\n    fromEntrySeq: function fromEntrySeq() {\n      return new FromEntriesSequence(this);\n    },\n\n    get: function get(searchKey, notSetValue) {\n      return this.find(function (_, key) { return is(key, searchKey); }, undefined, notSetValue);\n    },\n\n    getIn: getIn$1,\n\n    groupBy: function groupBy(grouper, context) {\n      return groupByFactory(this, grouper, context);\n    },\n\n    has: function has(searchKey) {\n      return this.get(searchKey, NOT_SET) !== NOT_SET;\n    },\n\n    hasIn: hasIn$1,\n\n    isSubset: function isSubset(iter) {\n      iter = typeof iter.includes === 'function' ? iter : Collection(iter);\n      return this.every(function (value) { return iter.includes(value); });\n    },\n\n    isSuperset: function isSuperset(iter) {\n      iter = typeof iter.isSubset === 'function' ? iter : Collection(iter);\n      return iter.isSubset(this);\n    },\n\n    keyOf: function keyOf(searchValue) {\n      return this.findKey(function (value) { return is(value, searchValue); });\n    },\n\n    keySeq: function keySeq() {\n      return this.toSeq().map(keyMapper).toIndexedSeq();\n    },\n\n    last: function last(notSetValue) {\n      return this.toSeq().reverse().first(notSetValue);\n    },\n\n    lastKeyOf: function lastKeyOf(searchValue) {\n      return this.toKeyedSeq().reverse().keyOf(searchValue);\n    },\n\n    max: function max(comparator) {\n      return maxFactory(this, comparator);\n    },\n\n    maxBy: function maxBy(mapper, comparator) {\n      return maxFactory(this, comparator, mapper);\n    },\n\n    min: function min(comparator) {\n      return maxFactory(\n        this,\n        comparator ? neg(comparator) : defaultNegComparator\n      );\n    },\n\n    minBy: function minBy(mapper, comparator) {\n      return maxFactory(\n        this,\n        comparator ? neg(comparator) : defaultNegComparator,\n        mapper\n      );\n    },\n\n    rest: function rest() {\n      return this.slice(1);\n    },\n\n    skip: function skip(amount) {\n      return amount === 0 ? this : this.slice(Math.max(0, amount));\n    },\n\n    skipLast: function skipLast(amount) {\n      return amount === 0 ? this : this.slice(0, -Math.max(0, amount));\n    },\n\n    skipWhile: function skipWhile(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, true));\n    },\n\n    skipUntil: function skipUntil(predicate, context) {\n      return this.skipWhile(not(predicate), context);\n    },\n\n    sortBy: function sortBy(mapper, comparator) {\n      return reify(this, sortFactory(this, comparator, mapper));\n    },\n\n    take: function take(amount) {\n      return this.slice(0, Math.max(0, amount));\n    },\n\n    takeLast: function takeLast(amount) {\n      return this.slice(-Math.max(0, amount));\n    },\n\n    takeWhile: function takeWhile(predicate, context) {\n      return reify(this, takeWhileFactory(this, predicate, context));\n    },\n\n    takeUntil: function takeUntil(predicate, context) {\n      return this.takeWhile(not(predicate), context);\n    },\n\n    update: function update(fn) {\n      return fn(this);\n    },\n\n    valueSeq: function valueSeq() {\n      return this.toIndexedSeq();\n    },\n\n    // ### Hashable Object\n\n    hashCode: function hashCode() {\n      return this.__hash || (this.__hash = hashCollection(this));\n    },\n\n    // ### Internal\n\n    // abstract __iterate(fn, reverse)\n\n    // abstract __iterator(type, reverse)\n  });\n\n  var CollectionPrototype = Collection.prototype;\n  CollectionPrototype[IS_COLLECTION_SYMBOL] = true;\n  CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;\n  CollectionPrototype.toJSON = CollectionPrototype.toArray;\n  CollectionPrototype.__toStringMapper = quoteString;\n  CollectionPrototype.inspect = CollectionPrototype.toSource = function () {\n    return this.toString();\n  };\n  CollectionPrototype.chain = CollectionPrototype.flatMap;\n  CollectionPrototype.contains = CollectionPrototype.includes;\n\n  mixin(KeyedCollection, {\n    // ### More sequential methods\n\n    flip: function flip() {\n      return reify(this, flipFactory(this));\n    },\n\n    mapEntries: function mapEntries(mapper, context) {\n      var this$1 = this;\n\n      var iterations = 0;\n      return reify(\n        this,\n        this.toSeq()\n          .map(function (v, k) { return mapper.call(context, [k, v], iterations++, this$1); })\n          .fromEntrySeq()\n      );\n    },\n\n    mapKeys: function mapKeys(mapper, context) {\n      var this$1 = this;\n\n      return reify(\n        this,\n        this.toSeq()\n          .flip()\n          .map(function (k, v) { return mapper.call(context, k, v, this$1); })\n          .flip()\n      );\n    },\n  });\n\n  var KeyedCollectionPrototype = KeyedCollection.prototype;\n  KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;\n  KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;\n  KeyedCollectionPrototype.toJSON = toObject;\n  KeyedCollectionPrototype.__toStringMapper = function (v, k) { return quoteString(k) + ': ' + quoteString(v); };\n\n  mixin(IndexedCollection, {\n    // ### Conversion to other types\n\n    toKeyedSeq: function toKeyedSeq() {\n      return new ToKeyedSequence(this, false);\n    },\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    filter: function filter(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, false));\n    },\n\n    findIndex: function findIndex(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    indexOf: function indexOf(searchValue) {\n      var key = this.keyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    lastIndexOf: function lastIndexOf(searchValue) {\n      var key = this.lastKeyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    reverse: function reverse() {\n      return reify(this, reverseFactory(this, false));\n    },\n\n    slice: function slice(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, false));\n    },\n\n    splice: function splice(index, removeNum /*, ...values*/) {\n      var numArgs = arguments.length;\n      removeNum = Math.max(removeNum || 0, 0);\n      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n        return this;\n      }\n      // If index is negative, it should resolve relative to the size of the\n      // collection. However size may be expensive to compute if not cached, so\n      // only call count() if the number is in fact negative.\n      index = resolveBegin(index, index < 0 ? this.count() : this.size);\n      var spliced = this.slice(0, index);\n      return reify(\n        this,\n        numArgs === 1\n          ? spliced\n          : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n      );\n    },\n\n    // ### More collection methods\n\n    findLastIndex: function findLastIndex(predicate, context) {\n      var entry = this.findLastEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    first: function first(notSetValue) {\n      return this.get(0, notSetValue);\n    },\n\n    flatten: function flatten(depth) {\n      return reify(this, flattenFactory(this, depth, false));\n    },\n\n    get: function get(index, notSetValue) {\n      index = wrapIndex(this, index);\n      return index < 0 ||\n        this.size === Infinity ||\n        (this.size !== undefined && index > this.size)\n        ? notSetValue\n        : this.find(function (_, key) { return key === index; }, undefined, notSetValue);\n    },\n\n    has: function has(index) {\n      index = wrapIndex(this, index);\n      return (\n        index >= 0 &&\n        (this.size !== undefined\n          ? this.size === Infinity || index < this.size\n          : this.indexOf(index) !== -1)\n      );\n    },\n\n    interpose: function interpose(separator) {\n      return reify(this, interposeFactory(this, separator));\n    },\n\n    interleave: function interleave(/*...collections*/) {\n      var collections = [this].concat(arrCopy(arguments));\n      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);\n      var interleaved = zipped.flatten(true);\n      if (zipped.size) {\n        interleaved.size = zipped.size * collections.length;\n      }\n      return reify(this, interleaved);\n    },\n\n    keySeq: function keySeq() {\n      return Range(0, this.size);\n    },\n\n    last: function last(notSetValue) {\n      return this.get(-1, notSetValue);\n    },\n\n    skipWhile: function skipWhile(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, false));\n    },\n\n    zip: function zip(/*, ...collections */) {\n      var collections = [this].concat(arrCopy(arguments));\n      return reify(this, zipWithFactory(this, defaultZipper, collections));\n    },\n\n    zipAll: function zipAll(/*, ...collections */) {\n      var collections = [this].concat(arrCopy(arguments));\n      return reify(this, zipWithFactory(this, defaultZipper, collections, true));\n    },\n\n    zipWith: function zipWith(zipper /*, ...collections */) {\n      var collections = arrCopy(arguments);\n      collections[0] = this;\n      return reify(this, zipWithFactory(this, zipper, collections));\n    },\n  });\n\n  var IndexedCollectionPrototype = IndexedCollection.prototype;\n  IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;\n  IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;\n\n  mixin(SetCollection, {\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    get: function get(value, notSetValue) {\n      return this.has(value) ? value : notSetValue;\n    },\n\n    includes: function includes(value) {\n      return this.has(value);\n    },\n\n    // ### More sequential methods\n\n    keySeq: function keySeq() {\n      return this.valueSeq();\n    },\n  });\n\n  SetCollection.prototype.has = CollectionPrototype.includes;\n  SetCollection.prototype.contains = SetCollection.prototype.includes;\n\n  // Mixin subclasses\n\n  mixin(KeyedSeq, KeyedCollection.prototype);\n  mixin(IndexedSeq, IndexedCollection.prototype);\n  mixin(SetSeq, SetCollection.prototype);\n\n  // #pragma Helper functions\n\n  function reduce(collection, reducer, reduction, context, useFirst, reverse) {\n    assertNotInfinite(collection.size);\n    collection.__iterate(function (v, k, c) {\n      if (useFirst) {\n        useFirst = false;\n        reduction = v;\n      } else {\n        reduction = reducer.call(context, reduction, v, k, c);\n      }\n    }, reverse);\n    return reduction;\n  }\n\n  function keyMapper(v, k) {\n    return k;\n  }\n\n  function entryMapper(v, k) {\n    return [k, v];\n  }\n\n  function not(predicate) {\n    return function () {\n      return !predicate.apply(this, arguments);\n    };\n  }\n\n  function neg(predicate) {\n    return function () {\n      return -predicate.apply(this, arguments);\n    };\n  }\n\n  function defaultZipper() {\n    return arrCopy(arguments);\n  }\n\n  function defaultNegComparator(a, b) {\n    return a < b ? 1 : a > b ? -1 : 0;\n  }\n\n  function hashCollection(collection) {\n    if (collection.size === Infinity) {\n      return 0;\n    }\n    var ordered = isOrdered(collection);\n    var keyed = isKeyed(collection);\n    var h = ordered ? 1 : 0;\n    var size = collection.__iterate(\n      keyed\n        ? ordered\n          ? function (v, k) {\n              h = (31 * h + hashMerge(hash(v), hash(k))) | 0;\n            }\n          : function (v, k) {\n              h = (h + hashMerge(hash(v), hash(k))) | 0;\n            }\n        : ordered\n        ? function (v) {\n            h = (31 * h + hash(v)) | 0;\n          }\n        : function (v) {\n            h = (h + hash(v)) | 0;\n          }\n    );\n    return murmurHashOfSize(size, h);\n  }\n\n  function murmurHashOfSize(size, h) {\n    h = imul(h, 0xcc9e2d51);\n    h = imul((h << 15) | (h >>> -15), 0x1b873593);\n    h = imul((h << 13) | (h >>> -13), 5);\n    h = ((h + 0xe6546b64) | 0) ^ size;\n    h = imul(h ^ (h >>> 16), 0x85ebca6b);\n    h = imul(h ^ (h >>> 13), 0xc2b2ae35);\n    h = smi(h ^ (h >>> 16));\n    return h;\n  }\n\n  function hashMerge(a, b) {\n    return (a ^ (b + 0x9e3779b9 + (a << 6) + (a >> 2))) | 0; // int\n  }\n\n  var OrderedSet = /*@__PURE__*/(function (Set) {\n    function OrderedSet(value) {\n      return value === null || value === undefined\n        ? emptyOrderedSet()\n        : isOrderedSet(value)\n        ? value\n        : emptyOrderedSet().withMutations(function (set) {\n            var iter = SetCollection(value);\n            assertNotInfinite(iter.size);\n            iter.forEach(function (v) { return set.add(v); });\n          });\n    }\n\n    if ( Set ) OrderedSet.__proto__ = Set;\n    OrderedSet.prototype = Object.create( Set && Set.prototype );\n    OrderedSet.prototype.constructor = OrderedSet;\n\n    OrderedSet.of = function of (/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedSet.fromKeys = function fromKeys (value) {\n      return this(KeyedCollection(value).keySeq());\n    };\n\n    OrderedSet.prototype.toString = function toString () {\n      return this.__toString('OrderedSet {', '}');\n    };\n\n    return OrderedSet;\n  }(Set));\n\n  OrderedSet.isOrderedSet = isOrderedSet;\n\n  var OrderedSetPrototype = OrderedSet.prototype;\n  OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;\n  OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;\n  OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;\n\n  OrderedSetPrototype.__empty = emptyOrderedSet;\n  OrderedSetPrototype.__make = makeOrderedSet;\n\n  function makeOrderedSet(map, ownerID) {\n    var set = Object.create(OrderedSetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_ORDERED_SET;\n  function emptyOrderedSet() {\n    return (\n      EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()))\n    );\n  }\n\n  var Record = function Record(defaultValues, name) {\n    var hasInitialized;\n\n    var RecordType = function Record(values) {\n      var this$1 = this;\n\n      if (values instanceof RecordType) {\n        return values;\n      }\n      if (!(this instanceof RecordType)) {\n        return new RecordType(values);\n      }\n      if (!hasInitialized) {\n        hasInitialized = true;\n        var keys = Object.keys(defaultValues);\n        var indices = (RecordTypePrototype._indices = {});\n        // Deprecated: left to attempt not to break any external code which\n        // relies on a ._name property existing on record instances.\n        // Use Record.getDescriptiveName() instead\n        RecordTypePrototype._name = name;\n        RecordTypePrototype._keys = keys;\n        RecordTypePrototype._defaultValues = defaultValues;\n        for (var i = 0; i < keys.length; i++) {\n          var propName = keys[i];\n          indices[propName] = i;\n          if (RecordTypePrototype[propName]) {\n            /* eslint-disable no-console */\n            typeof console === 'object' &&\n              console.warn &&\n              console.warn(\n                'Cannot define ' +\n                  recordName(this) +\n                  ' with property \"' +\n                  propName +\n                  '\" since that property name is part of the Record API.'\n              );\n            /* eslint-enable no-console */\n          } else {\n            setProp(RecordTypePrototype, propName);\n          }\n        }\n      }\n      this.__ownerID = undefined;\n      this._values = List().withMutations(function (l) {\n        l.setSize(this$1._keys.length);\n        KeyedCollection(values).forEach(function (v, k) {\n          l.set(this$1._indices[k], v === this$1._defaultValues[k] ? undefined : v);\n        });\n      });\n    };\n\n    var RecordTypePrototype = (RecordType.prototype =\n      Object.create(RecordPrototype));\n    RecordTypePrototype.constructor = RecordType;\n\n    if (name) {\n      RecordType.displayName = name;\n    }\n\n    return RecordType;\n  };\n\n  Record.prototype.toString = function toString () {\n    var str = recordName(this) + ' { ';\n    var keys = this._keys;\n    var k;\n    for (var i = 0, l = keys.length; i !== l; i++) {\n      k = keys[i];\n      str += (i ? ', ' : '') + k + ': ' + quoteString(this.get(k));\n    }\n    return str + ' }';\n  };\n\n  Record.prototype.equals = function equals (other) {\n    return (\n      this === other ||\n      (other &&\n        this._keys === other._keys &&\n        recordSeq(this).equals(recordSeq(other)))\n    );\n  };\n\n  Record.prototype.hashCode = function hashCode () {\n    return recordSeq(this).hashCode();\n  };\n\n  // @pragma Access\n\n  Record.prototype.has = function has (k) {\n    return this._indices.hasOwnProperty(k);\n  };\n\n  Record.prototype.get = function get (k, notSetValue) {\n    if (!this.has(k)) {\n      return notSetValue;\n    }\n    var index = this._indices[k];\n    var value = this._values.get(index);\n    return value === undefined ? this._defaultValues[k] : value;\n  };\n\n  // @pragma Modification\n\n  Record.prototype.set = function set (k, v) {\n    if (this.has(k)) {\n      var newValues = this._values.set(\n        this._indices[k],\n        v === this._defaultValues[k] ? undefined : v\n      );\n      if (newValues !== this._values && !this.__ownerID) {\n        return makeRecord(this, newValues);\n      }\n    }\n    return this;\n  };\n\n  Record.prototype.remove = function remove (k) {\n    return this.set(k);\n  };\n\n  Record.prototype.clear = function clear () {\n    var newValues = this._values.clear().setSize(this._keys.length);\n    return this.__ownerID ? this : makeRecord(this, newValues);\n  };\n\n  Record.prototype.wasAltered = function wasAltered () {\n    return this._values.wasAltered();\n  };\n\n  Record.prototype.toSeq = function toSeq () {\n    return recordSeq(this);\n  };\n\n  Record.prototype.toJS = function toJS$1 () {\n    return toJS(this);\n  };\n\n  Record.prototype.entries = function entries () {\n    return this.__iterator(ITERATE_ENTRIES);\n  };\n\n  Record.prototype.__iterator = function __iterator (type, reverse) {\n    return recordSeq(this).__iterator(type, reverse);\n  };\n\n  Record.prototype.__iterate = function __iterate (fn, reverse) {\n    return recordSeq(this).__iterate(fn, reverse);\n  };\n\n  Record.prototype.__ensureOwner = function __ensureOwner (ownerID) {\n    if (ownerID === this.__ownerID) {\n      return this;\n    }\n    var newValues = this._values.__ensureOwner(ownerID);\n    if (!ownerID) {\n      this.__ownerID = ownerID;\n      this._values = newValues;\n      return this;\n    }\n    return makeRecord(this, newValues, ownerID);\n  };\n\n  Record.isRecord = isRecord;\n  Record.getDescriptiveName = recordName;\n  var RecordPrototype = Record.prototype;\n  RecordPrototype[IS_RECORD_SYMBOL] = true;\n  RecordPrototype[DELETE] = RecordPrototype.remove;\n  RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;\n  RecordPrototype.getIn = getIn$1;\n  RecordPrototype.hasIn = CollectionPrototype.hasIn;\n  RecordPrototype.merge = merge;\n  RecordPrototype.mergeWith = mergeWith;\n  RecordPrototype.mergeIn = mergeIn;\n  RecordPrototype.mergeDeep = mergeDeep$1;\n  RecordPrototype.mergeDeepWith = mergeDeepWith$1;\n  RecordPrototype.mergeDeepIn = mergeDeepIn;\n  RecordPrototype.setIn = setIn$1;\n  RecordPrototype.update = update$1;\n  RecordPrototype.updateIn = updateIn$1;\n  RecordPrototype.withMutations = withMutations;\n  RecordPrototype.asMutable = asMutable;\n  RecordPrototype.asImmutable = asImmutable;\n  RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;\n  RecordPrototype.toJSON = RecordPrototype.toObject =\n    CollectionPrototype.toObject;\n  RecordPrototype.inspect = RecordPrototype.toSource = function () {\n    return this.toString();\n  };\n\n  function makeRecord(likeRecord, values, ownerID) {\n    var record = Object.create(Object.getPrototypeOf(likeRecord));\n    record._values = values;\n    record.__ownerID = ownerID;\n    return record;\n  }\n\n  function recordName(record) {\n    return record.constructor.displayName || record.constructor.name || 'Record';\n  }\n\n  function recordSeq(record) {\n    return keyedSeqFromValue(record._keys.map(function (k) { return [k, record.get(k)]; }));\n  }\n\n  function setProp(prototype, name) {\n    try {\n      Object.defineProperty(prototype, name, {\n        get: function () {\n          return this.get(name);\n        },\n        set: function (value) {\n          invariant(this.__ownerID, 'Cannot set on an immutable record.');\n          this.set(name, value);\n        },\n      });\n    } catch (error) {\n      // Object.defineProperty failed. Probably IE8.\n    }\n  }\n\n  /**\n   * Returns a lazy Seq of `value` repeated `times` times. When `times` is\n   * undefined, returns an infinite sequence of `value`.\n   */\n  var Repeat = /*@__PURE__*/(function (IndexedSeq) {\n    function Repeat(value, times) {\n      if (!(this instanceof Repeat)) {\n        return new Repeat(value, times);\n      }\n      this._value = value;\n      this.size = times === undefined ? Infinity : Math.max(0, times);\n      if (this.size === 0) {\n        if (EMPTY_REPEAT) {\n          return EMPTY_REPEAT;\n        }\n        EMPTY_REPEAT = this;\n      }\n    }\n\n    if ( IndexedSeq ) Repeat.__proto__ = IndexedSeq;\n    Repeat.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );\n    Repeat.prototype.constructor = Repeat;\n\n    Repeat.prototype.toString = function toString () {\n      if (this.size === 0) {\n        return 'Repeat []';\n      }\n      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n    };\n\n    Repeat.prototype.get = function get (index, notSetValue) {\n      return this.has(index) ? this._value : notSetValue;\n    };\n\n    Repeat.prototype.includes = function includes (searchValue) {\n      return is(this._value, searchValue);\n    };\n\n    Repeat.prototype.slice = function slice (begin, end) {\n      var size = this.size;\n      return wholeSlice(begin, end, size)\n        ? this\n        : new Repeat(\n            this._value,\n            resolveEnd(end, size) - resolveBegin(begin, size)\n          );\n    };\n\n    Repeat.prototype.reverse = function reverse () {\n      return this;\n    };\n\n    Repeat.prototype.indexOf = function indexOf (searchValue) {\n      if (is(this._value, searchValue)) {\n        return 0;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.lastIndexOf = function lastIndexOf (searchValue) {\n      if (is(this._value, searchValue)) {\n        return this.size;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.__iterate = function __iterate (fn, reverse) {\n      var size = this.size;\n      var i = 0;\n      while (i !== size) {\n        if (fn(this._value, reverse ? size - ++i : i++, this) === false) {\n          break;\n        }\n      }\n      return i;\n    };\n\n    Repeat.prototype.__iterator = function __iterator (type, reverse) {\n      var this$1 = this;\n\n      var size = this.size;\n      var i = 0;\n      return new Iterator(function () { return i === size\n          ? iteratorDone()\n          : iteratorValue(type, reverse ? size - ++i : i++, this$1._value); }\n      );\n    };\n\n    Repeat.prototype.equals = function equals (other) {\n      return other instanceof Repeat\n        ? is(this._value, other._value)\n        : deepEqual(other);\n    };\n\n    return Repeat;\n  }(IndexedSeq));\n\n  var EMPTY_REPEAT;\n\n  function fromJS(value, converter) {\n    return fromJSWith(\n      [],\n      converter || defaultConverter,\n      value,\n      '',\n      converter && converter.length > 2 ? [] : undefined,\n      { '': value }\n    );\n  }\n\n  function fromJSWith(stack, converter, value, key, keyPath, parentValue) {\n    var toSeq = Array.isArray(value)\n      ? IndexedSeq\n      : isPlainObj(value)\n      ? KeyedSeq\n      : null;\n    if (toSeq) {\n      if (~stack.indexOf(value)) {\n        throw new TypeError('Cannot convert circular structure to Immutable');\n      }\n      stack.push(value);\n      keyPath && key !== '' && keyPath.push(key);\n      var converted = converter.call(\n        parentValue,\n        key,\n        toSeq(value).map(function (v, k) { return fromJSWith(stack, converter, v, k, keyPath, value); }\n        ),\n        keyPath && keyPath.slice()\n      );\n      stack.pop();\n      keyPath && keyPath.pop();\n      return converted;\n    }\n    return value;\n  }\n\n  function defaultConverter(k, v) {\n    return isKeyed(v) ? v.toMap() : v.toList();\n  }\n\n  var version = \"4.0.0-rc.12\";\n\n  var Immutable = {\n    version: version,\n\n    Collection: Collection,\n    // Note: Iterable is deprecated\n    Iterable: Collection,\n\n    Seq: Seq,\n    Map: Map,\n    OrderedMap: OrderedMap,\n    List: List,\n    Stack: Stack,\n    Set: Set,\n    OrderedSet: OrderedSet,\n\n    Record: Record,\n    Range: Range,\n    Repeat: Repeat,\n\n    is: is,\n    fromJS: fromJS,\n    hash: hash,\n\n    isImmutable: isImmutable,\n    isCollection: isCollection,\n    isKeyed: isKeyed,\n    isIndexed: isIndexed,\n    isAssociative: isAssociative,\n    isOrdered: isOrdered,\n    isValueObject: isValueObject,\n    isSeq: isSeq,\n    isList: isList,\n    isMap: isMap,\n    isOrderedMap: isOrderedMap,\n    isStack: isStack,\n    isSet: isSet,\n    isOrderedSet: isOrderedSet,\n    isRecord: isRecord,\n\n    get: get,\n    getIn: getIn,\n    has: has,\n    hasIn: hasIn,\n    merge: merge$1,\n    mergeDeep: mergeDeep,\n    mergeWith: mergeWith$1,\n    mergeDeepWith: mergeDeepWith,\n    remove: remove,\n    removeIn: removeIn,\n    set: set,\n    setIn: setIn,\n    update: update,\n    updateIn: updateIn,\n  };\n\n  // Note: Iterable is deprecated\n  var Iterable = Collection;\n\n  exports.Collection = Collection;\n  exports.Iterable = Iterable;\n  exports.List = List;\n  exports.Map = Map;\n  exports.OrderedMap = OrderedMap;\n  exports.OrderedSet = OrderedSet;\n  exports.Range = Range;\n  exports.Record = Record;\n  exports.Repeat = Repeat;\n  exports.Seq = Seq;\n  exports.Set = Set;\n  exports.Stack = Stack;\n  exports.default = Immutable;\n  exports.fromJS = fromJS;\n  exports.get = get;\n  exports.getIn = getIn;\n  exports.has = has;\n  exports.hasIn = hasIn;\n  exports.hash = hash;\n  exports.is = is;\n  exports.isAssociative = isAssociative;\n  exports.isCollection = isCollection;\n  exports.isImmutable = isImmutable;\n  exports.isIndexed = isIndexed;\n  exports.isKeyed = isKeyed;\n  exports.isOrdered = isOrdered;\n  exports.isValueObject = isValueObject;\n  exports.merge = merge$1;\n  exports.mergeDeep = mergeDeep;\n  exports.mergeDeepWith = mergeDeepWith;\n  exports.mergeWith = mergeWith$1;\n  exports.remove = remove;\n  exports.removeIn = removeIn;\n  exports.set = set;\n  exports.setIn = setIn;\n  exports.update = update;\n  exports.updateIn = updateIn;\n  exports.version = version;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species != null &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayLike(value)\n  }\n\n  if (value == null) {\n    throw TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  var valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  var b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(\n      value[Symbol.toPrimitive]('string'), encodingOrOffset, length\n    )\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      buf = Buffer.from(buf)\n    }\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  var len = string.length\n  var mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n        : (firstByte > 0xBF) ? 2\n          : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  newBuf.__proto__ = Buffer.prototype\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (var i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    var len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","/**\n * marked - a markdown parser\n * Copyright (c) 2011-2020, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = global || self, global.marked = factory());\n}(this, (function () { 'use strict';\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it;\n\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    it = o[Symbol.iterator]();\n    return it.next.bind(it);\n  }\n\n  function createCommonjsModule(fn, module) {\n  \treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n  }\n\n  var defaults = createCommonjsModule(function (module) {\n    function getDefaults() {\n      return {\n        baseUrl: null,\n        breaks: false,\n        gfm: true,\n        headerIds: true,\n        headerPrefix: '',\n        highlight: null,\n        langPrefix: 'language-',\n        mangle: true,\n        pedantic: false,\n        renderer: null,\n        sanitize: false,\n        sanitizer: null,\n        silent: false,\n        smartLists: false,\n        smartypants: false,\n        tokenizer: null,\n        walkTokens: null,\n        xhtml: false\n      };\n    }\n\n    function changeDefaults(newDefaults) {\n      module.exports.defaults = newDefaults;\n    }\n\n    module.exports = {\n      defaults: getDefaults(),\n      getDefaults: getDefaults,\n      changeDefaults: changeDefaults\n    };\n  });\n  var defaults_1 = defaults.defaults;\n  var defaults_2 = defaults.getDefaults;\n  var defaults_3 = defaults.changeDefaults;\n\n  /**\n   * Helpers\n   */\n  var escapeTest = /[&<>\"']/;\n  var escapeReplace = /[&<>\"']/g;\n  var escapeTestNoEncode = /[<>\"']|&(?!#?\\w+;)/;\n  var escapeReplaceNoEncode = /[<>\"']|&(?!#?\\w+;)/g;\n  var escapeReplacements = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  var getEscapeReplacement = function getEscapeReplacement(ch) {\n    return escapeReplacements[ch];\n  };\n\n  function escape(html, encode) {\n    if (encode) {\n      if (escapeTest.test(html)) {\n        return html.replace(escapeReplace, getEscapeReplacement);\n      }\n    } else {\n      if (escapeTestNoEncode.test(html)) {\n        return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n      }\n    }\n\n    return html;\n  }\n\n  var unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n\n  function unescape(html) {\n    // explicitly match decimal, hex, and named HTML entities\n    return html.replace(unescapeTest, function (_, n) {\n      n = n.toLowerCase();\n      if (n === 'colon') return ':';\n\n      if (n.charAt(0) === '#') {\n        return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));\n      }\n\n      return '';\n    });\n  }\n\n  var caret = /(^|[^\\[])\\^/g;\n\n  function edit(regex, opt) {\n    regex = regex.source || regex;\n    opt = opt || '';\n    var obj = {\n      replace: function replace(name, val) {\n        val = val.source || val;\n        val = val.replace(caret, '$1');\n        regex = regex.replace(name, val);\n        return obj;\n      },\n      getRegex: function getRegex() {\n        return new RegExp(regex, opt);\n      }\n    };\n    return obj;\n  }\n\n  var nonWordAndColonTest = /[^\\w:]/g;\n  var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;\n\n  function cleanUrl(sanitize, base, href) {\n    if (sanitize) {\n      var prot;\n\n      try {\n        prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, '').toLowerCase();\n      } catch (e) {\n        return null;\n      }\n\n      if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n        return null;\n      }\n    }\n\n    if (base && !originIndependentUrl.test(href)) {\n      href = resolveUrl(base, href);\n    }\n\n    try {\n      href = encodeURI(href).replace(/%25/g, '%');\n    } catch (e) {\n      return null;\n    }\n\n    return href;\n  }\n\n  var baseUrls = {};\n  var justDomain = /^[^:]+:\\/*[^/]*$/;\n  var protocol = /^([^:]+:)[\\s\\S]*$/;\n  var domain = /^([^:]+:\\/*[^/]*)[\\s\\S]*$/;\n\n  function resolveUrl(base, href) {\n    if (!baseUrls[' ' + base]) {\n      // we can ignore everything in base after the last slash of its path component,\n      // but we might need to add _that_\n      // https://tools.ietf.org/html/rfc3986#section-3\n      if (justDomain.test(base)) {\n        baseUrls[' ' + base] = base + '/';\n      } else {\n        baseUrls[' ' + base] = rtrim(base, '/', true);\n      }\n    }\n\n    base = baseUrls[' ' + base];\n    var relativeBase = base.indexOf(':') === -1;\n\n    if (href.substring(0, 2) === '//') {\n      if (relativeBase) {\n        return href;\n      }\n\n      return base.replace(protocol, '$1') + href;\n    } else if (href.charAt(0) === '/') {\n      if (relativeBase) {\n        return href;\n      }\n\n      return base.replace(domain, '$1') + href;\n    } else {\n      return base + href;\n    }\n  }\n\n  var noopTest = {\n    exec: function noopTest() {}\n  };\n\n  function merge(obj) {\n    var i = 1,\n        target,\n        key;\n\n    for (; i < arguments.length; i++) {\n      target = arguments[i];\n\n      for (key in target) {\n        if (Object.prototype.hasOwnProperty.call(target, key)) {\n          obj[key] = target[key];\n        }\n      }\n    }\n\n    return obj;\n  }\n\n  function splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    var row = tableRow.replace(/\\|/g, function (match, offset, str) {\n      var escaped = false,\n          curr = offset;\n\n      while (--curr >= 0 && str[curr] === '\\\\') {\n        escaped = !escaped;\n      }\n\n      if (escaped) {\n        // odd number of slashes means | is escaped\n        // so we leave it alone\n        return '|';\n      } else {\n        // add space before unescaped |\n        return ' |';\n      }\n    }),\n        cells = row.split(/ \\|/);\n    var i = 0;\n\n    if (cells.length > count) {\n      cells.splice(count);\n    } else {\n      while (cells.length < count) {\n        cells.push('');\n      }\n    }\n\n    for (; i < cells.length; i++) {\n      // leading or trailing whitespace is ignored per the gfm spec\n      cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n    }\n\n    return cells;\n  } // Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n  // /c*$/ is vulnerable to REDOS.\n  // invert: Remove suffix of non-c chars instead. Default falsey.\n\n\n  function rtrim(str, c, invert) {\n    var l = str.length;\n\n    if (l === 0) {\n      return '';\n    } // Length of suffix matching the invert condition.\n\n\n    var suffLen = 0; // Step left until we fail to match the invert condition.\n\n    while (suffLen < l) {\n      var currChar = str.charAt(l - suffLen - 1);\n\n      if (currChar === c && !invert) {\n        suffLen++;\n      } else if (currChar !== c && invert) {\n        suffLen++;\n      } else {\n        break;\n      }\n    }\n\n    return str.substr(0, l - suffLen);\n  }\n\n  function findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n      return -1;\n    }\n\n    var l = str.length;\n    var level = 0,\n        i = 0;\n\n    for (; i < l; i++) {\n      if (str[i] === '\\\\') {\n        i++;\n      } else if (str[i] === b[0]) {\n        level++;\n      } else if (str[i] === b[1]) {\n        level--;\n\n        if (level < 0) {\n          return i;\n        }\n      }\n    }\n\n    return -1;\n  }\n\n  function checkSanitizeDeprecation(opt) {\n    if (opt && opt.sanitize && !opt.silent) {\n      console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');\n    }\n  }\n\n  var helpers = {\n    escape: escape,\n    unescape: unescape,\n    edit: edit,\n    cleanUrl: cleanUrl,\n    resolveUrl: resolveUrl,\n    noopTest: noopTest,\n    merge: merge,\n    splitCells: splitCells,\n    rtrim: rtrim,\n    findClosingBracket: findClosingBracket,\n    checkSanitizeDeprecation: checkSanitizeDeprecation\n  };\n\n  var defaults$1 = defaults.defaults;\n  var rtrim$1 = helpers.rtrim,\n      splitCells$1 = helpers.splitCells,\n      _escape = helpers.escape,\n      findClosingBracket$1 = helpers.findClosingBracket;\n\n  function outputLink(cap, link, raw) {\n    var href = link.href;\n    var title = link.title ? _escape(link.title) : null;\n    var text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n\n    if (cap[0].charAt(0) !== '!') {\n      return {\n        type: 'link',\n        raw: raw,\n        href: href,\n        title: title,\n        text: text\n      };\n    } else {\n      return {\n        type: 'image',\n        raw: raw,\n        href: href,\n        title: title,\n        text: _escape(text)\n      };\n    }\n  }\n\n  function indentCodeCompensation(raw, text) {\n    var matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n\n    if (matchIndentToCode === null) {\n      return text;\n    }\n\n    var indentToCode = matchIndentToCode[1];\n    return text.split('\\n').map(function (node) {\n      var matchIndentInNode = node.match(/^\\s+/);\n\n      if (matchIndentInNode === null) {\n        return node;\n      }\n\n      var indentInNode = matchIndentInNode[0];\n\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length);\n      }\n\n      return node;\n    }).join('\\n');\n  }\n  /**\n   * Tokenizer\n   */\n\n\n  var Tokenizer_1 = /*#__PURE__*/function () {\n    function Tokenizer(options) {\n      this.options = options || defaults$1;\n    }\n\n    var _proto = Tokenizer.prototype;\n\n    _proto.space = function space(src) {\n      var cap = this.rules.block.newline.exec(src);\n\n      if (cap) {\n        if (cap[0].length > 1) {\n          return {\n            type: 'space',\n            raw: cap[0]\n          };\n        }\n\n        return {\n          raw: '\\n'\n        };\n      }\n    };\n\n    _proto.code = function code(src, tokens) {\n      var cap = this.rules.block.code.exec(src);\n\n      if (cap) {\n        var lastToken = tokens[tokens.length - 1]; // An indented code block cannot interrupt a paragraph.\n\n        if (lastToken && lastToken.type === 'paragraph') {\n          return {\n            raw: cap[0],\n            text: cap[0].trimRight()\n          };\n        }\n\n        var text = cap[0].replace(/^ {4}/gm, '');\n        return {\n          type: 'code',\n          raw: cap[0],\n          codeBlockStyle: 'indented',\n          text: !this.options.pedantic ? rtrim$1(text, '\\n') : text\n        };\n      }\n    };\n\n    _proto.fences = function fences(src) {\n      var cap = this.rules.block.fences.exec(src);\n\n      if (cap) {\n        var raw = cap[0];\n        var text = indentCodeCompensation(raw, cap[3] || '');\n        return {\n          type: 'code',\n          raw: raw,\n          lang: cap[2] ? cap[2].trim() : cap[2],\n          text: text\n        };\n      }\n    };\n\n    _proto.heading = function heading(src) {\n      var cap = this.rules.block.heading.exec(src);\n\n      if (cap) {\n        return {\n          type: 'heading',\n          raw: cap[0],\n          depth: cap[1].length,\n          text: cap[2]\n        };\n      }\n    };\n\n    _proto.nptable = function nptable(src) {\n      var cap = this.rules.block.nptable.exec(src);\n\n      if (cap) {\n        var item = {\n          type: 'table',\n          header: splitCells$1(cap[1].replace(/^ *| *\\| *$/g, '')),\n          align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n          cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : [],\n          raw: cap[0]\n        };\n\n        if (item.header.length === item.align.length) {\n          var l = item.align.length;\n          var i;\n\n          for (i = 0; i < l; i++) {\n            if (/^ *-+: *$/.test(item.align[i])) {\n              item.align[i] = 'right';\n            } else if (/^ *:-+: *$/.test(item.align[i])) {\n              item.align[i] = 'center';\n            } else if (/^ *:-+ *$/.test(item.align[i])) {\n              item.align[i] = 'left';\n            } else {\n              item.align[i] = null;\n            }\n          }\n\n          l = item.cells.length;\n\n          for (i = 0; i < l; i++) {\n            item.cells[i] = splitCells$1(item.cells[i], item.header.length);\n          }\n\n          return item;\n        }\n      }\n    };\n\n    _proto.hr = function hr(src) {\n      var cap = this.rules.block.hr.exec(src);\n\n      if (cap) {\n        return {\n          type: 'hr',\n          raw: cap[0]\n        };\n      }\n    };\n\n    _proto.blockquote = function blockquote(src) {\n      var cap = this.rules.block.blockquote.exec(src);\n\n      if (cap) {\n        var text = cap[0].replace(/^ *> ?/gm, '');\n        return {\n          type: 'blockquote',\n          raw: cap[0],\n          text: text\n        };\n      }\n    };\n\n    _proto.list = function list(src) {\n      var cap = this.rules.block.list.exec(src);\n\n      if (cap) {\n        var raw = cap[0];\n        var bull = cap[2];\n        var isordered = bull.length > 1;\n        var isparen = bull[bull.length - 1] === ')';\n        var list = {\n          type: 'list',\n          raw: raw,\n          ordered: isordered,\n          start: isordered ? +bull.slice(0, -1) : '',\n          loose: false,\n          items: []\n        }; // Get each top-level item.\n\n        var itemMatch = cap[0].match(this.rules.block.item);\n        var next = false,\n            item,\n            space,\n            b,\n            addBack,\n            loose,\n            istask,\n            ischecked;\n        var l = itemMatch.length;\n\n        for (var i = 0; i < l; i++) {\n          item = itemMatch[i];\n          raw = item; // Remove the list item's bullet\n          // so it is seen as the next token.\n\n          space = item.length;\n          item = item.replace(/^ *([*+-]|\\d+[.)]) */, ''); // Outdent whatever the\n          // list item contains. Hacky.\n\n          if (~item.indexOf('\\n ')) {\n            space -= item.length;\n            item = !this.options.pedantic ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '') : item.replace(/^ {1,4}/gm, '');\n          } // Determine whether the next list item belongs here.\n          // Backpedal if it does not belong in this list.\n\n\n          if (i !== l - 1) {\n            b = this.rules.block.bullet.exec(itemMatch[i + 1])[0];\n\n            if (isordered ? b.length === 1 || !isparen && b[b.length - 1] === ')' : b.length > 1 || this.options.smartLists && b !== bull) {\n              addBack = itemMatch.slice(i + 1).join('\\n');\n              list.raw = list.raw.substring(0, list.raw.length - addBack.length);\n              i = l - 1;\n            }\n          } // Determine whether item is loose or not.\n          // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n          // for discount behavior.\n\n\n          loose = next || /\\n\\n(?!\\s*$)/.test(item);\n\n          if (i !== l - 1) {\n            next = item.charAt(item.length - 1) === '\\n';\n            if (!loose) loose = next;\n          }\n\n          if (loose) {\n            list.loose = true;\n          } // Check for task list items\n\n\n          istask = /^\\[[ xX]\\] /.test(item);\n          ischecked = undefined;\n\n          if (istask) {\n            ischecked = item[1] !== ' ';\n            item = item.replace(/^\\[[ xX]\\] +/, '');\n          }\n\n          list.items.push({\n            type: 'list_item',\n            raw: raw,\n            task: istask,\n            checked: ischecked,\n            loose: loose,\n            text: item\n          });\n        }\n\n        return list;\n      }\n    };\n\n    _proto.html = function html(src) {\n      var cap = this.rules.block.html.exec(src);\n\n      if (cap) {\n        return {\n          type: this.options.sanitize ? 'paragraph' : 'html',\n          raw: cap[0],\n          pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]\n        };\n      }\n    };\n\n    _proto.def = function def(src) {\n      var cap = this.rules.block.def.exec(src);\n\n      if (cap) {\n        if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);\n        var tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n        return {\n          tag: tag,\n          raw: cap[0],\n          href: cap[2],\n          title: cap[3]\n        };\n      }\n    };\n\n    _proto.table = function table(src) {\n      var cap = this.rules.block.table.exec(src);\n\n      if (cap) {\n        var item = {\n          type: 'table',\n          header: splitCells$1(cap[1].replace(/^ *| *\\| *$/g, '')),\n          align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n          cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n        };\n\n        if (item.header.length === item.align.length) {\n          item.raw = cap[0];\n          var l = item.align.length;\n          var i;\n\n          for (i = 0; i < l; i++) {\n            if (/^ *-+: *$/.test(item.align[i])) {\n              item.align[i] = 'right';\n            } else if (/^ *:-+: *$/.test(item.align[i])) {\n              item.align[i] = 'center';\n            } else if (/^ *:-+ *$/.test(item.align[i])) {\n              item.align[i] = 'left';\n            } else {\n              item.align[i] = null;\n            }\n          }\n\n          l = item.cells.length;\n\n          for (i = 0; i < l; i++) {\n            item.cells[i] = splitCells$1(item.cells[i].replace(/^ *\\| *| *\\| *$/g, ''), item.header.length);\n          }\n\n          return item;\n        }\n      }\n    };\n\n    _proto.lheading = function lheading(src) {\n      var cap = this.rules.block.lheading.exec(src);\n\n      if (cap) {\n        return {\n          type: 'heading',\n          raw: cap[0],\n          depth: cap[2].charAt(0) === '=' ? 1 : 2,\n          text: cap[1]\n        };\n      }\n    };\n\n    _proto.paragraph = function paragraph(src) {\n      var cap = this.rules.block.paragraph.exec(src);\n\n      if (cap) {\n        return {\n          type: 'paragraph',\n          raw: cap[0],\n          text: cap[1].charAt(cap[1].length - 1) === '\\n' ? cap[1].slice(0, -1) : cap[1]\n        };\n      }\n    };\n\n    _proto.text = function text(src, tokens) {\n      var cap = this.rules.block.text.exec(src);\n\n      if (cap) {\n        var lastToken = tokens[tokens.length - 1];\n\n        if (lastToken && lastToken.type === 'text') {\n          return {\n            raw: cap[0],\n            text: cap[0]\n          };\n        }\n\n        return {\n          type: 'text',\n          raw: cap[0],\n          text: cap[0]\n        };\n      }\n    };\n\n    _proto.escape = function escape(src) {\n      var cap = this.rules.inline.escape.exec(src);\n\n      if (cap) {\n        return {\n          type: 'escape',\n          raw: cap[0],\n          text: _escape(cap[1])\n        };\n      }\n    };\n\n    _proto.tag = function tag(src, inLink, inRawBlock) {\n      var cap = this.rules.inline.tag.exec(src);\n\n      if (cap) {\n        if (!inLink && /^<a /i.test(cap[0])) {\n          inLink = true;\n        } else if (inLink && /^<\\/a>/i.test(cap[0])) {\n          inLink = false;\n        }\n\n        if (!inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n          inRawBlock = true;\n        } else if (inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n          inRawBlock = false;\n        }\n\n        return {\n          type: this.options.sanitize ? 'text' : 'html',\n          raw: cap[0],\n          inLink: inLink,\n          inRawBlock: inRawBlock,\n          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]\n        };\n      }\n    };\n\n    _proto.link = function link(src) {\n      var cap = this.rules.inline.link.exec(src);\n\n      if (cap) {\n        var lastParenIndex = findClosingBracket$1(cap[2], '()');\n\n        if (lastParenIndex > -1) {\n          var start = cap[0].indexOf('!') === 0 ? 5 : 4;\n          var linkLen = start + cap[1].length + lastParenIndex;\n          cap[2] = cap[2].substring(0, lastParenIndex);\n          cap[0] = cap[0].substring(0, linkLen).trim();\n          cap[3] = '';\n        }\n\n        var href = cap[2];\n        var title = '';\n\n        if (this.options.pedantic) {\n          var link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n\n          if (link) {\n            href = link[1];\n            title = link[3];\n          } else {\n            title = '';\n          }\n        } else {\n          title = cap[3] ? cap[3].slice(1, -1) : '';\n        }\n\n        href = href.trim().replace(/^<([\\s\\S]*)>$/, '$1');\n        var token = outputLink(cap, {\n          href: href ? href.replace(this.rules.inline._escapes, '$1') : href,\n          title: title ? title.replace(this.rules.inline._escapes, '$1') : title\n        }, cap[0]);\n        return token;\n      }\n    };\n\n    _proto.reflink = function reflink(src, links) {\n      var cap;\n\n      if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n        var link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n        link = links[link.toLowerCase()];\n\n        if (!link || !link.href) {\n          var text = cap[0].charAt(0);\n          return {\n            type: 'text',\n            raw: text,\n            text: text\n          };\n        }\n\n        var token = outputLink(cap, link, cap[0]);\n        return token;\n      }\n    };\n\n    _proto.strong = function strong(src, maskedSrc, prevChar) {\n      if (prevChar === void 0) {\n        prevChar = '';\n      }\n\n      var match = this.rules.inline.strong.start.exec(src);\n\n      if (match && (!match[1] || match[1] && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar)))) {\n        maskedSrc = maskedSrc.slice(-1 * src.length);\n        var endReg = match[0] === '**' ? this.rules.inline.strong.endAst : this.rules.inline.strong.endUnd;\n        endReg.lastIndex = 0;\n        var cap;\n\n        while ((match = endReg.exec(maskedSrc)) != null) {\n          cap = this.rules.inline.strong.middle.exec(maskedSrc.slice(0, match.index + 3));\n\n          if (cap) {\n            return {\n              type: 'strong',\n              raw: src.slice(0, cap[0].length),\n              text: src.slice(2, cap[0].length - 2)\n            };\n          }\n        }\n      }\n    };\n\n    _proto.em = function em(src, maskedSrc, prevChar) {\n      if (prevChar === void 0) {\n        prevChar = '';\n      }\n\n      var match = this.rules.inline.em.start.exec(src);\n\n      if (match && (!match[1] || match[1] && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar)))) {\n        maskedSrc = maskedSrc.slice(-1 * src.length);\n        var endReg = match[0] === '*' ? this.rules.inline.em.endAst : this.rules.inline.em.endUnd;\n        endReg.lastIndex = 0;\n        var cap;\n\n        while ((match = endReg.exec(maskedSrc)) != null) {\n          cap = this.rules.inline.em.middle.exec(maskedSrc.slice(0, match.index + 2));\n\n          if (cap) {\n            return {\n              type: 'em',\n              raw: src.slice(0, cap[0].length),\n              text: src.slice(1, cap[0].length - 1)\n            };\n          }\n        }\n      }\n    };\n\n    _proto.codespan = function codespan(src) {\n      var cap = this.rules.inline.code.exec(src);\n\n      if (cap) {\n        var text = cap[2].replace(/\\n/g, ' ');\n        var hasNonSpaceChars = /[^ ]/.test(text);\n        var hasSpaceCharsOnBothEnds = text.startsWith(' ') && text.endsWith(' ');\n\n        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n          text = text.substring(1, text.length - 1);\n        }\n\n        text = _escape(text, true);\n        return {\n          type: 'codespan',\n          raw: cap[0],\n          text: text\n        };\n      }\n    };\n\n    _proto.br = function br(src) {\n      var cap = this.rules.inline.br.exec(src);\n\n      if (cap) {\n        return {\n          type: 'br',\n          raw: cap[0]\n        };\n      }\n    };\n\n    _proto.del = function del(src) {\n      var cap = this.rules.inline.del.exec(src);\n\n      if (cap) {\n        return {\n          type: 'del',\n          raw: cap[0],\n          text: cap[1]\n        };\n      }\n    };\n\n    _proto.autolink = function autolink(src, mangle) {\n      var cap = this.rules.inline.autolink.exec(src);\n\n      if (cap) {\n        var text, href;\n\n        if (cap[2] === '@') {\n          text = _escape(this.options.mangle ? mangle(cap[1]) : cap[1]);\n          href = 'mailto:' + text;\n        } else {\n          text = _escape(cap[1]);\n          href = text;\n        }\n\n        return {\n          type: 'link',\n          raw: cap[0],\n          text: text,\n          href: href,\n          tokens: [{\n            type: 'text',\n            raw: text,\n            text: text\n          }]\n        };\n      }\n    };\n\n    _proto.url = function url(src, mangle) {\n      var cap;\n\n      if (cap = this.rules.inline.url.exec(src)) {\n        var text, href;\n\n        if (cap[2] === '@') {\n          text = _escape(this.options.mangle ? mangle(cap[0]) : cap[0]);\n          href = 'mailto:' + text;\n        } else {\n          // do extended autolink path validation\n          var prevCapZero;\n\n          do {\n            prevCapZero = cap[0];\n            cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];\n          } while (prevCapZero !== cap[0]);\n\n          text = _escape(cap[0]);\n\n          if (cap[1] === 'www.') {\n            href = 'http://' + text;\n          } else {\n            href = text;\n          }\n        }\n\n        return {\n          type: 'link',\n          raw: cap[0],\n          text: text,\n          href: href,\n          tokens: [{\n            type: 'text',\n            raw: text,\n            text: text\n          }]\n        };\n      }\n    };\n\n    _proto.inlineText = function inlineText(src, inRawBlock, smartypants) {\n      var cap = this.rules.inline.text.exec(src);\n\n      if (cap) {\n        var text;\n\n        if (inRawBlock) {\n          text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0];\n        } else {\n          text = _escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);\n        }\n\n        return {\n          type: 'text',\n          raw: cap[0],\n          text: text\n        };\n      }\n    };\n\n    return Tokenizer;\n  }();\n\n  var noopTest$1 = helpers.noopTest,\n      edit$1 = helpers.edit,\n      merge$1 = helpers.merge;\n  /**\n   * Block-Level Grammar\n   */\n\n  var block = {\n    newline: /^\\n+/,\n    code: /^( {4}[^\\n]+\\n*)+/,\n    fences: /^ {0,3}(`{3,}(?=[^`\\n]*\\n)|~{3,})([^\\n]*)\\n(?:|([\\s\\S]*?)\\n)(?: {0,3}\\1[~`]* *(?:\\n+|$)|$)/,\n    hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)/,\n    heading: /^ {0,3}(#{1,6}) +([^\\n]*?)(?: +#+)? *(?:\\n+|$)/,\n    blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n    list: /^( {0,3})(bull) [\\s\\S]+?(?:hr|def|\\n{2,}(?! )(?!\\1bull )\\n*|\\s*$)/,\n    html: '^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (6)\n    + '|<(?!script|pre|style)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (7) open tag\n    + '|</(?!script|pre|style)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (7) closing tag\n    + ')',\n    def: /^ {0,3}\\[(label)\\]: *\\n? *<?([^\\s>]+)>?(?:(?: +\\n? *| *\\n *)(title))? *(?:\\n+|$)/,\n    nptable: noopTest$1,\n    table: noopTest$1,\n    lheading: /^([^\\n]+)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    // regex template, placeholders will be replaced according to different paragraph\n    // interruption rules of commonmark and the original markdown spec:\n    _paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html)[^\\n]+)*)/,\n    text: /^[^\\n]+/\n  };\n  block._label = /(?!\\s*\\])(?:\\\\[\\[\\]]|[^\\[\\]])+/;\n  block._title = /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/;\n  block.def = edit$1(block.def).replace('label', block._label).replace('title', block._title).getRegex();\n  block.bullet = /(?:[*+-]|\\d{1,9}[.)])/;\n  block.item = /^( *)(bull) ?[^\\n]*(?:\\n(?!\\1bull ?)[^\\n]*)*/;\n  block.item = edit$1(block.item, 'gm').replace(/bull/g, block.bullet).getRegex();\n  block.list = edit$1(block.list).replace(/bull/g, block.bullet).replace('hr', '\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))').replace('def', '\\\\n+(?=' + block.def.source + ')').getRegex();\n  block._tag = 'address|article|aside|base|basefont|blockquote|body|caption' + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr' + '|track|ul';\n  block._comment = /<!--(?!-?>)[\\s\\S]*?(?:-->|$)/;\n  block.html = edit$1(block.html, 'i').replace('comment', block._comment).replace('tag', block._tag).replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\n  block.paragraph = edit$1(block._paragraph).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n  .replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|!--)').replace('tag', block._tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n  block.blockquote = edit$1(block.blockquote).replace('paragraph', block.paragraph).getRegex();\n  /**\n   * Normal Block Grammar\n   */\n\n  block.normal = merge$1({}, block);\n  /**\n   * GFM Block Grammar\n   */\n\n  block.gfm = merge$1({}, block.normal, {\n    nptable: '^ *([^|\\\\n ].*\\\\|.*)\\\\n' // Header\n    + ' {0,3}([-:]+ *\\\\|[-| :]*)' // Align\n    + '(?:\\\\n((?:(?!\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)',\n    // Cells\n    table: '^ *\\\\|(.+)\\\\n' // Header\n    + ' {0,3}\\\\|?( *[-:]+[-| :]*)' // Align\n    + '(?:\\\\n *((?:(?!\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)' // Cells\n\n  });\n  block.gfm.nptable = edit$1(block.gfm.nptable).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|!--)').replace('tag', block._tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n  block.gfm.table = edit$1(block.gfm.table).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|!--)').replace('tag', block._tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n  /**\n   * Pedantic grammar (original John Gruber's loose markdown specification)\n   */\n\n  block.pedantic = merge$1({}, block.normal, {\n    html: edit$1('^ *(?:comment *(?:\\\\n|\\\\s*$)' + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n    + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))').replace('comment', block._comment).replace(/tag/g, '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b').getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^ *(#{1,6}) *([^\\n]+?) *(?:#+ *)?(?:\\n+|$)/,\n    fences: noopTest$1,\n    // fences not supported\n    paragraph: edit$1(block.normal._paragraph).replace('hr', block.hr).replace('heading', ' *#{1,6} *[^\\n]').replace('lheading', block.lheading).replace('blockquote', ' {0,3}>').replace('|fences', '').replace('|list', '').replace('|html', '').getRegex()\n  });\n  /**\n   * Inline-Level Grammar\n   */\n\n  var inline = {\n    escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n    autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n    url: noopTest$1,\n    tag: '^comment' + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>',\n    // CDATA section\n    link: /^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/,\n    reflink: /^!?\\[(label)\\]\\[(?!\\s*\\])((?:\\\\[\\[\\]]?|[^\\[\\]\\\\])+)\\]/,\n    nolink: /^!?\\[(?!\\s*\\])((?:\\[[^\\[\\]]*\\]|\\\\[\\[\\]]|[^\\[\\]])*)\\](?:\\[\\])?/,\n    reflinkSearch: 'reflink|nolink(?!\\\\()',\n    strong: {\n      start: /^(?:(\\*\\*(?=[*punctuation]))|\\*\\*)(?![\\s])|__/,\n      // (1) returns if starts w/ punctuation\n      middle: /^\\*\\*(?:(?:(?!overlapSkip)(?:[^*]|\\\\\\*)|overlapSkip)|\\*(?:(?!overlapSkip)(?:[^*]|\\\\\\*)|overlapSkip)*?\\*)+?\\*\\*$|^__(?![\\s])((?:(?:(?!overlapSkip)(?:[^_]|\\\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\\\_)|overlapSkip)*?_)+?)__$/,\n      endAst: /[^punctuation\\s]\\*\\*(?!\\*)|[punctuation]\\*\\*(?!\\*)(?:(?=[punctuation_\\s]|$))/,\n      // last char can't be punct, or final * must also be followed by punct (or endline)\n      endUnd: /[^\\s]__(?!_)(?:(?=[punctuation*\\s])|$)/ // last char can't be a space, and final _ must preceed punct or \\s (or endline)\n\n    },\n    em: {\n      start: /^(?:(\\*(?=[punctuation]))|\\*)(?![*\\s])|_/,\n      // (1) returns if starts w/ punctuation\n      middle: /^\\*(?:(?:(?!overlapSkip)(?:[^*]|\\\\\\*)|overlapSkip)|\\*(?:(?!overlapSkip)(?:[^*]|\\\\\\*)|overlapSkip)*?\\*)+?\\*$|^_(?![_\\s])(?:(?:(?!overlapSkip)(?:[^_]|\\\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\\\_)|overlapSkip)*?_)+?_$/,\n      endAst: /[^punctuation\\s]\\*(?!\\*)|[punctuation]\\*(?!\\*)(?:(?=[punctuation_\\s]|$))/,\n      // last char can't be punct, or final * must also be followed by punct (or endline)\n      endUnd: /[^\\s]_(?!_)(?:(?=[punctuation*\\s])|$)/ // last char can't be a space, and final _ must preceed punct or \\s (or endline)\n\n    },\n    code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,\n    br: /^( {2,}|\\\\)\\n(?!\\s*$)/,\n    del: noopTest$1,\n    text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*]|\\b_|$)|[^ ](?= {2,}\\n)))/,\n    punctuation: /^([\\s*punctuation])/\n  }; // list of punctuation marks from common mark spec\n  // without * and _ to workaround cases with double emphasis\n\n  inline._punctuation = '!\"#$%&\\'()+\\\\-.,/:;<=>?@\\\\[\\\\]`^{|}~';\n  inline.punctuation = edit$1(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex(); // sequences em should skip over [title](link), `code`, <html>\n\n  inline._blockSkip = '\\\\[[^\\\\]]*?\\\\]\\\\([^\\\\)]*?\\\\)|`[^`]*?`|<[^>]*?>';\n  inline._overlapSkip = '__[^_]*?__|\\\\*\\\\*\\\\[^\\\\*\\\\]*?\\\\*\\\\*';\n  inline._comment = edit$1(block._comment).replace('(?:-->|$)', '-->').getRegex();\n  inline.em.start = edit$1(inline.em.start).replace(/punctuation/g, inline._punctuation).getRegex();\n  inline.em.middle = edit$1(inline.em.middle).replace(/punctuation/g, inline._punctuation).replace(/overlapSkip/g, inline._overlapSkip).getRegex();\n  inline.em.endAst = edit$1(inline.em.endAst, 'g').replace(/punctuation/g, inline._punctuation).getRegex();\n  inline.em.endUnd = edit$1(inline.em.endUnd, 'g').replace(/punctuation/g, inline._punctuation).getRegex();\n  inline.strong.start = edit$1(inline.strong.start).replace(/punctuation/g, inline._punctuation).getRegex();\n  inline.strong.middle = edit$1(inline.strong.middle).replace(/punctuation/g, inline._punctuation).replace(/overlapSkip/g, inline._overlapSkip).getRegex();\n  inline.strong.endAst = edit$1(inline.strong.endAst, 'g').replace(/punctuation/g, inline._punctuation).getRegex();\n  inline.strong.endUnd = edit$1(inline.strong.endUnd, 'g').replace(/punctuation/g, inline._punctuation).getRegex();\n  inline.blockSkip = edit$1(inline._blockSkip, 'g').getRegex();\n  inline.overlapSkip = edit$1(inline._overlapSkip, 'g').getRegex();\n  inline._escapes = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/g;\n  inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\n  inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\n  inline.autolink = edit$1(inline.autolink).replace('scheme', inline._scheme).replace('email', inline._email).getRegex();\n  inline._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/;\n  inline.tag = edit$1(inline.tag).replace('comment', inline._comment).replace('attribute', inline._attribute).getRegex();\n  inline._label = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n  inline._href = /<(?:\\\\[<>]?|[^\\s<>\\\\])*>|[^\\s\\x00-\\x1f]*/;\n  inline._title = /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\n  inline.link = edit$1(inline.link).replace('label', inline._label).replace('href', inline._href).replace('title', inline._title).getRegex();\n  inline.reflink = edit$1(inline.reflink).replace('label', inline._label).getRegex();\n  inline.reflinkSearch = edit$1(inline.reflinkSearch, 'g').replace('reflink', inline.reflink).replace('nolink', inline.nolink).getRegex();\n  /**\n   * Normal Inline Grammar\n   */\n\n  inline.normal = merge$1({}, inline);\n  /**\n   * Pedantic Inline Grammar\n   */\n\n  inline.pedantic = merge$1({}, inline.normal, {\n    strong: {\n      start: /^__|\\*\\*/,\n      middle: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n      endAst: /\\*\\*(?!\\*)/g,\n      endUnd: /__(?!_)/g\n    },\n    em: {\n      start: /^_|\\*/,\n      middle: /^()\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)|^_(?=\\S)([\\s\\S]*?\\S)_(?!_)/,\n      endAst: /\\*(?!\\*)/g,\n      endUnd: /_(?!_)/g\n    },\n    link: edit$1(/^!?\\[(label)\\]\\((.*?)\\)/).replace('label', inline._label).getRegex(),\n    reflink: edit$1(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace('label', inline._label).getRegex()\n  });\n  /**\n   * GFM Inline Grammar\n   */\n\n  inline.gfm = merge$1({}, inline.normal, {\n    escape: edit$1(inline.escape).replace('])', '~|])').getRegex(),\n    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,\n    url: /^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\n    _backpedal: /(?:[^?!.,:;*_~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,\n    del: /^~+(?=\\S)([\\s\\S]*?\\S)~+/,\n    text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@))|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@))/\n  });\n  inline.gfm.url = edit$1(inline.gfm.url, 'i').replace('email', inline.gfm._extended_email).getRegex();\n  /**\n   * GFM + Line Breaks Inline Grammar\n   */\n\n  inline.breaks = merge$1({}, inline.gfm, {\n    br: edit$1(inline.br).replace('{2,}', '*').getRegex(),\n    text: edit$1(inline.gfm.text).replace('\\\\b_', '\\\\b_| {2,}\\\\n').replace(/\\{2,\\}/g, '*').getRegex()\n  });\n  var rules = {\n    block: block,\n    inline: inline\n  };\n\n  var defaults$2 = defaults.defaults;\n  var block$1 = rules.block,\n      inline$1 = rules.inline;\n  /**\n   * smartypants text replacement\n   */\n\n  function smartypants(text) {\n    return text // em-dashes\n    .replace(/---/g, \"\\u2014\") // en-dashes\n    .replace(/--/g, \"\\u2013\") // opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, \"$1\\u2018\") // closing singles & apostrophes\n    .replace(/'/g, \"\\u2019\") // opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, \"$1\\u201C\") // closing doubles\n    .replace(/\"/g, \"\\u201D\") // ellipses\n    .replace(/\\.{3}/g, \"\\u2026\");\n  }\n  /**\n   * mangle email addresses\n   */\n\n\n  function mangle(text) {\n    var out = '',\n        i,\n        ch;\n    var l = text.length;\n\n    for (i = 0; i < l; i++) {\n      ch = text.charCodeAt(i);\n\n      if (Math.random() > 0.5) {\n        ch = 'x' + ch.toString(16);\n      }\n\n      out += '&#' + ch + ';';\n    }\n\n    return out;\n  }\n  /**\n   * Block Lexer\n   */\n\n\n  var Lexer_1 = /*#__PURE__*/function () {\n    function Lexer(options) {\n      this.tokens = [];\n      this.tokens.links = Object.create(null);\n      this.options = options || defaults$2;\n      this.options.tokenizer = this.options.tokenizer || new Tokenizer_1();\n      this.tokenizer = this.options.tokenizer;\n      this.tokenizer.options = this.options;\n      var rules = {\n        block: block$1.normal,\n        inline: inline$1.normal\n      };\n\n      if (this.options.pedantic) {\n        rules.block = block$1.pedantic;\n        rules.inline = inline$1.pedantic;\n      } else if (this.options.gfm) {\n        rules.block = block$1.gfm;\n\n        if (this.options.breaks) {\n          rules.inline = inline$1.breaks;\n        } else {\n          rules.inline = inline$1.gfm;\n        }\n      }\n\n      this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */\n\n\n    /**\n     * Static Lex Method\n     */\n    Lexer.lex = function lex(src, options) {\n      var lexer = new Lexer(options);\n      return lexer.lex(src);\n    }\n    /**\n     * Static Lex Inline Method\n     */\n    ;\n\n    Lexer.lexInline = function lexInline(src, options) {\n      var lexer = new Lexer(options);\n      return lexer.inlineTokens(src);\n    }\n    /**\n     * Preprocessing\n     */\n    ;\n\n    var _proto = Lexer.prototype;\n\n    _proto.lex = function lex(src) {\n      src = src.replace(/\\r\\n|\\r/g, '\\n').replace(/\\t/g, '    ');\n      this.blockTokens(src, this.tokens, true);\n      this.inline(this.tokens);\n      return this.tokens;\n    }\n    /**\n     * Lexing\n     */\n    ;\n\n    _proto.blockTokens = function blockTokens(src, tokens, top) {\n      if (tokens === void 0) {\n        tokens = [];\n      }\n\n      if (top === void 0) {\n        top = true;\n      }\n\n      src = src.replace(/^ +$/gm, '');\n      var token, i, l, lastToken;\n\n      while (src) {\n        // newline\n        if (token = this.tokenizer.space(src)) {\n          src = src.substring(token.raw.length);\n\n          if (token.type) {\n            tokens.push(token);\n          }\n\n          continue;\n        } // code\n\n\n        if (token = this.tokenizer.code(src, tokens)) {\n          src = src.substring(token.raw.length);\n\n          if (token.type) {\n            tokens.push(token);\n          } else {\n            lastToken = tokens[tokens.length - 1];\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.text;\n          }\n\n          continue;\n        } // fences\n\n\n        if (token = this.tokenizer.fences(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // heading\n\n\n        if (token = this.tokenizer.heading(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // table no leading pipe (gfm)\n\n\n        if (token = this.tokenizer.nptable(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // hr\n\n\n        if (token = this.tokenizer.hr(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // blockquote\n\n\n        if (token = this.tokenizer.blockquote(src)) {\n          src = src.substring(token.raw.length);\n          token.tokens = this.blockTokens(token.text, [], top);\n          tokens.push(token);\n          continue;\n        } // list\n\n\n        if (token = this.tokenizer.list(src)) {\n          src = src.substring(token.raw.length);\n          l = token.items.length;\n\n          for (i = 0; i < l; i++) {\n            token.items[i].tokens = this.blockTokens(token.items[i].text, [], false);\n          }\n\n          tokens.push(token);\n          continue;\n        } // html\n\n\n        if (token = this.tokenizer.html(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // def\n\n\n        if (top && (token = this.tokenizer.def(src))) {\n          src = src.substring(token.raw.length);\n\n          if (!this.tokens.links[token.tag]) {\n            this.tokens.links[token.tag] = {\n              href: token.href,\n              title: token.title\n            };\n          }\n\n          continue;\n        } // table (gfm)\n\n\n        if (token = this.tokenizer.table(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // lheading\n\n\n        if (token = this.tokenizer.lheading(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // top-level paragraph\n\n\n        if (top && (token = this.tokenizer.paragraph(src))) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // text\n\n\n        if (token = this.tokenizer.text(src, tokens)) {\n          src = src.substring(token.raw.length);\n\n          if (token.type) {\n            tokens.push(token);\n          } else {\n            lastToken = tokens[tokens.length - 1];\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.text;\n          }\n\n          continue;\n        }\n\n        if (src) {\n          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n\n          if (this.options.silent) {\n            console.error(errMsg);\n            break;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n\n      return tokens;\n    };\n\n    _proto.inline = function inline(tokens) {\n      var i, j, k, l2, row, token;\n      var l = tokens.length;\n\n      for (i = 0; i < l; i++) {\n        token = tokens[i];\n\n        switch (token.type) {\n          case 'paragraph':\n          case 'text':\n          case 'heading':\n            {\n              token.tokens = [];\n              this.inlineTokens(token.text, token.tokens);\n              break;\n            }\n\n          case 'table':\n            {\n              token.tokens = {\n                header: [],\n                cells: []\n              }; // header\n\n              l2 = token.header.length;\n\n              for (j = 0; j < l2; j++) {\n                token.tokens.header[j] = [];\n                this.inlineTokens(token.header[j], token.tokens.header[j]);\n              } // cells\n\n\n              l2 = token.cells.length;\n\n              for (j = 0; j < l2; j++) {\n                row = token.cells[j];\n                token.tokens.cells[j] = [];\n\n                for (k = 0; k < row.length; k++) {\n                  token.tokens.cells[j][k] = [];\n                  this.inlineTokens(row[k], token.tokens.cells[j][k]);\n                }\n              }\n\n              break;\n            }\n\n          case 'blockquote':\n            {\n              this.inline(token.tokens);\n              break;\n            }\n\n          case 'list':\n            {\n              l2 = token.items.length;\n\n              for (j = 0; j < l2; j++) {\n                this.inline(token.items[j].tokens);\n              }\n\n              break;\n            }\n        }\n      }\n\n      return tokens;\n    }\n    /**\n     * Lexing/Compiling\n     */\n    ;\n\n    _proto.inlineTokens = function inlineTokens(src, tokens, inLink, inRawBlock, prevChar) {\n      if (tokens === void 0) {\n        tokens = [];\n      }\n\n      if (inLink === void 0) {\n        inLink = false;\n      }\n\n      if (inRawBlock === void 0) {\n        inRawBlock = false;\n      }\n\n      if (prevChar === void 0) {\n        prevChar = '';\n      }\n\n      var token; // String with links masked to avoid interference with em and strong\n\n      var maskedSrc = src;\n      var match; // Mask out reflinks\n\n      if (this.tokens.links) {\n        var links = Object.keys(this.tokens.links);\n\n        if (links.length > 0) {\n          while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n            if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n              maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n            }\n          }\n        }\n      } // Mask out other blocks\n\n\n      while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n        maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n      }\n\n      while (src) {\n        // escape\n        if (token = this.tokenizer.escape(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // tag\n\n\n        if (token = this.tokenizer.tag(src, inLink, inRawBlock)) {\n          src = src.substring(token.raw.length);\n          inLink = token.inLink;\n          inRawBlock = token.inRawBlock;\n          tokens.push(token);\n          continue;\n        } // link\n\n\n        if (token = this.tokenizer.link(src)) {\n          src = src.substring(token.raw.length);\n\n          if (token.type === 'link') {\n            token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);\n          }\n\n          tokens.push(token);\n          continue;\n        } // reflink, nolink\n\n\n        if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n          src = src.substring(token.raw.length);\n\n          if (token.type === 'link') {\n            token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);\n          }\n\n          tokens.push(token);\n          continue;\n        } // strong\n\n\n        if (token = this.tokenizer.strong(src, maskedSrc, prevChar)) {\n          src = src.substring(token.raw.length);\n          token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);\n          tokens.push(token);\n          continue;\n        } // em\n\n\n        if (token = this.tokenizer.em(src, maskedSrc, prevChar)) {\n          src = src.substring(token.raw.length);\n          token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);\n          tokens.push(token);\n          continue;\n        } // code\n\n\n        if (token = this.tokenizer.codespan(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // br\n\n\n        if (token = this.tokenizer.br(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // del (gfm)\n\n\n        if (token = this.tokenizer.del(src)) {\n          src = src.substring(token.raw.length);\n          token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);\n          tokens.push(token);\n          continue;\n        } // autolink\n\n\n        if (token = this.tokenizer.autolink(src, mangle)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // url (gfm)\n\n\n        if (!inLink && (token = this.tokenizer.url(src, mangle))) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // text\n\n\n        if (token = this.tokenizer.inlineText(src, inRawBlock, smartypants)) {\n          src = src.substring(token.raw.length);\n          prevChar = token.raw.slice(-1);\n          tokens.push(token);\n          continue;\n        }\n\n        if (src) {\n          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n\n          if (this.options.silent) {\n            console.error(errMsg);\n            break;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n\n      return tokens;\n    };\n\n    _createClass(Lexer, null, [{\n      key: \"rules\",\n      get: function get() {\n        return {\n          block: block$1,\n          inline: inline$1\n        };\n      }\n    }]);\n\n    return Lexer;\n  }();\n\n  var defaults$3 = defaults.defaults;\n  var cleanUrl$1 = helpers.cleanUrl,\n      escape$1 = helpers.escape;\n  /**\n   * Renderer\n   */\n\n  var Renderer_1 = /*#__PURE__*/function () {\n    function Renderer(options) {\n      this.options = options || defaults$3;\n    }\n\n    var _proto = Renderer.prototype;\n\n    _proto.code = function code(_code, infostring, escaped) {\n      var lang = (infostring || '').match(/\\S*/)[0];\n\n      if (this.options.highlight) {\n        var out = this.options.highlight(_code, lang);\n\n        if (out != null && out !== _code) {\n          escaped = true;\n          _code = out;\n        }\n      }\n\n      if (!lang) {\n        return '<pre><code>' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\\n';\n      }\n\n      return '<pre><code class=\"' + this.options.langPrefix + escape$1(lang, true) + '\">' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\\n';\n    };\n\n    _proto.blockquote = function blockquote(quote) {\n      return '<blockquote>\\n' + quote + '</blockquote>\\n';\n    };\n\n    _proto.html = function html(_html) {\n      return _html;\n    };\n\n    _proto.heading = function heading(text, level, raw, slugger) {\n      if (this.options.headerIds) {\n        return '<h' + level + ' id=\"' + this.options.headerPrefix + slugger.slug(raw) + '\">' + text + '</h' + level + '>\\n';\n      } // ignore IDs\n\n\n      return '<h' + level + '>' + text + '</h' + level + '>\\n';\n    };\n\n    _proto.hr = function hr() {\n      return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n    };\n\n    _proto.list = function list(body, ordered, start) {\n      var type = ordered ? 'ol' : 'ul',\n          startatt = ordered && start !== 1 ? ' start=\"' + start + '\"' : '';\n      return '<' + type + startatt + '>\\n' + body + '</' + type + '>\\n';\n    };\n\n    _proto.listitem = function listitem(text) {\n      return '<li>' + text + '</li>\\n';\n    };\n\n    _proto.checkbox = function checkbox(checked) {\n      return '<input ' + (checked ? 'checked=\"\" ' : '') + 'disabled=\"\" type=\"checkbox\"' + (this.options.xhtml ? ' /' : '') + '> ';\n    };\n\n    _proto.paragraph = function paragraph(text) {\n      return '<p>' + text + '</p>\\n';\n    };\n\n    _proto.table = function table(header, body) {\n      if (body) body = '<tbody>' + body + '</tbody>';\n      return '<table>\\n' + '<thead>\\n' + header + '</thead>\\n' + body + '</table>\\n';\n    };\n\n    _proto.tablerow = function tablerow(content) {\n      return '<tr>\\n' + content + '</tr>\\n';\n    };\n\n    _proto.tablecell = function tablecell(content, flags) {\n      var type = flags.header ? 'th' : 'td';\n      var tag = flags.align ? '<' + type + ' align=\"' + flags.align + '\">' : '<' + type + '>';\n      return tag + content + '</' + type + '>\\n';\n    } // span level renderer\n    ;\n\n    _proto.strong = function strong(text) {\n      return '<strong>' + text + '</strong>';\n    };\n\n    _proto.em = function em(text) {\n      return '<em>' + text + '</em>';\n    };\n\n    _proto.codespan = function codespan(text) {\n      return '<code>' + text + '</code>';\n    };\n\n    _proto.br = function br() {\n      return this.options.xhtml ? '<br/>' : '<br>';\n    };\n\n    _proto.del = function del(text) {\n      return '<del>' + text + '</del>';\n    };\n\n    _proto.link = function link(href, title, text) {\n      href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);\n\n      if (href === null) {\n        return text;\n      }\n\n      var out = '<a href=\"' + escape$1(href) + '\"';\n\n      if (title) {\n        out += ' title=\"' + title + '\"';\n      }\n\n      out += '>' + text + '</a>';\n      return out;\n    };\n\n    _proto.image = function image(href, title, text) {\n      href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);\n\n      if (href === null) {\n        return text;\n      }\n\n      var out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n\n      if (title) {\n        out += ' title=\"' + title + '\"';\n      }\n\n      out += this.options.xhtml ? '/>' : '>';\n      return out;\n    };\n\n    _proto.text = function text(_text) {\n      return _text;\n    };\n\n    return Renderer;\n  }();\n\n  /**\n   * TextRenderer\n   * returns only the textual part of the token\n   */\n  var TextRenderer_1 = /*#__PURE__*/function () {\n    function TextRenderer() {}\n\n    var _proto = TextRenderer.prototype;\n\n    // no need for block level renderers\n    _proto.strong = function strong(text) {\n      return text;\n    };\n\n    _proto.em = function em(text) {\n      return text;\n    };\n\n    _proto.codespan = function codespan(text) {\n      return text;\n    };\n\n    _proto.del = function del(text) {\n      return text;\n    };\n\n    _proto.html = function html(text) {\n      return text;\n    };\n\n    _proto.text = function text(_text) {\n      return _text;\n    };\n\n    _proto.link = function link(href, title, text) {\n      return '' + text;\n    };\n\n    _proto.image = function image(href, title, text) {\n      return '' + text;\n    };\n\n    _proto.br = function br() {\n      return '';\n    };\n\n    return TextRenderer;\n  }();\n\n  /**\n   * Slugger generates header id\n   */\n  var Slugger_1 = /*#__PURE__*/function () {\n    function Slugger() {\n      this.seen = {};\n    }\n\n    var _proto = Slugger.prototype;\n\n    _proto.serialize = function serialize(value) {\n      return value.toLowerCase().trim() // remove html tags\n      .replace(/<[!\\/a-z].*?>/ig, '') // remove unwanted chars\n      .replace(/[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,./:;<=>?@[\\]^`{|}~]/g, '').replace(/\\s/g, '-');\n    }\n    /**\n     * Finds the next safe (unique) slug to use\n     */\n    ;\n\n    _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {\n      var slug = originalSlug;\n      var occurenceAccumulator = 0;\n\n      if (this.seen.hasOwnProperty(slug)) {\n        occurenceAccumulator = this.seen[originalSlug];\n\n        do {\n          occurenceAccumulator++;\n          slug = originalSlug + '-' + occurenceAccumulator;\n        } while (this.seen.hasOwnProperty(slug));\n      }\n\n      if (!isDryRun) {\n        this.seen[originalSlug] = occurenceAccumulator;\n        this.seen[slug] = 0;\n      }\n\n      return slug;\n    }\n    /**\n     * Convert string to unique id\n     * @param {object} options\n     * @param {boolean} options.dryrun Generates the next unique slug without updating the internal accumulator.\n     */\n    ;\n\n    _proto.slug = function slug(value, options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      var slug = this.serialize(value);\n      return this.getNextSafeSlug(slug, options.dryrun);\n    };\n\n    return Slugger;\n  }();\n\n  var defaults$4 = defaults.defaults;\n  var unescape$1 = helpers.unescape;\n  /**\n   * Parsing & Compiling\n   */\n\n  var Parser_1 = /*#__PURE__*/function () {\n    function Parser(options) {\n      this.options = options || defaults$4;\n      this.options.renderer = this.options.renderer || new Renderer_1();\n      this.renderer = this.options.renderer;\n      this.renderer.options = this.options;\n      this.textRenderer = new TextRenderer_1();\n      this.slugger = new Slugger_1();\n    }\n    /**\n     * Static Parse Method\n     */\n\n\n    Parser.parse = function parse(tokens, options) {\n      var parser = new Parser(options);\n      return parser.parse(tokens);\n    }\n    /**\n     * Static Parse Inline Method\n     */\n    ;\n\n    Parser.parseInline = function parseInline(tokens, options) {\n      var parser = new Parser(options);\n      return parser.parseInline(tokens);\n    }\n    /**\n     * Parse Loop\n     */\n    ;\n\n    var _proto = Parser.prototype;\n\n    _proto.parse = function parse(tokens, top) {\n      if (top === void 0) {\n        top = true;\n      }\n\n      var out = '',\n          i,\n          j,\n          k,\n          l2,\n          l3,\n          row,\n          cell,\n          header,\n          body,\n          token,\n          ordered,\n          start,\n          loose,\n          itemBody,\n          item,\n          checked,\n          task,\n          checkbox;\n      var l = tokens.length;\n\n      for (i = 0; i < l; i++) {\n        token = tokens[i];\n\n        switch (token.type) {\n          case 'space':\n            {\n              continue;\n            }\n\n          case 'hr':\n            {\n              out += this.renderer.hr();\n              continue;\n            }\n\n          case 'heading':\n            {\n              out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape$1(this.parseInline(token.tokens, this.textRenderer)), this.slugger);\n              continue;\n            }\n\n          case 'code':\n            {\n              out += this.renderer.code(token.text, token.lang, token.escaped);\n              continue;\n            }\n\n          case 'table':\n            {\n              header = ''; // header\n\n              cell = '';\n              l2 = token.header.length;\n\n              for (j = 0; j < l2; j++) {\n                cell += this.renderer.tablecell(this.parseInline(token.tokens.header[j]), {\n                  header: true,\n                  align: token.align[j]\n                });\n              }\n\n              header += this.renderer.tablerow(cell);\n              body = '';\n              l2 = token.cells.length;\n\n              for (j = 0; j < l2; j++) {\n                row = token.tokens.cells[j];\n                cell = '';\n                l3 = row.length;\n\n                for (k = 0; k < l3; k++) {\n                  cell += this.renderer.tablecell(this.parseInline(row[k]), {\n                    header: false,\n                    align: token.align[k]\n                  });\n                }\n\n                body += this.renderer.tablerow(cell);\n              }\n\n              out += this.renderer.table(header, body);\n              continue;\n            }\n\n          case 'blockquote':\n            {\n              body = this.parse(token.tokens);\n              out += this.renderer.blockquote(body);\n              continue;\n            }\n\n          case 'list':\n            {\n              ordered = token.ordered;\n              start = token.start;\n              loose = token.loose;\n              l2 = token.items.length;\n              body = '';\n\n              for (j = 0; j < l2; j++) {\n                item = token.items[j];\n                checked = item.checked;\n                task = item.task;\n                itemBody = '';\n\n                if (item.task) {\n                  checkbox = this.renderer.checkbox(checked);\n\n                  if (loose) {\n                    if (item.tokens.length > 0 && item.tokens[0].type === 'text') {\n                      item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n\n                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                      }\n                    } else {\n                      item.tokens.unshift({\n                        type: 'text',\n                        text: checkbox\n                      });\n                    }\n                  } else {\n                    itemBody += checkbox;\n                  }\n                }\n\n                itemBody += this.parse(item.tokens, loose);\n                body += this.renderer.listitem(itemBody, task, checked);\n              }\n\n              out += this.renderer.list(body, ordered, start);\n              continue;\n            }\n\n          case 'html':\n            {\n              // TODO parse inline content if parameter markdown=1\n              out += this.renderer.html(token.text);\n              continue;\n            }\n\n          case 'paragraph':\n            {\n              out += this.renderer.paragraph(this.parseInline(token.tokens));\n              continue;\n            }\n\n          case 'text':\n            {\n              body = token.tokens ? this.parseInline(token.tokens) : token.text;\n\n              while (i + 1 < l && tokens[i + 1].type === 'text') {\n                token = tokens[++i];\n                body += '\\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);\n              }\n\n              out += top ? this.renderer.paragraph(body) : body;\n              continue;\n            }\n\n          default:\n            {\n              var errMsg = 'Token with \"' + token.type + '\" type was not found.';\n\n              if (this.options.silent) {\n                console.error(errMsg);\n                return;\n              } else {\n                throw new Error(errMsg);\n              }\n            }\n        }\n      }\n\n      return out;\n    }\n    /**\n     * Parse Inline Tokens\n     */\n    ;\n\n    _proto.parseInline = function parseInline(tokens, renderer) {\n      renderer = renderer || this.renderer;\n      var out = '',\n          i,\n          token;\n      var l = tokens.length;\n\n      for (i = 0; i < l; i++) {\n        token = tokens[i];\n\n        switch (token.type) {\n          case 'escape':\n            {\n              out += renderer.text(token.text);\n              break;\n            }\n\n          case 'html':\n            {\n              out += renderer.html(token.text);\n              break;\n            }\n\n          case 'link':\n            {\n              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'image':\n            {\n              out += renderer.image(token.href, token.title, token.text);\n              break;\n            }\n\n          case 'strong':\n            {\n              out += renderer.strong(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'em':\n            {\n              out += renderer.em(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'codespan':\n            {\n              out += renderer.codespan(token.text);\n              break;\n            }\n\n          case 'br':\n            {\n              out += renderer.br();\n              break;\n            }\n\n          case 'del':\n            {\n              out += renderer.del(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'text':\n            {\n              out += renderer.text(token.text);\n              break;\n            }\n\n          default:\n            {\n              var errMsg = 'Token with \"' + token.type + '\" type was not found.';\n\n              if (this.options.silent) {\n                console.error(errMsg);\n                return;\n              } else {\n                throw new Error(errMsg);\n              }\n            }\n        }\n      }\n\n      return out;\n    };\n\n    return Parser;\n  }();\n\n  var merge$2 = helpers.merge,\n      checkSanitizeDeprecation$1 = helpers.checkSanitizeDeprecation,\n      escape$2 = helpers.escape;\n  var getDefaults = defaults.getDefaults,\n      changeDefaults = defaults.changeDefaults,\n      defaults$5 = defaults.defaults;\n  /**\n   * Marked\n   */\n\n  function marked(src, opt, callback) {\n    // throw error in case of non string input\n    if (typeof src === 'undefined' || src === null) {\n      throw new Error('marked(): input parameter is undefined or null');\n    }\n\n    if (typeof src !== 'string') {\n      throw new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');\n    }\n\n    if (typeof opt === 'function') {\n      callback = opt;\n      opt = null;\n    }\n\n    opt = merge$2({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation$1(opt);\n\n    if (callback) {\n      var highlight = opt.highlight;\n      var tokens;\n\n      try {\n        tokens = Lexer_1.lex(src, opt);\n      } catch (e) {\n        return callback(e);\n      }\n\n      var done = function done(err) {\n        var out;\n\n        if (!err) {\n          try {\n            out = Parser_1.parse(tokens, opt);\n          } catch (e) {\n            err = e;\n          }\n        }\n\n        opt.highlight = highlight;\n        return err ? callback(err) : callback(null, out);\n      };\n\n      if (!highlight || highlight.length < 3) {\n        return done();\n      }\n\n      delete opt.highlight;\n      if (!tokens.length) return done();\n      var pending = 0;\n      marked.walkTokens(tokens, function (token) {\n        if (token.type === 'code') {\n          pending++;\n          setTimeout(function () {\n            highlight(token.text, token.lang, function (err, code) {\n              if (err) {\n                return done(err);\n              }\n\n              if (code != null && code !== token.text) {\n                token.text = code;\n                token.escaped = true;\n              }\n\n              pending--;\n\n              if (pending === 0) {\n                done();\n              }\n            });\n          }, 0);\n        }\n      });\n\n      if (pending === 0) {\n        done();\n      }\n\n      return;\n    }\n\n    try {\n      var _tokens = Lexer_1.lex(src, opt);\n\n      if (opt.walkTokens) {\n        marked.walkTokens(_tokens, opt.walkTokens);\n      }\n\n      return Parser_1.parse(_tokens, opt);\n    } catch (e) {\n      e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n      if (opt.silent) {\n        return '<p>An error occurred:</p><pre>' + escape$2(e.message + '', true) + '</pre>';\n      }\n\n      throw e;\n    }\n  }\n  /**\n   * Options\n   */\n\n\n  marked.options = marked.setOptions = function (opt) {\n    merge$2(marked.defaults, opt);\n    changeDefaults(marked.defaults);\n    return marked;\n  };\n\n  marked.getDefaults = getDefaults;\n  marked.defaults = defaults$5;\n  /**\n   * Use Extension\n   */\n\n  marked.use = function (extension) {\n    var opts = merge$2({}, extension);\n\n    if (extension.renderer) {\n      (function () {\n        var renderer = marked.defaults.renderer || new Renderer_1();\n\n        var _loop = function _loop(prop) {\n          var prevRenderer = renderer[prop];\n\n          renderer[prop] = function () {\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n\n            var ret = extension.renderer[prop].apply(renderer, args);\n\n            if (ret === false) {\n              ret = prevRenderer.apply(renderer, args);\n            }\n\n            return ret;\n          };\n        };\n\n        for (var prop in extension.renderer) {\n          _loop(prop);\n        }\n\n        opts.renderer = renderer;\n      })();\n    }\n\n    if (extension.tokenizer) {\n      (function () {\n        var tokenizer = marked.defaults.tokenizer || new Tokenizer_1();\n\n        var _loop2 = function _loop2(prop) {\n          var prevTokenizer = tokenizer[prop];\n\n          tokenizer[prop] = function () {\n            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              args[_key2] = arguments[_key2];\n            }\n\n            var ret = extension.tokenizer[prop].apply(tokenizer, args);\n\n            if (ret === false) {\n              ret = prevTokenizer.apply(tokenizer, args);\n            }\n\n            return ret;\n          };\n        };\n\n        for (var prop in extension.tokenizer) {\n          _loop2(prop);\n        }\n\n        opts.tokenizer = tokenizer;\n      })();\n    }\n\n    if (extension.walkTokens) {\n      var walkTokens = marked.defaults.walkTokens;\n\n      opts.walkTokens = function (token) {\n        extension.walkTokens(token);\n\n        if (walkTokens) {\n          walkTokens(token);\n        }\n      };\n    }\n\n    marked.setOptions(opts);\n  };\n  /**\n   * Run callback for every token\n   */\n\n\n  marked.walkTokens = function (tokens, callback) {\n    for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done;) {\n      var token = _step.value;\n      callback(token);\n\n      switch (token.type) {\n        case 'table':\n          {\n            for (var _iterator2 = _createForOfIteratorHelperLoose(token.tokens.header), _step2; !(_step2 = _iterator2()).done;) {\n              var cell = _step2.value;\n              marked.walkTokens(cell, callback);\n            }\n\n            for (var _iterator3 = _createForOfIteratorHelperLoose(token.tokens.cells), _step3; !(_step3 = _iterator3()).done;) {\n              var row = _step3.value;\n\n              for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done;) {\n                var _cell = _step4.value;\n                marked.walkTokens(_cell, callback);\n              }\n            }\n\n            break;\n          }\n\n        case 'list':\n          {\n            marked.walkTokens(token.items, callback);\n            break;\n          }\n\n        default:\n          {\n            if (token.tokens) {\n              marked.walkTokens(token.tokens, callback);\n            }\n          }\n      }\n    }\n  };\n  /**\n   * Parse Inline\n   */\n\n\n  marked.parseInline = function (src, opt) {\n    // throw error in case of non string input\n    if (typeof src === 'undefined' || src === null) {\n      throw new Error('marked.parseInline(): input parameter is undefined or null');\n    }\n\n    if (typeof src !== 'string') {\n      throw new Error('marked.parseInline(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');\n    }\n\n    opt = merge$2({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation$1(opt);\n\n    try {\n      var tokens = Lexer_1.lexInline(src, opt);\n\n      if (opt.walkTokens) {\n        marked.walkTokens(tokens, opt.walkTokens);\n      }\n\n      return Parser_1.parseInline(tokens, opt);\n    } catch (e) {\n      e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n      if (opt.silent) {\n        return '<p>An error occurred:</p><pre>' + escape$2(e.message + '', true) + '</pre>';\n      }\n\n      throw e;\n    }\n  };\n  /**\n   * Expose\n   */\n\n\n  marked.Parser = Parser_1;\n  marked.parser = Parser_1.parse;\n  marked.Renderer = Renderer_1;\n  marked.TextRenderer = TextRenderer_1;\n  marked.Lexer = Lexer_1;\n  marked.lexer = Lexer_1.lex;\n  marked.Tokenizer = Tokenizer_1;\n  marked.Slugger = Slugger_1;\n  marked.parse = marked;\n  var marked_1 = marked;\n\n  return marked_1;\n\n})));\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/**\n * Actions that modify the URL.\n */\nvar LocationActions = {\n\n  /**\n   * Indicates a new location is being pushed to the history stack.\n   */\n  PUSH: 'push',\n\n  /**\n   * Indicates the current location should be replaced.\n   */\n  REPLACE: 'replace',\n\n  /**\n   * Indicates the most recent entry should be removed from the history stack.\n   */\n  POP: 'pop'\n\n};\n\nmodule.exports = LocationActions;\n","var LocationActions = require('../actions/LocationActions');\n\n/**\n * A scroll behavior that attempts to imitate the default behavior\n * of modern browsers.\n */\nvar ImitateBrowserBehavior = {\n\n  updateScrollPosition: function (position, actionType) {\n    switch (actionType) {\n      case LocationActions.PUSH:\n      case LocationActions.REPLACE:\n        window.scrollTo(0, 0);\n        break;\n      case LocationActions.POP:\n        if (position) {\n          window.scrollTo(position.x, position.y);\n        } else {\n          window.scrollTo(0, 0);\n        }\n        break;\n    }\n  }\n\n};\n\nmodule.exports = ImitateBrowserBehavior;\n","/**\n * A scroll behavior that always scrolls to the top of the page\n * after a transition.\n */\nvar ScrollToTopBehavior = {\n\n  updateScrollPosition: function () {\n    window.scrollTo(0, 0);\n  }\n\n};\n\nmodule.exports = ScrollToTopBehavior;\n","var React = require('react');\nvar FakeNode = require('../mixins/FakeNode');\nvar PropTypes = require('../utils/PropTypes');\n\n/**\n * A <DefaultRoute> component is a special kind of <Route> that\n * renders when its parent matches but none of its siblings do.\n * Only one such route may be used at any given level in the\n * route hierarchy.\n */\nvar DefaultRoute = React.createClass({\n\n  displayName: 'DefaultRoute',\n\n  mixins: [ FakeNode ],\n\n  propTypes: {\n    name: React.PropTypes.string,\n    path: PropTypes.falsy,\n    handler: React.PropTypes.func.isRequired\n  }\n\n});\n\nmodule.exports = DefaultRoute;\n","var React = require('react');\nvar classSet = require('react/lib/cx');\nvar assign = require('react/lib/Object.assign');\nvar Navigation = require('../mixins/Navigation');\nvar State = require('../mixins/State');\n\nfunction isLeftClickEvent(event) {\n  return event.button === 0;\n}\n\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\n\n/**\n * <Link> components are used to create an <a> element that links to a route.\n * When that route is active, the link gets an \"active\" class name (or the\n * value of its `activeClassName` prop).\n *\n * For example, assuming you have the following route:\n *\n *   <Route name=\"showPost\" path=\"/posts/:postID\" handler={Post}/>\n *\n * You could use the following component to link to that route:\n *\n *   <Link to=\"showPost\" params={{ postID: \"123\" }} />\n *\n * In addition to params, links may pass along query string parameters\n * using the `query` prop.\n *\n *   <Link to=\"showPost\" params={{ postID: \"123\" }} query={{ show:true }}/>\n */\nvar Link = React.createClass({\n\n  displayName: 'Link',\n\n  mixins: [ Navigation, State ],\n\n  propTypes: {\n    activeClassName: React.PropTypes.string.isRequired,\n    to: React.PropTypes.string.isRequired,\n    params: React.PropTypes.object,\n    query: React.PropTypes.object,\n    onClick: React.PropTypes.func\n  },\n\n  getDefaultProps: function () {\n    return {\n      activeClassName: 'active'\n    };\n  },\n\n  handleClick: function (event) {\n    var allowTransition = true;\n    var clickResult;\n\n    if (this.props.onClick)\n      clickResult = this.props.onClick(event);\n\n    if (isModifiedEvent(event) || !isLeftClickEvent(event))\n      return;\n\n    if (clickResult === false || event.defaultPrevented === true)\n      allowTransition = false;\n\n    event.preventDefault();\n\n    if (allowTransition)\n      this.transitionTo(this.props.to, this.props.params, this.props.query);\n  },\n\n  /**\n   * Returns the value of the \"href\" attribute to use on the DOM element.\n   */\n  getHref: function () {\n    return this.makeHref(this.props.to, this.props.params, this.props.query);\n  },\n\n  /**\n   * Returns the value of the \"class\" attribute to use on the DOM element, which contains\n   * the value of the activeClassName property when this <Link> is active.\n   */\n  getClassName: function () {\n    var classNames = {};\n\n    if (this.props.className)\n      classNames[this.props.className] = true;\n\n    if (this.isActive(this.props.to, this.props.params, this.props.query))\n      classNames[this.props.activeClassName] = true;\n\n    return classSet(classNames);\n  },\n\n  render: function () {\n    var props = assign({}, this.props, {\n      href: this.getHref(),\n      className: this.getClassName(),\n      onClick: this.handleClick\n    });\n\n    return React.DOM.a(props, this.props.children);\n  }\n\n});\n\nmodule.exports = Link;\n","var React = require('react');\nvar FakeNode = require('../mixins/FakeNode');\nvar PropTypes = require('../utils/PropTypes');\n\n/**\n * A <NotFoundRoute> is a special kind of <Route> that\n * renders when the beginning of its parent's path matches\n * but none of its siblings do, including any <DefaultRoute>.\n * Only one such route may be used at any given level in the\n * route hierarchy.\n */\nvar NotFoundRoute = React.createClass({\n\n  displayName: 'NotFoundRoute',\n\n  mixins: [ FakeNode ],\n\n  propTypes: {\n    name: React.PropTypes.string,\n    path: PropTypes.falsy,\n    handler: React.PropTypes.func.isRequired\n  }\n\n});\n\nmodule.exports = NotFoundRoute;\n","var React = require('react');\nvar FakeNode = require('../mixins/FakeNode');\nvar PropTypes = require('../utils/PropTypes');\n\n/**\n * A <Redirect> component is a special kind of <Route> that always\n * redirects to another route when it matches.\n */\nvar Redirect = React.createClass({\n\n  displayName: 'Redirect',\n\n  mixins: [ FakeNode ],\n\n  propTypes: {\n    path: React.PropTypes.string,\n    from: React.PropTypes.string, // Alias for path.\n    to: React.PropTypes.string,\n    handler: PropTypes.falsy\n  }\n\n});\n\nmodule.exports = Redirect;\n","var React = require('react');\nvar FakeNode = require('../mixins/FakeNode');\n\n/**\n * <Route> components specify components that are rendered to the page when the\n * URL matches a given pattern.\n *\n * Routes are arranged in a nested tree structure. When a new URL is requested,\n * the tree is searched depth-first to find a route whose path matches the URL.\n * When one is found, all routes in the tree that lead to it are considered\n * \"active\" and their components are rendered into the DOM, nested in the same\n * order as they are in the tree.\n *\n * The preferred way to configure a router is using JSX. The XML-like syntax is\n * a great way to visualize how routes are laid out in an application.\n *\n *   var routes = [\n *     <Route handler={App}>\n *       <Route name=\"login\" handler={Login}/>\n *       <Route name=\"logout\" handler={Logout}/>\n *       <Route name=\"about\" handler={About}/>\n *     </Route>\n *   ];\n *   \n *   Router.run(routes, function (Handler) {\n *     React.render(<Handler/>, document.body);\n *   });\n *\n * Handlers for Route components that contain children can render their active\n * child route using a <RouteHandler> element.\n *\n *   var App = React.createClass({\n *     render: function () {\n *       return (\n *         <div class=\"application\">\n *           <RouteHandler/>\n *         </div>\n *       );\n *     }\n *   });\n */\nvar Route = React.createClass({\n\n  displayName: 'Route',\n\n  mixins: [ FakeNode ],\n\n  propTypes: {\n    name: React.PropTypes.string,\n    path: React.PropTypes.string,\n    handler: React.PropTypes.func.isRequired,\n    ignoreScrollBehavior: React.PropTypes.bool\n  }\n\n});\n\nmodule.exports = Route;\n","var React = require('react');\nvar RouteHandlerMixin = require('../mixins/RouteHandler');\n\n/**\n * A <RouteHandler> component renders the active child route handler\n * when routes are nested.\n */\nvar RouteHandler = React.createClass({\n\n  displayName: 'RouteHandler',\n\n  mixins: [RouteHandlerMixin],\n\n  getDefaultProps: function () {\n    return {\n      ref: '__routeHandler__'\n    };\n  },\n\n  render: function () {\n    return this.getRouteHandler();\n  }\n\n});\n\nmodule.exports = RouteHandler;\n","exports.DefaultRoute = require('./components/DefaultRoute');\nexports.Link = require('./components/Link');\nexports.NotFoundRoute = require('./components/NotFoundRoute');\nexports.Redirect = require('./components/Redirect');\nexports.Route = require('./components/Route');\nexports.RouteHandler = require('./components/RouteHandler');\n\nexports.HashLocation = require('./locations/HashLocation');\nexports.HistoryLocation = require('./locations/HistoryLocation');\nexports.RefreshLocation = require('./locations/RefreshLocation');\n\nexports.ImitateBrowserBehavior = require('./behaviors/ImitateBrowserBehavior');\nexports.ScrollToTopBehavior = require('./behaviors/ScrollToTopBehavior');\n\nexports.Navigation = require('./mixins/Navigation');\nexports.State = require('./mixins/State');\n\nexports.create = require('./utils/createRouter');\nexports.run = require('./utils/runRouter');\n\nexports.History = require('./utils/History');\n","var LocationActions = require('../actions/LocationActions');\nvar History = require('../utils/History');\nvar Path = require('../utils/Path');\n\n/**\n * Returns the current URL path from the `hash` portion of the URL, including\n * query string.\n */\nfunction getHashPath() {\n  return Path.decode(\n    // We can't use window.location.hash here because it's not\n    // consistent across browsers - Firefox will pre-decode it!\n    window.location.href.split('#')[1] || ''\n  );\n}\n\nvar _actionType;\n\nfunction ensureSlash() {\n  var path = getHashPath();\n\n  if (path.charAt(0) === '/')\n    return true;\n\n  HashLocation.replace('/' + path);\n\n  return false;\n}\n\nvar _changeListeners = [];\n\nfunction notifyChange(type) {\n  if (type === LocationActions.PUSH)\n    History.length += 1;\n\n  var change = {\n    path: getHashPath(),\n    type: type\n  };\n\n  _changeListeners.forEach(function (listener) {\n    listener(change);\n  });\n}\n\nvar _isListening = false;\n\nfunction onHashChange() {\n  if (ensureSlash()) {\n    // If we don't have an _actionType then all we know is the hash\n    // changed. It was probably caused by the user clicking the Back\n    // button, but may have also been the Forward button or manual\n    // manipulation. So just guess 'pop'.\n    notifyChange(_actionType || LocationActions.POP);\n    _actionType = null;\n  }\n}\n\n/**\n * A Location that uses `window.location.hash`.\n */\nvar HashLocation = {\n\n  addChangeListener: function (listener) {\n    _changeListeners.push(listener);\n\n    // Do this BEFORE listening for hashchange.\n    ensureSlash();\n\n    if (_isListening)\n      return;\n\n    if (window.addEventListener) {\n      window.addEventListener('hashchange', onHashChange, false);\n    } else {\n      window.attachEvent('onhashchange', onHashChange);\n    }\n\n    _isListening = true;\n  },\n\n  removeChangeListener: function(listener) {\n    for (var i = 0, l = _changeListeners.length; i < l; i ++) {\n      if (_changeListeners[i] === listener) {\n        _changeListeners.splice(i, 1);\n        break;\n      }\n    }\n\n    if (window.removeEventListener) {\n      window.removeEventListener('hashchange', onHashChange, false);\n    } else {\n      window.removeEvent('onhashchange', onHashChange);\n    }\n\n    if (_changeListeners.length === 0)\n      _isListening = false;\n  },\n\n\n\n  push: function (path) {\n    _actionType = LocationActions.PUSH;\n    window.location.hash = Path.encode(path);\n  },\n\n  replace: function (path) {\n    _actionType = LocationActions.REPLACE;\n    window.location.replace(window.location.pathname + '#' + Path.encode(path));\n  },\n\n  pop: function () {\n    _actionType = LocationActions.POP;\n    History.back();\n  },\n\n  getCurrentPath: getHashPath,\n\n  toString: function () {\n    return '<HashLocation>';\n  }\n\n};\n\nmodule.exports = HashLocation;\n","var LocationActions = require('../actions/LocationActions');\nvar History = require('../utils/History');\nvar Path = require('../utils/Path');\n\n/**\n * Returns the current URL path from `window.location`, including query string.\n */\nfunction getWindowPath() {\n  return Path.decode(\n    window.location.pathname + window.location.search\n  );\n}\n\nvar _changeListeners = [];\n\nfunction notifyChange(type) {\n  var change = {\n    path: getWindowPath(),\n    type: type\n  };\n\n  _changeListeners.forEach(function (listener) {\n    listener(change);\n  });\n}\n\nvar _isListening = false;\n\nfunction onPopState() {\n  notifyChange(LocationActions.POP);\n}\n\n/**\n * A Location that uses HTML5 history.\n */\nvar HistoryLocation = {\n\n  addChangeListener: function (listener) {\n    _changeListeners.push(listener);\n\n    if (_isListening)\n      return;\n\n    if (window.addEventListener) {\n      window.addEventListener('popstate', onPopState, false);\n    } else {\n      window.attachEvent('popstate', onPopState);\n    }\n\n    _isListening = true;\n  },\n\n  removeChangeListener: function(listener) {\n    for (var i = 0, l = _changeListeners.length; i < l; i ++) {\n      if (_changeListeners[i] === listener) {\n        _changeListeners.splice(i, 1);\n        break;\n      }\n    }\n\n    if (window.addEventListener) {\n      window.removeEventListener('popstate', onPopState);\n    } else {\n      window.removeEvent('popstate', onPopState);\n    }\n\n    if (_changeListeners.length === 0)\n      _isListening = false;\n  },\n\n\n\n  push: function (path) {\n    window.history.pushState({ path: path }, '', Path.encode(path));\n    History.length += 1;\n    notifyChange(LocationActions.PUSH);\n  },\n\n  replace: function (path) {\n    window.history.replaceState({ path: path }, '', Path.encode(path));\n    notifyChange(LocationActions.REPLACE);\n  },\n\n  pop: History.back,\n\n  getCurrentPath: getWindowPath,\n\n  toString: function () {\n    return '<HistoryLocation>';\n  }\n\n};\n\nmodule.exports = HistoryLocation;\n","var HistoryLocation = require('./HistoryLocation');\nvar History = require('../utils/History');\nvar Path = require('../utils/Path');\n\n/**\n * A Location that uses full page refreshes. This is used as\n * the fallback for HistoryLocation in browsers that do not\n * support the HTML5 history API.\n */\nvar RefreshLocation = {\n\n  push: function (path) {\n    window.location = Path.encode(path);\n  },\n\n  replace: function (path) {\n    window.location.replace(Path.encode(path));\n  },\n\n  pop: History.back,\n\n  getCurrentPath: HistoryLocation.getCurrentPath,\n\n  toString: function () {\n    return '<RefreshLocation>';\n  }\n\n};\n\nmodule.exports = RefreshLocation;\n","var invariant = require('react/lib/invariant');\n\nvar FakeNode = {\n\n  render: function () {\n    invariant(\n      false,\n      '%s elements should not be rendered',\n      this.constructor.displayName\n    );\n  }\n\n};\n\nmodule.exports = FakeNode;\n","var React = require('react');\n\n/**\n * A mixin for components that modify the URL.\n *\n * Example:\n *\n *   var MyLink = React.createClass({\n *     mixins: [ Router.Navigation ],\n *     handleClick: function (event) {\n *       event.preventDefault();\n *       this.transitionTo('aRoute', { the: 'params' }, { the: 'query' });\n *     },\n *     render: function () {\n *       return (\n *         <a onClick={this.handleClick}>Click me!</a>\n *       );\n *     }\n *   });\n */\nvar Navigation = {\n\n  contextTypes: {\n    makePath: React.PropTypes.func.isRequired,\n    makeHref: React.PropTypes.func.isRequired,\n    transitionTo: React.PropTypes.func.isRequired,\n    replaceWith: React.PropTypes.func.isRequired,\n    goBack: React.PropTypes.func.isRequired\n  },\n\n  /**\n   * Returns an absolute URL path created from the given route\n   * name, URL parameters, and query values.\n   */\n  makePath: function (to, params, query) {\n    return this.context.makePath(to, params, query);\n  },\n\n  /**\n   * Returns a string that may safely be used as the href of a\n   * link to the route with the given name.\n   */\n  makeHref: function (to, params, query) {\n    return this.context.makeHref(to, params, query);\n  },\n\n  /**\n   * Transitions to the URL specified in the arguments by pushing\n   * a new URL onto the history stack.\n   */\n  transitionTo: function (to, params, query) {\n    this.context.transitionTo(to, params, query);\n  },\n\n  /**\n   * Transitions to the URL specified in the arguments by replacing\n   * the current URL in the history stack.\n   */\n  replaceWith: function (to, params, query) {\n    this.context.replaceWith(to, params, query);\n  },\n\n  /**\n   * Transitions to the previous URL.\n   */\n  goBack: function () {\n    this.context.goBack();\n  }\n\n};\n\nmodule.exports = Navigation;\n","var React = require('react');\n\n/**\n * Provides the router with context for Router.Navigation.\n */\nvar NavigationContext = {\n\n  childContextTypes: {\n    makePath: React.PropTypes.func.isRequired,\n    makeHref: React.PropTypes.func.isRequired,\n    transitionTo: React.PropTypes.func.isRequired,\n    replaceWith: React.PropTypes.func.isRequired,\n    goBack: React.PropTypes.func.isRequired\n  },\n\n  getChildContext: function () {\n    return {\n      makePath: this.constructor.makePath,\n      makeHref: this.constructor.makeHref,\n      transitionTo: this.constructor.transitionTo,\n      replaceWith: this.constructor.replaceWith,\n      goBack: this.constructor.goBack\n    };\n  }\n\n};\n\nmodule.exports = NavigationContext;\n","var React = require('react');\n\nmodule.exports = {\n  contextTypes: {\n    getRouteAtDepth: React.PropTypes.func.isRequired,\n    getRouteComponents: React.PropTypes.func.isRequired,\n    routeHandlers: React.PropTypes.array.isRequired\n  },\n\n  childContextTypes: {\n    routeHandlers: React.PropTypes.array.isRequired\n  },\n\n  getChildContext: function () {\n    return {\n      routeHandlers: this.context.routeHandlers.concat([ this ])\n    };\n  },\n\n  getRouteDepth: function () {\n    return this.context.routeHandlers.length - 1;\n  },\n\n  componentDidMount: function () {\n    this._updateRouteComponent();\n  },\n\n  componentDidUpdate: function () {\n    this._updateRouteComponent();\n  },\n\n  _updateRouteComponent: function () {\n    var depth = this.getRouteDepth();\n    var components = this.context.getRouteComponents();\n    components[depth] = this.refs[this.props.ref || '__routeHandler__'];\n  },\n\n  getRouteHandler: function (props) {\n    var route = this.context.getRouteAtDepth(this.getRouteDepth());\n    return route ? React.createElement(route.handler, props || this.props) : null;\n  }\n};","var invariant = require('react/lib/invariant');\nvar canUseDOM = require('react/lib/ExecutionEnvironment').canUseDOM;\nvar getWindowScrollPosition = require('../utils/getWindowScrollPosition');\n\nfunction shouldUpdateScroll(state, prevState) {\n  if (!prevState)\n    return true;\n\n  // Don't update scroll position when only the query has changed.\n  if (state.pathname === prevState.pathname)\n    return false;\n\n  var routes = state.routes;\n  var prevRoutes = prevState.routes;\n\n  var sharedAncestorRoutes = routes.filter(function (route) {\n    return prevRoutes.indexOf(route) !== -1;\n  });\n\n  return !sharedAncestorRoutes.some(function (route) {\n    return route.ignoreScrollBehavior;\n  });\n}\n\n/**\n * Provides the router with the ability to manage window scroll position\n * according to its scroll behavior.\n */\nvar Scrolling = {\n\n  statics: {\n    /**\n     * Records curent scroll position as the last known position for the given URL path.\n     */\n    recordScrollPosition: function (path) {\n      if (!this.scrollHistory)\n        this.scrollHistory = {};\n\n      this.scrollHistory[path] = getWindowScrollPosition();\n    },\n\n    /**\n     * Returns the last known scroll position for the given URL path.\n     */\n    getScrollPosition: function (path) {\n      if (!this.scrollHistory)\n        this.scrollHistory = {};\n\n      return this.scrollHistory[path] || null;\n    }\n  },\n\n  componentWillMount: function () {\n    invariant(\n      this.getScrollBehavior() == null || canUseDOM,\n      'Cannot use scroll behavior without a DOM'\n    );\n  },\n\n  componentDidMount: function () {\n    this._updateScroll();\n  },\n\n  componentDidUpdate: function (prevProps, prevState) {\n    this._updateScroll(prevState);\n  },\n\n  _updateScroll: function (prevState) {\n    if (!shouldUpdateScroll(this.state, prevState))\n      return;\n\n    var scrollBehavior = this.getScrollBehavior();\n\n    if (scrollBehavior)\n      scrollBehavior.updateScrollPosition(\n        this.constructor.getScrollPosition(this.state.path),\n        this.state.action\n      );\n  }\n\n};\n\nmodule.exports = Scrolling;\n","var React = require('react');\n\n/**\n * A mixin for components that need to know the path, routes, URL\n * params and query that are currently active.\n *\n * Example:\n *\n *   var AboutLink = React.createClass({\n *     mixins: [ Router.State ],\n *     render: function () {\n *       var className = this.props.className;\n *   \n *       if (this.isActive('about'))\n *         className += ' is-active';\n *   \n *       return React.DOM.a({ className: className }, this.props.children);\n *     }\n *   });\n */\nvar State = {\n\n  contextTypes: {\n    getCurrentPath: React.PropTypes.func.isRequired,\n    getCurrentRoutes: React.PropTypes.func.isRequired,\n    getCurrentPathname: React.PropTypes.func.isRequired,\n    getCurrentParams: React.PropTypes.func.isRequired,\n    getCurrentQuery: React.PropTypes.func.isRequired,\n    isActive: React.PropTypes.func.isRequired\n  },\n\n  /**\n   * Returns the current URL path.\n   */\n  getPath: function () {\n    return this.context.getCurrentPath();\n  },\n\n  /**\n   * Returns an array of the routes that are currently active.\n   */\n  getRoutes: function () {\n    return this.context.getCurrentRoutes();\n  },\n\n  /**\n   * Returns the current URL path without the query string.\n   */\n  getPathname: function () {\n    return this.context.getCurrentPathname();\n  },\n\n  /**\n   * Returns an object of the URL params that are currently active.\n   */\n  getParams: function () {\n    return this.context.getCurrentParams();\n  },\n\n  /**\n   * Returns an object of the query params that are currently active.\n   */\n  getQuery: function () {\n    return this.context.getCurrentQuery();\n  },\n\n  /**\n   * A helper method to determine if a given route, params, and query\n   * are active.\n   */\n  isActive: function (to, params, query) {\n    return this.context.isActive(to, params, query);\n  }\n\n};\n\nmodule.exports = State;\n","var React = require('react');\nvar assign = require('react/lib/Object.assign');\nvar Path = require('../utils/Path');\n\nfunction routeIsActive(activeRoutes, routeName) {\n  return activeRoutes.some(function (route) {\n    return route.name === routeName;\n  });\n}\n\nfunction paramsAreActive(activeParams, params) {\n  for (var property in params)\n    if (String(activeParams[property]) !== String(params[property]))\n      return false;\n\n  return true;\n}\n\nfunction queryIsActive(activeQuery, query) {\n  for (var property in query)\n    if (String(activeQuery[property]) !== String(query[property]))\n      return false;\n\n  return true;\n}\n\n/**\n * Provides the router with context for Router.State.\n */\nvar StateContext = {\n\n  /**\n   * Returns the current URL path + query string.\n   */\n  getCurrentPath: function () {\n    return this.state.path;\n  },\n\n  /**\n   * Returns a read-only array of the currently active routes.\n   */\n  getCurrentRoutes: function () {\n    return this.state.routes.slice(0);\n  },\n\n  /**\n   * Returns the current URL path without the query string.\n   */\n  getCurrentPathname: function () {\n    return this.state.pathname;\n  },\n\n  /**\n   * Returns a read-only object of the currently active URL parameters.\n   */\n  getCurrentParams: function () {\n    return assign({}, this.state.params);\n  },\n\n  /**\n   * Returns a read-only object of the currently active query parameters.\n   */\n  getCurrentQuery: function () {\n    return assign({}, this.state.query);\n  },\n\n  /**\n   * Returns true if the given route, params, and query are active.\n   */\n  isActive: function (to, params, query) {\n    if (Path.isAbsolute(to))\n      return to === this.state.path;\n\n    return routeIsActive(this.state.routes, to) &&\n      paramsAreActive(this.state.params, params) &&\n      (query == null || queryIsActive(this.state.query, query));\n  },\n\n  childContextTypes: {\n    getCurrentPath: React.PropTypes.func.isRequired,\n    getCurrentRoutes: React.PropTypes.func.isRequired,\n    getCurrentPathname: React.PropTypes.func.isRequired,\n    getCurrentParams: React.PropTypes.func.isRequired,\n    getCurrentQuery: React.PropTypes.func.isRequired,\n    isActive: React.PropTypes.func.isRequired\n  },\n\n  getChildContext: function () {\n    return {\n      getCurrentPath: this.getCurrentPath,\n      getCurrentRoutes: this.getCurrentRoutes,\n      getCurrentPathname: this.getCurrentPathname,\n      getCurrentParams: this.getCurrentParams,\n      getCurrentQuery: this.getCurrentQuery,\n      isActive: this.isActive\n    };\n  }\n\n};\n\nmodule.exports = StateContext;\n","/**\n * Represents a cancellation caused by navigating away\n * before the previous transition has fully resolved.\n */\nfunction Cancellation() { }\n\nmodule.exports = Cancellation;\n","var invariant = require('react/lib/invariant');\nvar canUseDOM = require('react/lib/ExecutionEnvironment').canUseDOM;\n\nvar History = {\n\n  /**\n   * Sends the browser back one entry in the history.\n   */\n  back: function () {\n    invariant(\n      canUseDOM,\n      'Cannot use History.back without a DOM'\n    );\n\n    // Do this first so that History.length will\n    // be accurate in location change listeners.\n    History.length -= 1;\n\n    window.history.back();\n  },\n\n  /**\n   * The current number of entries in the history.\n   */\n  length: 1\n\n};\n\nmodule.exports = History;\n","var invariant = require('react/lib/invariant');\nvar merge = require('qs/lib/utils').merge;\nvar qs = require('qs');\n\nvar paramCompileMatcher = /:([a-zA-Z_$][a-zA-Z0-9_$]*)|[*.()\\[\\]\\\\+|{}^$]/g;\nvar paramInjectMatcher = /:([a-zA-Z_$][a-zA-Z0-9_$?]*[?]?)|[*]/g;\nvar paramInjectTrailingSlashMatcher = /\\/\\/\\?|\\/\\?/g;\nvar queryMatcher = /\\?(.+)/;\n\nvar _compiledPatterns = {};\n\nfunction compilePattern(pattern) {\n  if (!(pattern in _compiledPatterns)) {\n    var paramNames = [];\n    var source = pattern.replace(paramCompileMatcher, function (match, paramName) {\n      if (paramName) {\n        paramNames.push(paramName);\n        return '([^/?#]+)';\n      } else if (match === '*') {\n        paramNames.push('splat');\n        return '(.*?)';\n      } else {\n        return '\\\\' + match;\n      }\n    });\n\n    _compiledPatterns[pattern] = {\n      matcher: new RegExp('^' + source + '$', 'i'),\n      paramNames: paramNames\n    };\n  }\n\n  return _compiledPatterns[pattern];\n}\n\nvar Path = {\n\n  /**\n   * Safely decodes special characters in the given URL path.\n   */\n  decode: function (path) {\n    return decodeURI(path.replace(/\\+/g, ' '));\n  },\n\n  /**\n   * Safely encodes special characters in the given URL path.\n   */\n  encode: function (path) {\n    return encodeURI(path).replace(/%20/g, '+');\n  },\n\n  /**\n   * Returns an array of the names of all parameters in the given pattern.\n   */\n  extractParamNames: function (pattern) {\n    return compilePattern(pattern).paramNames;\n  },\n\n  /**\n   * Extracts the portions of the given URL path that match the given pattern\n   * and returns an object of param name => value pairs. Returns null if the\n   * pattern does not match the given path.\n   */\n  extractParams: function (pattern, path) {\n    var object = compilePattern(pattern);\n    var match = path.match(object.matcher);\n\n    if (!match)\n      return null;\n\n    var params = {};\n\n    object.paramNames.forEach(function (paramName, index) {\n      params[paramName] = match[index + 1];\n    });\n\n    return params;\n  },\n\n  /**\n   * Returns a version of the given route path with params interpolated. Throws\n   * if there is a dynamic segment of the route path for which there is no param.\n   */\n  injectParams: function (pattern, params) {\n    params = params || {};\n\n    var splatIndex = 0;\n\n    return pattern.replace(paramInjectMatcher, function (match, paramName) {\n      paramName = paramName || 'splat';\n\n      // If param is optional don't check for existence\n      if (paramName.slice(-1) !== '?') {\n        invariant(\n          params[paramName] != null,\n          'Missing \"' + paramName + '\" parameter for path \"' + pattern + '\"'\n        );\n      } else {\n        paramName = paramName.slice(0, -1);\n\n        if (params[paramName] == null)\n          return '';\n      }\n\n      var segment;\n      if (paramName === 'splat' && Array.isArray(params[paramName])) {\n        segment = params[paramName][splatIndex++];\n\n        invariant(\n          segment != null,\n          'Missing splat # ' + splatIndex + ' for path \"' + pattern + '\"'\n        );\n      } else {\n        segment = params[paramName];\n      }\n\n      return segment;\n    }).replace(paramInjectTrailingSlashMatcher, '/');\n  },\n\n  /**\n   * Returns an object that is the result of parsing any query string contained\n   * in the given path, null if the path contains no query string.\n   */\n  extractQuery: function (path) {\n    var match = path.match(queryMatcher);\n    return match && qs.parse(match[1]);\n  },\n\n  /**\n   * Returns a version of the given path without the query string.\n   */\n  withoutQuery: function (path) {\n    return path.replace(queryMatcher, '');\n  },\n\n  /**\n   * Returns a version of the given path with the parameters in the given\n   * query merged into the query string.\n   */\n  withQuery: function (path, query) {\n    var existingQuery = Path.extractQuery(path);\n\n    if (existingQuery)\n      query = query ? merge(existingQuery, query) : existingQuery;\n\n    var queryString = query && qs.stringify(query);\n\n    if (queryString)\n      return Path.withoutQuery(path) + '?' + queryString;\n\n    return path;\n  },\n\n  /**\n   * Returns true if the given path is absolute.\n   */\n  isAbsolute: function (path) {\n    return path.charAt(0) === '/';\n  },\n\n  /**\n   * Returns a normalized version of the given path.\n   */\n  normalize: function (path, parentRoute) {\n    return path.replace(/^\\/*/, '/');\n  },\n\n  /**\n   * Joins two URL paths together.\n   */\n  join: function (a, b) {\n    return a.replace(/\\/*$/, '/') + b;\n  }\n\n};\n\nmodule.exports = Path;\n","var Promise = require('when/lib/Promise');\n\n// TODO: Use process.env.NODE_ENV check + envify to enable\n// when's promise monitor here when in dev.\n\nmodule.exports = Promise;\n","var PropTypes = {\n\n  /**\n   * Requires that the value of a prop be falsy.\n   */\n  falsy: function (props, propName, componentName) {\n    if (props[propName])\n      return new Error('<' + componentName + '> may not have a \"' + propName + '\" prop');\n  }\n\n};\n\nmodule.exports = PropTypes;\n","/**\n * Encapsulates a redirect to the given route.\n */\nfunction Redirect(to, params, query) {\n  this.to = to;\n  this.params = params;\n  this.query = query;\n}\n\nmodule.exports = Redirect;\n","var assign = require('react/lib/Object.assign');\nvar reversedArray = require('./reversedArray');\nvar Redirect = require('./Redirect');\nvar Promise = require('./Promise');\n\n/**\n * Runs all hook functions serially and calls callback(error) when finished.\n * A hook may return a promise if it needs to execute asynchronously.\n */\nfunction runHooks(hooks, callback) {\n  var promise;\n  try {\n    promise = hooks.reduce(function (promise, hook) {\n      // The first hook to use transition.wait makes the rest\n      // of the transition async from that point forward.\n      return promise ? promise.then(hook) : hook();\n    }, null);\n  } catch (error) {\n    return callback(error); // Sync error.\n  }\n\n  if (promise) {\n    // Use setTimeout to break the promise chain.\n    promise.then(function () {\n      setTimeout(callback);\n    }, function (error) {\n      setTimeout(function () {\n        callback(error);\n      });\n    });\n  } else {\n    callback();\n  }\n}\n\n/**\n * Calls the willTransitionFrom hook of all handlers in the given matches\n * serially in reverse with the transition object and the current instance of\n * the route's handler, so that the deepest nested handlers are called first.\n * Calls callback(error) when finished.\n */\nfunction runTransitionFromHooks(transition, routes, components, callback) {\n  components = reversedArray(components);\n\n  var hooks = reversedArray(routes).map(function (route, index) {\n    return function () {\n      var handler = route.handler;\n\n      if (!transition.isAborted && handler.willTransitionFrom)\n        return handler.willTransitionFrom(transition, components[index]);\n\n      var promise = transition._promise;\n      transition._promise = null;\n\n      return promise;\n    };\n  });\n\n  runHooks(hooks, callback);\n}\n\n/**\n * Calls the willTransitionTo hook of all handlers in the given matches\n * serially with the transition object and any params that apply to that\n * handler. Calls callback(error) when finished.\n */\nfunction runTransitionToHooks(transition, routes, params, query, callback) {\n  var hooks = routes.map(function (route) {\n    return function () {\n      var handler = route.handler;\n\n      if (!transition.isAborted && handler.willTransitionTo)\n        handler.willTransitionTo(transition, params, query);\n\n      var promise = transition._promise;\n      transition._promise = null;\n\n      return promise;\n    };\n  });\n\n  runHooks(hooks, callback);\n}\n\n/**\n * Encapsulates a transition to a given path.\n *\n * The willTransitionTo and willTransitionFrom handlers receive\n * an instance of this class as their first argument.\n */\nfunction Transition(path, retry) {\n  this.path = path;\n  this.abortReason = null;\n  this.isAborted = false;\n  this.retry = retry.bind(this);\n  this._promise = null;\n}\n\nassign(Transition.prototype, {\n\n  abort: function (reason) {\n    if (this.isAborted) {\n      // First abort wins.\n      return;\n    }\n\n    this.abortReason = reason;\n    this.isAborted = true;\n  },\n\n  redirect: function (to, params, query) {\n    this.abort(new Redirect(to, params, query));\n  },\n\n  wait: function (value) {\n    this._promise = Promise.resolve(value);\n  },\n\n  from: function (routes, components, callback) {\n    return runTransitionFromHooks(this, routes, components, callback);\n  },\n\n  to: function (routes, params, query, callback) {\n    return runTransitionToHooks(this, routes, params, query, callback);\n  }\n\n});\n\nmodule.exports = Transition;\n","/* jshint -W058 */\nvar React = require('react');\nvar warning = require('react/lib/warning');\nvar invariant = require('react/lib/invariant');\nvar canUseDOM = require('react/lib/ExecutionEnvironment').canUseDOM;\nvar ImitateBrowserBehavior = require('../behaviors/ImitateBrowserBehavior');\nvar RouteHandler = require('../components/RouteHandler');\nvar LocationActions = require('../actions/LocationActions');\nvar HashLocation = require('../locations/HashLocation');\nvar HistoryLocation = require('../locations/HistoryLocation');\nvar RefreshLocation = require('../locations/RefreshLocation');\nvar NavigationContext = require('../mixins/NavigationContext');\nvar StateContext = require('../mixins/StateContext');\nvar Scrolling = require('../mixins/Scrolling');\nvar createRoutesFromChildren = require('./createRoutesFromChildren');\nvar supportsHistory = require('./supportsHistory');\nvar Transition = require('./Transition');\nvar PropTypes = require('./PropTypes');\nvar Redirect = require('./Redirect');\nvar History = require('./History');\nvar Cancellation = require('./Cancellation');\nvar Path = require('./Path');\n\n/**\n * The default location for new routers.\n */\nvar DEFAULT_LOCATION = canUseDOM ? HashLocation : '/';\n\n/**\n * The default scroll behavior for new routers.\n */\nvar DEFAULT_SCROLL_BEHAVIOR = canUseDOM ? ImitateBrowserBehavior : null;\n\n/**\n * The default error handler for new routers.\n */\nfunction defaultErrorHandler(error) {\n  // Throw so we don't silently swallow async errors.\n  throw error; // This error probably originated in a transition hook.\n}\n\n/**\n * The default aborted transition handler for new routers.\n */\nfunction defaultAbortHandler(abortReason, location) {\n  if (typeof location === 'string')\n    throw new Error('Unhandled aborted transition! Reason: ' + abortReason);\n\n  if (abortReason instanceof Cancellation) {\n    return;\n  } else if (abortReason instanceof Redirect) {\n    location.replace(this.makePath(abortReason.to, abortReason.params, abortReason.query));\n  } else {\n    location.pop();\n  }\n}\n\nfunction findMatch(pathname, routes, defaultRoute, notFoundRoute) {\n  var match, route, params;\n\n  for (var i = 0, len = routes.length; i < len; ++i) {\n    route = routes[i];\n\n    // Check the subtree first to find the most deeply-nested match.\n    match = findMatch(pathname, route.childRoutes, route.defaultRoute, route.notFoundRoute);\n\n    if (match != null) {\n      match.routes.unshift(route);\n      return match;\n    }\n\n    // No routes in the subtree matched, so check this route.\n    params = Path.extractParams(route.path, pathname);\n\n    if (params)\n      return createMatch(route, params);\n  }\n\n  // No routes matched, so try the default route if there is one.\n  if (defaultRoute && (params = Path.extractParams(defaultRoute.path, pathname)))\n    return createMatch(defaultRoute, params);\n\n  // Last attempt: does the \"not found\" route match?\n  if (notFoundRoute && (params = Path.extractParams(notFoundRoute.path, pathname)))\n    return createMatch(notFoundRoute, params);\n\n  return match;\n}\n\nfunction createMatch(route, params) {\n  return { routes: [ route ], params: params };\n}\n\nfunction hasProperties(object, properties) {\n  for (var propertyName in properties)\n    if (properties.hasOwnProperty(propertyName) && object[propertyName] !== properties[propertyName])\n      return false;\n\n  return true;\n}\n\nfunction hasMatch(routes, route, prevParams, nextParams, prevQuery, nextQuery) {\n  return routes.some(function (r) {\n    if (r !== route)\n      return false;\n\n    var paramNames = route.paramNames;\n    var paramName;\n\n    // Ensure that all params the route cares about did not change.\n    for (var i = 0, len = paramNames.length; i < len; ++i) {\n      paramName = paramNames[i];\n\n      if (nextParams[paramName] !== prevParams[paramName])\n        return false;\n    }\n\n    // Ensure the query hasn't changed.\n    return hasProperties(prevQuery, nextQuery) && hasProperties(nextQuery, prevQuery);\n  });\n}\n\n/**\n * Creates and returns a new router using the given options. A router\n * is a ReactComponent class that knows how to react to changes in the\n * URL and keep the contents of the page in sync.\n *\n * Options may be any of the following:\n *\n * - routes           (required) The route config\n * - location         The location to use. Defaults to HashLocation when\n *                    the DOM is available, \"/\" otherwise\n * - scrollBehavior   The scroll behavior to use. Defaults to ImitateBrowserBehavior\n *                    when the DOM is available, null otherwise\n * - onError          A function that is used to handle errors\n * - onAbort          A function that is used to handle aborted transitions\n *\n * When rendering in a server-side environment, the location should simply\n * be the URL path that was used in the request, including the query string.\n */\nfunction createRouter(options) {\n  options = options || {};\n\n  if (typeof options === 'function') {\n    options = { routes: options }; // Router.create(<Route>)\n  } else if (Array.isArray(options)) {\n    options = { routes: options }; // Router.create([ <Route>, <Route> ])\n  }\n\n  var routes = [];\n  var namedRoutes = {};\n  var components = [];\n  var location = options.location || DEFAULT_LOCATION;\n  var scrollBehavior = options.scrollBehavior || DEFAULT_SCROLL_BEHAVIOR;\n  var onError = options.onError || defaultErrorHandler;\n  var onAbort = options.onAbort || defaultAbortHandler;\n  var state = {};\n  var nextState = {};\n  var pendingTransition = null;\n\n  function updateState() {\n    state = nextState;\n    nextState = {};\n  }\n\n  if (typeof location === 'string') {\n    warning(\n      !canUseDOM || process.env.NODE_ENV === 'test',\n      'You should not use a static location in a DOM environment because ' +\n      'the router will not be kept in sync with the current URL'\n    );\n  } else {\n    invariant(\n      canUseDOM,\n      'You cannot use %s without a DOM',\n      location\n    );\n  }\n\n  // Automatically fall back to full page refreshes in\n  // browsers that don't support the HTML history API.\n  if (location === HistoryLocation && !supportsHistory())\n    location = RefreshLocation;\n\n  var router = React.createClass({\n\n    displayName: 'Router',\n\n    mixins: [ NavigationContext, StateContext, Scrolling ],\n\n    statics: {\n\n      defaultRoute: null,\n      notFoundRoute: null,\n\n      /**\n       * Adds routes to this router from the given children object (see ReactChildren).\n       */\n      addRoutes: function (children) {\n        routes.push.apply(routes, createRoutesFromChildren(children, this, namedRoutes));\n      },\n\n      /**\n       * Returns an absolute URL path created from the given route\n       * name, URL parameters, and query.\n       */\n      makePath: function (to, params, query) {\n        var path;\n        if (Path.isAbsolute(to)) {\n          path = Path.normalize(to);\n        } else {\n          var route = namedRoutes[to];\n\n          invariant(\n            route,\n            'Unable to find <Route name=\"%s\">',\n            to\n          );\n\n          path = route.path;\n        }\n\n        return Path.withQuery(Path.injectParams(path, params), query);\n      },\n\n      /**\n       * Returns a string that may safely be used as the href of a link\n       * to the route with the given name, URL parameters, and query.\n       */\n      makeHref: function (to, params, query) {\n        var path = this.makePath(to, params, query);\n        return (location === HashLocation) ? '#' + path : path;\n      },\n\n      /**\n       * Transitions to the URL specified in the arguments by pushing\n       * a new URL onto the history stack.\n       */\n      transitionTo: function (to, params, query) {\n        invariant(\n          typeof location !== 'string',\n          'You cannot use transitionTo with a static location'\n        );\n\n        var path = this.makePath(to, params, query);\n\n        if (pendingTransition) {\n          // Replace so pending location does not stay in history.\n          location.replace(path);\n        } else {\n          location.push(path);\n        }\n      },\n\n      /**\n       * Transitions to the URL specified in the arguments by replacing\n       * the current URL in the history stack.\n       */\n      replaceWith: function (to, params, query) {\n        invariant(\n          typeof location !== 'string',\n          'You cannot use replaceWith with a static location'\n        );\n\n        location.replace(this.makePath(to, params, query));\n      },\n\n      /**\n       * Transitions to the previous URL if one is available. Returns true if the\n       * router was able to go back, false otherwise.\n       *\n       * Note: The router only tracks history entries in your application, not the\n       * current browser session, so you can safely call this function without guarding\n       * against sending the user back to some other site. However, when using\n       * RefreshLocation (which is the fallback for HistoryLocation in browsers that\n       * don't support HTML5 history) this method will *always* send the client back\n       * because we cannot reliably track history length.\n       */\n      goBack: function () {\n        invariant(\n          typeof location !== 'string',\n          'You cannot use goBack with a static location'\n        );\n\n        if (History.length > 1 || location === RefreshLocation) {\n          location.pop();\n          return true;\n        }\n\n        warning(false, 'goBack() was ignored because there is no router history');\n\n        return false;\n      },\n\n      /**\n       * Performs a match of the given pathname against this router and returns an object\n       * with the { routes, params } that match. Returns null if no match can be made.\n       */\n      match: function (pathname) {\n        return findMatch(pathname, routes, this.defaultRoute, this.notFoundRoute) || null;\n      },\n\n      /**\n       * Performs a transition to the given path and calls callback(error, abortReason)\n       * when the transition is finished. If both arguments are null the router's state\n       * was updated. Otherwise the transition did not complete.\n       *\n       * In a transition, a router first determines which routes are involved by beginning\n       * with the current route, up the route tree to the first parent route that is shared\n       * with the destination route, and back down the tree to the destination route. The\n       * willTransitionFrom hook is invoked on all route handlers we're transitioning away\n       * from, in reverse nesting order. Likewise, the willTransitionTo hook is invoked on\n       * all route handlers we're transitioning to.\n       *\n       * Both willTransitionFrom and willTransitionTo hooks may either abort or redirect the\n       * transition. To resolve asynchronously, they may use transition.wait(promise). If no\n       * hooks wait, the transition is fully synchronous.\n       */\n      dispatch: function (path, action, callback) {\n        if (pendingTransition) {\n          pendingTransition.abort(new Cancellation);\n          pendingTransition = null;\n        }\n\n        var prevPath = state.path;\n        if (prevPath === path)\n          return; // Nothing to do!\n\n        // Record the scroll position as early as possible to\n        // get it before browsers try update it automatically.\n        if (prevPath && action !== LocationActions.REPLACE)\n          this.recordScrollPosition(prevPath);\n\n        var pathname = Path.withoutQuery(path);\n        var match = this.match(pathname);\n\n        warning(\n          match != null,\n          'No route matches path \"%s\". Make sure you have <Route path=\"%s\"> somewhere in your routes',\n          path, path\n        );\n\n        if (match == null)\n          match = {};\n\n        var prevRoutes = state.routes || [];\n        var prevParams = state.params || {};\n        var prevQuery = state.query || {};\n\n        var nextRoutes = match.routes || [];\n        var nextParams = match.params || {};\n        var nextQuery = Path.extractQuery(path) || {};\n\n        var fromRoutes, toRoutes;\n        if (prevRoutes.length) {\n          fromRoutes = prevRoutes.filter(function (route) {\n            return !hasMatch(nextRoutes, route, prevParams, nextParams, prevQuery, nextQuery);\n          });\n\n          toRoutes = nextRoutes.filter(function (route) {\n            return !hasMatch(prevRoutes, route, prevParams, nextParams, prevQuery, nextQuery);\n          });\n        } else {\n          fromRoutes = [];\n          toRoutes = nextRoutes;\n        }\n\n        var transition = new Transition(path, this.replaceWith.bind(this, path));\n        pendingTransition = transition;\n\n        transition.from(fromRoutes, components, function (error) {\n          if (error || transition.isAborted)\n            return callback.call(router, error, transition);\n\n          transition.to(toRoutes, nextParams, nextQuery, function (error) {\n            if (error || transition.isAborted)\n              return callback.call(router, error, transition);\n\n            nextState.path = path;\n            nextState.action = action;\n            nextState.pathname = pathname;\n            nextState.routes = nextRoutes;\n            nextState.params = nextParams;\n            nextState.query = nextQuery;\n\n            callback.call(router, null, transition);\n          });\n        });\n      },\n\n      /**\n       * Starts this router and calls callback(router, state) when the route changes.\n       *\n       * If the router's location is static (i.e. a URL path in a server environment)\n       * the callback is called only once. Otherwise, the location should be one of the\n       * Router.*Location objects (e.g. Router.HashLocation or Router.HistoryLocation).\n       */\n      run: function (callback) {\n        var dispatchHandler = function (error, transition) {\n          pendingTransition = null;\n\n          if (error) {\n            onError.call(router, error);\n          } else if (transition.isAborted) {\n            onAbort.call(router, transition.abortReason, location);\n          } else {\n            callback.call(router, router, nextState);\n          }\n        };\n\n        if (typeof location === 'string') {\n          router.dispatch(location, null, dispatchHandler);\n        } else {\n          // Listen for changes to the location.\n          var changeListener = function (change) {\n            router.dispatch(change.path, change.type, dispatchHandler);\n          };\n\n          if (location.addChangeListener)\n            location.addChangeListener(changeListener);\n\n          // Bootstrap using the current path.\n          router.dispatch(location.getCurrentPath(), null, dispatchHandler);\n        }\n      },\n\n      teardown: function() {\n        location.removeChangeListener(this.changeListener);\n      }\n\n    },\n\n    propTypes: {\n      children: PropTypes.falsy\n    },\n\n    getLocation: function () {\n      return location;\n    },\n\n    getScrollBehavior: function () {\n      return scrollBehavior;\n    },\n\n    getRouteAtDepth: function (depth) {\n      var routes = this.state.routes;\n      return routes && routes[depth];\n    },\n\n    getRouteComponents: function () {\n      return components;\n    },\n\n    getInitialState: function () {\n      updateState();\n      return state;\n    },\n\n    componentWillReceiveProps: function () {\n      updateState();\n      this.setState(state);\n    },\n\n    componentWillUnmount: function() {\n      router.teardown();\n    },\n\n    render: function () {\n      return this.getRouteAtDepth(0) ? React.createElement(RouteHandler, this.props) : null;\n    },\n\n    childContextTypes: {\n      getRouteAtDepth: React.PropTypes.func.isRequired,\n      getRouteComponents: React.PropTypes.func.isRequired,\n      routeHandlers: React.PropTypes.array.isRequired\n    },\n\n    getChildContext: function () {\n      return {\n        getRouteComponents: this.getRouteComponents,\n        getRouteAtDepth: this.getRouteAtDepth,\n        routeHandlers: [ this ]\n      };\n    }\n\n  });\n\n  if (options.routes)\n    router.addRoutes(options.routes);\n\n  return router;\n}\n\nmodule.exports = createRouter;\n","/* jshint -W084 */\nvar React = require('react');\nvar warning = require('react/lib/warning');\nvar invariant = require('react/lib/invariant');\nvar DefaultRoute = require('../components/DefaultRoute');\nvar NotFoundRoute = require('../components/NotFoundRoute');\nvar Redirect = require('../components/Redirect');\nvar Route = require('../components/Route');\nvar Path = require('./Path');\n\nvar CONFIG_ELEMENT_TYPES = [\n  DefaultRoute.type,\n  NotFoundRoute.type,\n  Redirect.type,\n  Route.type\n];\n\nfunction createRedirectHandler(to, _params, _query) {\n  return React.createClass({\n    statics: {\n      willTransitionTo: function (transition, params, query) {\n        transition.redirect(to, _params || params, _query || query);\n      }\n    },\n\n    render: function () {\n      return null;\n    }\n  });\n}\n\nfunction checkPropTypes(componentName, propTypes, props) {\n  for (var propName in propTypes) {\n    if (propTypes.hasOwnProperty(propName)) {\n      var error = propTypes[propName](props, propName, componentName);\n\n      if (error instanceof Error)\n        warning(false, error.message);\n    }\n  }\n}\n\nfunction createRoute(element, parentRoute, namedRoutes) {\n  var type = element.type;\n  var props = element.props;\n  var componentName = (type && type.displayName) || 'UnknownComponent';\n\n  invariant(\n    CONFIG_ELEMENT_TYPES.indexOf(type) !== -1,\n    'Unrecognized route configuration element \"<%s>\"',\n    componentName\n  );\n\n  if (type.propTypes)\n    checkPropTypes(componentName, type.propTypes, props);\n\n  var route = { name: props.name };\n\n  if (props.ignoreScrollBehavior) {\n    route.ignoreScrollBehavior = true;\n  }\n\n  if (type === Redirect.type) {\n    route.handler = createRedirectHandler(props.to, props.params, props.query);\n    props.path = props.path || props.from || '*';\n  } else {\n    route.handler = props.handler;\n  }\n\n  var parentPath = (parentRoute && parentRoute.path) || '/';\n\n  if ((props.path || props.name) && type !== DefaultRoute.type && type !== NotFoundRoute.type) {\n    var path = props.path || props.name;\n\n    // Relative paths extend their parent.\n    if (!Path.isAbsolute(path))\n      path = Path.join(parentPath, path);\n\n    route.path = Path.normalize(path);\n  } else {\n    route.path = parentPath;\n\n    if (type === NotFoundRoute.type)\n      route.path += '*';\n  }\n\n  route.paramNames = Path.extractParamNames(route.path);\n\n  // Make sure the route's path has all params its parent needs.\n  if (parentRoute && Array.isArray(parentRoute.paramNames)) {\n    parentRoute.paramNames.forEach(function (paramName) {\n      invariant(\n        route.paramNames.indexOf(paramName) !== -1,\n        'The nested route path \"%s\" is missing the \"%s\" parameter of its parent path \"%s\"',\n        route.path, paramName, parentRoute.path\n      );\n    });\n  }\n\n  // Make sure the route can be looked up by <Link>s.\n  if (props.name) {\n    invariant(\n      namedRoutes[props.name] == null,\n      'You cannot use the name \"%s\" for more than one route',\n      props.name\n    );\n\n    namedRoutes[props.name] = route;\n  }\n\n  // Handle <NotFoundRoute>.\n  if (type === NotFoundRoute.type) {\n    invariant(\n      parentRoute,\n      '<NotFoundRoute> must have a parent <Route>'\n    );\n\n    invariant(\n      parentRoute.notFoundRoute == null,\n      'You may not have more than one <NotFoundRoute> per <Route>'\n    );\n\n    parentRoute.notFoundRoute = route;\n\n    return null;\n  }\n\n  // Handle <DefaultRoute>.\n  if (type === DefaultRoute.type) {\n    invariant(\n      parentRoute,\n      '<DefaultRoute> must have a parent <Route>'\n    );\n\n    invariant(\n      parentRoute.defaultRoute == null,\n      'You may not have more than one <DefaultRoute> per <Route>'\n    );\n\n    parentRoute.defaultRoute = route;\n\n    return null;\n  }\n\n  route.childRoutes = createRoutesFromChildren(props.children, route, namedRoutes);\n\n  return route;\n}\n\n/**\n * Creates and returns an array of route objects from the given ReactChildren.\n */\nfunction createRoutesFromChildren(children, parentRoute, namedRoutes) {\n  var routes = [];\n\n  React.Children.forEach(children, function (child) {\n    // Exclude <DefaultRoute>s and <NotFoundRoute>s.\n    if (child = createRoute(child, parentRoute, namedRoutes))\n      routes.push(child);\n  });\n\n  return routes;\n}\n\nmodule.exports = createRoutesFromChildren;\n","var invariant = require('react/lib/invariant');\nvar canUseDOM = require('react/lib/ExecutionEnvironment').canUseDOM;\n\n/**\n * Returns the current scroll position of the window as { x, y }.\n */\nfunction getWindowScrollPosition() {\n  invariant(\n    canUseDOM,\n    'Cannot get current scroll position without a DOM'\n  );\n\n  return {\n    x: window.pageXOffset || document.documentElement.scrollLeft,\n    y: window.pageYOffset || document.documentElement.scrollTop\n  };\n}\n\nmodule.exports = getWindowScrollPosition;\n","function reversedArray(array) {\n  return array.slice(0).reverse();\n}\n\nmodule.exports = reversedArray;\n","var createRouter = require('./createRouter');\n\n/**\n * A high-level convenience method that creates, configures, and\n * runs a router in one shot. The method signature is:\n *\n *   Router.run(routes[, location ], callback);\n *\n * Using `window.location.hash` to manage the URL, you could do:\n *\n *   Router.run(routes, function (Handler) {\n *     React.render(<Handler/>, document.body);\n *   });\n * \n * Using HTML5 history and a custom \"cursor\" prop:\n * \n *   Router.run(routes, Router.HistoryLocation, function (Handler) {\n *     React.render(<Handler cursor={cursor}/>, document.body);\n *   });\n *\n * Returns the newly created router.\n *\n * Note: If you need to specify further options for your router such\n * as error/abort handling or custom scroll behavior, use Router.create\n * instead.\n *\n *   var router = Router.create(options);\n *   router.run(function (Handler) {\n *     // ...\n *   });\n */\nfunction runRouter(routes, location, callback) {\n  if (typeof location === 'function') {\n    callback = location;\n    location = null;\n  }\n\n  var router = createRouter({\n    routes: routes,\n    location: location\n  });\n\n  router.run(callback);\n\n  return router;\n}\n\nmodule.exports = runRouter;\n","function supportsHistory() {\n  /*! taken from modernizr\n   * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\n   * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\n   * changed to avoid false negatives for Windows Phones: https://github.com/rackt/react-router/issues/586\n   */\n  var ua = navigator.userAgent;\n  if ((ua.indexOf('Android 2.') !== -1 ||\n      (ua.indexOf('Android 4.0') !== -1)) &&\n      ua.indexOf('Mobile Safari') !== -1 &&\n      ua.indexOf('Chrome') === -1 &&\n      ua.indexOf('Windows Phone') === -1) {\n    return false;\n  }\n  return (window.history && 'pushState' in window.history);\n}\n\nmodule.exports = supportsHistory;\n","module.exports = require('./lib');\n","// Load modules\n\nvar Stringify = require('./stringify');\nvar Parse = require('./parse');\n\n\n// Declare internals\n\nvar internals = {};\n\n\nmodule.exports = {\n    stringify: Stringify,\n    parse: Parse\n};\n","// Load modules\n\nvar Utils = require('./utils');\n\n\n// Declare internals\n\nvar internals = {\n    delimiter: '&',\n    depth: 5,\n    arrayLimit: 20,\n    parameterLimit: 1000\n};\n\n\ninternals.parseValues = function (str, options) {\n\n    var obj = {};\n    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);\n\n    for (var i = 0, il = parts.length; i < il; ++i) {\n        var part = parts[i];\n        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;\n\n        if (pos === -1) {\n            obj[Utils.decode(part)] = '';\n        }\n        else {\n            var key = Utils.decode(part.slice(0, pos));\n            var val = Utils.decode(part.slice(pos + 1));\n\n            if (!obj[key]) {\n                obj[key] = val;\n            }\n            else {\n                obj[key] = [].concat(obj[key]).concat(val);\n            }\n        }\n    }\n\n    return obj;\n};\n\n\ninternals.parseObject = function (chain, val, options) {\n\n    if (!chain.length) {\n        return val;\n    }\n\n    var root = chain.shift();\n\n    var obj = {};\n    if (root === '[]') {\n        obj = [];\n        obj = obj.concat(internals.parseObject(chain, val, options));\n    }\n    else {\n        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;\n        var index = parseInt(cleanRoot, 10);\n        if (!isNaN(index) &&\n            root !== cleanRoot &&\n            index <= options.arrayLimit) {\n\n            obj = [];\n            obj[index] = internals.parseObject(chain, val, options);\n        }\n        else {\n            obj[cleanRoot] = internals.parseObject(chain, val, options);\n        }\n    }\n\n    return obj;\n};\n\n\ninternals.parseKeys = function (key, val, options) {\n\n    if (!key) {\n        return;\n    }\n\n    // The regex chunks\n\n    var parent = /^([^\\[\\]]*)/;\n    var child = /(\\[[^\\[\\]]*\\])/g;\n\n    // Get the parent\n\n    var segment = parent.exec(key);\n\n    // Don't allow them to overwrite object prototype properties\n\n    if (Object.prototype.hasOwnProperty(segment[1])) {\n        return;\n    }\n\n    // Stash the parent if it exists\n\n    var keys = [];\n    if (segment[1]) {\n        keys.push(segment[1]);\n    }\n\n    // Loop through children appending to the array until we hit depth\n\n    var i = 0;\n    while ((segment = child.exec(key)) !== null && i < options.depth) {\n\n        ++i;\n        if (!Object.prototype.hasOwnProperty(segment[1].replace(/\\[|\\]/g, ''))) {\n            keys.push(segment[1]);\n        }\n    }\n\n    // If there's a remainder, just add whatever is left\n\n    if (segment) {\n        keys.push('[' + key.slice(segment.index) + ']');\n    }\n\n    return internals.parseObject(keys, val, options);\n};\n\n\nmodule.exports = function (str, options) {\n\n    if (str === '' ||\n        str === null ||\n        typeof str === 'undefined') {\n\n        return {};\n    }\n\n    options = options || {};\n    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;\n    options.depth = typeof options.depth === 'number' ? options.depth : internals.depth;\n    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : internals.arrayLimit;\n    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : internals.parameterLimit;\n\n    var tempObj = typeof str === 'string' ? internals.parseValues(str, options) : str;\n    var obj = {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0, il = keys.length; i < il; ++i) {\n        var key = keys[i];\n        var newObj = internals.parseKeys(key, tempObj[key], options);\n        obj = Utils.merge(obj, newObj);\n    }\n\n    return Utils.compact(obj);\n};\n","// Load modules\n\nvar Utils = require('./utils');\n\n\n// Declare internals\n\nvar internals = {\n    delimiter: '&'\n};\n\n\ninternals.stringify = function (obj, prefix) {\n\n    if (Utils.isBuffer(obj)) {\n        obj = obj.toString();\n    }\n    else if (obj instanceof Date) {\n        obj = obj.toISOString();\n    }\n    else if (obj === null) {\n        obj = '';\n    }\n\n    if (typeof obj === 'string' ||\n        typeof obj === 'number' ||\n        typeof obj === 'boolean') {\n\n        return [encodeURIComponent(prefix) + '=' + encodeURIComponent(obj)];\n    }\n\n    var values = [];\n\n    for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            values = values.concat(internals.stringify(obj[key], prefix + '[' + key + ']'));\n        }\n    }\n\n    return values;\n};\n\n\nmodule.exports = function (obj, options) {\n\n    options = options || {};\n    var delimiter = typeof options.delimiter === 'undefined' ? internals.delimiter : options.delimiter;\n\n    var keys = [];\n\n    for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            keys = keys.concat(internals.stringify(obj[key], key));\n        }\n    }\n\n    return keys.join(delimiter);\n};\n","// Load modules\n\n\n// Declare internals\n\nvar internals = {};\n\n\nexports.arrayToObject = function (source) {\n\n    var obj = {};\n    for (var i = 0, il = source.length; i < il; ++i) {\n        if (typeof source[i] !== 'undefined') {\n\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\n\nexports.merge = function (target, source) {\n\n    if (!source) {\n        return target;\n    }\n\n    if (Array.isArray(source)) {\n        for (var i = 0, il = source.length; i < il; ++i) {\n            if (typeof source[i] !== 'undefined') {\n                if (typeof target[i] === 'object') {\n                    target[i] = exports.merge(target[i], source[i]);\n                }\n                else {\n                    target[i] = source[i];\n                }\n            }\n        }\n\n        return target;\n    }\n\n    if (Array.isArray(target)) {\n        if (typeof source !== 'object') {\n            target.push(source);\n            return target;\n        }\n        else {\n            target = exports.arrayToObject(target);\n        }\n    }\n\n    var keys = Object.keys(source);\n    for (var k = 0, kl = keys.length; k < kl; ++k) {\n        var key = keys[k];\n        var value = source[key];\n\n        if (value &&\n            typeof value === 'object') {\n\n            if (!target[key]) {\n                target[key] = value;\n            }\n            else {\n                target[key] = exports.merge(target[key], value);\n            }\n        }\n        else {\n            target[key] = value;\n        }\n    }\n\n    return target;\n};\n\n\nexports.decode = function (str) {\n\n    try {\n        return decodeURIComponent(str.replace(/\\+/g, ' '));\n    } catch (e) {\n        return str;\n    }\n};\n\n\nexports.compact = function (obj, refs) {\n\n    if (typeof obj !== 'object' ||\n        obj === null) {\n\n        return obj;\n    }\n\n    refs = refs || [];\n    var lookup = refs.indexOf(obj);\n    if (lookup !== -1) {\n        return refs[lookup];\n    }\n\n    refs.push(obj);\n\n    if (Array.isArray(obj)) {\n        var compacted = [];\n\n        for (var i = 0, l = obj.length; i < l; ++i) {\n            if (typeof obj[i] !== 'undefined') {\n                compacted.push(obj[i]);\n            }\n        }\n\n        return compacted;\n    }\n\n    var keys = Object.keys(obj);\n    for (var i = 0, il = keys.length; i < il; ++i) {\n        var key = keys[i];\n        obj[key] = exports.compact(obj[key], refs);\n    }\n\n    return obj;\n};\n\n\nexports.isRegExp = function (obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\n\nexports.isBuffer = function (obj) {\n\n    if (typeof Buffer !== 'undefined') {\n        return Buffer.isBuffer(obj);\n    }\n    else {\n        return false;\n    }\n};\n","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function (require) {\n\n\tvar makePromise = require('./makePromise');\n\tvar Scheduler = require('./Scheduler');\n\tvar async = require('./async');\n\n\treturn makePromise({\n\t\tscheduler: new Scheduler(async)\n\t});\n\n});\n})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });\n","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\t/**\n\t * Circular queue\n\t * @param {number} capacityPow2 power of 2 to which this queue's capacity\n\t *  will be set initially. eg when capacityPow2 == 3, queue capacity\n\t *  will be 8.\n\t * @constructor\n\t */\n\tfunction Queue(capacityPow2) {\n\t\tthis.head = this.tail = this.length = 0;\n\t\tthis.buffer = new Array(1 << capacityPow2);\n\t}\n\n\tQueue.prototype.push = function(x) {\n\t\tif(this.length === this.buffer.length) {\n\t\t\tthis._ensureCapacity(this.length * 2);\n\t\t}\n\n\t\tthis.buffer[this.tail] = x;\n\t\tthis.tail = (this.tail + 1) & (this.buffer.length - 1);\n\t\t++this.length;\n\t\treturn this.length;\n\t};\n\n\tQueue.prototype.shift = function() {\n\t\tvar x = this.buffer[this.head];\n\t\tthis.buffer[this.head] = void 0;\n\t\tthis.head = (this.head + 1) & (this.buffer.length - 1);\n\t\t--this.length;\n\t\treturn x;\n\t};\n\n\tQueue.prototype._ensureCapacity = function(capacity) {\n\t\tvar head = this.head;\n\t\tvar buffer = this.buffer;\n\t\tvar newBuffer = new Array(capacity);\n\t\tvar i = 0;\n\t\tvar len;\n\n\t\tif(head === 0) {\n\t\t\tlen = this.length;\n\t\t\tfor(; i<len; ++i) {\n\t\t\t\tnewBuffer[i] = buffer[i];\n\t\t\t}\n\t\t} else {\n\t\t\tcapacity = buffer.length;\n\t\t\tlen = this.tail;\n\t\t\tfor(; head<capacity; ++i, ++head) {\n\t\t\t\tnewBuffer[i] = buffer[head];\n\t\t\t}\n\n\t\t\tfor(head=0; head<len; ++i, ++head) {\n\t\t\t\tnewBuffer[i] = buffer[head];\n\t\t\t}\n\t\t}\n\n\t\tthis.buffer = newBuffer;\n\t\tthis.head = 0;\n\t\tthis.tail = this.length;\n\t};\n\n\treturn Queue;\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\tvar Queue = require('./Queue');\n\n\t// Credit to Twisol (https://github.com/Twisol) for suggesting\n\t// this type of extensible queue + trampoline approach for next-tick conflation.\n\n\t/**\n\t * Async task scheduler\n\t * @param {function} async function to schedule a single async function\n\t * @constructor\n\t */\n\tfunction Scheduler(async) {\n\t\tthis._async = async;\n\t\tthis._queue = new Queue(15);\n\t\tthis._afterQueue = new Queue(5);\n\t\tthis._running = false;\n\n\t\tvar self = this;\n\t\tthis.drain = function() {\n\t\t\tself._drain();\n\t\t};\n\t}\n\n\t/**\n\t * Enqueue a task\n\t * @param {{ run:function }} task\n\t */\n\tScheduler.prototype.enqueue = function(task) {\n\t\tthis._add(this._queue, task);\n\t};\n\n\t/**\n\t * Enqueue a task to run after the main task queue\n\t * @param {{ run:function }} task\n\t */\n\tScheduler.prototype.afterQueue = function(task) {\n\t\tthis._add(this._afterQueue, task);\n\t};\n\n\t/**\n\t * Drain the handler queue entirely, and then the after queue\n\t */\n\tScheduler.prototype._drain = function() {\n\t\trunQueue(this._queue);\n\t\tthis._running = false;\n\t\trunQueue(this._afterQueue);\n\t};\n\n\t/**\n\t * Add a task to the q, and schedule drain if not already scheduled\n\t * @param {Queue} queue\n\t * @param {{run:function}} task\n\t * @private\n\t */\n\tScheduler.prototype._add = function(queue, task) {\n\t\tqueue.push(task);\n\t\tif(!this._running) {\n\t\t\tthis._running = true;\n\t\t\tthis._async(this.drain);\n\t\t}\n\t};\n\n\t/**\n\t * Run all the tasks in the q\n\t * @param queue\n\t */\n\tfunction runQueue(queue) {\n\t\twhile(queue.length > 0) {\n\t\t\tqueue.shift().run();\n\t\t}\n\t}\n\n\treturn Scheduler;\n\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function(require) {\n\n\t// Sniff \"best\" async scheduling option\n\t// Prefer process.nextTick or MutationObserver, then check for\n\t// vertx and finally fall back to setTimeout\n\n\t/*jshint maxcomplexity:6*/\n\t/*global process,document,setTimeout,MutationObserver,WebKitMutationObserver*/\n\tvar nextTick, MutationObs;\n\n\tif (typeof process !== 'undefined' && process !== null &&\n\t\ttypeof process.nextTick === 'function') {\n\t\tnextTick = function(f) {\n\t\t\tprocess.nextTick(f);\n\t\t};\n\n\t} else if (MutationObs =\n\t\t(typeof MutationObserver === 'function' && MutationObserver) ||\n\t\t(typeof WebKitMutationObserver === 'function' && WebKitMutationObserver)) {\n\t\tnextTick = (function (document, MutationObserver) {\n\t\t\tvar scheduled;\n\t\t\tvar el = document.createElement('div');\n\t\t\tvar o = new MutationObserver(run);\n\t\t\to.observe(el, { attributes: true });\n\n\t\t\tfunction run() {\n\t\t\t\tvar f = scheduled;\n\t\t\t\tscheduled = void 0;\n\t\t\t\tf();\n\t\t\t}\n\n\t\t\treturn function (f) {\n\t\t\t\tscheduled = f;\n\t\t\t\tel.setAttribute('class', 'x');\n\t\t\t};\n\t\t}(document, MutationObs));\n\n\t} else {\n\t\tnextTick = (function(cjsRequire) {\n\t\t\tvar vertx;\n\t\t\ttry {\n\t\t\t\t// vert.x 1.x || 2.x\n\t\t\t\tvertx = cjsRequire('vertx');\n\t\t\t} catch (ignore) {}\n\n\t\t\tif (vertx) {\n\t\t\t\tif (typeof vertx.runOnLoop === 'function') {\n\t\t\t\t\treturn vertx.runOnLoop;\n\t\t\t\t}\n\t\t\t\tif (typeof vertx.runOnContext === 'function') {\n\t\t\t\t\treturn vertx.runOnContext;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// capture setTimeout to avoid being caught by fake timers\n\t\t\t// used in time based tests\n\t\t\tvar capturedSetTimeout = setTimeout;\n\t\t\treturn function (t) {\n\t\t\t\tcapturedSetTimeout(t, 0);\n\t\t\t};\n\t\t}(require));\n\t}\n\n\treturn nextTick;\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));\n","/** @license MIT License (c) copyright 2010-2014 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n(function(define) { 'use strict';\ndefine(function() {\n\n\treturn function makePromise(environment) {\n\n\t\tvar tasks = environment.scheduler;\n\n\t\tvar objectCreate = Object.create ||\n\t\t\tfunction(proto) {\n\t\t\t\tfunction Child() {}\n\t\t\t\tChild.prototype = proto;\n\t\t\t\treturn new Child();\n\t\t\t};\n\n\t\t/**\n\t\t * Create a promise whose fate is determined by resolver\n\t\t * @constructor\n\t\t * @returns {Promise} promise\n\t\t * @name Promise\n\t\t */\n\t\tfunction Promise(resolver, handler) {\n\t\t\tthis._handler = resolver === Handler ? handler : init(resolver);\n\t\t}\n\n\t\t/**\n\t\t * Run the supplied resolver\n\t\t * @param resolver\n\t\t * @returns {Pending}\n\t\t */\n\t\tfunction init(resolver) {\n\t\t\tvar handler = new Pending();\n\n\t\t\ttry {\n\t\t\t\tresolver(promiseResolve, promiseReject, promiseNotify);\n\t\t\t} catch (e) {\n\t\t\t\tpromiseReject(e);\n\t\t\t}\n\n\t\t\treturn handler;\n\n\t\t\t/**\n\t\t\t * Transition from pre-resolution state to post-resolution state, notifying\n\t\t\t * all listeners of the ultimate fulfillment or rejection\n\t\t\t * @param {*} x resolution value\n\t\t\t */\n\t\t\tfunction promiseResolve (x) {\n\t\t\t\thandler.resolve(x);\n\t\t\t}\n\t\t\t/**\n\t\t\t * Reject this promise with reason, which will be used verbatim\n\t\t\t * @param {Error|*} reason rejection reason, strongly suggested\n\t\t\t *   to be an Error type\n\t\t\t */\n\t\t\tfunction promiseReject (reason) {\n\t\t\t\thandler.reject(reason);\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Issue a progress event, notifying all progress listeners\n\t\t\t * @param {*} x progress event payload to pass to all listeners\n\t\t\t */\n\t\t\tfunction promiseNotify (x) {\n\t\t\t\thandler.notify(x);\n\t\t\t}\n\t\t}\n\n\t\t// Creation\n\n\t\tPromise.resolve = resolve;\n\t\tPromise.reject = reject;\n\t\tPromise.never = never;\n\n\t\tPromise._defer = defer;\n\t\tPromise._handler = getHandler;\n\n\t\t/**\n\t\t * Returns a trusted promise. If x is already a trusted promise, it is\n\t\t * returned, otherwise returns a new trusted Promise which follows x.\n\t\t * @param  {*} x\n\t\t * @return {Promise} promise\n\t\t */\n\t\tfunction resolve(x) {\n\t\t\treturn isPromise(x) ? x\n\t\t\t\t: new Promise(Handler, new Async(getHandler(x)));\n\t\t}\n\n\t\t/**\n\t\t * Return a reject promise with x as its reason (x is used verbatim)\n\t\t * @param {*} x\n\t\t * @returns {Promise} rejected promise\n\t\t */\n\t\tfunction reject(x) {\n\t\t\treturn new Promise(Handler, new Async(new Rejected(x)));\n\t\t}\n\n\t\t/**\n\t\t * Return a promise that remains pending forever\n\t\t * @returns {Promise} forever-pending promise.\n\t\t */\n\t\tfunction never() {\n\t\t\treturn foreverPendingPromise; // Should be frozen\n\t\t}\n\n\t\t/**\n\t\t * Creates an internal {promise, resolver} pair\n\t\t * @private\n\t\t * @returns {Promise}\n\t\t */\n\t\tfunction defer() {\n\t\t\treturn new Promise(Handler, new Pending());\n\t\t}\n\n\t\t// Transformation and flow control\n\n\t\t/**\n\t\t * Transform this promise's fulfillment value, returning a new Promise\n\t\t * for the transformed result.  If the promise cannot be fulfilled, onRejected\n\t\t * is called with the reason.  onProgress *may* be called with updates toward\n\t\t * this promise's fulfillment.\n\t\t * @param {function=} onFulfilled fulfillment handler\n\t\t * @param {function=} onRejected rejection handler\n\t\t * @deprecated @param {function=} onProgress progress handler\n\t\t * @return {Promise} new promise\n\t\t */\n\t\tPromise.prototype.then = function(onFulfilled, onRejected) {\n\t\t\tvar parent = this._handler;\n\t\t\tvar state = parent.join().state();\n\n\t\t\tif ((typeof onFulfilled !== 'function' && state > 0) ||\n\t\t\t\t(typeof onRejected !== 'function' && state < 0)) {\n\t\t\t\t// Short circuit: value will not change, simply share handler\n\t\t\t\treturn new this.constructor(Handler, parent);\n\t\t\t}\n\n\t\t\tvar p = this._beget();\n\t\t\tvar child = p._handler;\n\n\t\t\tparent.chain(child, parent.receiver, onFulfilled, onRejected,\n\t\t\t\t\targuments.length > 2 ? arguments[2] : void 0);\n\n\t\t\treturn p;\n\t\t};\n\n\t\t/**\n\t\t * If this promise cannot be fulfilled due to an error, call onRejected to\n\t\t * handle the error. Shortcut for .then(undefined, onRejected)\n\t\t * @param {function?} onRejected\n\t\t * @return {Promise}\n\t\t */\n\t\tPromise.prototype['catch'] = function(onRejected) {\n\t\t\treturn this.then(void 0, onRejected);\n\t\t};\n\n\t\t/**\n\t\t * Creates a new, pending promise of the same type as this promise\n\t\t * @private\n\t\t * @returns {Promise}\n\t\t */\n\t\tPromise.prototype._beget = function() {\n\t\t\tvar parent = this._handler;\n\t\t\tvar child = new Pending(parent.receiver, parent.join().context);\n\t\t\treturn new this.constructor(Handler, child);\n\t\t};\n\n\t\t// Array combinators\n\n\t\tPromise.all = all;\n\t\tPromise.race = race;\n\n\t\t/**\n\t\t * Return a promise that will fulfill when all promises in the\n\t\t * input array have fulfilled, or will reject when one of the\n\t\t * promises rejects.\n\t\t * @param {array} promises array of promises\n\t\t * @returns {Promise} promise for array of fulfillment values\n\t\t */\n\t\tfunction all(promises) {\n\t\t\t/*jshint maxcomplexity:8*/\n\t\t\tvar resolver = new Pending();\n\t\t\tvar pending = promises.length >>> 0;\n\t\t\tvar results = new Array(pending);\n\n\t\t\tvar i, h, x, s;\n\t\t\tfor (i = 0; i < promises.length; ++i) {\n\t\t\t\tx = promises[i];\n\n\t\t\t\tif (x === void 0 && !(i in promises)) {\n\t\t\t\t\t--pending;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (maybeThenable(x)) {\n\t\t\t\t\th = getHandlerMaybeThenable(x);\n\n\t\t\t\t\ts = h.state();\n\t\t\t\t\tif (s === 0) {\n\t\t\t\t\t\th.fold(settleAt, i, results, resolver);\n\t\t\t\t\t} else if (s > 0) {\n\t\t\t\t\t\tresults[i] = h.value;\n\t\t\t\t\t\t--pending;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tunreportRemaining(promises, i+1, h);\n\t\t\t\t\t\tresolver.become(h);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tresults[i] = x;\n\t\t\t\t\t--pending;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(pending === 0) {\n\t\t\t\tresolver.become(new Fulfilled(results));\n\t\t\t}\n\n\t\t\treturn new Promise(Handler, resolver);\n\n\t\t\tfunction settleAt(i, x, resolver) {\n\t\t\t\t/*jshint validthis:true*/\n\t\t\t\tthis[i] = x;\n\t\t\t\tif(--pending === 0) {\n\t\t\t\t\tresolver.become(new Fulfilled(this));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction unreportRemaining(promises, start, rejectedHandler) {\n\t\t\tvar i, h, x;\n\t\t\tfor(i=start; i<promises.length; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif(maybeThenable(x)) {\n\t\t\t\t\th = getHandlerMaybeThenable(x);\n\n\t\t\t\t\tif(h !== rejectedHandler) {\n\t\t\t\t\t\th.visit(h, void 0, h._unreport);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Fulfill-reject competitive race. Return a promise that will settle\n\t\t * to the same state as the earliest input promise to settle.\n\t\t *\n\t\t * WARNING: The ES6 Promise spec requires that race()ing an empty array\n\t\t * must return a promise that is pending forever.  This implementation\n\t\t * returns a singleton forever-pending promise, the same singleton that is\n\t\t * returned by Promise.never(), thus can be checked with ===\n\t\t *\n\t\t * @param {array} promises array of promises to race\n\t\t * @returns {Promise} if input is non-empty, a promise that will settle\n\t\t * to the same outcome as the earliest input promise to settle. if empty\n\t\t * is empty, returns a promise that will never settle.\n\t\t */\n\t\tfunction race(promises) {\n\t\t\t// Sigh, race([]) is untestable unless we return *something*\n\t\t\t// that is recognizable without calling .then() on it.\n\t\t\tif(Object(promises) === promises && promises.length === 0) {\n\t\t\t\treturn never();\n\t\t\t}\n\n\t\t\tvar h = new Pending();\n\t\t\tvar i, x;\n\t\t\tfor(i=0; i<promises.length; ++i) {\n\t\t\t\tx = promises[i];\n\t\t\t\tif (x !== void 0 && i in promises) {\n\t\t\t\t\tgetHandler(x).visit(h, h.resolve, h.reject);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new Promise(Handler, h);\n\t\t}\n\n\t\t// Promise internals\n\t\t// Below this, everything is @private\n\n\t\t/**\n\t\t * Get an appropriate handler for x, without checking for cycles\n\t\t * @param {*} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandler(x) {\n\t\t\tif(isPromise(x)) {\n\t\t\t\treturn x._handler.join();\n\t\t\t}\n\t\t\treturn maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);\n\t\t}\n\n\t\t/**\n\t\t * Get a handler for thenable x.\n\t\t * NOTE: You must only call this if maybeThenable(x) == true\n\t\t * @param {object|function|Promise} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandlerMaybeThenable(x) {\n\t\t\treturn isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);\n\t\t}\n\n\t\t/**\n\t\t * Get a handler for potentially untrusted thenable x\n\t\t * @param {*} x\n\t\t * @returns {object} handler\n\t\t */\n\t\tfunction getHandlerUntrusted(x) {\n\t\t\ttry {\n\t\t\t\tvar untrustedThen = x.then;\n\t\t\t\treturn typeof untrustedThen === 'function'\n\t\t\t\t\t? new Thenable(untrustedThen, x)\n\t\t\t\t\t: new Fulfilled(x);\n\t\t\t} catch(e) {\n\t\t\t\treturn new Rejected(e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Handler for a promise that is pending forever\n\t\t * @constructor\n\t\t */\n\t\tfunction Handler() {}\n\n\t\tHandler.prototype.when\n\t\t\t= Handler.prototype.become\n\t\t\t= Handler.prototype.notify\n\t\t\t= Handler.prototype.fail\n\t\t\t= Handler.prototype._unreport\n\t\t\t= Handler.prototype._report\n\t\t\t= noop;\n\n\t\tHandler.prototype._state = 0;\n\n\t\tHandler.prototype.state = function() {\n\t\t\treturn this._state;\n\t\t};\n\n\t\t/**\n\t\t * Recursively collapse handler chain to find the handler\n\t\t * nearest to the fully resolved value.\n\t\t * @returns {object} handler nearest the fully resolved value\n\t\t */\n\t\tHandler.prototype.join = function() {\n\t\t\tvar h = this;\n\t\t\twhile(h.handler !== void 0) {\n\t\t\t\th = h.handler;\n\t\t\t}\n\t\t\treturn h;\n\t\t};\n\n\t\tHandler.prototype.chain = function(to, receiver, fulfilled, rejected, progress) {\n\t\t\tthis.when({\n\t\t\t\tresolver: to,\n\t\t\t\treceiver: receiver,\n\t\t\t\tfulfilled: fulfilled,\n\t\t\t\trejected: rejected,\n\t\t\t\tprogress: progress\n\t\t\t});\n\t\t};\n\n\t\tHandler.prototype.visit = function(receiver, fulfilled, rejected, progress) {\n\t\t\tthis.chain(failIfRejected, receiver, fulfilled, rejected, progress);\n\t\t};\n\n\t\tHandler.prototype.fold = function(f, z, c, to) {\n\t\t\tthis.visit(to, function(x) {\n\t\t\t\tf.call(c, z, x, this);\n\t\t\t}, to.reject, to.notify);\n\t\t};\n\n\t\t/**\n\t\t * Handler that invokes fail() on any handler it becomes\n\t\t * @constructor\n\t\t */\n\t\tfunction FailIfRejected() {}\n\n\t\tinherit(Handler, FailIfRejected);\n\n\t\tFailIfRejected.prototype.become = function(h) {\n\t\t\th.fail();\n\t\t};\n\n\t\tvar failIfRejected = new FailIfRejected();\n\n\t\t/**\n\t\t * Handler that manages a queue of consumers waiting on a pending promise\n\t\t * @constructor\n\t\t */\n\t\tfunction Pending(receiver, inheritedContext) {\n\t\t\tPromise.createContext(this, inheritedContext);\n\n\t\t\tthis.consumers = void 0;\n\t\t\tthis.receiver = receiver;\n\t\t\tthis.handler = void 0;\n\t\t\tthis.resolved = false;\n\t\t}\n\n\t\tinherit(Handler, Pending);\n\n\t\tPending.prototype._state = 0;\n\n\t\tPending.prototype.resolve = function(x) {\n\t\t\tthis.become(getHandler(x));\n\t\t};\n\n\t\tPending.prototype.reject = function(x) {\n\t\t\tif(this.resolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.become(new Rejected(x));\n\t\t};\n\n\t\tPending.prototype.join = function() {\n\t\t\tif (!this.resolved) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tvar h = this;\n\n\t\t\twhile (h.handler !== void 0) {\n\t\t\t\th = h.handler;\n\t\t\t\tif (h === this) {\n\t\t\t\t\treturn this.handler = cycle();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn h;\n\t\t};\n\n\t\tPending.prototype.run = function() {\n\t\t\tvar q = this.consumers;\n\t\t\tvar handler = this.join();\n\t\t\tthis.consumers = void 0;\n\n\t\t\tfor (var i = 0; i < q.length; ++i) {\n\t\t\t\thandler.when(q[i]);\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.become = function(handler) {\n\t\t\tif(this.resolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.resolved = true;\n\t\t\tthis.handler = handler;\n\t\t\tif(this.consumers !== void 0) {\n\t\t\t\ttasks.enqueue(this);\n\t\t\t}\n\n\t\t\tif(this.context !== void 0) {\n\t\t\t\thandler._report(this.context);\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.when = function(continuation) {\n\t\t\tif(this.resolved) {\n\t\t\t\ttasks.enqueue(new ContinuationTask(continuation, this.handler));\n\t\t\t} else {\n\t\t\t\tif(this.consumers === void 0) {\n\t\t\t\t\tthis.consumers = [continuation];\n\t\t\t\t} else {\n\t\t\t\t\tthis.consumers.push(continuation);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.notify = function(x) {\n\t\t\tif(!this.resolved) {\n\t\t\t\ttasks.enqueue(new ProgressTask(x, this));\n\t\t\t}\n\t\t};\n\n\t\tPending.prototype.fail = function(context) {\n\t\t\tvar c = typeof context === 'undefined' ? this.context : context;\n\t\t\tthis.resolved && this.handler.join().fail(c);\n\t\t};\n\n\t\tPending.prototype._report = function(context) {\n\t\t\tthis.resolved && this.handler.join()._report(context);\n\t\t};\n\n\t\tPending.prototype._unreport = function() {\n\t\t\tthis.resolved && this.handler.join()._unreport();\n\t\t};\n\n\t\t/**\n\t\t * Wrap another handler and force it into a future stack\n\t\t * @param {object} handler\n\t\t * @constructor\n\t\t */\n\t\tfunction Async(handler) {\n\t\t\tthis.handler = handler;\n\t\t}\n\n\t\tinherit(Handler, Async);\n\n\t\tAsync.prototype.when = function(continuation) {\n\t\t\ttasks.enqueue(new ContinuationTask(continuation, this));\n\t\t};\n\n\t\tAsync.prototype._report = function(context) {\n\t\t\tthis.join()._report(context);\n\t\t};\n\n\t\tAsync.prototype._unreport = function() {\n\t\t\tthis.join()._unreport();\n\t\t};\n\n\t\t/**\n\t\t * Handler that wraps an untrusted thenable and assimilates it in a future stack\n\t\t * @param {function} then\n\t\t * @param {{then: function}} thenable\n\t\t * @constructor\n\t\t */\n\t\tfunction Thenable(then, thenable) {\n\t\t\tPending.call(this);\n\t\t\ttasks.enqueue(new AssimilateTask(then, thenable, this));\n\t\t}\n\n\t\tinherit(Pending, Thenable);\n\n\t\t/**\n\t\t * Handler for a fulfilled promise\n\t\t * @param {*} x fulfillment value\n\t\t * @constructor\n\t\t */\n\t\tfunction Fulfilled(x) {\n\t\t\tPromise.createContext(this);\n\t\t\tthis.value = x;\n\t\t}\n\n\t\tinherit(Handler, Fulfilled);\n\n\t\tFulfilled.prototype._state = 1;\n\n\t\tFulfilled.prototype.fold = function(f, z, c, to) {\n\t\t\trunContinuation3(f, z, this, c, to);\n\t\t};\n\n\t\tFulfilled.prototype.when = function(cont) {\n\t\t\trunContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);\n\t\t};\n\n\t\tvar errorId = 0;\n\n\t\t/**\n\t\t * Handler for a rejected promise\n\t\t * @param {*} x rejection reason\n\t\t * @constructor\n\t\t */\n\t\tfunction Rejected(x) {\n\t\t\tPromise.createContext(this);\n\n\t\t\tthis.id = ++errorId;\n\t\t\tthis.value = x;\n\t\t\tthis.handled = false;\n\t\t\tthis.reported = false;\n\n\t\t\tthis._report();\n\t\t}\n\n\t\tinherit(Handler, Rejected);\n\n\t\tRejected.prototype._state = -1;\n\n\t\tRejected.prototype.fold = function(f, z, c, to) {\n\t\t\tto.become(this);\n\t\t};\n\n\t\tRejected.prototype.when = function(cont) {\n\t\t\tif(typeof cont.rejected === 'function') {\n\t\t\t\tthis._unreport();\n\t\t\t}\n\t\t\trunContinuation1(cont.rejected, this, cont.receiver, cont.resolver);\n\t\t};\n\n\t\tRejected.prototype._report = function(context) {\n\t\t\ttasks.afterQueue(new ReportTask(this, context));\n\t\t};\n\n\t\tRejected.prototype._unreport = function() {\n\t\t\tthis.handled = true;\n\t\t\ttasks.afterQueue(new UnreportTask(this));\n\t\t};\n\n\t\tRejected.prototype.fail = function(context) {\n\t\t\tPromise.onFatalRejection(this, context === void 0 ? this.context : context);\n\t\t};\n\n\t\tfunction ReportTask(rejection, context) {\n\t\t\tthis.rejection = rejection;\n\t\t\tthis.context = context;\n\t\t}\n\n\t\tReportTask.prototype.run = function() {\n\t\t\tif(!this.rejection.handled) {\n\t\t\t\tthis.rejection.reported = true;\n\t\t\t\tPromise.onPotentiallyUnhandledRejection(this.rejection, this.context);\n\t\t\t}\n\t\t};\n\n\t\tfunction UnreportTask(rejection) {\n\t\t\tthis.rejection = rejection;\n\t\t}\n\n\t\tUnreportTask.prototype.run = function() {\n\t\t\tif(this.rejection.reported) {\n\t\t\t\tPromise.onPotentiallyUnhandledRejectionHandled(this.rejection);\n\t\t\t}\n\t\t};\n\n\t\t// Unhandled rejection hooks\n\t\t// By default, everything is a noop\n\n\t\t// TODO: Better names: \"annotate\"?\n\t\tPromise.createContext\n\t\t\t= Promise.enterContext\n\t\t\t= Promise.exitContext\n\t\t\t= Promise.onPotentiallyUnhandledRejection\n\t\t\t= Promise.onPotentiallyUnhandledRejectionHandled\n\t\t\t= Promise.onFatalRejection\n\t\t\t= noop;\n\n\t\t// Errors and singletons\n\n\t\tvar foreverPendingHandler = new Handler();\n\t\tvar foreverPendingPromise = new Promise(Handler, foreverPendingHandler);\n\n\t\tfunction cycle() {\n\t\t\treturn new Rejected(new TypeError('Promise cycle'));\n\t\t}\n\n\t\t// Task runners\n\n\t\t/**\n\t\t * Run a single consumer\n\t\t * @constructor\n\t\t */\n\t\tfunction ContinuationTask(continuation, handler) {\n\t\t\tthis.continuation = continuation;\n\t\t\tthis.handler = handler;\n\t\t}\n\n\t\tContinuationTask.prototype.run = function() {\n\t\t\tthis.handler.join().when(this.continuation);\n\t\t};\n\n\t\t/**\n\t\t * Run a queue of progress handlers\n\t\t * @constructor\n\t\t */\n\t\tfunction ProgressTask(value, handler) {\n\t\t\tthis.handler = handler;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tProgressTask.prototype.run = function() {\n\t\t\tvar q = this.handler.consumers;\n\t\t\tif(q === void 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var c, i = 0; i < q.length; ++i) {\n\t\t\t\tc = q[i];\n\t\t\t\trunNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Assimilate a thenable, sending it's value to resolver\n\t\t * @param {function} then\n\t\t * @param {object|function} thenable\n\t\t * @param {object} resolver\n\t\t * @constructor\n\t\t */\n\t\tfunction AssimilateTask(then, thenable, resolver) {\n\t\t\tthis._then = then;\n\t\t\tthis.thenable = thenable;\n\t\t\tthis.resolver = resolver;\n\t\t}\n\n\t\tAssimilateTask.prototype.run = function() {\n\t\t\tvar h = this.resolver;\n\t\t\ttryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);\n\n\t\t\tfunction _resolve(x) { h.resolve(x); }\n\t\t\tfunction _reject(x)  { h.reject(x); }\n\t\t\tfunction _notify(x)  { h.notify(x); }\n\t\t};\n\n\t\tfunction tryAssimilate(then, thenable, resolve, reject, notify) {\n\t\t\ttry {\n\t\t\t\tthen.call(thenable, resolve, reject, notify);\n\t\t\t} catch (e) {\n\t\t\t\treject(e);\n\t\t\t}\n\t\t}\n\n\t\t// Other helpers\n\n\t\t/**\n\t\t * @param {*} x\n\t\t * @returns {boolean} true iff x is a trusted Promise\n\t\t */\n\t\tfunction isPromise(x) {\n\t\t\treturn x instanceof Promise;\n\t\t}\n\n\t\t/**\n\t\t * Test just enough to rule out primitives, in order to take faster\n\t\t * paths in some code\n\t\t * @param {*} x\n\t\t * @returns {boolean} false iff x is guaranteed *not* to be a thenable\n\t\t */\n\t\tfunction maybeThenable(x) {\n\t\t\treturn (typeof x === 'object' || typeof x === 'function') && x !== null;\n\t\t}\n\n\t\tfunction runContinuation1(f, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.become(h);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReject(f, h.value, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\tfunction runContinuation3(f, x, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.become(h);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReject3(f, x, h.value, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\tfunction runNotify(f, x, h, receiver, next) {\n\t\t\tif(typeof f !== 'function') {\n\t\t\t\treturn next.notify(x);\n\t\t\t}\n\n\t\t\tPromise.enterContext(h);\n\t\t\ttryCatchReturn(f, x, receiver, next);\n\t\t\tPromise.exitContext();\n\t\t}\n\n\t\t/**\n\t\t * Return f.call(thisArg, x), or if it throws return a rejected promise for\n\t\t * the thrown exception\n\t\t */\n\t\tfunction tryCatchReject(f, x, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tnext.become(getHandler(f.call(thisArg, x)));\n\t\t\t} catch(e) {\n\t\t\t\tnext.become(new Rejected(e));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Same as above, but includes the extra argument parameter.\n\t\t */\n\t\tfunction tryCatchReject3(f, x, y, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tf.call(thisArg, x, y, next);\n\t\t\t} catch(e) {\n\t\t\t\tnext.become(new Rejected(e));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Return f.call(thisArg, x), or if it throws, *return* the exception\n\t\t */\n\t\tfunction tryCatchReturn(f, x, thisArg, next) {\n\t\t\ttry {\n\t\t\t\tnext.notify(f.call(thisArg, x));\n\t\t\t} catch(e) {\n\t\t\t\tnext.notify(e);\n\t\t\t}\n\t\t}\n\n\t\tfunction inherit(Parent, Child) {\n\t\t\tChild.prototype = objectCreate(Parent.prototype);\n\t\t\tChild.prototype.constructor = Child;\n\t\t}\n\n\t\tfunction noop() {}\n\n\t\treturn Promise;\n\t};\n});\n}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));\n","/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule CSSCore\n * @typechecks\n */\n\nvar invariant = require(\"./invariant\");\n\n/**\n * The CSSCore module specifies the API (and implements most of the methods)\n * that should be used when dealing with the display of elements (via their\n * CSS classes and visibility on screen. It is an API focused on mutating the\n * display and not reading it as no logical state should be encoded in the\n * display of elements.\n */\n\nvar CSSCore = {\n\n  /**\n   * Adds the class passed in to the element if it doesn't already have it.\n   *\n   * @param {DOMElement} element the element to set the class on\n   * @param {string} className the CSS className\n   * @return {DOMElement} the element passed in\n   */\n  addClass: function(element, className) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      !/\\s/.test(className),\n      'CSSCore.addClass takes only a single class name. \"%s\" contains ' +\n      'multiple classes.', className\n    ) : invariant(!/\\s/.test(className)));\n\n    if (className) {\n      if (element.classList) {\n        element.classList.add(className);\n      } else if (!CSSCore.hasClass(element, className)) {\n        element.className = element.className + ' ' + className;\n      }\n    }\n    return element;\n  },\n\n  /**\n   * Removes the class passed in from the element\n   *\n   * @param {DOMElement} element the element to set the class on\n   * @param {string} className the CSS className\n   * @return {DOMElement} the element passed in\n   */\n  removeClass: function(element, className) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      !/\\s/.test(className),\n      'CSSCore.removeClass takes only a single class name. \"%s\" contains ' +\n      'multiple classes.', className\n    ) : invariant(!/\\s/.test(className)));\n\n    if (className) {\n      if (element.classList) {\n        element.classList.remove(className);\n      } else if (CSSCore.hasClass(element, className)) {\n        element.className = element.className\n          .replace(new RegExp('(^|\\\\s)' + className + '(?:\\\\s|$)', 'g'), '$1')\n          .replace(/\\s+/g, ' ') // multiple spaces to one\n          .replace(/^\\s*|\\s*$/g, ''); // trim the ends\n      }\n    }\n    return element;\n  },\n\n  /**\n   * Helper to add or remove a class from an element based on a condition.\n   *\n   * @param {DOMElement} element the element to set the class on\n   * @param {string} className the CSS className\n   * @param {*} bool condition to whether to add or remove the class\n   * @return {DOMElement} the element passed in\n   */\n  conditionClass: function(element, className, bool) {\n    return (bool ? CSSCore.addClass : CSSCore.removeClass)(element, className);\n  },\n\n  /**\n   * Tests whether the element has the class specified.\n   *\n   * @param {DOMNode|DOMWindow} element the element to set the class on\n   * @param {string} className the CSS className\n   * @return {boolean} true if the element has the class, false if not\n   */\n  hasClass: function(element, className) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      !/\\s/.test(className),\n      'CSS.hasClass takes only a single class name.'\n    ) : invariant(!/\\s/.test(className)));\n    if (element.classList) {\n      return !!className && element.classList.contains(className);\n    }\n    return (' ' + element.className + ' ').indexOf(' ' + className + ' ') > -1;\n  }\n\n};\n\nmodule.exports = CSSCore;\n","/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ExecutionEnvironment\n */\n\n/*jslint evil: true */\n\n\"use strict\";\n\nvar canUseDOM = !!(\n  typeof window !== 'undefined' &&\n  window.document &&\n  window.document.createElement\n);\n\n/**\n * Simple, lightweight module assisting with the detection and context of\n * Worker. Helps avoid circular dependencies and allows code to reason about\n * whether or not they are in a Worker, even if they never include the main\n * `ReactWorker` dependency.\n */\nvar ExecutionEnvironment = {\n\n  canUseDOM: canUseDOM,\n\n  canUseWorkers: typeof Worker !== 'undefined',\n\n  canUseEventListeners:\n    canUseDOM && !!(window.addEventListener || window.attachEvent),\n\n  canUseViewport: canUseDOM && !!window.screen,\n\n  isInWorker: !canUseDOM // For now, this is true - might change in the future.\n\n};\n\nmodule.exports = ExecutionEnvironment;\n","/**\n * Copyright 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Object.assign\n */\n\n// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign\n\nfunction assign(target, sources) {\n  if (target == null) {\n    throw new TypeError('Object.assign target cannot be null or undefined');\n  }\n\n  var to = Object(target);\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {\n    var nextSource = arguments[nextIndex];\n    if (nextSource == null) {\n      continue;\n    }\n\n    var from = Object(nextSource);\n\n    // We don't currently support accessors nor proxies. Therefore this\n    // copy cannot throw. If we ever supported this then we must handle\n    // exceptions and side-effects. We don't support symbols so they won't\n    // be transferred.\n\n    for (var key in from) {\n      if (hasOwnProperty.call(from, key)) {\n        to[key] = from[key];\n      }\n    }\n  }\n\n  return to;\n};\n\nmodule.exports = assign;\n","/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactTransitionEvents\n */\n\n\"use strict\";\n\nvar ExecutionEnvironment = require(\"./ExecutionEnvironment\");\n\n/**\n * EVENT_NAME_MAP is used to determine which event fired when a\n * transition/animation ends, based on the style property used to\n * define that event.\n */\nvar EVENT_NAME_MAP = {\n  transitionend: {\n    'transition': 'transitionend',\n    'WebkitTransition': 'webkitTransitionEnd',\n    'MozTransition': 'mozTransitionEnd',\n    'OTransition': 'oTransitionEnd',\n    'msTransition': 'MSTransitionEnd'\n  },\n\n  animationend: {\n    'animation': 'animationend',\n    'WebkitAnimation': 'webkitAnimationEnd',\n    'MozAnimation': 'mozAnimationEnd',\n    'OAnimation': 'oAnimationEnd',\n    'msAnimation': 'MSAnimationEnd'\n  }\n};\n\nvar endEvents = [];\n\nfunction detectEvents() {\n  var testEl = document.createElement('div');\n  var style = testEl.style;\n\n  // On some platforms, in particular some releases of Android 4.x,\n  // the un-prefixed \"animation\" and \"transition\" properties are defined on the\n  // style object but the events that fire will still be prefixed, so we need\n  // to check if the un-prefixed events are useable, and if not remove them\n  // from the map\n  if (!('AnimationEvent' in window)) {\n    delete EVENT_NAME_MAP.animationend.animation;\n  }\n\n  if (!('TransitionEvent' in window)) {\n    delete EVENT_NAME_MAP.transitionend.transition;\n  }\n\n  for (var baseEventName in EVENT_NAME_MAP) {\n    var baseEvents = EVENT_NAME_MAP[baseEventName];\n    for (var styleName in baseEvents) {\n      if (styleName in style) {\n        endEvents.push(baseEvents[styleName]);\n        break;\n      }\n    }\n  }\n}\n\nif (ExecutionEnvironment.canUseDOM) {\n  detectEvents();\n}\n\n// We use the raw {add|remove}EventListener() call because EventListener\n// does not know how to remove event listeners and we really should\n// clean up. Also, these events are not triggered in older browsers\n// so we should be A-OK here.\n\nfunction addEventListener(node, eventName, eventListener) {\n  node.addEventListener(eventName, eventListener, false);\n}\n\nfunction removeEventListener(node, eventName, eventListener) {\n  node.removeEventListener(eventName, eventListener, false);\n}\n\nvar ReactTransitionEvents = {\n  addEndEventListener: function(node, eventListener) {\n    if (endEvents.length === 0) {\n      // If CSS transitions are not supported, trigger an \"end animation\"\n      // event immediately.\n      window.setTimeout(eventListener, 0);\n      return;\n    }\n    endEvents.forEach(function(endEvent) {\n      addEventListener(node, endEvent, eventListener);\n    });\n  },\n\n  removeEndEventListener: function(node, eventListener) {\n    if (endEvents.length === 0) {\n      return;\n    }\n    endEvents.forEach(function(endEvent) {\n      removeEventListener(node, endEvent, eventListener);\n    });\n  }\n};\n\nmodule.exports = ReactTransitionEvents;\n","/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule cx\n */\n\n/**\n * This function is used to mark string literals representing CSS class names\n * so that they can be transformed statically. This allows for modularization\n * and minification of CSS class names.\n *\n * In static_upstream, this function is actually implemented, but it should\n * eventually be replaced with something more descriptive, and the transform\n * that is used in the main stack should be ported for use elsewhere.\n *\n * @param string|object className to modularize, or an object of key/values.\n *                      In the object case, the values are conditions that\n *                      determine if the className keys should be included.\n * @param [string ...]  Variable list of classNames in the string case.\n * @return string       Renderable space-separated CSS className.\n */\nfunction cx(classNames) {\n  if (typeof classNames == 'object') {\n    return Object.keys(classNames).filter(function(className) {\n      return classNames[className];\n    }).join(' ');\n  } else {\n    return Array.prototype.join.call(arguments, ' ');\n  }\n}\n\nmodule.exports = cx;\n","/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule emptyFunction\n */\n\nfunction makeEmptyFunction(arg) {\n  return function() {\n    return arg;\n  };\n}\n\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\nfunction emptyFunction() {}\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\nemptyFunction.thatReturnsThis = function() { return this; };\nemptyFunction.thatReturnsArgument = function(arg) { return arg; };\n\nmodule.exports = emptyFunction;\n","/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule invariant\n */\n\n\"use strict\";\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (\"production\" !== process.env.NODE_ENV) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        'Invariant Violation: ' +\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n","/**\n * Copyright 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule warning\n */\n\n\"use strict\";\n\nvar emptyFunction = require(\"./emptyFunction\");\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = emptyFunction;\n\nif (\"production\" !== process.env.NODE_ENV) {\n  warning = function(condition, format ) {for (var args=[],$__0=2,$__1=arguments.length;$__0<$__1;$__0++) args.push(arguments[$__0]);\n    if (format === undefined) {\n      throw new Error(\n        '`warning(condition, format, ...args)` requires a warning ' +\n        'message argument'\n      );\n    }\n\n    if (!condition) {\n      var argIndex = 0;\n      console.warn('Warning: ' + format.replace(/%s/g, function()  {return args[argIndex++];}));\n    }\n  };\n}\n\nmodule.exports = warning;\n","module.exports={\n  \"name\": \"immutable\",\n  \"version\": \"4.0.0-rc.12\",\n  \"description\": \"Immutable Data Collections\",\n  \"license\": \"MIT\",\n  \"homepage\": \"https://immutable-js.com\",\n  \"author\": {\n    \"name\": \"Lee Byron\",\n    \"url\": \"https://github.com/leebyron\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/immutable-js/immutable-js.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/immutable-js/immutable-js/issues\"\n  },\n  \"main\": \"dist/immutable.js\",\n  \"module\": \"dist/immutable.es.js\",\n  \"typings\": \"dist/immutable-nonambient.d.ts\",\n  \"typescript\": {\n    \"definition\": \"dist/immutable.d.ts\"\n  },\n  \"scripts\": {\n    \"build\": \"run-s build:*\",\n    \"build:dist\": \"run-s clean:dist bundle:dist bundle:es copy:dist stats:dist prepare:dist\",\n    \"build:pages\": \"gulp --gulpfile ./resources/gulpfile.js default\",\n    \"stats:dist\": \"node ./resources/dist-stats.js\",\n    \"clean:dist\": \"rimraf dist\",\n    \"bundle:dist\": \"rollup -c ./resources/rollup-config.js\",\n    \"bundle:es\": \"rollup -c ./resources/rollup-config-es.js\",\n    \"copy:dist\": \"node ./resources/copy-dist-typedefs.js\",\n    \"prepare:dist\": \"./resources/prepare-dist.sh\",\n    \"format\": \"npm run lint:format -- --write\",\n    \"lint\": \"run-s lint:*\",\n    \"lint:ts\": \"tslint \\\"__tests__/**/*.ts\\\"\",\n    \"lint:js\": \"eslint \\\"{__tests__,src,pages/src,pages/lib}/**/*.js\\\"\",\n    \"lint:format\": \"prettier --check \\\"{__tests__,src,pages/src,pages/lib,perf,resources}/**/*{\\\\.js,\\\\.ts}\\\"\",\n    \"testonly\": \"./resources/jest\",\n    \"test\": \"run-s format build lint testonly test:types\",\n    \"test:travis\": \"npm run test && npm run check:git-clean\",\n    \"check:git-clean\": \"./resources/check-changes\",\n    \"test:types\": \"run-s test:types:*\",\n    \"test:types:ts\": \"tsc ./type-definitions/Immutable.d.ts --lib es2015 && dtslint type-definitions/ts-tests\",\n    \"test:types:flow\": \"flow check type-definitions/tests --include-warnings\",\n    \"perf\": \"node ./resources/bench.js\",\n    \"start\": \"gulp --gulpfile ./resources/gulpfile.js dev\"\n  },\n  \"prettier\": {\n    \"singleQuote\": true,\n    \"trailingComma\": \"es5\",\n    \"semi\": true,\n    \"arrowParens\": \"avoid\"\n  },\n  \"jest\": {\n    \"moduleFileExtensions\": [\n      \"js\",\n      \"ts\"\n    ],\n    \"transform\": {\n      \"^.+\\\\.ts$\": \"<rootDir>/resources/jestPreprocessor.js\"\n    },\n    \"testRegex\": \"/__tests__/.*\\\\.(ts|js)$\",\n    \"unmockedModulePathPatterns\": [\n      \"./node_modules/react\"\n    ]\n  },\n  \"devDependencies\": {\n    \"benchmark\": \"2.1.4\",\n    \"browser-sync\": \"^2.26.12\",\n    \"browserify\": \"16.5.2\",\n    \"colors\": \"1.4.0\",\n    \"del\": \"6.0.0\",\n    \"dtslint\": \"4.1.0\",\n    \"eslint\": \"7.11.0\",\n    \"eslint-config-airbnb\": \"18.2.0\",\n    \"eslint-config-prettier\": \"6.12.0\",\n    \"eslint-plugin-import\": \"2.22.1\",\n    \"eslint-plugin-jsx-a11y\": \"6.3.1\",\n    \"eslint-plugin-prettier\": \"3.1.4\",\n    \"eslint-plugin-react\": \"7.21.4\",\n    \"flow-bin\": \"0.85.0\",\n    \"gulp\": \"4.0.2\",\n    \"gulp-concat\": \"2.6.1\",\n    \"gulp-filter\": \"6.0.0\",\n    \"gulp-header\": \"2.0.9\",\n    \"gulp-less\": \"4.0.1\",\n    \"gulp-size\": \"3.0.0\",\n    \"gulp-sourcemaps\": \"2.6.5\",\n    \"gulp-uglify\": \"3.0.2\",\n    \"gulp-util\": \"3.0.8\",\n    \"jasmine-check\": \"0.1.5\",\n    \"jest\": \"26.5.2\",\n    \"marked\": \"1.2.0\",\n    \"microtime\": \"3.0.0\",\n    \"mkdirp\": \"1.0.4\",\n    \"npm-run-all\": \"4.1.5\",\n    \"prettier\": \"^2.3.1\",\n    \"react\": \"^0.12.2\",\n    \"react-router\": \"^0.11.6\",\n    \"react-tools\": \"0.13.3\",\n    \"rimraf\": \"3.0.2\",\n    \"rollup\": \"2.29.0\",\n    \"rollup-plugin-buble\": \"0.19.2\",\n    \"rollup-plugin-commonjs\": \"9.1.3\",\n    \"rollup-plugin-json\": \"3.0.0\",\n    \"rollup-plugin-strip-banner\": \"2.0.0\",\n    \"through2\": \"4.0.2\",\n    \"transducers-js\": \"^0.4.174\",\n    \"tslint\": \"5.20.1\",\n    \"typescript\": \"3.0.3\",\n    \"uglify-js\": \"3.11.1\",\n    \"uglify-save-license\": \"0.4.1\",\n    \"vinyl-buffer\": \"1.0.1\",\n    \"vinyl-source-stream\": \"2.0.0\"\n  },\n  \"files\": [\n    \"dist\",\n    \"contrib\",\n    \"README.md\",\n    \"LICENSE\"\n  ],\n  \"keywords\": [\n    \"immutable\",\n    \"persistent\",\n    \"lazy\",\n    \"data\",\n    \"datastructure\",\n    \"functional\",\n    \"collection\",\n    \"stateless\",\n    \"sequence\",\n    \"iteration\"\n  ]\n}\n","module.exports={\"Immutable\":{\"doc\":{\"synopsis\":\"Immutable data encourages pure functions (data-in, data-out) and lends itself\\nto much simpler application development and enabling techniques from\\nfunctional programming such as lazy evaluation.\",\"description\":\"While designed to bring these powerful functional concepts to JavaScript, it\\npresents an Object-Oriented API familiar to Javascript engineers and closely\\nmirroring that of Array, Map, and Set. It is easy and efficient to convert to\\nand from plain Javascript types.\\n\\n## How to read these docs\\n\\nIn order to better explain what kinds of values the Immutable.js API expects\\nand produces, this documentation is presented in a statically typed dialect of\\nJavaScript (like [Flow][] or [TypeScript][]). You *don't need* to use these\\ntype checking tools in order to use Immutable.js, however becoming familiar\\nwith their syntax will help you get a deeper understanding of this API.\\n\\n**A few examples and how to read them.**\\n\\nAll methods describe the kinds of data they accept and the kinds of data\\nthey return. For example a function which accepts two numbers and returns\\na number would look like this:\\n\\n```js\\nsum(first: number, second: number): number\\n```\\n\\nSometimes, methods can accept different kinds of data or return different\\nkinds of data, and this is described with a *type variable*, which is\\ntypically in all-caps. For example, a function which always returns the same\\nkind of data it was provided would look like this:\\n\\n```js\\nidentity<T>(value: T): T\\n```\\n\\nType variables are defined with classes and referred to in methods. For\\nexample, a class that holds onto a value for you might look like this:\\n\\n```js\\nclass Box<T> {\\n  constructor(value: T)\\n  getValue(): T\\n}\\n```\\n\\nIn order to manipulate Immutable data, methods that we're used to affecting\\na Collection instead return a new Collection of the same type. The type\\n`this` refers to the same kind of class. For example, a List which returns\\nnew Lists when you `push` a value onto it might look like:\\n\\n```js\\nclass List<T> {\\n  push(value: T): this\\n}\\n```\\n\\nMany methods in Immutable.js accept values which implement the JavaScript\\n[Iterable][] protocol, and might appear like `Iterable<string>` for something\\nwhich represents sequence of strings. Typically in JavaScript we use plain\\nArrays (`[]`) when an Iterable is expected, but also all of the Immutable.js\\ncollections are iterable themselves!\\n\\nFor example, to get a value deep within a structure of data, we might use\\n`getIn` which expects an `Iterable` path:\\n\\n```\\ngetIn(path: Iterable<string | number>): unknown\\n```\\n\\nTo use this method, we could pass an array: `data.getIn([ \\\"key\\\", 2 ])`.\\n\\n\\nNote: All examples are presented in the modern [ES2015][] version of\\nJavaScript. Use tools like Babel to support older browsers.\\n\\nFor example:\\n\\n```js\\n// ES2015\\nconst mappedFoo = foo.map(x => x * x);\\n// ES5\\nvar mappedFoo = foo.map(function (x) { return x * x; });\\n```\\n\\n[ES2015]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla\\n[TypeScript]: http://www.typescriptlang.org/\\n[Flow]: https://flowtype.org/\\n[Iterable]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\",\"notes\":[]},\"module\":{\"List\":{\"doc\":{\"synopsis\":\"Lists are ordered indexed dense collections, much like a JavaScript\\nArray.\",\"description\":\"Lists are immutable and fully persistent with O(log32 N) gets and sets,\\nand O(1) push and pop.\\n\\nLists implement Deque, with efficient addition and removal from both the\\nend (`push`, `pop`) and beginning (`unshift`, `shift`).\\n\\nUnlike a JavaScript Array, there is no distinction between an\\n\\\"unset\\\" index and an index set to `undefined`. `List#forEach` visits all\\nindices from 0 to size, regardless of whether they were explicitly defined.\",\"notes\":[]},\"module\":{\"isList\":{\"call\":{\"doc\":{\"synopsis\":\"True if the provided value is a List\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable');\\nList.isList([]); // false\\nList.isList(List()); // true\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeList\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":120}]}},\"of\":{\"call\":{\"doc\":{\"synopsis\":\"Creates a new List containing `values`.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable');\\nList.of(1, 2, 3, 4)\\n// List [ 1, 2, 3, 4 ]\\n```\\n\\nNote: Values are not altered or converted in any way.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable');\\nList.of({x:1}, 2, [3], 4)\\n// List [ { x: 1 }, 2, [ 3 ], 4 ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":141}]}}},\"call\":{\"doc\":{\"synopsis\":\"Create a new immutable List containing the values of the provided\\ncollection-like.\",\"description\":\"Note: `List` is a factory function and not a class, and does not use the\\n`new` keyword during construction.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { List, Set } = require('immutable')\\n\\nconst emptyList = List()\\n// List []\\n\\nconst plainArray = [ 1, 2, 3, 4 ]\\nconst listFromPlainArray = List(plainArray)\\n// List [ 1, 2, 3, 4 ]\\n\\nconst plainSet = Set([ 1, 2, 3, 4 ])\\nconst listFromPlainSet = List(plainSet)\\n// List [ 1, 2, 3, 4 ]\\n\\nconst arrayIterator = plainArray[Symbol.iterator]()\\nconst listFromCollectionArray = List(arrayIterator)\\n// List [ 1, 2, 3, 4 ]\\n\\nlistFromPlainArray.equals(listFromCollectionArray) // true\\nlistFromPlainSet.equals(listFromCollectionArray) // true\\nlistFromPlainSet.equals(listFromPlainArray) // true\\n```\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":17}]},\"line\":175},{\"typeParams\":[\"T\"],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":176},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":177}]},\"interface\":{\"line\":179,\"typeParams\":[\"T\"],\"extends\":[{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]}],\"groups\":[{\"members\":{\"#size\":{\"line\":184}}},{\"title\":\"Persistent changes\",\"members\":{\"#set\":{\"doc\":{\"synopsis\":\"Returns a new List which includes `value` at `index`. If `index` already\\nexists in this List, it will be replaced.\",\"description\":\"`index` may be a negative number, which indexes back from the end of the\\nList. `v.set(-1, \\\"value\\\")` sets the last item in the List.\\n\\nIf `index` larger than `size`, the returned List's `size` will be large\\nenough to include the `index`.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nconst originalList = List([ 0 ]);\\n// List [ 0 ]\\noriginalList.set(1, 1);\\n// List [ 0, 1 ]\\noriginalList.set(0, 'overwritten');\\n// List [ \\\"overwritten\\\" ]\\noriginalList.set(2, 2);\\n// List [ 0, undefined, 2 ]\\n\\nList().set(50000, 'value').size;\\n// 50001\\n```\\n\\nNote: `set` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":217}]},\"#delete\":{\"doc\":{\"synopsis\":\"Returns a new List which excludes this `index` and with a size 1 less\\nthan this List. Values at indices above `index` are shifted down by 1 to\\nfill the position.\",\"description\":\"This is synonymous with `list.splice(index, 1)`.\\n\\n`index` may be a negative number, which indexes back from the end of the\\nList. `v.delete(-1)` deletes the last item in the List.\\n\\nNote: `delete` cannot be safely used in IE8\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nList([ 0, 1, 2, 3, 4 ]).delete(0);\\n// List [ 1, 2, 3, 4 ]\\n```\\n\\nSince `delete()` re-indexes values, it produces a complete copy, which\\nhas `O(N)` complexity.\\n\\nNote: `delete` *cannot* be used in `withMutations`.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"remove\"}]},\"signatures\":[{\"params\":[{\"name\":\"index\",\"type\":{\"k\":2}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":246}]},\"#insert\":{\"doc\":{\"synopsis\":\"Returns a new List with `value` at `index` with a size 1 more than this\\nList. Values at indices above `index` are shifted over by 1.\",\"description\":\"This is synonymous with `list.splice(index, 0, value)`.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nList([ 0, 1, 2, 3, 4 ]).insert(6, 5)\\n// List [ 0, 1, 2, 3, 4, 5 ]\\n```\\n\\nSince `insert()` re-indexes values, it produces a complete copy, which\\nhas `O(N)` complexity.\\n\\nNote: `insert` *cannot* be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":268}]},\"#clear\":{\"doc\":{\"synopsis\":\"Returns a new List with 0 size and no values in constant time.\",\"description\":\"<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nList([ 1, 2, 3, 4 ]).clear()\\n// List []\\n```\\n\\nNote: `clear` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":283}]},\"#push\":{\"doc\":{\"synopsis\":\"Returns a new List with the provided `values` appended, starting at this\\nList's `size`.\",\"description\":\"<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nList([ 1, 2, 3, 4 ]).push(5)\\n// List [ 1, 2, 3, 4, 5 ]\\n```\\n\\nNote: `push` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":299}]},\"#pop\":{\"doc\":{\"synopsis\":\"Returns a new List with a size ones less than this List, excluding\\nthe last index in this List.\",\"description\":\"Note: this differs from `Array#pop` because it returns a new\\nList rather than the removed value. Use `last()` to get the last value\\nin this List.\\n\\n```js\\nList([ 1, 2, 3, 4 ]).pop()\\n// List[ 1, 2, 3 ]\\n```\\n\\nNote: `pop` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":316}]},\"#unshift\":{\"doc\":{\"synopsis\":\"Returns a new List with the provided `values` prepended, shifting other\\nvalues ahead to higher indices.\",\"description\":\"<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nList([ 2, 3, 4]).unshift(1);\\n// List [ 1, 2, 3, 4 ]\\n```\\n\\nNote: `unshift` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":332}]},\"#shift\":{\"doc\":{\"synopsis\":\"Returns a new List with a size ones less than this List, excluding\\nthe first index in this List, shifting all other values to a lower index.\",\"description\":\"Note: this differs from `Array#shift` because it returns a new\\nList rather than the removed value. Use `first()` to get the first\\nvalue in this List.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nList([ 0, 1, 2, 3, 4 ]).shift();\\n// List [ 1, 2, 3, 4 ]\\n```\\n\\nNote: `shift` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":352}]},\"#update\":{\"doc\":{\"synopsis\":\"Returns a new List with an updated value at `index` with the return\\nvalue of calling `updater` with the existing value, or `notSetValue` if\\n`index` was not set. If called with a single argument, `updater` is\\ncalled with the List itself.\",\"description\":\"`index` may be a negative number, which indexes back from the end of the\\nList. `v.update(-1)` updates the last item in the List.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nconst list = List([ 'a', 'b', 'c' ])\\nconst result = list.update(2, val => val.toUpperCase())\\n// List [ \\\"a\\\", \\\"b\\\", \\\"C\\\" ]\\n```\\n\\nThis can be very useful as a way to \\\"chain\\\" a normal function into a\\nsequence of methods. RxJS calls this \\\"let\\\" and lodash calls it \\\"thru\\\".\\n\\nFor example, to sum a List after mapping and filtering:\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nfunction sum(collection) {\\n  return collection.reduce((sum, x) => sum + x, 0)\\n}\\n\\nList([ 1, 2, 3 ])\\n  .map(x => x + 1)\\n  .filter(x => x % 2 === 0)\\n  .update(sum)\\n// 6\\n```\\n\\nNote: `update(index)` can be used in `withMutations`.\\n\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#update`\"}]},\"signatures\":[{\"params\":[{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":8,\"param\":\"T\"}}}],\"type\":{\"k\":10},\"line\":396},{\"params\":[{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":8,\"param\":\"T\"}}}],\"type\":{\"k\":10},\"line\":397},{\"typeParams\":[\"R\"],\"params\":[{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"R\"}}}],\"type\":{\"k\":8,\"param\":\"R\"},\"line\":398}]},\"#setSize\":{\"doc\":{\"synopsis\":\"Returns a new List with size `size`. If `size` is less than this\\nList's size, the new List will exclude values at the higher indices.\\nIf `size` is greater than this List's size, the new List will have\\nundefined values for the newly available indices.\",\"description\":\"When building a new List and the final size is known up front, `setSize`\\nused in conjunction with `withMutations` may result in the more\\nperformant construction.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"size\",\"type\":{\"k\":2}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":410}]}}},{\"title\":\"Deep persistent changes\",\"members\":{\"#setIn\":{\"doc\":{\"synopsis\":\"Returns a new List having set `value` at this `keyPath`. If any keys in\\n`keyPath` do not exist, a new immutable Map will be created at that key.\",\"description\":\"Index numbers are used as keys to determine the path to follow in\\nthe List.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nconst list = List([ 0, 1, 2, List([ 3, 4 ])])\\nlist.setIn([3, 0], 999);\\n// List [ 0, 1, 2, List [ 999, 4 ] ]\\n```\\n\\nPlain JavaScript Object or Arrays may be nested within an Immutable.js\\nCollection, and setIn() can update those values as well, treating them\\nimmutably by creating new copies of those values with the changes applied.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nconst list = List([ 0, 1, 2, { plain: 'object' }])\\nlist.setIn([3, 'plain'], 'value');\\n// List([ 0, 1, 2, { plain: 'value' }])\\n```\\n\\nNote: `setIn` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":10},\"line\":444}]},\"#deleteIn\":{\"doc\":{\"synopsis\":\"Returns a new List having removed the value at this `keyPath`. If any\\nkeys in `keyPath` do not exist, no change will occur.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nconst list = List([ 0, 1, 2, List([ 3, 4 ])])\\nlist.deleteIn([3, 0]);\\n// List [ 0, 1, 2, List [ 4 ] ]\\n```\\n\\nPlain JavaScript Object or Arrays may be nested within an Immutable.js\\nCollection, and removeIn() can update those values as well, treating them\\nimmutably by creating new copies of those values with the changes applied.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nconst list = List([ 0, 1, 2, { plain: 'object' }])\\nlist.removeIn([3, 'plain']);\\n// List([ 0, 1, 2, {}])\\n```\\n\\nNote: `deleteIn` *cannot* be safely used in `withMutations`.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"removeIn\"}]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}}],\"type\":{\"k\":10},\"line\":474}]},\"#updateIn\":{\"doc\":{\"synopsis\":\"Note: `updateIn` can be used in `withMutations`.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#updateIn`\"}]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"notSetValue\",\"type\":{\"k\":17}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":482},{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":483}]},\"#mergeIn\":{\"doc\":{\"synopsis\":\"Note: `mergeIn` can be used in `withMutations`.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#mergeIn`\"}]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":490}]},\"#mergeDeepIn\":{\"doc\":{\"synopsis\":\"Note: `mergeDeepIn` can be used in `withMutations`.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#mergeDeepIn`\"}]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":497}]}}},{\"title\":\"Transient changes\",\"members\":{\"#withMutations\":{\"doc\":{\"synopsis\":\"Note: Not all methods can be safely used on a mutable collection or within\\n`withMutations`! Check the documentation for each method to see if it\\nallows being used in `withMutations`.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#withMutations`\"}]},\"signatures\":[{\"params\":[{\"name\":\"mutator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"mutable\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":508}]},\"#asMutable\":{\"doc\":{\"synopsis\":\"An alternative API for withMutations()\",\"description\":\"Note: Not all methods can be safely used on a mutable collection or within\\n`withMutations`! Check the documentation for each method to see if it\\nallows being used in `withMutations`.\\n\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asMutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":519}]},\"#wasAltered\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#wasAltered`\"}]},\"signatures\":[{\"type\":{\"k\":1},\"line\":524}]},\"#asImmutable\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asImmutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":529}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new List with other values or collections concatenated to this one.\",\"description\":\"Note: `concat` can be used in `withMutations`.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"merge\"}]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"valuesOrCollections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"C\"}]},{\"k\":8,\"param\":\"C\"}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":540}]},\"#map\":{\"doc\":{\"synopsis\":\"Returns a new List with values passed through a\\n`mapper` function.\",\"description\":\"<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nList([ 1, 2 ]).map(x => 10 * x)\\n// List [ 10, 20 ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":555}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the List, returning a new List.\",\"description\":\"Similar to `list.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":565}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new List with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"F\"}]},\"line\":577},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":581}]},\"#zip\":{\"doc\":{\"synopsis\":\"Returns a List \\\"zipped\\\" with the provided collection.\",\"description\":\"Like `zipWith`, but using the default `zipper`: creating an `Array`.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nconst a = List([ 1, 2, 3 ]);\\nconst b = List([ 4, 5, 6 ]);\\nconst c = a.zip(b); // List [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":600},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":601},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":17}]},\"line\":602}]},\"#zipAll\":{\"doc\":{\"synopsis\":\"Returns a List \\\"zipped\\\" with the provided collections.\",\"description\":\"Unlike `zip`, `zipAll` continues zipping until the longest collection is\\nexhausted. Missing values from shorter collections are filled with `undefined`.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nconst a = List([ 1, 2 ]);\\nconst b = List([ 3, 4, 5 ]);\\nconst c = a.zipAll(b); // List [ [ 1, 3 ], [ 2, 4 ], [ undefined, 5 ] ]\\n```\\n\\nNote: Since zipAll will return a collection as large as the largest\\ninput, some results may contain undefined values. TypeScript cannot\\naccount for these without cases (as of v2.5).\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":623},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":624},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":17}]},\"line\":625}]},\"#zipWith\":{\"doc\":{\"synopsis\":\"Returns a List \\\"zipped\\\" with the provided collections by using a\\ncustom `zipper` function.\",\"description\":\"<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable');\\\" }\\n-->\\n```js\\nconst a = List([ 1, 2, 3 ]);\\nconst b = List([ 4, 5, 6 ]);\\nconst c = a.zipWith((a, b) => a + b, b);\\n// List [ 5, 7, 9 ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":641},{\"typeParams\":[\"U\",\"V\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}},{\"name\":\"thirdValue\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"thirdCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":645},{\"typeParams\":[\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"any\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":650}]}}}]}},\"Map\":{\"doc\":{\"synopsis\":\"Immutable Map is an unordered Collection.Keyed of (key, value) pairs with\\n`O(log32 N)` gets and `O(log32 N)` persistent sets.\",\"description\":\"Iteration order of a Map is undefined, however is stable. Multiple\\niterations of the same Map will iterate in the same order.\\n\\nMap's keys can be of any type, and use `Immutable.is` to determine key\\nequality. This allows the use of any value (including NaN) as a key.\\n\\nBecause `Immutable.is` returns equality based on value semantics, and\\nImmutable collections are treated as values, any Immutable collection may\\nbe used as a key.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map, List } = require('immutable');\\nMap().set(List([ 1 ]), 'listofone').get(List([ 1 ]));\\n// 'listofone'\\n```\\n\\nAny JavaScript object may be used as a key, however strict identity is used\\nto evaluate key equality. Two similar looking objects will represent two\\ndifferent keys.\\n\\nImplemented by a hash-array mapped trie.\",\"notes\":[]},\"module\":{\"isMap\":{\"call\":{\"doc\":{\"synopsis\":\"True if the provided value is a Map\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap.isMap({}) // false\\nMap.isMap(Map()) // true\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeMap\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":696}]}}},\"call\":{\"doc\":{\"synopsis\":\"Creates a new Immutable Map.\",\"description\":\"Created with the same key value pairs as the provided Collection.Keyed or\\nJavaScript Object or expects a Collection of [K, V] tuple entries.\\n\\nNote: `Map` is a factory function and not a class, and does not use the\\n`new` keyword during construction.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap({ key: \\\"value\\\" })\\nMap([ [ \\\"key\\\", \\\"value\\\" ] ])\\n```\\n\\nKeep in mind, when using JS objects to construct Immutable Maps, that\\nJavaScript Object properties are always strings, even if written in a\\nquote-less shorthand, while Immutable Maps accept keys of any type.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable');\\\" }\\n-->\\n```js\\nlet obj = { 1: \\\"one\\\" }\\nObject.keys(obj) // [ \\\"1\\\" ]\\nassert.equal(obj[\\\"1\\\"], obj[1]) // \\\"one\\\" === \\\"one\\\"\\n\\nlet map = Map(obj)\\nassert.notEqual(map.get(\\\"1\\\"), map.get(1)) // \\\"one\\\" !== undefined\\n```\\n\\nProperty access for JavaScript Objects first converts the key to a string,\\nbut since Immutable Map keys can be of any type the argument to `get()` is\\nnot altered.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\",\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]}}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":753},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"obj\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":3},{\"k\":8,\"param\":\"V\"}]},\"line\":754},{\"typeParams\":[\"K\",\"V\"],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":755},{\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":17},{\"k\":17}]},\"line\":756}]},\"interface\":{\"line\":758,\"typeParams\":[\"K\",\"V\"],\"extends\":[{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}],\"groups\":[{\"members\":{\"#size\":{\"line\":763}}},{\"title\":\"Persistent changes\",\"members\":{\"#set\":{\"doc\":{\"synopsis\":\"Returns a new Map also containing the new key, value pair. If an equivalent\\nkey already exists in this Map, it will be replaced.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst originalMap = Map()\\nconst newerMap = originalMap.set('key', 'value')\\nconst newestMap = newerMap.set('key', 'newer value')\\n\\noriginalMap\\n// Map {}\\nnewerMap\\n// Map { \\\"key\\\": \\\"value\\\" }\\nnewestMap\\n// Map { \\\"key\\\": \\\"newer value\\\" }\\n```\\n\\nNote: `set` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":10},\"line\":788}]},\"#delete\":{\"doc\":{\"synopsis\":\"Returns a new Map which excludes this `key`.\",\"description\":\"Note: `delete` cannot be safely used in IE8, but is provided to mirror\\nthe ES6 collection API.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst originalMap = Map({\\n  key: 'value',\\n  otherKey: 'other value'\\n})\\n// Map { \\\"key\\\": \\\"value\\\", \\\"otherKey\\\": \\\"other value\\\" }\\noriginalMap.delete('otherKey')\\n// Map { \\\"key\\\": \\\"value\\\" }\\n```\\n\\nNote: `delete` can be used in `withMutations`.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"remove\"}]},\"signatures\":[{\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":10},\"line\":812}]},\"#deleteAll\":{\"doc\":{\"synopsis\":\"Returns a new Map which excludes the provided `keys`.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst names = Map({ a: \\\"Aaron\\\", b: \\\"Barry\\\", c: \\\"Connor\\\" })\\nnames.deleteAll([ 'a', 'c' ])\\n// Map { \\\"b\\\": \\\"Barry\\\" }\\n```\\n\\nNote: `deleteAll` can be used in `withMutations`.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"removeAll\"}]},\"signatures\":[{\"params\":[{\"name\":\"keys\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"K\"}]}}],\"type\":{\"k\":10},\"line\":830}]},\"#clear\":{\"doc\":{\"synopsis\":\"Returns a new Map containing no keys or values.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap({ key: 'value' }).clear()\\n// Map {}\\n```\\n\\nNote: `clear` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":845}]},\"#update\":{\"doc\":{\"synopsis\":\"Returns a new Map having updated the value at this `key` with the return\\nvalue of calling `updater` with the existing value.\",\"description\":\"Similar to: `map.set(key, updater(map.get(key)))`.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst aMap = Map({ key: 'value' })\\nconst newMap = aMap.update('key', value => value + value)\\n// Map { \\\"key\\\": \\\"valuevalue\\\" }\\n```\\n\\nThis is most commonly used to call methods on collections within a\\nstructure of data. For example, in order to `.push()` onto a nested `List`,\\n`update` and `push` can be used together:\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map, List } = require('immutable');\\\" }\\n-->\\n```js\\nconst aMap = Map({ nestedList: List([ 1, 2, 3 ]) })\\nconst newMap = aMap.update('nestedList', list => list.push(4))\\n// Map { \\\"nestedList\\\": List [ 1, 2, 3, 4 ] }\\n```\\n\\nWhen a `notSetValue` is provided, it is provided to the `updater`\\nfunction when the value at the key does not exist in the Map.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable');\\\" }\\n-->\\n```js\\nconst aMap = Map({ key: 'value' })\\nconst newMap = aMap.update('noKey', 'no value', value => value + value)\\n// Map { \\\"key\\\": \\\"value\\\", \\\"noKey\\\": \\\"no valueno value\\\" }\\n```\\n\\nHowever, if the `updater` function returns the same value it was called\\nwith, then no change will occur. This is still true if `notSetValue`\\nis provided.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable');\\\" }\\n-->\\n```js\\nconst aMap = Map({ apples: 10 })\\nconst newMap = aMap.update('oranges', 0, val => val)\\n// Map { \\\"apples\\\": 10 }\\nassert.strictEqual(newMap, map);\\n```\\n\\nFor code using ES2015 or later, using `notSetValue` is discourged in\\nfavor of function parameter default values. This helps to avoid any\\npotential confusion with identify functions as described above.\\n\\nThe previous example behaves differently when written with default values:\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable');\\\" }\\n-->\\n```js\\nconst aMap = Map({ apples: 10 })\\nconst newMap = aMap.update('oranges', (val = 0) => val)\\n// Map { \\\"apples\\\": 10, \\\"oranges\\\": 0 }\\n```\\n\\nIf no key is provided, then the `updater` function return value is\\nreturned as well.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable');\\\" }\\n-->\\n```js\\nconst aMap = Map({ key: 'value' })\\nconst result = aMap.update(aMap => aMap.get('key'))\\n// \\\"value\\\"\\n```\\n\\nThis can be very useful as a way to \\\"chain\\\" a normal function into a\\nsequence of methods. RxJS calls this \\\"let\\\" and lodash calls it \\\"thru\\\".\\n\\nFor example, to sum the values in a Map\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable');\\\" }\\n-->\\n```js\\nfunction sum(collection) {\\n  return collection.reduce((sum, x) => sum + x, 0)\\n}\\n\\nMap({ x: 1, y: 2, z: 3 })\\n  .map(x => x + 1)\\n  .filter(x => x % 2 === 0)\\n  .update(sum)\\n// 6\\n```\\n\\nNote: `update(key)` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"V\"}}}],\"type\":{\"k\":10},\"line\":949},{\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"V\"}}}],\"type\":{\"k\":10},\"line\":950},{\"typeParams\":[\"R\"],\"params\":[{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"R\"}}}],\"type\":{\"k\":8,\"param\":\"R\"},\"line\":951}]},\"#merge\":{\"doc\":{\"synopsis\":\"Returns a new Map resulting from merging the provided Collections\\n(or JS objects) into this Map. In other words, this takes each entry of\\neach collection and sets it on this Map.\",\"description\":\"Note: Values provided to `merge` are shallowly converted before being\\nmerged. No nested values are altered.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst one = Map({ a: 10, b: 20, c: 30 })\\nconst two = Map({ b: 40, a: 50, d: 60 })\\none.merge(two) // Map { \\\"a\\\": 50, \\\"b\\\": 40, \\\"c\\\": 30, \\\"d\\\": 60 }\\ntwo.merge(one) // Map { \\\"b\\\": 20, \\\"a\\\": 10, \\\"d\\\": 60, \\\"c\\\": 30 }\\n```\\n\\nNote: `merge` can be used in `withMutations`.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"concat\"}]},\"signatures\":[{\"typeParams\":[\"KC\",\"VC\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KC\"},{\"k\":8,\"param\":\"VC\"}]}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"KC\"}]},{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"VC\"}]}]},\"line\":974},{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"C\"}}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":3}]},{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":975}]},\"#mergeWith\":{\"doc\":{\"synopsis\":\"Like `merge()`, `mergeWith()` returns a new Map resulting from merging\\nthe provided Collections (or JS objects) into this Map, but uses the\\n`merger` function for dealing with conflicts.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst one = Map({ a: 10, b: 20, c: 30 })\\nconst two = Map({ b: 40, a: 50, d: 60 })\\none.mergeWith((oldVal, newVal) => oldVal / newVal, two)\\n// { \\\"a\\\": 0.2, \\\"b\\\": 0.5, \\\"c\\\": 30, \\\"d\\\": 60 }\\ntwo.mergeWith((oldVal, newVal) => oldVal / newVal, one)\\n// { \\\"b\\\": 2, \\\"a\\\": 5, \\\"d\\\": 60, \\\"c\\\": 30 }\\n```\\n\\nNote: `mergeWith` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"merger\",\"type\":{\"k\":7,\"params\":[{\"name\":\"oldVal\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"newVal\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":8,\"param\":\"V\"}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":997}]},\"#mergeDeep\":{\"doc\":{\"synopsis\":\"Like `merge()`, but when two Collections conflict, it merges them as well,\\nrecursing deeply through the nested data.\",\"description\":\"Note: Values provided to `merge` are shallowly converted before being\\nmerged. No nested values are altered unless they will also be merged at\\na deeper level.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst one = Map({ a: Map({ x: 10, y: 10 }), b: Map({ x: 20, y: 50 }) })\\nconst two = Map({ a: Map({ x: 2 }), b: Map({ y: 5 }), c: Map({ z: 3 }) })\\none.mergeDeep(two)\\n// Map {\\n//   \\\"a\\\": Map { \\\"x\\\": 2, \\\"y\\\": 10 },\\n//   \\\"b\\\": Map { \\\"x\\\": 20, \\\"y\\\": 5 },\\n//   \\\"c\\\": Map { \\\"z\\\": 3 }\\n// }\\n```\\n\\nNote: `mergeDeep` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":1025}]},\"#mergeDeepWith\":{\"doc\":{\"synopsis\":\"Like `mergeDeep()`, but when two non-Collections conflict, it uses the\\n`merger` function to determine the resulting value.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst one = Map({ a: Map({ x: 10, y: 10 }), b: Map({ x: 20, y: 50 }) })\\nconst two = Map({ a: Map({ x: 2 }), b: Map({ y: 5 }), c: Map({ z: 3 }) })\\none.mergeDeepWith((oldVal, newVal) => oldVal / newVal, two)\\n// Map {\\n//   \\\"a\\\": Map { \\\"x\\\": 5, \\\"y\\\": 10 },\\n//   \\\"b\\\": Map { \\\"x\\\": 20, \\\"y\\\": 10 },\\n//   \\\"c\\\": Map { \\\"z\\\": 3 }\\n// }\\n```\\n\\nNote: `mergeDeepWith` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"merger\",\"type\":{\"k\":7,\"params\":[{\"name\":\"oldVal\",\"type\":{\"k\":17}},{\"name\":\"newVal\",\"type\":{\"k\":17}},{\"name\":\"key\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":1046}]}}},{\"title\":\"Deep persistent changes\",\"members\":{\"#setIn\":{\"doc\":{\"synopsis\":\"Returns a new Map having set `value` at this `keyPath`. If any keys in\\n`keyPath` do not exist, a new immutable Map will be created at that key.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst originalMap = Map({\\n  subObject: Map({\\n    subKey: 'subvalue',\\n    subSubObject: Map({\\n      subSubKey: 'subSubValue'\\n    })\\n  })\\n})\\n\\nconst newMap = originalMap.setIn(['subObject', 'subKey'], 'ha ha!')\\n// Map {\\n//   \\\"subObject\\\": Map {\\n//     \\\"subKey\\\": \\\"ha ha!\\\",\\n//     \\\"subSubObject\\\": Map { \\\"subSubKey\\\": \\\"subSubValue\\\" }\\n//   }\\n// }\\n\\nconst newerMap = originalMap.setIn(\\n  ['subObject', 'subSubObject', 'subSubKey'],\\n  'ha ha ha!'\\n)\\n// Map {\\n//   \\\"subObject\\\": Map {\\n//     \\\"subKey\\\": \\\"subvalue\\\",\\n//     \\\"subSubObject\\\": Map { \\\"subSubKey\\\": \\\"ha ha ha!\\\" }\\n//   }\\n// }\\n```\\n\\nPlain JavaScript Object or Arrays may be nested within an Immutable.js\\nCollection, and setIn() can update those values as well, treating them\\nimmutably by creating new copies of those values with the changes applied.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst originalMap = Map({\\n  subObject: {\\n    subKey: 'subvalue',\\n    subSubObject: {\\n      subSubKey: 'subSubValue'\\n    }\\n  }\\n})\\n\\noriginalMap.setIn(['subObject', 'subKey'], 'ha ha!')\\n// Map {\\n//   \\\"subObject\\\": {\\n//     subKey: \\\"ha ha!\\\",\\n//     subSubObject: { subSubKey: \\\"subSubValue\\\" }\\n//   }\\n// }\\n```\\n\\nIf any key in the path exists but cannot be updated (such as a primitive\\nlike number or a custom Object like Date), an error will be thrown.\\n\\nNote: `setIn` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":10},\"line\":1120}]},\"#deleteIn\":{\"doc\":{\"synopsis\":\"Returns a new Map having removed the value at this `keyPath`. If any keys\\nin `keyPath` do not exist, no change will occur.\",\"description\":\"Note: `deleteIn` can be used in `withMutations`.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"removeIn\"}]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}}],\"type\":{\"k\":10},\"line\":1130}]},\"#updateIn\":{\"doc\":{\"synopsis\":\"Returns a new Map having applied the `updater` to the entry found at the\\nkeyPath.\",\"description\":\"This is most commonly used to call methods on collections nested within a\\nstructure of data. For example, in order to `.push()` onto a nested `List`,\\n`updateIn` and `push` can be used together:\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map, List } = require('immutable')\\nconst map = Map({ inMap: Map({ inList: List([ 1, 2, 3 ]) }) })\\nconst newMap = map.updateIn(['inMap', 'inList'], list => list.push(4))\\n// Map { \\\"inMap\\\": Map { \\\"inList\\\": List [ 1, 2, 3, 4 ] } }\\n```\\n\\nIf any keys in `keyPath` do not exist, new Immutable `Map`s will\\nbe created at those keys. If the `keyPath` does not already contain a\\nvalue, the `updater` function will be called with `notSetValue`, if\\nprovided, otherwise `undefined`.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable')\\\" }\\n-->\\n```js\\nconst map = Map({ a: Map({ b: Map({ c: 10 }) }) })\\nconst newMap = map.updateIn(['a', 'b', 'c'], val => val * 2)\\n// Map { \\\"a\\\": Map { \\\"b\\\": Map { \\\"c\\\": 20 } } }\\n```\\n\\nIf the `updater` function returns the same value it was called with, then\\nno change will occur. This is still true if `notSetValue` is provided.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable')\\\" }\\n-->\\n```js\\nconst map = Map({ a: Map({ b: Map({ c: 10 }) }) })\\nconst newMap = map.updateIn(['a', 'b', 'x'], 100, val => val)\\n// Map { \\\"a\\\": Map { \\\"b\\\": Map { \\\"c\\\": 10 } } }\\nassert.strictEqual(newMap, aMap)\\n```\\n\\nFor code using ES2015 or later, using `notSetValue` is discourged in\\nfavor of function parameter default values. This helps to avoid any\\npotential confusion with identify functions as described above.\\n\\nThe previous example behaves differently when written with default values:\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable')\\\" }\\n-->\\n```js\\nconst map = Map({ a: Map({ b: Map({ c: 10 }) }) })\\nconst newMap = map.updateIn(['a', 'b', 'x'], (val = 100) => val)\\n// Map { \\\"a\\\": Map { \\\"b\\\": Map { \\\"c\\\": 10, \\\"x\\\": 100 } } }\\n```\\n\\nPlain JavaScript Object or Arrays may be nested within an Immutable.js\\nCollection, and updateIn() can update those values as well, treating them\\nimmutably by creating new copies of those values with the changes applied.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Map } = require('immutable')\\\" }\\n-->\\n```js\\nconst map = Map({ a: { b: { c: 10 } } })\\nconst newMap = map.updateIn(['a', 'b', 'c'], val => val * 2)\\n// Map { \\\"a\\\": { b: { c: 20 } } }\\n```\\n\\nIf any key in the path exists but cannot be updated (such as a primitive\\nlike number or a custom Object like Date), an error will be thrown.\\n\\nNote: `updateIn` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"notSetValue\",\"type\":{\"k\":17}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":1209},{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":1210}]},\"#mergeIn\":{\"doc\":{\"synopsis\":\"A combination of `updateIn` and `merge`, returning a new Map, but\\nperforming the merge at a point arrived at by following the keyPath.\\nIn other words, these two lines are equivalent:\",\"description\":\"```js\\nmap.updateIn(['a', 'b', 'c'], abc => abc.merge(y))\\nmap.mergeIn(['a', 'b', 'c'], y)\\n```\\n\\nNote: `mergeIn` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":1224}]},\"#mergeDeepIn\":{\"doc\":{\"synopsis\":\"A combination of `updateIn` and `mergeDeep`, returning a new Map, but\\nperforming the deep merge at a point arrived at by following the keyPath.\\nIn other words, these two lines are equivalent:\",\"description\":\"```js\\nmap.updateIn(['a', 'b', 'c'], abc => abc.mergeDeep(y))\\nmap.mergeDeepIn(['a', 'b', 'c'], y)\\n```\\n\\nNote: `mergeDeepIn` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":1238}]}}},{\"title\":\"Transient changes\",\"members\":{\"#withMutations\":{\"doc\":{\"synopsis\":\"Every time you call one of the above functions, a new immutable Map is\\ncreated. If a pure function calls a number of these to produce a final\\nreturn value, then a penalty on performance and memory has been paid by\\ncreating all of the intermediate immutable Maps.\",\"description\":\"If you need to apply a series of mutations to produce a new immutable\\nMap, `withMutations()` creates a temporary mutable copy of the Map which\\ncan apply mutations in a highly performant manner. In fact, this is\\nexactly how complex mutations like `merge` are done.\\n\\nAs an example, this results in the creation of 2, not 4, new Maps:\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst map1 = Map()\\nconst map2 = map1.withMutations(map => {\\n  map.set('a', 1).set('b', 2).set('c', 3)\\n})\\nassert.equal(map1.size, 0)\\nassert.equal(map2.size, 3)\\n```\\n\\nNote: Not all methods can be used on a mutable collection or within\\n`withMutations`! Read the documentation for each method to see if it\\nis safe to use in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"mutator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"mutable\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":1270}]},\"#asMutable\":{\"doc\":{\"synopsis\":\"Another way to avoid creation of intermediate Immutable maps is to create\\na mutable copy of this collection. Mutable copies *always* return `this`,\\nand thus shouldn't be used for equality. Your function should never return\\na mutable copy of a collection, only use it internally to create a new\\ncollection.\",\"description\":\"If possible, use `withMutations` to work with temporary mutable copies as\\nit provides an easier to use API and considers many common optimizations.\\n\\nNote: if the collection is already mutable, `asMutable` returns itself.\\n\\nNote: Not all methods can be used on a mutable collection or within\\n`withMutations`! Read the documentation for each method to see if it\\nis safe to use in `withMutations`.\\n\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asImmutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":1290}]},\"#wasAltered\":{\"doc\":{\"synopsis\":\"Returns true if this is a mutable copy (see `asMutable()`) and mutative\\nalterations have been applied.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asMutable`\"}]},\"signatures\":[{\"type\":{\"k\":1},\"line\":1298}]},\"#asImmutable\":{\"doc\":{\"synopsis\":\"The yin to `asMutable`'s yang. Because it applies to mutable collections,\\nthis operation is *mutable* and may return itself (though may not\\nreturn itself, i.e. if the result is an empty collection). Once\\nperformed, the original mutable copy must no longer be mutated since it\\nmay be the immutable result.\",\"description\":\"If possible, use `withMutations` to work with temporary mutable copies as\\nit provides an easier to use API and considers many common optimizations.\\n\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asMutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":1312}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Map with values passed through a\\n`mapper` function.\",\"description\":\"    Map({ a: 1, b: 2 }).map(x => 10 * x)\\n    // Map { a: 10, b: 20 }\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"M\"}]},\"line\":1323}]},\"#mapKeys\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.mapKeys\"}]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"M\"},{\"k\":8,\"param\":\"V\"}]},\"line\":1331}]},\"#mapEntries\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.mapEntries\"}]},\"signatures\":[{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"entry\",\"type\":{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":1339}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Map, returning a new Map.\",\"description\":\"Similar to `data.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":1349}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Map with only the entries for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"F\"}]},\"line\":1361},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":1365}]},\"#flip\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.flip\"}]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"K\"}]},\"line\":1373}]}}}]}},\"OrderedMap\":{\"doc\":{\"synopsis\":\"A type of Map that has the additional guarantee that the iteration order of\\nentries will be the order in which they were set().\",\"description\":\"The iteration behavior of OrderedMap is the same as native ES6 Map and\\nJavaScript Object.\\n\\nNote that `OrderedMap` are more expensive than non-ordered `Map` and may\\nconsume more memory. `OrderedMap#set` is amortized O(log32 N), but not\\nstable.\",\"notes\":[]},\"module\":{\"isOrderedMap\":{\"call\":{\"doc\":{\"synopsis\":\"True if the provided value is an OrderedMap.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeOrderedMap\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":1394}]}}},\"call\":{\"doc\":{\"synopsis\":\"Creates a new Immutable OrderedMap.\",\"description\":\"Created with the same key value pairs as the provided Collection.Keyed or\\nJavaScript Object or expects a Collection of [K, V] tuple entries.\\n\\nThe iteration order of key-value pairs provided to this constructor will\\nbe preserved in the OrderedMap.\\n\\n    let newOrderedMap = OrderedMap({key: \\\"value\\\"})\\n    let newOrderedMap = OrderedMap([[\\\"key\\\", \\\"value\\\"]])\\n\\nNote: `OrderedMap` is a factory function and not a class, and does not use\\nthe `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\",\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]}}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":1412},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"obj\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":3},{\"k\":8,\"param\":\"V\"}]},\"line\":1413},{\"typeParams\":[\"K\",\"V\"],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":1414},{\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":17},{\"k\":17}]},\"line\":1415}]},\"interface\":{\"line\":1417,\"typeParams\":[\"K\",\"V\"],\"extends\":[{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}],\"groups\":[{\"members\":{\"#size\":{\"line\":1422},\"#set\":{\"doc\":{\"synopsis\":\"Returns a new OrderedMap also containing the new key, value pair. If an\\nequivalent key already exists in this OrderedMap, it will be replaced\\nwhile maintaining the existing order.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { OrderedMap } = require('immutable')\\nconst originalMap = OrderedMap({a:1, b:1, c:1})\\nconst updatedMap = originalMap.set('b', 2)\\n\\noriginalMap\\n// OrderedMap {a: 1, b: 1, c: 1}\\nupdatedMap\\n// OrderedMap {a: 1, b: 2, c: 1}\\n```\\n\\nNote: `set` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":10},\"line\":1443}]},\"#merge\":{\"doc\":{\"synopsis\":\"Returns a new OrderedMap resulting from merging the provided Collections\\n(or JS objects) into this OrderedMap. In other words, this takes each\\nentry of each collection and sets it on this OrderedMap.\",\"description\":\"Note: Values provided to `merge` are shallowly converted before being\\nmerged. No nested values are altered.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { OrderedMap } = require('immutable')\\nconst one = OrderedMap({ a: 10, b: 20, c: 30 })\\nconst two = OrderedMap({ b: 40, a: 50, d: 60 })\\none.merge(two) // OrderedMap { \\\"a\\\": 50, \\\"b\\\": 40, \\\"c\\\": 30, \\\"d\\\": 60 }\\ntwo.merge(one) // OrderedMap { \\\"b\\\": 20, \\\"a\\\": 10, \\\"d\\\": 60, \\\"c\\\": 30 }\\n```\\n\\nNote: `merge` can be used in `withMutations`.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"concat\"}]},\"signatures\":[{\"typeParams\":[\"KC\",\"VC\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KC\"},{\"k\":8,\"param\":\"VC\"}]}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"KC\"}]},{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"VC\"}]}]},\"line\":1466},{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"C\"}}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":3}]},{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":1467}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#map\":{\"doc\":{\"synopsis\":\"Returns a new OrderedMap with values passed through a\\n`mapper` function.\",\"description\":\"    OrderedMap({ a: 1, b: 2 }).map(x => 10 * x)\\n    // OrderedMap { \\\"a\\\": 10, \\\"b\\\": 20 }\\n\\nNote: `map()` always returns a new instance, even if it produced the same\\nvalue at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"M\"}]},\"line\":1483}]},\"#mapKeys\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.mapKeys\"}]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"M\"},{\"k\":8,\"param\":\"V\"}]},\"line\":1491}]},\"#mapEntries\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.mapEntries\"}]},\"signatures\":[{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"entry\",\"type\":{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":1499}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the OrderedMap, returning a new OrderedMap.\",\"description\":\"Similar to `data.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":1509}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new OrderedMap with only the entries for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"F\"}]},\"line\":1521},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":1525}]},\"#flip\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.flip\"}]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"K\"}]},\"line\":1533}]}}}]}},\"Set\":{\"doc\":{\"synopsis\":\"A Collection of unique values with `O(log32 N)` adds and has.\",\"description\":\"When iterating a Set, the entries will be (value, value) pairs. Iteration\\norder of a Set is undefined, however is stable. Multiple iterations of the\\nsame Set will iterate in the same order.\\n\\nSet values, like Map keys, may be of any type. Equality is determined using\\n`Immutable.is`, enabling Sets to uniquely include other Immutable\\ncollections, custom value types, and NaN.\",\"notes\":[]},\"module\":{\"isSet\":{\"call\":{\"doc\":{\"synopsis\":\"True if the provided value is a Set\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeSet\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":1553}]}},\"of\":{\"call\":{\"doc\":{\"synopsis\":\"Creates a new Set containing `values`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1558}]}},\"fromKeys\":{\"call\":{\"doc\":{\"synopsis\":\"`Set.fromKeys()` creates a new immutable Set containing the keys from\\nthis Collection or JavaScript Object.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"iter\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"T\"},{\"k\":17}]}}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1564},{\"params\":[{\"name\":\"obj\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]}}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":3}]},\"line\":1565}]}},\"intersect\":{\"call\":{\"doc\":{\"synopsis\":\"`Set.intersect()` creates a new immutable Set that is the intersection of\\na collection of other sets.\",\"description\":\"```js\\nconst { Set } = require('immutable')\\nconst intersected = Set.intersect([\\n  Set([ 'a', 'b', 'c' ])\\n  Set([ 'c', 'a', 't' ])\\n])\\n// Set [ \\\"a\\\", \\\"c\\\" ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"sets\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}]}}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1580}]}},\"union\":{\"call\":{\"doc\":{\"synopsis\":\"`Set.union()` creates a new immutable Set that is the union of a\\ncollection of other sets.\",\"description\":\"```js\\nconst { Set } = require('immutable')\\nconst unioned = Set.union([\\n  Set([ 'a', 'b', 'c' ])\\n  Set([ 'c', 'a', 't' ])\\n])\\n// Set [ \\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"t\\\" ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"sets\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}]}}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1595}]}}},\"call\":{\"doc\":{\"synopsis\":\"Create a new immutable Set containing the values of the provided\\ncollection-like.\",\"description\":\"Note: `Set` is a factory function and not a class, and does not use the\\n`new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":17}]},\"line\":1605},{\"typeParams\":[\"T\"],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1606},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1607}]},\"interface\":{\"line\":1609,\"typeParams\":[\"T\"],\"extends\":[{\"k\":9,\"name\":\"Collection.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]}],\"groups\":[{\"members\":{\"#size\":{\"line\":1614}}},{\"title\":\"Persistent changes\",\"members\":{\"#add\":{\"doc\":{\"synopsis\":\"Returns a new Set which also includes this value.\",\"description\":\"Note: `add` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":10},\"line\":1623}]},\"#delete\":{\"doc\":{\"synopsis\":\"Returns a new Set which excludes this value.\",\"description\":\"Note: `delete` can be used in `withMutations`.\\n\\nNote: `delete` **cannot** be safely used in IE8, use `remove` if\\nsupporting old browsers.\\n\",\"notes\":[{\"name\":\"alias\",\"body\":\"remove\"}]},\"signatures\":[{\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":10},\"line\":1635}]},\"#clear\":{\"doc\":{\"synopsis\":\"Returns a new Set containing no values.\",\"description\":\"Note: `clear` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":1643}]},\"#union\":{\"doc\":{\"synopsis\":\"Returns a Set including any value from `collections` that does not already\\nexist in this Set.\",\"description\":\"Note: `union` can be used in `withMutations`.\",\"notes\":[{\"name\":\"alias\",\"body\":\"merge\"},{\"name\":\"alias\",\"body\":\"concat\"}]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"C\"}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":1653}]},\"#intersect\":{\"doc\":{\"synopsis\":\"Returns a Set which has removed any values not also contained\\nwithin `collections`.\",\"description\":\"Note: `intersect` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":1663}]},\"#subtract\":{\"doc\":{\"synopsis\":\"Returns a Set excluding any values contained within `collections`.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { OrderedSet } = require('immutable')\\nOrderedSet([ 1, 2, 3 ]).subtract([1, 3])\\n// OrderedSet [2]\\n```\\n\\nNote: `subtract` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":1677}]}}},{\"title\":\"Transient changes\",\"members\":{\"#withMutations\":{\"doc\":{\"synopsis\":\"Note: Not all methods can be used on a mutable collection or within\\n`withMutations`! Check the documentation for each method to see if it\\nmentions being safe to use in `withMutations`.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#withMutations`\"}]},\"signatures\":[{\"params\":[{\"name\":\"mutator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"mutable\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":1689}]},\"#asMutable\":{\"doc\":{\"synopsis\":\"Note: Not all methods can be used on a mutable collection or within\\n`withMutations`! Check the documentation for each method to see if it\\nmentions being safe to use in `withMutations`.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asMutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":1698}]},\"#wasAltered\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#wasAltered`\"}]},\"signatures\":[{\"type\":{\"k\":1},\"line\":1703}]},\"#asImmutable\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asImmutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":1708}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Set with values passed through a\\n`mapper` function.\",\"description\":\"    Set([1,2]).map(x => 10 * x)\\n    // Set [10,20]\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":1719}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Set, returning a new Set.\",\"description\":\"Similar to `set.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":1729}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Set with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"F\"}]},\"line\":1741},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":1745}]}}}]}},\"OrderedSet\":{\"doc\":{\"synopsis\":\"A type of Set that has the additional guarantee that the iteration order of\\nvalues will be the order in which they were `add`ed.\",\"description\":\"The iteration behavior of OrderedSet is the same as native ES6 Set.\\n\\nNote that `OrderedSet` are more expensive than non-ordered `Set` and may\\nconsume more memory. `OrderedSet#add` is amortized O(log32 N), but not\\nstable.\",\"notes\":[]},\"module\":{\"isOrderedSet\":{\"call\":{\"doc\":{\"synopsis\":\"True if the provided value is an OrderedSet.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeOrderedSet\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":1767}]}},\"of\":{\"call\":{\"doc\":{\"synopsis\":\"Creates a new OrderedSet containing `values`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1772}]}},\"fromKeys\":{\"call\":{\"doc\":{\"synopsis\":\"`OrderedSet.fromKeys()` creates a new immutable OrderedSet containing\\nthe keys from this Collection or JavaScript Object.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"iter\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"T\"},{\"k\":17}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1778},{\"params\":[{\"name\":\"obj\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":3}]},\"line\":1779}]}}},\"call\":{\"doc\":{\"synopsis\":\"Create a new immutable OrderedSet containing the values of the provided\\ncollection-like.\",\"description\":\"Note: `OrderedSet` is a factory function and not a class, and does not use\\nthe `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":17}]},\"line\":1789},{\"typeParams\":[\"T\"],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1790},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1791}]},\"interface\":{\"line\":1793,\"typeParams\":[\"T\"],\"extends\":[{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]}],\"groups\":[{\"members\":{\"#size\":{\"line\":1798},\"#union\":{\"doc\":{\"synopsis\":\"Returns an OrderedSet including any value from `collections` that does\\nnot already exist in this OrderedSet.\",\"description\":\"Note: `union` can be used in `withMutations`.\",\"notes\":[{\"name\":\"alias\",\"body\":\"merge\"},{\"name\":\"alias\",\"body\":\"concat\"}]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"C\"}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":1808}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Set with values passed through a\\n`mapper` function.\",\"description\":\"    OrderedSet([ 1, 2 ]).map(x => 10 * x)\\n    // OrderedSet [10, 20]\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":1821}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the OrderedSet, returning a new OrderedSet.\",\"description\":\"Similar to `set.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":1831}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new OrderedSet with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"F\"}]},\"line\":1843},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":1847}]},\"#zip\":{\"doc\":{\"synopsis\":\"Returns an OrderedSet of the same type \\\"zipped\\\" with the provided\\ncollections.\",\"description\":\"Like `zipWith`, but using the default `zipper`: creating an `Array`.\\n\\n```js\\nconst a = OrderedSet([ 1, 2, 3 ])\\nconst b = OrderedSet([ 4, 5, 6 ])\\nconst c = a.zip(b)\\n// OrderedSet [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":1865},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other1\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":1866},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":17}]},\"line\":1867}]},\"#zipAll\":{\"doc\":{\"synopsis\":\"Returns a OrderedSet of the same type \\\"zipped\\\" with the provided\\ncollections.\",\"description\":\"Unlike `zip`, `zipAll` continues zipping until the longest collection is\\nexhausted. Missing values from shorter collections are filled with `undefined`.\\n\\n```js\\nconst a = OrderedSet([ 1, 2 ]);\\nconst b = OrderedSet([ 3, 4, 5 ]);\\nconst c = a.zipAll(b); // OrderedSet [ [ 1, 3 ], [ 2, 4 ], [ undefined, 5 ] ]\\n```\\n\\nNote: Since zipAll will return a collection as large as the largest\\ninput, some results may contain undefined values. TypeScript cannot\\naccount for these without cases (as of v2.5).\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":1886},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other1\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":1887},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":17}]},\"line\":1888}]},\"#zipWith\":{\"doc\":{\"synopsis\":\"Returns an OrderedSet of the same type \\\"zipped\\\" with the provided\\ncollections by using a custom `zipper` function.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Seq.Indexed.zipWith\"}]},\"signatures\":[{\"typeParams\":[\"U\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":1896},{\"typeParams\":[\"U\",\"V\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}},{\"name\":\"thirdValue\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"thirdCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":1900},{\"typeParams\":[\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"any\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":1905}]}}}]}},\"Stack\":{\"doc\":{\"synopsis\":\"Stacks are indexed collections which support very efficient O(1) addition\\nand removal from the front using `unshift(v)` and `shift()`.\",\"description\":\"For familiarity, Stack also provides `push(v)`, `pop()`, and `peek()`, but\\nbe aware that they also operate on the front of the list, unlike List or\\na JavaScript Array.\\n\\nNote: `reverse()` or any inherent reverse traversal (`reduceRight`,\\n`lastIndexOf`, etc.) is not efficient with a Stack.\\n\\nStack is implemented with a Single-Linked List.\",\"notes\":[]},\"module\":{\"isStack\":{\"call\":{\"doc\":{\"synopsis\":\"True if the provided value is a Stack\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeStack\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":1931}]}},\"of\":{\"call\":{\"doc\":{\"synopsis\":\"Creates a new Stack containing `values`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1936}]}}},\"call\":{\"doc\":{\"synopsis\":\"Create a new immutable Stack containing the values of the provided\\ncollection-like.\",\"description\":\"The iteration order of the provided collection is preserved in the\\nresulting `Stack`.\\n\\nNote: `Stack` is a factory function and not a class, and does not use the\\n`new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":17}]},\"line\":1949},{\"typeParams\":[\"T\"],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1950},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1951}]},\"interface\":{\"line\":1953,\"typeParams\":[\"T\"],\"extends\":[{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]}],\"groups\":[{\"members\":{\"#size\":{\"line\":1958}}},{\"title\":\"Reading values\",\"members\":{\"#peek\":{\"doc\":{\"synopsis\":\"Alias for `Stack.first()`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":11}]},\"line\":1965}]}}},{\"title\":\"Persistent changes\",\"members\":{\"#clear\":{\"doc\":{\"synopsis\":\"Returns a new Stack with 0 size and no values.\",\"description\":\"Note: `clear` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1975}]},\"#unshift\":{\"doc\":{\"synopsis\":\"Returns a new Stack with the provided `values` prepended, shifting other\\nvalues ahead to higher indices.\",\"description\":\"This is very efficient for Stack.\\n\\nNote: `unshift` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1985}]},\"#unshiftAll\":{\"doc\":{\"synopsis\":\"Like `Stack#unshift`, but accepts a collection rather than varargs.\",\"description\":\"Note: `unshiftAll` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"iter\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":1992}]},\"#shift\":{\"doc\":{\"synopsis\":\"Returns a new Stack with a size ones less than this Stack, excluding\\nthe first item in this Stack, shifting all other values to a lower index.\",\"description\":\"Note: this differs from `Array#shift` because it returns a new\\nStack rather than the removed value. Use `first()` or `peek()` to get the\\nfirst value in this Stack.\\n\\nNote: `shift` can be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2004}]},\"#push\":{\"doc\":{\"synopsis\":\"Alias for `Stack#unshift` and is not equivalent to `List#push`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2009}]},\"#pushAll\":{\"doc\":{\"synopsis\":\"Alias for `Stack#unshiftAll`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"iter\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2014}]},\"#pop\":{\"doc\":{\"synopsis\":\"Alias for `Stack#shift` and is not equivalent to `List#pop`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2019}]}}},{\"title\":\"Transient changes\",\"members\":{\"#withMutations\":{\"doc\":{\"synopsis\":\"Note: Not all methods can be used on a mutable collection or within\\n`withMutations`! Check the documentation for each method to see if it\\nmentions being safe to use in `withMutations`.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#withMutations`\"}]},\"signatures\":[{\"params\":[{\"name\":\"mutator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"mutable\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":2031}]},\"#asMutable\":{\"doc\":{\"synopsis\":\"Note: Not all methods can be used on a mutable collection or within\\n`withMutations`! Check the documentation for each method to see if it\\nmentions being safe to use in `withMutations`.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asMutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":2040}]},\"#wasAltered\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#wasAltered`\"}]},\"signatures\":[{\"type\":{\"k\":1},\"line\":2045}]},\"#asImmutable\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asImmutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":2050}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new Stack with other collections concatenated to this one.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"valuesOrCollections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"C\"}]},{\"k\":8,\"param\":\"C\"}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":2057}]},\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Stack with values passed through a\\n`mapper` function.\",\"description\":\"    Stack([ 1, 2 ]).map(x => 10 * x)\\n    // Stack [ 10, 20 ]\\n\\nNote: `map()` always returns a new instance, even if it produced the same\\nvalue at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":2069}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Stack, returning a new Stack.\",\"description\":\"Similar to `stack.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":2079}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Set with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"F\"}]},\"line\":2091},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":2095}]},\"#zip\":{\"doc\":{\"synopsis\":\"Returns a Stack \\\"zipped\\\" with the provided collections.\",\"description\":\"Like `zipWith`, but using the default `zipper`: creating an `Array`.\\n\\n```js\\nconst a = Stack([ 1, 2, 3 ]);\\nconst b = Stack([ 4, 5, 6 ]);\\nconst c = a.zip(b); // Stack [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":2111},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":2112},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":17}]},\"line\":2113}]},\"#zipAll\":{\"doc\":{\"synopsis\":\"Returns a Stack \\\"zipped\\\" with the provided collections.\",\"description\":\"Unlike `zip`, `zipAll` continues zipping until the longest collection is\\nexhausted. Missing values from shorter collections are filled with `undefined`.\\n\\n```js\\nconst a = Stack([ 1, 2 ]);\\nconst b = Stack([ 3, 4, 5 ]);\\nconst c = a.zipAll(b); // Stack [ [ 1, 3 ], [ 2, 4 ], [ undefined, 5 ] ]\\n```\\n\\nNote: Since zipAll will return a collection as large as the largest\\ninput, some results may contain undefined values. TypeScript cannot\\naccount for these without cases (as of v2.5).\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":2131},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":2132},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":17}]},\"line\":2133}]},\"#zipWith\":{\"doc\":{\"synopsis\":\"Returns a Stack \\\"zipped\\\" with the provided collections by using a\\ncustom `zipper` function.\",\"description\":\"```js\\nconst a = Stack([ 1, 2, 3 ]);\\nconst b = Stack([ 4, 5, 6 ]);\\nconst c = a.zipWith((a, b) => a + b, b);\\n// Stack [ 5, 7, 9 ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":2146},{\"typeParams\":[\"U\",\"V\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}},{\"name\":\"thirdValue\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"thirdCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":2150},{\"typeParams\":[\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"any\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":2155}]}}}]}},\"Range\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a Seq.Indexed of numbers from `start` (inclusive) to `end`\\n(exclusive), by `step`, where `start` defaults to 0, `step` to 1, and `end` to\\ninfinity. When `start` is equal to `end`, returns empty range.\",\"description\":\"Note: `Range` is a factory function and not a class, and does not use the\\n`new` keyword during construction.\\n\\n```js\\nconst { Range } = require('immutable')\\nRange() // [ 0, 1, 2, 3, ... ]\\nRange(10) // [ 10, 11, 12, 13, ... ]\\nRange(10, 15) // [ 10, 11, 12, 13, 14 ]\\nRange(10, 30, 5) // [ 10, 15, 20, 25 ]\\nRange(30, 10, 5) // [ 30, 25, 20, 15 ]\\nRange(30, 30, 5) // []\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"start\",\"type\":{\"k\":2},\"optional\":true},{\"name\":\"end\",\"type\":{\"k\":2},\"optional\":true},{\"name\":\"step\",\"type\":{\"k\":2},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":2}]},\"line\":2180}]}},\"Repeat\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a Seq.Indexed of `value` repeated `times` times. When `times` is\\nnot defined, returns an infinite `Seq` of `value`.\",\"description\":\"Note: `Repeat` is a factory function and not a class, and does not use the\\n`new` keyword during construction.\\n\\n```js\\nconst { Repeat } = require('immutable')\\nRepeat('foo') // [ 'foo', 'foo', 'foo', ... ]\\nRepeat('bar', 4) // [ 'bar', 'bar', 'bar', 'bar' ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"times\",\"type\":{\"k\":2},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2196}]}},\"Record\":{\"doc\":{\"synopsis\":\"A record is similar to a JS object, but enforces a specific set of allowed\\nstring keys, and has default values.\",\"description\":\"The `Record()` function produces new Record Factories, which when called\\ncreate Record instances.\\n\\n```js\\nconst { Record } = require('immutable')\\nconst ABRecord = Record({ a: 1, b: 2 })\\nconst myRecord = ABRecord({ b: 3 })\\n```\\n\\nRecords always have a value for the keys they define. `remove`ing a key\\nfrom a record simply resets it to the default value for that key.\\n\\n```js\\nmyRecord.size // 2\\nmyRecord.get('a') // 1\\nmyRecord.get('b') // 3\\nconst myRecordWithoutB = myRecord.remove('b')\\nmyRecordWithoutB.get('b') // 2\\nmyRecordWithoutB.size // 2\\n```\\n\\nValues provided to the constructor not found in the Record type will\\nbe ignored. For example, in this case, ABRecord is provided a key \\\"x\\\" even\\nthough only \\\"a\\\" and \\\"b\\\" have been defined. The value for \\\"x\\\" will be\\nignored for this record.\\n\\n```js\\nconst myRecord = ABRecord({ b: 3, x: 10 })\\nmyRecord.get('x') // undefined\\n```\\n\\nBecause Records have a known set of string keys, property get access works\\nas expected, however property sets will throw an Error.\\n\\nNote: IE8 does not support property access. Only use `get()` when\\nsupporting IE8.\\n\\n```js\\nmyRecord.b // 3\\nmyRecord.b = 5 // throws Error\\n```\\n\\nRecord Types can be extended as well, allowing for custom methods on your\\nRecord. This is not a common pattern in functional environments, but is in\\nmany JS programs.\\n\\nHowever Record Types are more restricted than typical JavaScript classes.\\nThey do not use a class constructor, which also means they cannot use\\nclass properties (since those are technically part of a constructor).\\n\\nWhile Record Types can be syntactically created with the JavaScript `class`\\nform, the resulting Record function is actually a factory function, not a\\nclass constructor. Even though Record Types are not classes, JavaScript\\ncurrently requires the use of `new` when creating new Record instances if\\nthey are defined as a `class`.\\n\\n```\\nclass ABRecord extends Record({ a: 1, b: 2 }) {\\n  getAB() {\\n    return this.a + this.b;\\n  }\\n}\\n\\nvar myRecord = new ABRecord({b: 3})\\nmyRecord.getAB() // 4\\n```\\n\\n\\n**Flow Typing Records:**\\n\\nImmutable.js exports two Flow types designed to make it easier to use\\nRecords with flow typed code, `RecordOf<TProps>` and `RecordFactory<TProps>`.\\n\\nWhen defining a new kind of Record factory function, use a flow type that\\ndescribes the values the record contains along with `RecordFactory<TProps>`.\\nTo type instances of the Record (which the factory function returns),\\nuse `RecordOf<TProps>`.\\n\\nTypically, new Record definitions will export both the Record factory\\nfunction as well as the Record instance type for use in other code.\\n\\n```js\\nimport type { RecordFactory, RecordOf } from 'immutable';\\n\\n// Use RecordFactory<TProps> for defining new Record factory functions.\\ntype Point3DProps = { x: number, y: number, z: number };\\nconst defaultValues: Point3DProps = { x: 0, y: 0, z: 0 };\\nconst makePoint3D: RecordFactory<Point3DProps> = Record(defaultValues);\\nexport makePoint3D;\\n\\n// Use RecordOf<T> for defining new instances of that Record.\\nexport type Point3D = RecordOf<Point3DProps>;\\nconst some3DPoint: Point3D = makePoint3D({ x: 10, y: 20, z: 30 });\\n```\\n\\n**Flow Typing Record Subclasses:**\\n\\nRecords can be subclassed as a means to add additional methods to Record\\ninstances. This is generally discouraged in favor of a more functional API,\\nsince Subclasses have some minor overhead. However the ability to create\\na rich API on Record types can be quite valuable.\\n\\nWhen using Flow to type Subclasses, do not use `RecordFactory<TProps>`,\\ninstead apply the props type when subclassing:\\n\\n```js\\ntype PersonProps = {name: string, age: number};\\nconst defaultValues: PersonProps = {name: 'Aristotle', age: 2400};\\nconst PersonRecord = Record(defaultValues);\\nclass Person extends PersonRecord<PersonProps> {\\n  getName(): string {\\n    return this.get('name')\\n  }\\n\\n  setName(name: string): this {\\n    return this.set('name', name);\\n  }\\n}\\n```\\n\\n**Choosing Records vs plain JavaScript objects**\\n\\nRecords offer a persistently immutable alternative to plain JavaScript\\nobjects, however they're not required to be used within Immutable.js\\ncollections. In fact, the deep-access and deep-updating functions\\nlike `getIn()` and `setIn()` work with plain JavaScript Objects as well.\\n\\nDeciding to use Records or Objects in your application should be informed\\nby the tradeoffs and relative benefits of each:\\n\\n- *Runtime immutability*: plain JS objects may be carefully treated as\\n  immutable, however Record instances will *throw* if attempted to be\\n  mutated directly. Records provide this additional guarantee, however at\\n  some marginal runtime cost. While JS objects are mutable by nature, the\\n  use of type-checking tools like [Flow](https://medium.com/@gcanti/immutability-with-flow-faa050a1aef4)\\n  can help gain confidence in code written to favor immutability.\\n\\n- *Value equality*: Records use value equality when compared with `is()`\\n  or `record.equals()`. That is, two Records with the same keys and values\\n  are equal. Plain objects use *reference equality*. Two objects with the\\n  same keys and values are not equal since they are different objects.\\n  This is important to consider when using objects as keys in a `Map` or\\n  values in a `Set`, which use equality when retrieving values.\\n\\n- *API methods*: Records have a full featured API, with methods like\\n  `.getIn()`, and `.equals()`. These can make working with these values\\n  easier, but comes at the cost of not allowing keys with those names.\\n\\n- *Default values*: Records provide default values for every key, which\\n  can be useful when constructing Records with often unchanging values.\\n  However default values can make using Flow and TypeScript more laborious.\\n\\n- *Serialization*: Records use a custom internal representation to\\n  efficiently store and update their values. Converting to and from this\\n  form isn't free. If converting Records to plain objects is common,\\n  consider sticking with plain objects to begin with.\",\"notes\":[]},\"module\":{\"isRecord\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeRecord` is an instance of a Record.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeRecord\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":2365}]}},\"getDescriptiveName\":{\"call\":{\"doc\":{\"synopsis\":\"Records allow passing a second parameter to supply a descriptive name\\nthat appears when converting a Record to a string or in any error\\nmessages. A descriptive name for any record can be accessed by using this\\nmethod. If one was not provided, the string \\\"Record\\\" is returned.\",\"description\":\"```js\\nconst { Record } = require('immutable')\\nconst Person = Record({\\n  name: null\\n}, 'Person')\\n\\nvar me = Person({ name: 'My Name' })\\nme.toString() // \\\"Person { \\\"name\\\": \\\"My Name\\\" }\\\"\\nRecord.getDescriptiveName(me) // \\\"Person\\\"\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"record\",\"type\":{\"k\":9,\"name\":\"Record\",\"args\":[{\"k\":4,\"members\":[]}]}}],\"type\":{\"k\":3},\"line\":2384}]}},\"Factory\":{\"doc\":{\"synopsis\":\"A Record.Factory is created by the `Record()` function. Record instances\\nare created by passing it some of the accepted values for that Record\\ntype:\",\"description\":\"<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Record } = require('immutable')\\\" }\\n-->\\n```js\\n// makePerson is a Record Factory function\\nconst makePerson = Record({ name: null, favoriteColor: 'unknown' });\\n\\n// alan is a Record instance\\nconst alan = makePerson({ name: 'Alan' });\\n```\\n\\nNote that Record Factories return `Record<TProps> & Readonly<TProps>`,\\nthis allows use of both the Record instance API, and direct property\\naccess on the resulting instances:\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Record } = require('immutable');const makePerson = Record({ name: null, favoriteColor: 'unknown' });const alan = makePerson({ name: 'Alan' });\\\" }\\n-->\\n```js\\n// Use the Record API\\nconsole.log('Record API: ' + alan.get('name'))\\n\\n// Or direct property access (Readonly)\\nconsole.log('property access: ' + alan.name)\\n```\\n\\n**Flow Typing Records:**\\n\\nUse the `RecordFactory<TProps>` Flow type to get high quality type checking of\\nRecords:\\n\\n```js\\nimport type { RecordFactory, RecordOf } from 'immutable';\\n\\n// Use RecordFactory<TProps> for defining new Record factory functions.\\ntype PersonProps = { name: ?string, favoriteColor: string };\\nconst makePerson: RecordFactory<PersonProps> = Record({ name: null, favoriteColor: 'unknown' });\\n\\n// Use RecordOf<T> for defining new instances of that Record.\\ntype Person = RecordOf<PersonProps>;\\nconst alan: Person = makePerson({ name: 'Alan' });\\n```\",\"notes\":[]},\"module\":{},\"interface\":{\"line\":2436,\"typeParams\":[\"TProps\"],\"groups\":[{\"members\":{\"#displayName\":{\"line\":2444}}}]},\"call\":{\"signatures\":[{\"typeParams\":[\"TProps\"],\"params\":[{\"name\":\"values\",\"type\":{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Partial\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":3},{\"k\":17}]}]}]},\"optional\":true}],\"type\":{\"k\":13,\"types\":[{\"k\":9,\"name\":\"Record\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]},{\"k\":9,\"name\":\"Readonly\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]}]},\"line\":2447}]}}},\"call\":{\"doc\":{\"synopsis\":\"Unlike other types in Immutable.js, the `Record()` function creates a new\\nRecord Factory, which is a function that creates Record instances.\",\"description\":\"See above for examples of using `Record()`.\\n\\nNote: `Record` is a factory function and not a class, and does not use the\\n`new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"TProps\"],\"params\":[{\"name\":\"defaultValues\",\"type\":{\"k\":8,\"param\":\"TProps\"}},{\"name\":\"name\",\"type\":{\"k\":3},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Record.Factory\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]},\"line\":2459}]},\"interface\":{\"line\":2461,\"typeParams\":[\"TProps\"],\"groups\":[{\"title\":\"Reading values\",\"members\":{\"#has\":{\"signatures\":[{\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":1},\"line\":2465}]},\"#get\":{\"doc\":{\"synopsis\":\"Returns the value associated with the provided key, which may be the\\ndefault value defined when creating the Record factory function.\",\"description\":\"If the requested key is not defined by this Record type, then\\nnotSetValue will be returned if provided. Note that this scenario would\\nproduce an error when using Flow or TypeScript.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\"],\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}},\"line\":2475},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":8,\"param\":\"T\"},\"line\":2476}]}}},{\"title\":\"Reading deep values\",\"members\":{\"#hasIn\":{\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}}],\"type\":{\"k\":1},\"line\":2480}]},\"#getIn\":{\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}}],\"type\":{\"k\":17},\"line\":2481}]}}},{\"title\":\"Value equality\",\"members\":{\"#equals\":{\"signatures\":[{\"params\":[{\"name\":\"other\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":2485}]},\"#hashCode\":{\"signatures\":[{\"type\":{\"k\":2},\"line\":2486}]}}},{\"title\":\"Persistent changes\",\"members\":{\"#set\":{\"signatures\":[{\"typeParams\":[\"K\"],\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}}}],\"type\":{\"k\":10},\"line\":2490}]},\"#update\":{\"signatures\":[{\"typeParams\":[\"K\"],\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}}}],\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}}}}],\"type\":{\"k\":10},\"line\":2491}]},\"#merge\":{\"signatures\":[{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Partial\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":3},{\"k\":17}]}]}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":2492}]},\"#mergeDeep\":{\"signatures\":[{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Partial\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":3},{\"k\":17}]}]}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":2493}]},\"#mergeWith\":{\"signatures\":[{\"params\":[{\"name\":\"merger\",\"type\":{\"k\":7,\"params\":[{\"name\":\"oldVal\",\"type\":{\"k\":17}},{\"name\":\"newVal\",\"type\":{\"k\":17}},{\"name\":\"key\",\"type\":{\"k\":16,\"operator\":\"keyof\",\"type\":{\"k\":8,\"param\":\"TProps\"}}}],\"type\":{\"k\":17}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Partial\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":3},{\"k\":17}]}]}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":2495}]},\"#mergeDeepWith\":{\"signatures\":[{\"params\":[{\"name\":\"merger\",\"type\":{\"k\":7,\"params\":[{\"name\":\"oldVal\",\"type\":{\"k\":17}},{\"name\":\"newVal\",\"type\":{\"k\":17}},{\"name\":\"key\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Partial\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":3},{\"k\":17}]}]}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":2499}]},\"#delete\":{\"doc\":{\"synopsis\":\"Returns a new instance of this Record type with the value for the\\nspecific key set to its default value.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"alias\",\"body\":\"remove\"}]},\"signatures\":[{\"typeParams\":[\"K\"],\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":10},\"line\":2510}]},\"#clear\":{\"doc\":{\"synopsis\":\"Returns a new instance of this Record type with all values set\\nto their default values.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":2517}]}}},{\"title\":\"Deep persistent changes\",\"members\":{\"#setIn\":{\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":10},\"line\":2521}]},\"#updateIn\":{\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":2522}]},\"#mergeIn\":{\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":2523}]},\"#mergeDeepIn\":{\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":2524}]},\"#deleteIn\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"alias\",\"body\":\"removeIn\"}]},\"signatures\":[{\"params\":[{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}}],\"type\":{\"k\":10},\"line\":2529}]}}},{\"title\":\"Conversion to JavaScript types\",\"members\":{\"#toJS\":{\"doc\":{\"synopsis\":\"Deeply converts this Record to equivalent native JavaScript Object.\",\"description\":\"Note: This method may not be overridden. Objects with custom\\nserialization to plain JS may override toJSON() instead.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]},\"line\":2540}]},\"#toJSON\":{\"doc\":{\"synopsis\":\"Shallowly converts this Record to equivalent native JavaScript Object.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":8,\"param\":\"TProps\"},\"line\":2545}]},\"#toObject\":{\"doc\":{\"synopsis\":\"Shallowly converts this Record to equivalent JavaScript Object.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":8,\"param\":\"TProps\"},\"line\":2550}]}}},{\"title\":\"Transient changes\",\"members\":{\"#withMutations\":{\"doc\":{\"synopsis\":\"Note: Not all methods can be used on a mutable collection or within\\n`withMutations`! Only `set` may be used mutatively.\\n\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#withMutations`\"}]},\"signatures\":[{\"params\":[{\"name\":\"mutator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"mutable\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":10},\"line\":2560}]},\"#asMutable\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asMutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":2565}]},\"#wasAltered\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#wasAltered`\"}]},\"signatures\":[{\"type\":{\"k\":1},\"line\":2570}]},\"#asImmutable\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"`Map#asImmutable`\"}]},\"signatures\":[{\"type\":{\"k\":10},\"line\":2575}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#toSeq\":{\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":16,\"operator\":\"keyof\",\"type\":{\"k\":8,\"param\":\"TProps\"}},{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":16,\"operator\":\"keyof\",\"type\":{\"k\":8,\"param\":\"TProps\"}}}]},\"line\":2579}]},\"#[Symbol.iterator]\":{\"signatures\":[{\"type\":{\"k\":9,\"name\":\"IterableIterator\",\"args\":[{\"k\":14,\"types\":[{\"k\":16,\"operator\":\"keyof\",\"type\":{\"k\":8,\"param\":\"TProps\"}},{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":16,\"operator\":\"keyof\",\"type\":{\"k\":8,\"param\":\"TProps\"}}}]}]},\"line\":2581}]}}}]}},\"Seq\":{\"doc\":{\"synopsis\":\"`Seq` describes a lazy operation, allowing them to efficiently chain\\nuse of all the higher-order collection methods (such as `map` and `filter`)\\nby not creating intermediate collections.\",\"description\":\"**Seq is immutable** — Once a Seq is created, it cannot be\\nchanged, appended to, rearranged or otherwise modified. Instead, any\\nmutative method called on a `Seq` will return a new `Seq`.\\n\\n**Seq is lazy** — `Seq` does as little work as necessary to respond to any\\nmethod call. Values are often created during iteration, including implicit\\niteration when reducing or converting to a concrete data structure such as\\na `List` or JavaScript `Array`.\\n\\nFor example, the following performs no work, because the resulting\\n`Seq`'s values are never iterated:\\n\\n```js\\nconst { Seq } = require('immutable')\\nconst oddSquares = Seq([ 1, 2, 3, 4, 5, 6, 7, 8 ])\\n  .filter(x => x % 2 !== 0)\\n  .map(x => x * x)\\n```\\n\\nOnce the `Seq` is used, it performs only the work necessary. In this\\nexample, no intermediate arrays are ever created, filter is called three\\ntimes, and map is only called once:\\n\\n```js\\noddSquares.get(1); // 9\\n```\\n\\nAny collection can be converted to a lazy Seq with `Seq()`.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nconst map = Map({ a: 1, b: 2, c: 3 })\\nconst lazySeq = Seq(map)\\n```\\n\\n`Seq` allows for the efficient chaining of operations, allowing for the\\nexpression of logic that can otherwise be very tedious:\\n\\n```js\\nlazySeq\\n  .flip()\\n  .map(key => key.toUpperCase())\\n  .flip()\\n// Seq { A: 1, B: 1, C: 1 }\\n```\\n\\nAs well as expressing logic that would otherwise seem memory or time\\nlimited, for example `Range` is a special kind of Lazy sequence.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Range } = require('immutable')\\nRange(1, Infinity)\\n  .skip(1000)\\n  .map(n => -n)\\n  .filter(n => n % 2 === 0)\\n  .take(2)\\n  .reduce((r, n) => r * n, 1)\\n// 1006008\\n```\\n\\nSeq is often used to provide a rich collection API to JavaScript Object.\\n\\n```js\\nSeq({ x: 0, y: 1, z: 2 }).map(v => v * 2).toObject();\\n// { x: 0, y: 2, z: 4 }\\n```\",\"notes\":[]},\"module\":{\"isSeq\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeSeq` is a Seq, it is not backed by a concrete\\nstructure such as Map, List, or Set.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeSeq\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":2673}]}},\"Keyed\":{\"doc\":{\"synopsis\":\"`Seq` which represents key-value pairs.\",\"description\":\"\",\"notes\":[]},\"module\":{},\"call\":{\"doc\":{\"synopsis\":\"Always returns a Seq.Keyed, if input is not keyed, expects an\\ncollection of [K, V] tuples.\",\"description\":\"Note: `Seq.Keyed` is a conversion function and not a class, and does not\\nuse the `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\",\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":2688},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"obj\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":3},{\"k\":8,\"param\":\"V\"}]},\"line\":2689},{\"typeParams\":[\"K\",\"V\"],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":2690},{\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":17},{\"k\":17}]},\"line\":2691}]},\"interface\":{\"line\":2693,\"typeParams\":[\"K\",\"V\"],\"extends\":[{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}],\"groups\":[{\"members\":{\"#toJS\":{\"doc\":{\"synopsis\":\"Deeply converts this Keyed Seq to equivalent native JavaScript Object.\",\"description\":\"Converts keys to Strings.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Object\"},\"line\":2699}]},\"#toJSON\":{\"doc\":{\"synopsis\":\"Shallowly converts this Keyed Seq to equivalent native JavaScript Object.\",\"description\":\"Converts keys to Strings.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]},\"line\":2706}]},\"#toArray\":{\"doc\":{\"synopsis\":\"Shallowly converts this collection to an Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":2711}]},\"#toSeq\":{\"doc\":{\"synopsis\":\"Returns itself\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":2716}]},\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new Seq with other collections concatenated to this one.\",\"description\":\"All entries will be present in the resulting Seq, even if they\\nhave the same key.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"KC\",\"VC\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KC\"},{\"k\":8,\"param\":\"VC\"}]}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"KC\"}]},{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"VC\"}]}]},\"line\":2724},{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"C\"}}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":3}]},{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":2725}]},\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Seq.Keyed with values passed through a\\n`mapper` function.\",\"description\":\"```js\\nconst { Seq } = require('immutable')\\nSeq.Keyed({ a: 1, b: 2 }).map(x => 10 * x)\\n// Seq { \\\"a\\\": 10, \\\"b\\\": 20 }\\n```\\n\\nNote: `map()` always returns a new instance, even if it produced the\\nsame value at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"M\"}]},\"line\":2740}]},\"#mapKeys\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.mapKeys\"}]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"M\"},{\"k\":8,\"param\":\"V\"}]},\"line\":2748}]},\"#mapEntries\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.mapEntries\"}]},\"signatures\":[{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"entry\",\"type\":{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":2756}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Seq, returning a Seq of the same type.\",\"description\":\"Similar to `seq.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":2766}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Seq with only the entries for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"F\"}]},\"line\":2778},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":2782}]},\"#flip\":{\"doc\":{\"synopsis\":\"\",\"description\":\"\",\"notes\":[{\"name\":\"see\",\"body\":\"Collection.Keyed.flip\"}]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"K\"}]},\"line\":2790}]}}}]}},\"Indexed\":{\"doc\":{\"synopsis\":\"`Seq` which represents an ordered indexed list of values.\",\"description\":\"\",\"notes\":[]},\"module\":{\"of\":{\"call\":{\"doc\":{\"synopsis\":\"Provides an Seq.Indexed of the values provided.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2802}]}}},\"call\":{\"doc\":{\"synopsis\":\"Always returns Seq.Indexed, discarding associated keys and\\nsupplying incrementing indices.\",\"description\":\"Note: `Seq.Indexed` is a conversion function and not a class, and does\\nnot use the `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":17}]},\"line\":2812},{\"typeParams\":[\"T\"],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2813},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2814}]},\"interface\":{\"line\":2816,\"typeParams\":[\"T\"],\"extends\":[{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":2},{\"k\":8,\"param\":\"T\"}]},{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]}],\"groups\":[{\"members\":{\"#toJS\":{\"doc\":{\"synopsis\":\"Deeply converts this Indexed Seq to equivalent native JavaScript Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"line\":2820}]},\"#toJSON\":{\"doc\":{\"synopsis\":\"Shallowly converts this Indexed Seq to equivalent native JavaScript Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2825}]},\"#toArray\":{\"doc\":{\"synopsis\":\"Shallowly converts this collection to an Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2830}]},\"#toSeq\":{\"doc\":{\"synopsis\":\"Returns itself\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":2835}]},\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new Seq with other collections concatenated to this one.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"valuesOrCollections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"C\"}]},{\"k\":8,\"param\":\"C\"}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":2840}]},\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Seq.Indexed with values passed through a\\n`mapper` function.\",\"description\":\"```js\\nconst { Seq } = require('immutable')\\nSeq.Indexed([ 1, 2 ]).map(x => 10 * x)\\n// Seq [ 10, 20 ]\\n```\\n\\nNote: `map()` always returns a new instance, even if it produced the\\nsame value at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":2855}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Seq, returning a a Seq of the same type.\",\"description\":\"Similar to `seq.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":2865}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Seq with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"F\"}]},\"line\":2877},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":2881}]},\"#zip\":{\"doc\":{\"synopsis\":\"Returns a Seq \\\"zipped\\\" with the provided collections.\",\"description\":\"Like `zipWith`, but using the default `zipper`: creating an `Array`.\\n\\n```js\\nconst a = Seq([ 1, 2, 3 ]);\\nconst b = Seq([ 4, 5, 6 ]);\\nconst c = a.zip(b); // Seq [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":2897},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":2898},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":17}]},\"line\":2899}]},\"#zipAll\":{\"doc\":{\"synopsis\":\"Returns a Seq \\\"zipped\\\" with the provided collections.\",\"description\":\"Unlike `zip`, `zipAll` continues zipping until the longest collection is\\nexhausted. Missing values from shorter collections are filled with `undefined`.\\n\\n```js\\nconst a = Seq([ 1, 2 ]);\\nconst b = Seq([ 3, 4, 5 ]);\\nconst c = a.zipAll(b); // Seq [ [ 1, 3 ], [ 2, 4 ], [ undefined, 5 ] ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":2913},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":2914},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":17}]},\"line\":2915}]},\"#zipWith\":{\"doc\":{\"synopsis\":\"Returns a Seq \\\"zipped\\\" with the provided collections by using a\\ncustom `zipper` function.\",\"description\":\"```js\\nconst a = Seq([ 1, 2, 3 ]);\\nconst b = Seq([ 4, 5, 6 ]);\\nconst c = a.zipWith((a, b) => a + b, b);\\n// Seq [ 5, 7, 9 ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":2928},{\"typeParams\":[\"U\",\"V\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}},{\"name\":\"thirdValue\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"thirdCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":2932},{\"typeParams\":[\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"any\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":2937}]}}}]}},\"Set\":{\"doc\":{\"synopsis\":\"`Seq` which represents a set of values.\",\"description\":\"Because `Seq` are often lazy, `Seq.Set` does not provide the same guarantee\\nof value uniqueness as the concrete `Set`.\",\"notes\":[]},\"module\":{\"of\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a Seq.Set of the provided values\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2955}]}}},\"call\":{\"doc\":{\"synopsis\":\"Always returns a Seq.Set, discarding associated indices or keys.\",\"description\":\"Note: `Seq.Set` is a conversion function and not a class, and does not\\nuse the `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":17}]},\"line\":2964},{\"typeParams\":[\"T\"],\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2965},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2966}]},\"interface\":{\"line\":2968,\"typeParams\":[\"T\"],\"extends\":[{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"T\"}]},{\"k\":9,\"name\":\"Collection.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]}],\"groups\":[{\"members\":{\"#toJS\":{\"doc\":{\"synopsis\":\"Deeply converts this Set Seq to equivalent native JavaScript Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"line\":2972}]},\"#toJSON\":{\"doc\":{\"synopsis\":\"Shallowly converts this Set Seq to equivalent native JavaScript Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2977}]},\"#toArray\":{\"doc\":{\"synopsis\":\"Shallowly converts this collection to an Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":2982}]},\"#toSeq\":{\"doc\":{\"synopsis\":\"Returns itself\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":2987}]},\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new Seq with other collections concatenated to this one.\",\"description\":\"All entries will be present in the resulting Seq, even if they\\nare duplicates.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"U\"}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":2995}]},\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Seq.Set with values passed through a\\n`mapper` function.\",\"description\":\"```js\\nSeq.Set([ 1, 2 ]).map(x => 10 * x)\\n// Seq { 10, 20 }\\n```\\n\\nNote: `map()` always returns a new instance, even if it produced the\\nsame value at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":3009}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Seq, returning a Seq of the same type.\",\"description\":\"Similar to `seq.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":3019}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Seq with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"F\"}]},\"line\":3031},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":3035}]}}}]}}},\"call\":{\"doc\":{\"synopsis\":\"Creates a Seq.\",\"description\":\"Returns a particular kind of `Seq` based on the input.\\n\\n  * If a `Seq`, that same `Seq`.\\n  * If an `Collection`, a `Seq` of the same kind (Keyed, Indexed, or Set).\\n  * If an Array-like, an `Seq.Indexed`.\\n  * If an Iterable Object, an `Seq.Indexed`.\\n  * If an Object, a `Seq.Keyed`.\\n\\nNote: An Iterator itself will be treated as an object, becoming a `Seq.Keyed`,\\nwhich is usually not what you want. You should turn your Iterator Object into\\nan iterable object by defining a Symbol.iterator (or @@iterator) method which\\nreturns `this`.\\n\\nNote: `Seq` is a conversion function and not a class, and does not use the\\n`new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"S\"],\"params\":[{\"name\":\"seq\",\"type\":{\"k\":8,\"param\":\"S\"}}],\"type\":{\"k\":8,\"param\":\"S\"},\"line\":3062},{\"typeParams\":[\"K\",\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":3063},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3064},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Collection.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3065},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3066},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"obj\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":3},{\"k\":8,\"param\":\"V\"}]},\"line\":3067},{\"type\":{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":17},{\"k\":17}]},\"line\":3068}]},\"interface\":{\"line\":3070,\"typeParams\":[\"K\",\"V\"],\"extends\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}],\"groups\":[{\"members\":{\"#size\":{\"line\":3082}}},{\"title\":\"Force evaluation\",\"members\":{\"#cacheResult\":{\"doc\":{\"synopsis\":\"Because Sequences are lazy and designed to be chained together, they do\\nnot cache their results. For example, this map function is called a total\\nof 6 times, as each `join` iterates the Seq of three values.\",\"description\":\"    var squares = Seq([ 1, 2, 3 ]).map(x => x * x)\\n    squares.join() + squares.join()\\n\\nIf you know a `Seq` will be used multiple times, it may be more\\nefficient to first cache it in memory. Here, the map function is called\\nonly 3 times.\\n\\n    var squares = Seq([ 1, 2, 3 ]).map(x => x * x).cacheResult()\\n    squares.join() + squares.join()\\n\\nUse this method judiciously, as it must fully evaluate a Seq which can be\\na burden on memory and possibly performance.\\n\\nNote: after calling `cacheResult`, a Seq will always have a `size`.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":3107}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Seq with values passed through a\\n`mapper` function.\",\"description\":\"```js\\nconst { Seq } = require('immutable')\\nSeq([ 1, 2 ]).map(x => 10 * x)\\n// Seq [ 10, 20 ]\\n```\\n\\nNote: `map()` always returns a new instance, even if it produced the same\\nvalue at every step.\\nNote: used only for sets.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"M\"}]},\"line\":3124},{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":8,\"param\":\"M\"},{\"k\":8,\"param\":\"M\"}]},\"line\":3143}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Seq, returning a Seq of the same type.\",\"description\":\"Similar to `seq.map(...).flatten(true)`.\\nNote: Used only for sets.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"M\"}]},\"line\":3153},{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":8,\"param\":\"M\"},{\"k\":8,\"param\":\"M\"}]},\"line\":3164}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Seq with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"F\"}]},\"line\":3176},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":3180}]}}}]}},\"Collection\":{\"doc\":{\"synopsis\":\"The `Collection` is a set of (key, value) entries which can be iterated, and\\nis the base class for all collections in `immutable`, allowing them to\\nmake use of all the Collection methods (such as `map` and `filter`).\",\"description\":\"Note: A collection is always iterated in the same order, however that order\\nmay not always be well defined, as is the case for the `Map` and `Set`.\\n\\nCollection is the abstract base class for concrete data structures. It\\ncannot be constructed directly.\\n\\nImplementations should extend one of the subclasses, `Collection.Keyed`,\\n`Collection.Indexed`, or `Collection.Set`.\",\"notes\":[]},\"module\":{\"Keyed\":{\"doc\":{\"synopsis\":\"Keyed Collections have discrete keys tied to each value.\",\"description\":\"When iterating `Collection.Keyed`, each iteration will yield a `[K, V]`\\ntuple, in other words, `Collection#entries` is the default iterator for\\nKeyed Collections.\",\"notes\":[]},\"module\":{},\"call\":{\"doc\":{\"synopsis\":\"Creates a Collection.Keyed\",\"description\":\"Similar to `Collection()`, however it expects collection-likes of [K, V]\\ntuples if not constructed from a Collection.Keyed or JS Object.\\n\\nNote: `Collection.Keyed` is a conversion function and not a class, and\\ndoes not use the `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\",\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":3241},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"obj\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":3},{\"k\":8,\"param\":\"V\"}]},\"line\":3242}]},\"interface\":{\"line\":3244,\"typeParams\":[\"K\",\"V\"],\"extends\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}],\"groups\":[{\"members\":{\"#toJS\":{\"doc\":{\"synopsis\":\"Deeply converts this Keyed collection to equivalent native JavaScript Object.\",\"description\":\"Converts keys to Strings.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Object\"},\"line\":3250}]},\"#toJSON\":{\"doc\":{\"synopsis\":\"Shallowly converts this Keyed collection to equivalent native JavaScript Object.\",\"description\":\"Converts keys to Strings.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]},\"line\":3257}]},\"#toArray\":{\"doc\":{\"synopsis\":\"Shallowly converts this collection to an Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":3262}]},\"#toSeq\":{\"doc\":{\"synopsis\":\"Returns Seq.Keyed.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":3268}]}}},{\"title\":\"Sequence functions\",\"members\":{\"#flip\":{\"doc\":{\"synopsis\":\"Returns a new Collection.Keyed of the same type where the keys and values\\nhave been flipped.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap({ a: 'z', b: 'y' }).flip()\\n// Map { \\\"z\\\": \\\"a\\\", \\\"y\\\": \\\"b\\\" }\\n```\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"K\"}]},\"line\":3284}]},\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new Collection with other collections concatenated to this one.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"KC\",\"VC\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KC\"},{\"k\":8,\"param\":\"VC\"}]}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"KC\"}]},{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"VC\"}]}]},\"line\":3289},{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"C\"}}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":3}]},{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":3290}]},\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Collection.Keyed with values passed through a\\n`mapper` function.\",\"description\":\"```js\\nconst { Collection } = require('immutable')\\nCollection.Keyed({ a: 1, b: 2 }).map(x => 10 * x)\\n// Seq { \\\"a\\\": 10, \\\"b\\\": 20 }\\n```\\n\\nNote: `map()` always returns a new instance, even if it produced the\\nsame value at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"M\"}]},\"line\":3305}]},\"#mapKeys\":{\"doc\":{\"synopsis\":\"Returns a new Collection.Keyed of the same type with keys passed through\\na `mapper` function.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap({ a: 1, b: 2 }).mapKeys(x => x.toUpperCase())\\n// Map { \\\"A\\\": 1, \\\"B\\\": 2 }\\n```\\n\\nNote: `mapKeys()` always returns a new instance, even if it produced\\nthe same key at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"M\"},{\"k\":8,\"param\":\"V\"}]},\"line\":3324}]},\"#mapEntries\":{\"doc\":{\"synopsis\":\"Returns a new Collection.Keyed of the same type with entries\\n([key, value] tuples) passed through a `mapper` function.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap({ a: 1, b: 2 })\\n  .mapEntries(([ k, v ]) => [ k.toUpperCase(), v * 2 ])\\n// Map { \\\"A\\\": 2, \\\"B\\\": 4 }\\n```\\n\\nNote: `mapEntries()` always returns a new instance, even if it produced\\nthe same entry at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"entry\",\"type\":{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":3344}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Collection, returning a Collection of the same type.\",\"description\":\"Similar to `collection.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":3354}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Collection with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"F\"}]},\"line\":3366},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":3370}]},\"#[Symbol.iterator]\":{\"signatures\":[{\"type\":{\"k\":9,\"name\":\"IterableIterator\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":3375}]}}}]}},\"Indexed\":{\"doc\":{\"synopsis\":\"Indexed Collections have incrementing numeric keys. They exhibit\\nslightly different behavior than `Collection.Keyed` for some methods in order\\nto better mirror the behavior of JavaScript's `Array`, and add methods\\nwhich do not make sense on non-indexed Collections such as `indexOf`.\",\"description\":\"Unlike JavaScript arrays, `Collection.Indexed`s are always dense. \\\"Unset\\\"\\nindices and `undefined` indices are indistinguishable, and all indices from\\n0 to `size` are visited when iterated.\\n\\nAll Collection.Indexed methods return re-indexed Collections. In other words,\\nindices always start at 0 and increment until size. If you wish to\\npreserve indices, using them as keys, convert to a Collection.Keyed by\\ncalling `toKeyedSeq`.\",\"notes\":[]},\"module\":{},\"call\":{\"doc\":{\"synopsis\":\"Creates a new Collection.Indexed.\",\"description\":\"Note: `Collection.Indexed` is a conversion function and not a class, and\\ndoes not use the `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3402}]},\"interface\":{\"line\":3404,\"typeParams\":[\"T\"],\"extends\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":2},{\"k\":8,\"param\":\"T\"}]}],\"groups\":[{\"members\":{\"#toJS\":{\"doc\":{\"synopsis\":\"Deeply converts this Indexed collection to equivalent native JavaScript Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"line\":3408}]},\"#toJSON\":{\"doc\":{\"synopsis\":\"Shallowly converts this Indexed collection to equivalent native JavaScript Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3413}]},\"#toArray\":{\"doc\":{\"synopsis\":\"Shallowly converts this collection to an Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3418}]}}},{\"title\":\"Reading values\",\"members\":{\"#get\":{\"doc\":{\"synopsis\":\"Returns the value associated with the provided index, or notSetValue if\\nthe index is beyond the bounds of the Collection.\",\"description\":\"`index` may be a negative number, which indexes back from the end of the\\nCollection. `s.get(-1)` gets the last item in the Collection.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"NSV\"],\"params\":[{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"NSV\"}]},\"line\":3429},{\"params\":[{\"name\":\"index\",\"type\":{\"k\":2}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":11}]},\"line\":3430}]}}},{\"title\":\"Conversion to Seq\",\"members\":{\"#toSeq\":{\"doc\":{\"synopsis\":\"Returns Seq.Indexed.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3439}]},\"#fromEntrySeq\":{\"doc\":{\"synopsis\":\"If this is a collection of [key, value] entry tuples, it will return a\\nSeq.Keyed of those entries.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":17},{\"k\":17}]},\"line\":3445}]}}},{\"title\":\"Combination\",\"members\":{\"#interpose\":{\"doc\":{\"synopsis\":\"Returns a Collection of the same type with `separator` between each item\\nin this Collection.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"separator\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":10},\"line\":3454}]},\"#interleave\":{\"doc\":{\"synopsis\":\"Returns a Collection of the same type with the provided `collections`\\ninterleaved into this collection.\",\"description\":\"The resulting Collection includes the first item from each, then the\\nsecond from each, etc.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"require('immutable')\\\"}\\n-->\\n```js\\nconst { List } = require('immutable')\\nList([ 1, 2, 3 ]).interleave(List([ 'A', 'B', 'C' ]))\\n// List [ 1, \\\"A\\\", 2, \\\"B\\\", 3, \\\"C\\\" ]\\n```\\n\\nThe shortest Collection stops interleave.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable')\\\" }\\n-->\\n```js\\nList([ 1, 2, 3 ]).interleave(\\n  List([ 'A', 'B' ]),\\n  List([ 'X', 'Y', 'Z' ])\\n)\\n// List [ 1, \\\"A\\\", \\\"X\\\", 2, \\\"B\\\", \\\"Y\\\" ]\\n```\\n\\nSince `interleave()` re-indexes values, it produces a complete copy,\\nwhich has `O(N)` complexity.\\n\\nNote: `interleave` *cannot* be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"T\"}]}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":3490}]},\"#splice\":{\"doc\":{\"synopsis\":\"Splice returns a new indexed Collection by replacing a region of this\\nCollection with new values. If values are not provided, it only skips the\\nregion to be removed.\",\"description\":\"`index` may be a negative number, which indexes back from the end of the\\nCollection. `s.splice(-2)` splices after the second to last item.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nList([ 'a', 'b', 'c', 'd' ]).splice(1, 2, 'q', 'r', 's')\\n// List [ \\\"a\\\", \\\"q\\\", \\\"r\\\", \\\"s\\\", \\\"d\\\" ]\\n```\\n\\nSince `splice()` re-indexes values, it produces a complete copy, which\\nhas `O(N)` complexity.\\n\\nNote: `splice` *cannot* be used in `withMutations`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"removeNum\",\"type\":{\"k\":2}},{\"name\":\"values\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"varArgs\":true}],\"type\":{\"k\":10},\"line\":3512}]},\"#zip\":{\"doc\":{\"synopsis\":\"Returns a Collection of the same type \\\"zipped\\\" with the provided\\ncollections.\",\"description\":\"Like `zipWith`, but using the default `zipper`: creating an `Array`.\\n\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable')\\\" }\\n-->\\n```js\\nconst a = List([ 1, 2, 3 ]);\\nconst b = List([ 4, 5, 6 ]);\\nconst c = a.zip(b); // List [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":3534},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":3535},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":17}]},\"line\":3536}]},\"#zipAll\":{\"doc\":{\"synopsis\":\"Returns a Collection \\\"zipped\\\" with the provided collections.\",\"description\":\"Unlike `zip`, `zipAll` continues zipping until the longest collection is\\nexhausted. Missing values from shorter collections are filled with `undefined`.\\n\\n```js\\nconst a = List([ 1, 2 ]);\\nconst b = List([ 3, 4, 5 ]);\\nconst c = a.zipAll(b); // List [ [ 1, 3 ], [ 2, 4 ], [ undefined, 5 ] ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":3550},{\"typeParams\":[\"U\",\"V\"],\"params\":[{\"name\":\"other\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"other2\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":3551},{\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":17}]},\"line\":3552}]},\"#zipWith\":{\"doc\":{\"synopsis\":\"Returns a Collection of the same type \\\"zipped\\\" with the provided\\ncollections by using a custom `zipper` function.\",\"description\":\"<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { List } = require('immutable')\\\" }\\n-->\\n```js\\nconst a = List([ 1, 2, 3 ]);\\nconst b = List([ 4, 5, 6 ]);\\nconst c = a.zipWith((a, b) => a + b, b);\\n// List [ 5, 7, 9 ]\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":3568},{\"typeParams\":[\"U\",\"V\",\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"otherValue\",\"type\":{\"k\":8,\"param\":\"U\"}},{\"name\":\"thirdValue\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"otherCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"U\"}]}},{\"name\":\"thirdCollection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":3572},{\"typeParams\":[\"Z\"],\"params\":[{\"name\":\"zipper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"any\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"Z\"}}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"Z\"}]},\"line\":3577}]}}},{\"title\":\"Search for value\",\"members\":{\"#indexOf\":{\"doc\":{\"synopsis\":\"Returns the first index at which a given value can be found in the\\nCollection, or -1 if it is not present.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"searchValue\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":2},\"line\":3589}]},\"#lastIndexOf\":{\"doc\":{\"synopsis\":\"Returns the last index at which a given value can be found in the\\nCollection, or -1 if it is not present.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"searchValue\",\"type\":{\"k\":8,\"param\":\"T\"}}],\"type\":{\"k\":2},\"line\":3595}]},\"#findIndex\":{\"doc\":{\"synopsis\":\"Returns the first index in the Collection where a value satisfies the\\nprovided predicate function. Otherwise -1 is returned.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":2},\"line\":3601}]},\"#findLastIndex\":{\"doc\":{\"synopsis\":\"Returns the last index in the Collection where a value satisfies the\\nprovided predicate function. Otherwise -1 is returned.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":2},\"line\":3610}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new Collection with other collections concatenated to this one.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"valuesOrCollections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"C\"}]},{\"k\":8,\"param\":\"C\"}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"C\"}]}]},\"line\":3620}]},\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Collection.Indexed with values passed through a\\n`mapper` function.\",\"description\":\"```js\\nconst { Collection } = require('immutable')\\nCollection.Indexed([1,2]).map(x => 10 * x)\\n// Seq [ 1, 2 ]\\n```\\n\\nNote: `map()` always returns a new instance, even if it produced the\\nsame value at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":3635}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Collection, returning a Collection of the same type.\",\"description\":\"Similar to `collection.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":3645}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Collection with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"F\"}]},\"line\":3657},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"index\",\"type\":{\"k\":2}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":3661}]},\"#[Symbol.iterator]\":{\"signatures\":[{\"type\":{\"k\":9,\"name\":\"IterableIterator\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3666}]}}}]}},\"Set\":{\"doc\":{\"synopsis\":\"Set Collections only represent values. They have no associated keys or\\nindices. Duplicate values are possible in the lazy `Seq.Set`s, however\\nthe concrete `Set` Collection does not allow duplicate values.\",\"description\":\"Collection methods on Collection.Set such as `map` and `forEach` will provide\\nthe value as both the first and second arguments to the provided function.\\n\\n```js\\nconst { Collection } = require('immutable')\\nconst seq = Collection.Set([ 'A', 'B', 'C' ])\\n// Seq { \\\"A\\\", \\\"B\\\", \\\"C\\\" }\\nseq.forEach((v, k) =>\\n assert.equal(v, k)\\n)\\n```\",\"notes\":[]},\"module\":{},\"call\":{\"doc\":{\"synopsis\":\"Similar to `Collection()`, but always returns a Collection.Set.\",\"description\":\"Note: `Collection.Set` is a factory function and not a class, and does\\nnot use the `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3695}]},\"interface\":{\"line\":3697,\"typeParams\":[\"T\"],\"extends\":[{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"T\"}]}],\"groups\":[{\"members\":{\"#toJS\":{\"doc\":{\"synopsis\":\"Deeply converts this Set collection to equivalent native JavaScript Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"line\":3701}]},\"#toJSON\":{\"doc\":{\"synopsis\":\"Shallowly converts this Set collection to equivalent native JavaScript Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3706}]},\"#toArray\":{\"doc\":{\"synopsis\":\"Shallowly converts this collection to an Array.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3711}]},\"#toSeq\":{\"doc\":{\"synopsis\":\"Returns Seq.Set.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3717}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new Collection with other collections concatenated to this one.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"U\"],\"params\":[{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"U\"}]}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Set\",\"args\":[{\"k\":12,\"types\":[{\"k\":8,\"param\":\"T\"},{\"k\":8,\"param\":\"U\"}]}]},\"line\":3724}]},\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Collection.Set with values passed through a\\n`mapper` function.\",\"description\":\"```\\nCollection.Set([ 1, 2 ]).map(x => 10 * x)\\n// Seq { 1, 2 }\\n```\\n\\nNote: `map()` always returns a new instance, even if it produced the\\nsame value at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Set\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":3738}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Collection, returning a Collection of the same type.\",\"description\":\"Similar to `collection.map(...).flatten(true)`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Set\",\"args\":[{\"k\":8,\"param\":\"M\"}]},\"line\":3748}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Collection with only the values for which the `predicate`\\nfunction returns true.\",\"description\":\"Note: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection.Set\",\"args\":[{\"k\":8,\"param\":\"F\"}]},\"line\":3760},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"T\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":3764}]},\"#[Symbol.iterator]\":{\"signatures\":[{\"type\":{\"k\":9,\"name\":\"IterableIterator\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3769}]}}}]}}},\"call\":{\"doc\":{\"synopsis\":\"Creates a Collection.\",\"description\":\"The type of Collection created is based on the input.\\n\\n  * If an `Collection`, that same `Collection`.\\n  * If an Array-like, an `Collection.Indexed`.\\n  * If an Object with an Iterator defined, an `Collection.Indexed`.\\n  * If an Object, an `Collection.Keyed`.\\n\\nThis methods forces the conversion of Objects and Strings to Collections.\\nIf you want to ensure that a Collection of one item is returned, use\\n`Seq.of`.\\n\\nNote: An Iterator itself will be treated as an object, becoming a `Seq.Keyed`,\\nwhich is usually not what you want. You should turn your Iterator Object into\\nan iterable object by defining a Symbol.iterator (or @@iterator) method which\\nreturns `this`.\\n\\nNote: `Collection` is a conversion function and not a class, and does not\\nuse the `new` keyword during construction.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"I\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"I\"}}],\"type\":{\"k\":8,\"param\":\"I\"},\"line\":3796},{\"typeParams\":[\"T\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"T\"}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":8,\"param\":\"T\"}]},\"line\":3797},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"obj\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}}],\"type\":{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":3},{\"k\":8,\"param\":\"V\"}]},\"line\":3798}]},\"interface\":{\"line\":3800,\"typeParams\":[\"K\",\"V\"],\"extends\":[{\"k\":9,\"name\":\"ValueObject\"}],\"groups\":[{\"title\":\"Value equality\",\"members\":{\"#equals\":{\"doc\":{\"synopsis\":\"True if this and the other Collection have value equality, as defined\\nby `Immutable.is()`.\",\"description\":\"Note: This is equivalent to `Immutable.is(this, other)`, but provided to\\nallow for chained expressions.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"other\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":3811}]},\"#hashCode\":{\"doc\":{\"synopsis\":\"Computes and returns the hashed identity for this Collection.\",\"description\":\"The `hashCode` of a Collection is used to determine potential equality,\\nand is used when adding this to a `Set` or as a key in a `Map`, enabling\\nlookup via a different instance.\\n\\n<!-- runkit:activate\\n     { \\\"preamble\\\": \\\"const { Set,  List } = require('immutable')\\\" }\\n-->\\n```js\\nconst a = List([ 1, 2, 3 ]);\\nconst b = List([ 1, 2, 3 ]);\\nassert.notStrictEqual(a, b); // different instances\\nconst set = Set([ a ]);\\nassert.equal(set.has(b), true);\\n```\\n\\nIf two values have the same `hashCode`, they are [not guaranteed\\nto be equal][Hash Collision]. If two values have different `hashCode`s,\\nthey must not be equal.\\n\\n[Hash Collision]: http://en.wikipedia.org/wiki/Collision_(computer_science)\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":2},\"line\":3837}]}}},{\"title\":\"Reading values\",\"members\":{\"#get\":{\"doc\":{\"synopsis\":\"Returns the value associated with the provided key, or notSetValue if\\nthe Collection does not contain this key.\",\"description\":\"Note: it is possible a key may be associated with an `undefined` value,\\nso if `notSetValue` is not provided and this method returns `undefined`,\\nthat does not guarantee the key was not found.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"NSV\"],\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]},\"line\":3850},{\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":3851}]},\"#has\":{\"doc\":{\"synopsis\":\"True if a key exists within this `Collection`, using `Immutable.is`\\nto determine equality\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":1},\"line\":3857}]},\"#includes\":{\"doc\":{\"synopsis\":\"True if a value exists within this `Collection`, using `Immutable.is`\\nto determine equality\",\"description\":\"\",\"notes\":[{\"name\":\"alias\",\"body\":\"contains\"}]},\"signatures\":[{\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":1},\"line\":3864}]},\"#first\":{\"doc\":{\"synopsis\":\"In case the `Collection` is not empty returns the first element of the\\n`Collection`.\\nIn case the `Collection` is empty returns the optional default\\nvalue if provided, if no default value is provided returns undefined.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"NSV\"],\"params\":[{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]},\"line\":3873}]},\"#last\":{\"doc\":{\"synopsis\":\"In case the `Collection` is not empty returns the last element of the\\n`Collection`.\\nIn case the `Collection` is empty returns the optional default\\nvalue if provided, if no default value is provided returns undefined.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"NSV\"],\"params\":[{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]},\"line\":3881}]}}},{\"title\":\"Reading deep values\",\"members\":{\"#getIn\":{\"doc\":{\"synopsis\":\"Returns the value found by following a path of keys or indices through\\nnested Collections.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map, List } = require('immutable')\\nconst deepData = Map({ x: List([ Map({ y: 123 }) ]) });\\ndeepData.getIn(['x', 0, 'y']) // 123\\n```\\n\\nPlain JavaScript Object or Arrays may be nested within an Immutable.js\\nCollection, and getIn() can access those values as well:\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map, List } = require('immutable')\\nconst deepData = Map({ x: [ { y: 123 } ] });\\ndeepData.getIn(['x', 0, 'y']) // 123\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"searchKeyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"notSetValue\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":17},\"line\":3906}]},\"#hasIn\":{\"doc\":{\"synopsis\":\"True if the result of following a path of keys or indices through nested\\nCollections results in a set value.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"searchKeyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}}],\"type\":{\"k\":1},\"line\":3912}]}}},{\"title\":\"Persistent changes\",\"members\":{\"#update\":{\"doc\":{\"synopsis\":\"This can be very useful as a way to \\\"chain\\\" a normal function into a\\nsequence of methods. RxJS calls this \\\"let\\\" and lodash calls it \\\"thru\\\".\",\"description\":\"For example, to sum a Seq after mapping and filtering:\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Seq } = require('immutable')\\n\\nfunction sum(collection) {\\n  return collection.reduce((sum, x) => sum + x, 0)\\n}\\n\\nSeq([ 1, 2, 3 ])\\n  .map(x => x + 1)\\n  .filter(x => x % 2 === 0)\\n  .update(sum)\\n// 6\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"R\"],\"params\":[{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"R\"}}}],\"type\":{\"k\":8,\"param\":\"R\"},\"line\":3937}]}}},{\"title\":\"Conversion to JavaScript types\",\"members\":{\"#toJS\":{\"doc\":{\"synopsis\":\"Deeply converts this Collection to equivalent native JavaScript Array or Object.\",\"description\":\"`Collection.Indexed`, and `Collection.Set` become `Array`, while\\n`Collection.Keyed` become `Object`, converting keys to Strings.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]}]},\"line\":3948}]},\"#toJSON\":{\"doc\":{\"synopsis\":\"Shallowly converts this Collection to equivalent native JavaScript Array or Object.\",\"description\":\"`Collection.Indexed`, and `Collection.Set` become `Array`, while\\n`Collection.Keyed` become `Object`, converting keys to Strings.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"V\"}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}]},\"line\":3956}]},\"#toArray\":{\"doc\":{\"synopsis\":\"Shallowly converts this collection to an Array.\",\"description\":\"`Collection.Indexed`, and `Collection.Set` produce an Array of values.\\n`Collection.Keyed` produce an Array of [key, value] tuples.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"V\"}]},{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]}]},\"line\":3964}]},\"#toObject\":{\"doc\":{\"synopsis\":\"Shallowly converts this Collection to an Object.\",\"description\":\"Converts keys to Strings.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]},\"line\":3971}]}}},{\"title\":\"Conversion to Collections\",\"members\":{\"#toMap\":{\"doc\":{\"synopsis\":\"Converts this Collection to a Map, Throws if keys are not hashable.\",\"description\":\"Note: This is equivalent to `Map(this.toKeyedSeq())`, but provided\\nfor convenience and to allow for chained expressions.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":3982}]},\"#toOrderedMap\":{\"doc\":{\"synopsis\":\"Converts this Collection to a Map, maintaining the order of iteration.\",\"description\":\"Note: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but\\nprovided for convenience and to allow for chained expressions.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"OrderedMap\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":3990}]},\"#toSet\":{\"doc\":{\"synopsis\":\"Converts this Collection to a Set, discarding keys. Throws if values\\nare not hashable.\",\"description\":\"Note: This is equivalent to `Set(this)`, but provided to allow for\\nchained expressions.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Set\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":3999}]},\"#toOrderedSet\":{\"doc\":{\"synopsis\":\"Converts this Collection to a Set, maintaining the order of iteration and\\ndiscarding keys.\",\"description\":\"Note: This is equivalent to `OrderedSet(this.valueSeq())`, but provided\\nfor convenience and to allow for chained expressions.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"OrderedSet\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":4008}]},\"#toList\":{\"doc\":{\"synopsis\":\"Converts this Collection to a List, discarding keys.\",\"description\":\"This is similar to `List(collection)`, but provided to allow for chained\\nexpressions. However, when called on `Map` or other keyed collections,\\n`collection.toList()` discards the keys and creates a list of only the\\nvalues, whereas `List(collection)` creates a list of entry tuples.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map, List } = require('immutable')\\nvar myMap = Map({ a: 'Apple', b: 'Banana' })\\nList(myMap) // List [ [ \\\"a\\\", \\\"Apple\\\" ], [ \\\"b\\\", \\\"Banana\\\" ] ]\\nmyMap.toList() // List [ \\\"Apple\\\", \\\"Banana\\\" ]\\n```\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"List\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":4026}]},\"#toStack\":{\"doc\":{\"synopsis\":\"Converts this Collection to a Stack, discarding keys. Throws if values\\nare not hashable.\",\"description\":\"Note: This is equivalent to `Stack(this)`, but provided to allow for\\nchained expressions.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Stack\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":4035}]}}},{\"title\":\"Conversion to Seq\",\"members\":{\"#toSeq\":{\"doc\":{\"synopsis\":\"Converts this Collection to a Seq of the same kind (indexed,\\nkeyed, or set).\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":4044}]},\"#toKeyedSeq\":{\"doc\":{\"synopsis\":\"Returns a Seq.Keyed from this Collection where indices are treated as keys.\",\"description\":\"This is useful if you want to operate on an\\nCollection.Indexed and preserve the [index, value] pairs.\\n\\nThe returned Seq will have identical iteration order as\\nthis Collection.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Seq } = require('immutable')\\nconst indexedSeq = Seq([ 'A', 'B', 'C' ])\\n// Seq [ \\\"A\\\", \\\"B\\\", \\\"C\\\" ]\\nindexedSeq.filter(v => v === 'B')\\n// Seq [ \\\"B\\\" ]\\nconst keyedSeq = indexedSeq.toKeyedSeq()\\n// Seq { 0: \\\"A\\\", 1: \\\"B\\\", 2: \\\"C\\\" }\\nkeyedSeq.filter(v => v === 'B')\\n// Seq { 1: \\\"B\\\" }\\n```\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},\"line\":4068}]},\"#toIndexedSeq\":{\"doc\":{\"synopsis\":\"Returns an Seq.Indexed of the values of this Collection, discarding keys.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":4073}]},\"#toSetSeq\":{\"doc\":{\"synopsis\":\"Returns a Seq.Set of the values of this Collection, discarding keys.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Set\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":4078}]}}},{\"title\":\"Iterators\",\"members\":{\"#keys\":{\"doc\":{\"synopsis\":\"An iterator of this `Collection`'s keys.\",\"description\":\"Note: this will return an ES6 iterator which does not support\\nImmutable.js sequence algorithms. Use `keySeq` instead, if this is\\nwhat you want.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"IterableIterator\",\"args\":[{\"k\":8,\"param\":\"K\"}]},\"line\":4090}]},\"#values\":{\"doc\":{\"synopsis\":\"An iterator of this `Collection`'s values.\",\"description\":\"Note: this will return an ES6 iterator which does not support\\nImmutable.js sequence algorithms. Use `valueSeq` instead, if this is\\nwhat you want.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"IterableIterator\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":4099}]},\"#entries\":{\"doc\":{\"synopsis\":\"An iterator of this `Collection`'s entries as `[ key, value ]` tuples.\",\"description\":\"Note: this will return an ES6 iterator which does not support\\nImmutable.js sequence algorithms. Use `entrySeq` instead, if this is\\nwhat you want.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"IterableIterator\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":4108}]}}},{\"title\":\"Collections (Seq)\",\"members\":{\"#keySeq\":{\"doc\":{\"synopsis\":\"Returns a new Seq.Indexed of the keys of this Collection,\\ndiscarding values.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"K\"}]},\"line\":4117}]},\"#valueSeq\":{\"doc\":{\"synopsis\":\"Returns an Seq.Indexed of the values of this Collection, discarding keys.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":4122}]},\"#entrySeq\":{\"doc\":{\"synopsis\":\"Returns a new Seq.Indexed of [key, value] tuples.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":9,\"name\":\"Seq.Indexed\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":4127}]}}},{\"title\":\"Sequence algorithms\",\"members\":{\"#map\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type with values passed through a\\n`mapper` function.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Collection } = require('immutable')\\nCollection({ a: 1, b: 2 }).map(x => 10 * x)\\n// Seq { \\\"a\\\": 10, \\\"b\\\": 20 }\\n```\\n\\nNote: `map()` always returns a new instance, even if it produced the same\\nvalue at every step.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"M\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"M\"}]},\"line\":4146}]},\"#filter\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type with only the entries for which\\nthe `predicate` function returns true.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap({ a: 1, b: 2, c: 3, d: 4}).filter(x => x % 2 === 0)\\n// Map { \\\"b\\\": 2, \\\"d\\\": 4 }\\n```\\n\\nNote: `filter()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"F\"],\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"F\"}]},\"line\":4173},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":4177}]},\"#filterNot\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type with only the entries for which\\nthe `predicate` function returns false.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)\\n// Map { \\\"a\\\": 1, \\\"c\\\": 3 }\\n```\\n\\nNote: `filterNot()` always returns a new instance, even if it results in\\nnot filtering out any values.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":4196}]},\"#reverse\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type in reverse order.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":4204}]},\"#sort\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which includes the same entries,\\nstably sorted by using a `comparator`.\",\"description\":\"If a `comparator` is not provided, a default comparator uses `<` and `>`.\\n\\n`comparator(valueA, valueB)`:\\n\\n  * Returns `0` if the elements should not be swapped.\\n  * Returns `-1` (or any negative number) if `valueA` comes before `valueB`\\n  * Returns `1` (or any positive number) if `valueA` comes after `valueB`\\n  * Is pure, i.e. it must always return the same value for the same pair\\n    of values.\\n\\nWhen sorting collections which have no defined order, their ordered\\nequivalents will be returned. e.g. `map.sort()` returns OrderedMap.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nMap({ \\\"c\\\": 3, \\\"a\\\": 1, \\\"b\\\": 2 }).sort((a, b) => {\\n  if (a < b) { return -1; }\\n  if (a > b) { return 1; }\\n  if (a === b) { return 0; }\\n});\\n// OrderedMap { \\\"a\\\": 1, \\\"b\\\": 2, \\\"c\\\": 3 }\\n```\\n\\nNote: `sort()` Always returns a new instance, even if the original was\\nalready sorted.\\n\\nNote: This is always an eager operation.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"comparator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"valueA\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"valueB\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":2}},\"optional\":true}],\"type\":{\"k\":10},\"line\":4239}]},\"#sortBy\":{\"doc\":{\"synopsis\":\"Like `sort`, but also accepts a `comparatorValueMapper` which allows for\\nsorting by more sophisticated means:\",\"description\":\"    hitters.sortBy(hitter => hitter.avgHits)\\n\\nNote: `sortBy()` Always returns a new instance, even if the original was\\nalready sorted.\\n\\nNote: This is always an eager operation.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"comparatorValueMapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"C\"}}},{\"name\":\"comparator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"valueA\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"valueB\",\"type\":{\"k\":8,\"param\":\"C\"}}],\"type\":{\"k\":2}},\"optional\":true}],\"type\":{\"k\":10},\"line\":4252}]},\"#groupBy\":{\"doc\":{\"synopsis\":\"Returns a `Collection.Keyed` of `Collection.Keyeds`, grouped by the return\\nvalue of the `grouper` function.\",\"description\":\"Note: This is always an eager operation.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { List, Map } = require('immutable')\\nconst listOfMaps = List([\\n  Map({ v: 0 }),\\n  Map({ v: 1 }),\\n  Map({ v: 1 }),\\n  Map({ v: 0 }),\\n  Map({ v: 2 })\\n])\\nconst groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))\\n// Map {\\n//   0: List [ Map{ \\\"v\\\": 0 }, Map { \\\"v\\\": 0 } ],\\n//   1: List [ Map{ \\\"v\\\": 1 }, Map { \\\"v\\\": 1 } ],\\n//   2: List [ Map{ \\\"v\\\": 2 } ],\\n// }\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"G\"],\"params\":[{\"name\":\"grouper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"G\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Seq.Keyed\",\"args\":[{\"k\":8,\"param\":\"G\"},{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}]},\"line\":4281}]}}},{\"title\":\"Side effects\",\"members\":{\"#forEach\":{\"doc\":{\"synopsis\":\"The `sideEffect` is executed for every entry in the Collection.\",\"description\":\"Unlike `Array#forEach`, if any call of `sideEffect` returns\\n`false`, the iteration will stop. Returns the number of entries iterated\\n(including the last iteration which returned false).\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"sideEffect\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":17}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":2},\"line\":4296}]}}},{\"title\":\"Creating subsets\",\"members\":{\"#slice\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type representing a portion of this\\nCollection from start up to but not including end.\",\"description\":\"If begin is negative, it is offset from the end of the Collection. e.g.\\n`slice(-2)` returns a Collection of the last two entries. If it is not\\nprovided the new Collection will begin at the beginning of this Collection.\\n\\nIf end is negative, it is offset from the end of the Collection. e.g.\\n`slice(0, -1)` returns a Collection of everything but the last entry. If\\nit is not provided, the new Collection will continue through the end of\\nthis Collection.\\n\\nIf the requested slice is equivalent to the current Collection, then it\\nwill return itself.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"begin\",\"type\":{\"k\":2},\"optional\":true},{\"name\":\"end\",\"type\":{\"k\":2},\"optional\":true}],\"type\":{\"k\":10},\"line\":4320}]},\"#rest\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type containing all entries except\\nthe first.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":4326}]},\"#butLast\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type containing all entries except\\nthe last.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":10},\"line\":4332}]},\"#skip\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which excludes the first `amount`\\nentries from this Collection.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"amount\",\"type\":{\"k\":2}}],\"type\":{\"k\":10},\"line\":4338}]},\"#skipLast\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which excludes the last `amount`\\nentries from this Collection.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"amount\",\"type\":{\"k\":2}}],\"type\":{\"k\":10},\"line\":4344}]},\"#skipWhile\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which includes entries starting\\nfrom when `predicate` first returns false.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\\n  .skipWhile(x => x.match(/g/))\\n// List [ \\\"cat\\\", \\\"hat\\\", \\\"god\\\" ]\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":4358}]},\"#skipUntil\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which includes entries starting\\nfrom when `predicate` first returns true.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\\n  .skipUntil(x => x.match(/hat/))\\n// List [ \\\"hat\\\", \\\"god\\\" ]\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":4375}]},\"#take\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which includes the first `amount`\\nentries from this Collection.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"amount\",\"type\":{\"k\":2}}],\"type\":{\"k\":10},\"line\":4384}]},\"#takeLast\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which includes the last `amount`\\nentries from this Collection.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"amount\",\"type\":{\"k\":2}}],\"type\":{\"k\":10},\"line\":4390}]},\"#takeWhile\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which includes entries from this\\nCollection as long as the `predicate` returns true.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\\n  .takeWhile(x => x.match(/o/))\\n// List [ \\\"dog\\\", \\\"frog\\\" ]\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":4404}]},\"#takeUntil\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type which includes entries from this\\nCollection as long as the `predicate` returns false.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { List } = require('immutable')\\nList([ 'dog', 'frog', 'cat', 'hat', 'god' ])\\n  .takeUntil(x => x.match(/at/))\\n// List [ \\\"dog\\\", \\\"frog\\\" ]\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":10},\"line\":4421}]}}},{\"title\":\"Combination\",\"members\":{\"#concat\":{\"doc\":{\"synopsis\":\"Returns a new Collection of the same type with other values and\\ncollection-like concatenated to this one.\",\"description\":\"For Seqs, all entries will be present in the resulting Seq, even if they\\nhave the same key.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"valuesOrCollections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":17}]},\"varArgs\":true}],\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]},\"line\":4436}]},\"#flatten\":{\"doc\":{\"synopsis\":\"Flattens nested Collections.\",\"description\":\"Will deeply flatten the Collection by default, returning a Collection of the\\nsame type, but a `depth` can be provided in the form of a number or\\nboolean (where true means to shallowly flatten one level). A depth of 0\\n(or shallow: false) will deeply flatten.\\n\\nFlattens only others Collection, not Arrays or Objects.\\n\\nNote: `flatten(true)` operates on Collection<unknown, Collection<K, V>> and\\nreturns Collection<K, V>\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"depth\",\"type\":{\"k\":2},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]},\"line\":4451},{\"params\":[{\"name\":\"shallow\",\"type\":{\"k\":1},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":17},{\"k\":17}]},\"line\":4452}]},\"#flatMap\":{\"doc\":{\"synopsis\":\"Flat-maps the Collection, returning a Collection of the same type.\",\"description\":\"Similar to `collection.map(...).flatten(true)`.\\nUsed for Dictionaries only.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"M\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"M\"}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"M\"}]},\"line\":4459},{\"typeParams\":[\"KM\",\"VM\"],\"params\":[{\"name\":\"mapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]}]}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"KM\"},{\"k\":8,\"param\":\"VM\"}]},\"line\":4470}]}}},{\"title\":\"Reducing a value\",\"members\":{\"#reduce\":{\"doc\":{\"synopsis\":\"Reduces the Collection to a value by calling the `reducer` for every entry\\nin the Collection and passing along the reduced value.\",\"description\":\"If `initialReduction` is not provided, the first item in the\\nCollection will be used.\\n\",\"notes\":[{\"name\":\"see\",\"body\":\"`Array#reduce`.\"}]},\"signatures\":[{\"typeParams\":[\"R\"],\"params\":[{\"name\":\"reducer\",\"type\":{\"k\":7,\"params\":[{\"name\":\"reduction\",\"type\":{\"k\":8,\"param\":\"R\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"R\"}}},{\"name\":\"initialReduction\",\"type\":{\"k\":8,\"param\":\"R\"}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":8,\"param\":\"R\"},\"line\":4486},{\"typeParams\":[\"R\"],\"params\":[{\"name\":\"reducer\",\"type\":{\"k\":7,\"params\":[{\"name\":\"reduction\",\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"R\"}]}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"R\"}}}],\"type\":{\"k\":8,\"param\":\"R\"},\"line\":4491}]},\"#reduceRight\":{\"doc\":{\"synopsis\":\"Reduces the Collection in reverse (from the right side).\",\"description\":\"Note: Similar to this.reverse().reduce(), and provided for parity\\nwith `Array#reduceRight`.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"R\"],\"params\":[{\"name\":\"reducer\",\"type\":{\"k\":7,\"params\":[{\"name\":\"reduction\",\"type\":{\"k\":8,\"param\":\"R\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"R\"}}},{\"name\":\"initialReduction\",\"type\":{\"k\":8,\"param\":\"R\"}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":8,\"param\":\"R\"},\"line\":4501},{\"typeParams\":[\"R\"],\"params\":[{\"name\":\"reducer\",\"type\":{\"k\":7,\"params\":[{\"name\":\"reduction\",\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"R\"}]}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"R\"}}}],\"type\":{\"k\":8,\"param\":\"R\"},\"line\":4506}]},\"#every\":{\"doc\":{\"synopsis\":\"True if `predicate` returns true for all entries in the Collection.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":1},\"line\":4513}]},\"#some\":{\"doc\":{\"synopsis\":\"True if `predicate` returns true for any entry in the Collection.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":1},\"line\":4521}]},\"#join\":{\"doc\":{\"synopsis\":\"Joins values together as a string, inserting a separator between each.\\nThe default separator is `\\\",\\\"`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"separator\",\"type\":{\"k\":3},\"optional\":true}],\"type\":{\"k\":3},\"line\":4530}]},\"#isEmpty\":{\"doc\":{\"synopsis\":\"Returns true if this Collection includes no values.\",\"description\":\"For some lazy `Seq`, `isEmpty` might need to iterate to determine\\nemptiness. At most one iteration will occur.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":1},\"line\":4538}]},\"#count\":{\"doc\":{\"synopsis\":\"Returns the size of this Collection.\",\"description\":\"Regardless of if this Collection can describe its size lazily (some Seqs\\ncannot), this method will always return the correct size. E.g. it\\nevaluates a lazy `Seq` if necessary.\\n\\nIf `predicate` is provided, then this returns the count of entries in the\\nCollection for which the `predicate` returns true.\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":2},\"line\":4550},{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":2},\"line\":4551}]},\"#countBy\":{\"doc\":{\"synopsis\":\"Returns a `Seq.Keyed` of counts, grouped by the return value of\\nthe `grouper` function.\",\"description\":\"Note: This is not a lazy operation.\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"G\"],\"params\":[{\"name\":\"grouper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"G\"}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":9,\"name\":\"Map\",\"args\":[{\"k\":8,\"param\":\"G\"},{\"k\":2}]},\"line\":4562}]}}},{\"title\":\"Search for value\",\"members\":{\"#find\":{\"doc\":{\"synopsis\":\"Returns the first value for which the `predicate` returns true.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"V\"},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":4573}]},\"#findLast\":{\"doc\":{\"synopsis\":\"Returns the last value for which the `predicate` returns true.\",\"description\":\"Note: `predicate` will be called for each entry in reverse.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"V\"},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":4584}]},\"#findEntry\":{\"doc\":{\"synopsis\":\"Returns the first [key, value] entry for which the `predicate` returns true.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"V\"},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},{\"k\":11}]},\"line\":4593}]},\"#findLastEntry\":{\"doc\":{\"synopsis\":\"Returns the last [key, value] entry for which the `predicate`\\nreturns true.\",\"description\":\"Note: `predicate` will be called for each entry in reverse.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"V\"},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":14,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]},{\"k\":11}]},\"line\":4605}]},\"#findKey\":{\"doc\":{\"synopsis\":\"Returns the key for which the `predicate` returns true.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":11}]},\"line\":4614}]},\"#findLastKey\":{\"doc\":{\"synopsis\":\"Returns the last key for which the `predicate` returns true.\",\"description\":\"Note: `predicate` will be called for each entry in reverse.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"predicate\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":1}}},{\"name\":\"context\",\"type\":{\"k\":17},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":11}]},\"line\":4624}]},\"#keyOf\":{\"doc\":{\"synopsis\":\"Returns the key associated with the search value, or undefined.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"searchValue\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":11}]},\"line\":4632}]},\"#lastKeyOf\":{\"doc\":{\"synopsis\":\"Returns the last key associated with the search value, or undefined.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"searchValue\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"K\"},{\"k\":11}]},\"line\":4637}]},\"#max\":{\"doc\":{\"synopsis\":\"Returns the maximum value in this collection. If any values are\\ncomparatively equivalent, the first one found will be returned.\",\"description\":\"The `comparator` is used in the same way as `Collection#sort`. If it is not\\nprovided, the default comparator is `>`.\\n\\nWhen two values are considered equivalent, the first encountered will be\\nreturned. Otherwise, `max` will operate independent of the order of input\\nas long as the comparator is commutative. The default comparator `>` is\\ncommutative *only* when types do not differ.\\n\\nIf `comparator` returns 0 and either value is NaN, undefined, or null,\\nthat value will be returned.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"comparator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"valueA\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"valueB\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":2}},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":4654}]},\"#maxBy\":{\"doc\":{\"synopsis\":\"Like `max`, but also accepts a `comparatorValueMapper` which allows for\\ncomparing by more sophisticated means:\",\"description\":\"    hitters.maxBy(hitter => hitter.avgHits);\\n\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"comparatorValueMapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"C\"}}},{\"name\":\"comparator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"valueA\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"valueB\",\"type\":{\"k\":8,\"param\":\"C\"}}],\"type\":{\"k\":2}},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":4663}]},\"#min\":{\"doc\":{\"synopsis\":\"Returns the minimum value in this collection. If any values are\\ncomparatively equivalent, the first one found will be returned.\",\"description\":\"The `comparator` is used in the same way as `Collection#sort`. If it is not\\nprovided, the default comparator is `<`.\\n\\nWhen two values are considered equivalent, the first encountered will be\\nreturned. Otherwise, `min` will operate independent of the order of input\\nas long as the comparator is commutative. The default comparator `<` is\\ncommutative *only* when types do not differ.\\n\\nIf `comparator` returns 0 and either value is NaN, undefined, or null,\\nthat value will be returned.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"comparator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"valueA\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"valueB\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":2}},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":4683}]},\"#minBy\":{\"doc\":{\"synopsis\":\"Like `min`, but also accepts a `comparatorValueMapper` which allows for\\ncomparing by more sophisticated means:\",\"description\":\"    hitters.minBy(hitter => hitter.avgHits);\\n\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"comparatorValueMapper\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"iter\",\"type\":{\"k\":10}}],\"type\":{\"k\":8,\"param\":\"C\"}}},{\"name\":\"comparator\",\"type\":{\"k\":7,\"params\":[{\"name\":\"valueA\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"valueB\",\"type\":{\"k\":8,\"param\":\"C\"}}],\"type\":{\"k\":2}},\"optional\":true}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":4692}]}}},{\"title\":\"Comparison\",\"members\":{\"#isSubset\":{\"doc\":{\"synopsis\":\"True if `iter` includes every value in this Collection.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"iter\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":1},\"line\":4703}]},\"#isSuperset\":{\"doc\":{\"synopsis\":\"True if this Collection includes every value in `iter`.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"iter\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":8,\"param\":\"V\"}]}}],\"type\":{\"k\":1},\"line\":4708}]}}}]}},\"ValueObject\":{\"interface\":{\"line\":4714,\"doc\":{\"synopsis\":\"The interface to fulfill to qualify as a Value Object.\",\"description\":\"\",\"notes\":[]},\"groups\":[{\"members\":{\"#equals\":{\"doc\":{\"synopsis\":\"True if this and the other Collection have value equality, as defined\\nby `Immutable.is()`.\",\"description\":\"Note: This is equivalent to `Immutable.is(this, other)`, but provided to\\nallow for chained expressions.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"other\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4722}]},\"#hashCode\":{\"doc\":{\"synopsis\":\"Computes and returns the hashed identity for this Collection.\",\"description\":\"The `hashCode` of a Collection is used to determine potential equality,\\nand is used when adding this to a `Set` or as a key in a `Map`, enabling\\nlookup via a different instance.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { List, Set } = require('immutable');\\nconst a = List([ 1, 2, 3 ]);\\nconst b = List([ 1, 2, 3 ]);\\nassert.notStrictEqual(a, b); // different instances\\nconst set = Set([ a ]);\\nassert.equal(set.has(b), true);\\n```\\n\\nNote: hashCode() MUST return a Uint32 number. The easiest way to\\nguarantee this is to return `myHash | 0` from a custom implementation.\\n\\nIf two values have the same `hashCode`, they are [not guaranteed\\nto be equal][Hash Collision]. If two values have different `hashCode`s,\\nthey must not be equal.\\n\\nNote: `hashCode()` is not guaranteed to always be called before\\n`equals()`. Most but not all Immutable.js collections use hash codes to\\norganize their internal data structures, while all Immutable.js\\ncollections use equality during lookups.\\n\\n[Hash Collision]: http://en.wikipedia.org/wiki/Collision_(computer_science)\",\"notes\":[]},\"signatures\":[{\"type\":{\"k\":2},\"line\":4755}]}}}]}},\"fromJS\":{\"call\":{\"doc\":{\"synopsis\":\"Deeply converts plain JS objects and arrays to Immutable Maps and Lists.\",\"description\":\"If a `reviver` is optionally provided, it will be called with every\\ncollection as a Seq (beginning with the most nested collections\\nand proceeding to the top-level collection itself), along with the key\\nreferring to each collection and the parent JS object provided as `this`.\\nFor the top level, object, the key will be `\\\"\\\"`. This `reviver` is expected\\nto return a new Immutable Collection, allowing for custom conversions from\\ndeep JS objects. Finally, a `path` is provided which is the sequence of\\nkeys to this value from the starting value.\\n\\n`reviver` acts similarly to the [same parameter in `JSON.parse`][1].\\n\\nIf `reviver` is not provided, the default behavior will convert Objects\\ninto Maps and Arrays into Lists like so:\\n\\n<!-- runkit:activate -->\\n```js\\nconst { fromJS, isKeyed } = require('immutable')\\nfunction (key, value) {\\n  return isKeyed(value) ? value.toMap() : value.toList()\\n}\\n```\\n\\n`fromJS` is conservative in its conversion. It will only convert\\narrays which pass `Array.isArray` to Lists, and only raw objects (no custom\\nprototype) to Map.\\n\\nAccordingly, this example converts native JS data to OrderedMap and List:\\n\\n<!-- runkit:activate -->\\n```js\\nconst { fromJS, isKeyed } = require('immutable')\\nfromJS({ a: {b: [10, 20, 30]}, c: 40}, function (key, value, path) {\\n  console.log(key, value, path)\\n  return isKeyed(value) ? value.toOrderedMap() : value.toList()\\n})\\n\\n> \\\"b\\\", [ 10, 20, 30 ], [ \\\"a\\\", \\\"b\\\" ]\\n> \\\"a\\\", {b: [10, 20, 30]}, [ \\\"a\\\" ]\\n> \\\"\\\", {a: {b: [10, 20, 30]}, c: 40}, []\\n```\\n\\nKeep in mind, when using JS objects to construct Immutable Maps, that\\nJavaScript Object properties are always strings, even if written in a\\nquote-less shorthand, while Immutable Maps accept keys of any type.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map } = require('immutable')\\nlet obj = { 1: \\\"one\\\" };\\nObject.keys(obj); // [ \\\"1\\\" ]\\nassert.equal(obj[\\\"1\\\"], obj[1]); // \\\"one\\\" === \\\"one\\\"\\n\\nlet map = Map(obj);\\nassert.notEqual(map.get(\\\"1\\\"), map.get(1)); // \\\"one\\\" !== undefined\\n```\\n\\nProperty access for JavaScript Objects first converts the key to a string,\\nbut since Immutable Map keys can be of any type the argument to `get()` is\\nnot altered.\\n\\n[1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Example.3A_Using_the_reviver_parameter\\n     \\\"Using the reviver parameter\\\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"jsValue\",\"type\":{\"k\":17}},{\"name\":\"reviver\",\"type\":{\"k\":7,\"params\":[{\"name\":\"key\",\"type\":{\"k\":12,\"types\":[{\"k\":3},{\"k\":2}]}},{\"name\":\"sequence\",\"type\":{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Collection.Keyed\",\"args\":[{\"k\":3},{\"k\":17}]},{\"k\":9,\"name\":\"Collection.Indexed\",\"args\":[{\"k\":17}]}]}},{\"name\":\"path\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":3},{\"k\":2}]}]},\"optional\":true}],\"type\":{\"k\":17}},\"optional\":true}],\"type\":{\"k\":17},\"line\":4824}]}},\"is\":{\"call\":{\"doc\":{\"synopsis\":\"Value equality check with semantics similar to `Object.is`, but treats\\nImmutable `Collection`s as values, equal if the second `Collection` includes\\nequivalent values.\",\"description\":\"It's used throughout Immutable when checking for equality, including `Map`\\nkey equality and `Set` membership.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { Map, is } = require('immutable')\\nconst map1 = Map({ a: 1, b: 1, c: 1 })\\nconst map2 = Map({ a: 1, b: 1, c: 1 })\\nassert.equal(map1 !== map2, true)\\nassert.equal(Object.is(map1, map2), false)\\nassert.equal(is(map1, map2), true)\\n```\\n\\n`is()` compares primitive types like strings and numbers, Immutable.js\\ncollections like `Map` and `List`, but also any custom object which\\nimplements `ValueObject` by providing `equals()` and `hashCode()` methods.\\n\\nNote: Unlike `Object.is`, `Immutable.is` assumes `0` and `-0` are the same\\nvalue, matching the behavior of ES6 Map key equality.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"first\",\"type\":{\"k\":17}},{\"name\":\"second\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4858}]}},\"hash\":{\"call\":{\"doc\":{\"synopsis\":\"The `hash()` function is an important part of how Immutable determines if\\ntwo values are equivalent and is used to determine how to store those\\nvalues. Provided with any value, `hash()` will return a 31-bit integer.\",\"description\":\"When designing Objects which may be equal, it's important that when a\\n`.equals()` method returns true, that both values `.hashCode()` method\\nreturn the same value. `hash()` may be used to produce those values.\\n\\nFor non-Immutable Objects that do not provide a `.hashCode()` functions\\n(including plain Objects, plain Arrays, Date objects, etc), a unique hash\\nvalue will be created for each *instance*. That is, the create hash\\nrepresents referential equality, and not value equality for Objects. This\\nensures that if that Object is mutated over time that its hash code will\\nremain consistent, allowing Objects to be used as keys and values in\\nImmutable.js collections.\\n\\nNote that `hash()` attempts to balance between speed and avoiding\\ncollisions, however it makes no attempt to produce secure hashes.\\n\\n*New in Version 4.0*\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":2},\"line\":4882}]}},\"isImmutable\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeImmutable` is an Immutable Collection or Record.\",\"description\":\"Note: Still returns true even if the collections is within a `withMutations()`.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { isImmutable, Map, List, Stack } = require('immutable');\\nisImmutable([]); // false\\nisImmutable({}); // false\\nisImmutable(Map()); // true\\nisImmutable(List()); // true\\nisImmutable(Stack()); // true\\nisImmutable(Map().asMutable()); // true\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeImmutable\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4900}]}},\"isCollection\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeCollection` is a Collection, or any of its subclasses.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { isCollection, Map, List, Stack } = require('immutable');\\nisCollection([]); // false\\nisCollection({}); // false\\nisCollection(Map()); // true\\nisCollection(List()); // true\\nisCollection(Stack()); // true\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeCollection\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4915}]}},\"isKeyed\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeKeyed` is a Collection.Keyed, or any of its subclasses.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { isKeyed, Map, List, Stack } = require('immutable');\\nisKeyed([]); // false\\nisKeyed({}); // false\\nisKeyed(Map()); // true\\nisKeyed(List()); // false\\nisKeyed(Stack()); // false\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeKeyed\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4930}]}},\"isIndexed\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeIndexed` is a Collection.Indexed, or any of its subclasses.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { isIndexed, Map, List, Stack, Set } = require('immutable');\\nisIndexed([]); // false\\nisIndexed({}); // false\\nisIndexed(Map()); // false\\nisIndexed(List()); // true\\nisIndexed(Stack()); // true\\nisIndexed(Set()); // false\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeIndexed\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4946}]}},\"isAssociative\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeAssociative` is either a Keyed or Indexed Collection.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { isAssociative, Map, List, Stack, Set } = require('immutable');\\nisAssociative([]); // false\\nisAssociative({}); // false\\nisAssociative(Map()); // true\\nisAssociative(List()); // true\\nisAssociative(Stack()); // true\\nisAssociative(Set()); // false\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeAssociative\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4962}]}},\"isOrdered\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeOrdered` is a Collection where iteration order is well\\ndefined. True for Collection.Indexed as well as OrderedMap and OrderedSet.\",\"description\":\"<!-- runkit:activate -->\\n```js\\nconst { isOrdered, Map, OrderedMap, List, Set } = require('immutable');\\nisOrdered([]); // false\\nisOrdered({}); // false\\nisOrdered(Map()); // false\\nisOrdered(OrderedMap()); // true\\nisOrdered(List()); // true\\nisOrdered(Set()); // false\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeOrdered\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4979}]}},\"isValueObject\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeValue` is a JavaScript Object which has *both* `equals()`\\nand `hashCode()` methods.\",\"description\":\"Any two instances of *value objects* can be compared for value equality with\\n`Immutable.is()` and can be used as keys in a `Map` or members in a `Set`.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeValue\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4988}]}},\"isSeq\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeSeq` is a Seq.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeSeq\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4994}]}},\"isList\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeList` is a List.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeList\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":4999}]}},\"isMap\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeMap` is a Map.\",\"description\":\"Also true for OrderedMaps.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeMap\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":5006}]}},\"isOrderedMap\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeOrderedMap` is an OrderedMap.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeOrderedMap\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":5011}]}},\"isStack\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeStack` is a Stack.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeStack\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":5016}]}},\"isSet\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeSet` is a Set.\",\"description\":\"Also true for OrderedSets.\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeSet\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":5023}]}},\"isOrderedSet\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeOrderedSet` is an OrderedSet.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeOrderedSet\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":5028}]}},\"isRecord\":{\"call\":{\"doc\":{\"synopsis\":\"True if `maybeRecord` is a Record.\",\"description\":\"\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"maybeRecord\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":5033}]}},\"get\":{\"call\":{\"doc\":{\"synopsis\":\"Returns the value within the provided collection associated with the\\nprovided key, or notSetValue if the key is not defined in the collection.\",\"description\":\"A functional alternative to `collection.get(key)` which will also work on\\nplain Objects and Arrays as an alternative for `collection[key]`.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { get } = require('immutable')\\nget([ 'dog', 'frog', 'cat' ], 2) // 'frog'\\nget({ x: 123, y: 456 }, 'x') // 123\\nget({ x: 123, y: 456 }, 'z', 'ifNotSet') // 'ifNotSet'\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\",\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":5052},{\"typeParams\":[\"K\",\"V\",\"NSV\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Collection\",\"args\":[{\"k\":8,\"param\":\"K\"},{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]},\"line\":5053},{\"typeParams\":[\"TProps\",\"K\"],\"params\":[{\"name\":\"record\",\"type\":{\"k\":9,\"name\":\"Record\",\"args\":[{\"k\":8,\"param\":\"TProps\"}]}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":17}}],\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}},\"line\":5054},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"key\",\"type\":{\"k\":2}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":5055},{\"typeParams\":[\"V\",\"NSV\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]},\"line\":5056},{\"typeParams\":[\"C\",\"K\"],\"params\":[{\"name\":\"object\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":17}}],\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"C\"},\"index\":{\"k\":8,\"param\":\"K\"}},\"line\":5057},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}},{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":11}]},\"line\":5058},{\"typeParams\":[\"V\",\"NSV\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]}},{\"name\":\"key\",\"type\":{\"k\":3}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}}],\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]},\"line\":5059}]}},\"has\":{\"call\":{\"doc\":{\"synopsis\":\"Returns true if the key is defined in the provided collection.\",\"description\":\"A functional alternative to `collection.has(key)` which will also work with\\nplain Objects and Arrays as an alternative for\\n`collection.hasOwnProperty(key)`.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { has } = require('immutable')\\nhas([ 'dog', 'frog', 'cat' ], 2) // true\\nhas([ 'dog', 'frog', 'cat' ], 5) // false\\nhas({ x: 123, y: 456 }, 'x') // true\\nhas({ x: 123, y: 456 }, 'z') // false\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Object\"}},{\"name\":\"key\",\"type\":{\"k\":17}}],\"type\":{\"k\":1},\"line\":5077}]}},\"remove\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the value at key removed.\",\"description\":\"A functional alternative to `collection.remove(key)` which will also work\\nwith plain Objects and Arrays as an alternative for\\n`delete collectionCopy[key]`.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { remove } = require('immutable')\\nconst originalArray = [ 'dog', 'frog', 'cat' ]\\nremove(originalArray, 1) // [ 'dog', 'cat' ]\\nconsole.log(originalArray) // [ 'dog', 'frog', 'cat' ]\\nconst originalObject = { x: 123, y: 456 }\\nremove(originalObject, 'x') // { y: 456 }\\nconsole.log(originalObject) // { x: 123, y: 456 }\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\",\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5097},{\"typeParams\":[\"TProps\",\"C\",\"K\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5098},{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":2}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5099},{\"typeParams\":[\"C\",\"K\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5100},{\"typeParams\":[\"C\",\"K\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5101}]}},\"set\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the value at key set to the provided\\nvalue.\",\"description\":\"A functional alternative to `collection.set(key, value)` which will also\\nwork with plain Objects and Arrays as an alternative for\\n`collectionCopy[key] = value`.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { set } = require('immutable')\\nconst originalArray = [ 'dog', 'frog', 'cat' ]\\nset(originalArray, 1, 'cow') // [ 'dog', 'cow', 'cat' ]\\nconsole.log(originalArray) // [ 'dog', 'frog', 'cat' ]\\nconst originalObject = { x: 123, y: 456 }\\nset(originalObject, 'x', 789) // { x: 789, y: 456 }\\nconsole.log(originalObject) // { x: 123, y: 456 }\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\",\"V\",\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5122},{\"typeParams\":[\"TProps\",\"C\",\"K\"],\"params\":[{\"name\":\"record\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5123},{\"typeParams\":[\"V\",\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5124},{\"typeParams\":[\"C\",\"K\"],\"params\":[{\"name\":\"object\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"value\",\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"C\"},\"index\":{\"k\":8,\"param\":\"K\"}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5125},{\"typeParams\":[\"V\",\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":3}},{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5126}]}},\"update\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the value at key set to the result of\\nproviding the existing value to the updating function.\",\"description\":\"A functional alternative to `collection.update(key, fn)` which will also\\nwork with plain Objects and Arrays as an alternative for\\n`collectionCopy[key] = fn(collection[key])`.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { update } = require('immutable')\\nconst originalArray = [ 'dog', 'frog', 'cat' ]\\nupdate(originalArray, 1, val => val.toUpperCase()) // [ 'dog', 'FROG', 'cat' ]\\nconsole.log(originalArray) // [ 'dog', 'frog', 'cat' ]\\nconst originalObject = { x: 123, y: 456 }\\nupdate(originalObject, 'x', val => val * 6) // { x: 738, y: 456 }\\nconsole.log(originalObject) // { x: 123, y: 456 }\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"K\",\"V\",\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"V\"}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5147},{\"typeParams\":[\"K\",\"V\",\"C\",\"NSV\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]}}],\"type\":{\"k\":8,\"param\":\"V\"}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5148},{\"typeParams\":[\"TProps\",\"C\",\"K\"],\"params\":[{\"name\":\"record\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}}}],\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5149},{\"typeParams\":[\"TProps\",\"C\",\"K\",\"NSV\"],\"params\":[{\"name\":\"record\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":12,\"types\":[{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}},{\"k\":8,\"param\":\"NSV\"}]}}],\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"TProps\"},\"index\":{\"k\":8,\"param\":\"K\"}}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5150},{\"typeParams\":[\"V\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"V\"}}}],\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":5151},{\"typeParams\":[\"V\",\"NSV\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"V\"}]}},{\"name\":\"key\",\"type\":{\"k\":2}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]}}],\"type\":{\"k\":8,\"param\":\"V\"}}}],\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":8,\"param\":\"V\"}]},\"line\":5152},{\"typeParams\":[\"C\",\"K\"],\"params\":[{\"name\":\"object\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"C\"},\"index\":{\"k\":8,\"param\":\"K\"}}}],\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"C\"},\"index\":{\"k\":8,\"param\":\"K\"}}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5153},{\"typeParams\":[\"C\",\"K\",\"NSV\"],\"params\":[{\"name\":\"object\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":12,\"types\":[{\"k\":15,\"type\":{\"k\":8,\"param\":\"C\"},\"index\":{\"k\":8,\"param\":\"K\"}},{\"k\":8,\"param\":\"NSV\"}]}}],\"type\":{\"k\":15,\"type\":{\"k\":8,\"param\":\"C\"},\"index\":{\"k\":8,\"param\":\"K\"}}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5154},{\"typeParams\":[\"V\",\"C\",\"K\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":8,\"param\":\"V\"}}],\"type\":{\"k\":8,\"param\":\"V\"}}}],\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]},\"line\":5155},{\"typeParams\":[\"V\",\"C\",\"K\",\"NSV\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"key\",\"type\":{\"k\":8,\"param\":\"K\"}},{\"name\":\"notSetValue\",\"type\":{\"k\":8,\"param\":\"NSV\"}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":12,\"types\":[{\"k\":8,\"param\":\"V\"},{\"k\":8,\"param\":\"NSV\"}]}}],\"type\":{\"k\":8,\"param\":\"V\"}}}],\"type\":{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":8,\"param\":\"V\"}}]},\"line\":5156}]}},\"getIn\":{\"call\":{\"doc\":{\"synopsis\":\"Returns the value at the provided key path starting at the provided\\ncollection, or notSetValue if the key path is not defined.\",\"description\":\"A functional alternative to `collection.getIn(keypath)` which will also\\nwork with plain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { getIn } = require('immutable')\\ngetIn({ x: { y: { z: 123 }}}, ['x', 'y', 'z']) // 123\\ngetIn({ x: { y: { z: 123 }}}, ['x', 'q', 'p'], 'ifNotSet') // 'ifNotSet'\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"collection\",\"type\":{\"k\":17}},{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"notSetValue\",\"type\":{\"k\":17}}],\"type\":{\"k\":17},\"line\":5172}]}},\"hasIn\":{\"call\":{\"doc\":{\"synopsis\":\"Returns true if the key path is defined in the provided collection.\",\"description\":\"A functional alternative to `collection.hasIn(keypath)` which will also\\nwork with plain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { hasIn } = require('immutable')\\nhasIn({ x: { y: { z: 123 }}}, ['x', 'y', 'z']) // true\\nhasIn({ x: { y: { z: 123 }}}, ['x', 'q', 'p']) // false\\n```\",\"notes\":[]},\"signatures\":[{\"params\":[{\"name\":\"collection\",\"type\":{\"k\":17}},{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}}],\"type\":{\"k\":1},\"line\":5187}]}},\"removeIn\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the value at the key path removed.\",\"description\":\"A functional alternative to `collection.removeIn(keypath)` which will also\\nwork with plain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { removeIn } = require('immutable')\\nconst original = { x: { y: { z: 123 }}}\\nremoveIn(original, ['x', 'y', 'z']) // { x: { y: {}}}\\nconsole.log(original) // { x: { y: { z: 123 }}}\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5203}]}},\"setIn\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the value at the key path set to the\\nprovided value.\",\"description\":\"A functional alternative to `collection.setIn(keypath)` which will also\\nwork with plain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { setIn } = require('immutable')\\nconst original = { x: { y: { z: 123 }}}\\nsetIn(original, ['x', 'y', 'z'], 456) // { x: { y: { z: 456 }}}\\nconsole.log(original) // { x: { y: { z: 123 }}}\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5220}]}},\"updateIn\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the value at key path set to the\\nresult of providing the existing value to the updating function.\",\"description\":\"A functional alternative to `collection.updateIn(keypath)` which will also\\nwork with plain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { updateIn } = require('immutable')\\nconst original = { x: { y: { z: 123 }}}\\nupdateIn(original, ['x', 'y', 'z'], val => val * 6) // { x: { y: { z: 738 }}}\\nconsole.log(original) // { x: { y: { z: 123 }}}\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5237},{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"keyPath\",\"type\":{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]}},{\"name\":\"notSetValue\",\"type\":{\"k\":17}},{\"name\":\"updater\",\"type\":{\"k\":7,\"params\":[{\"name\":\"value\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5238}]}},\"merge\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the remaining collections merged in.\",\"description\":\"A functional alternative to `collection.merge()` which will also work with\\nplain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { merge } = require('immutable')\\nconst original = { x: 123, y: 456 }\\nmerge(original, { y: 789, z: 'abc' }) // { x: 123, y: 789, z: 'abc' }\\nconsole.log(original) // { x: 123, y: 456 }\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":17},{\"k\":17}]}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]}]}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5254}]}},\"mergeWith\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the remaining collections merged in,\\ncalling the `merger` function whenever an existing value is encountered.\",\"description\":\"A functional alternative to `collection.mergeWith()` which will also work\\nwith plain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { mergeWith } = require('immutable')\\nconst original = { x: 123, y: 456 }\\nmergeWith(\\n  (oldVal, newVal) => oldVal + newVal,\\n  original,\\n  { y: 789, z: 'abc' }\\n) // { x: 123, y: 1245, z: 'abc' }\\nconsole.log(original) // { x: 123, y: 456 }\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"merger\",\"type\":{\"k\":7,\"params\":[{\"name\":\"oldVal\",\"type\":{\"k\":17}},{\"name\":\"newVal\",\"type\":{\"k\":17}},{\"name\":\"key\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}},{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":17},{\"k\":17}]}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]}]}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5278}]}},\"mergeDeep\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the remaining collections merged in\\ndeeply (recursively).\",\"description\":\"A functional alternative to `collection.mergeDeep()` which will also work\\nwith plain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { mergeDeep } = require('immutable')\\nconst original = { x: { y: 123 }}\\nmergeDeep(original, { x: { z: 456 }}) // { x: { y: 123, z: 456 }}\\nconsole.log(original) // { x: { y: 123 }}\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":17},{\"k\":17}]}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]}]}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5299}]}},\"mergeDeepWith\":{\"call\":{\"doc\":{\"synopsis\":\"Returns a copy of the collection with the remaining collections merged in\\ndeeply (recursively), calling the `merger` function whenever an existing\\nvalue is encountered.\",\"description\":\"A functional alternative to `collection.mergeDeepWith()` which will also\\nwork with plain Objects and Arrays.\\n\\n<!-- runkit:activate -->\\n```js\\nconst { mergeDeepWith } = require('immutable')\\nconst original = { x: { y: 123 }}\\nmergeDeepWith(\\n  (oldVal, newVal) => oldVal + newVal,\\n  original,\\n  { x: { y: 456 }}\\n) // { x: { y: 579 }}\\nconsole.log(original) // { x: { y: 123 }}\\n```\",\"notes\":[]},\"signatures\":[{\"typeParams\":[\"C\"],\"params\":[{\"name\":\"merger\",\"type\":{\"k\":7,\"params\":[{\"name\":\"oldVal\",\"type\":{\"k\":17}},{\"name\":\"newVal\",\"type\":{\"k\":17}},{\"name\":\"key\",\"type\":{\"k\":17}}],\"type\":{\"k\":17}}},{\"name\":\"collection\",\"type\":{\"k\":8,\"param\":\"C\"}},{\"name\":\"collections\",\"type\":{\"k\":9,\"name\":\"Array\",\"args\":[{\"k\":12,\"types\":[{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":17}]},{\"k\":9,\"name\":\"Iterable\",\"args\":[{\"k\":14,\"types\":[{\"k\":17},{\"k\":17}]}]},{\"k\":4,\"members\":[{\"index\":true,\"params\":[{\"name\":\"key\",\"type\":{\"k\":3}}],\"type\":{\"k\":17}}]}]}]},\"varArgs\":true}],\"type\":{\"k\":8,\"param\":\"C\"},\"line\":5324}]}}}},\"immutable\":{\"module\":{}}}","var TypeKind = {\n  Any: 0,\n\n  Boolean: 1,\n  Number: 2,\n  String: 3,\n  Object: 4,\n  Array: 5,\n  Never: 6,\n  Function: 7,\n\n  Param: 8,\n  Type: 9,\n\n  This: 10,\n  Undefined: 11,\n  Union: 12,\n  Intersection: 13,\n  Tuple: 14,\n  Indexed: 15,\n  Operator: 16,\n\n  Unknown: 17,\n};\n\nmodule.exports = TypeKind;\n","var $__0=    require('../../'),Seq=$__0.Seq;\n// Note: intentionally using raw defs, not getTypeDefs to avoid circular ref.\nvar defs = require('../generated/immutable.d.json');\n\nfunction collectMemberGroups(interfaceDef, options) {\n  var members = {};\n\n  if (interfaceDef) {\n    collectFromDef(interfaceDef);\n  }\n\n  var groups = { '': [] };\n\n  if (options.showInGroups) {\n    Seq(members).forEach(function(member)  {\n      (groups[member.group] || (groups[member.group] = [])).push(member);\n    });\n  } else {\n    groups[''] = Seq(members)\n      .sortBy(function(member)  {return member.memberName;})\n      .toArray();\n  }\n\n  if (!options.showInherited) {\n    groups = Seq(groups)\n      .map(function(members)  {return members.filter(function(member)  {return !member.inherited;});})\n      .toObject();\n  }\n\n  return groups;\n\n  function collectFromDef(def, name) {\n    def.groups &&\n      def.groups.forEach(function(g)  {\n        Seq(g.members).forEach(function(memberDef, memberName)  {\n          collectMember(g.title || '', memberName, memberDef);\n        });\n      });\n\n    def.extends &&\n      def.extends.forEach(function(e)  {\n        var superModule = defs.Immutable;\n        e.name.split('.').forEach(function(part)  {\n          superModule =\n            superModule && superModule.module && superModule.module[part];\n        });\n        var superInterface = superModule && superModule.interface;\n        if (superInterface) {\n          collectFromDef(superInterface, e.name);\n        }\n      });\n\n    function collectMember(group, memberName, memberDef) {\n      var member = members[memberName];\n      if (member) {\n        if (!member.inherited) {\n          member.overrides = { name:name, def:def, memberDef:memberDef };\n        }\n        if (!member.group && group) {\n          member.group = group;\n        }\n      } else {\n        member = {\n          group:group,\n          memberName: memberName.substr(1),\n          memberDef:memberDef,\n        };\n        if (def !== interfaceDef) {\n          member.inherited = { name:name, def:def };\n        }\n        members[memberName] = member;\n      }\n    }\n  }\n}\n\nmodule.exports = collectMemberGroups;\n","var markdownDocs = require('./markdownDocs');\nvar defs = require('../generated/immutable.d.json');\n\nmarkdownDocs(defs);\n\nmodule.exports = defs;\n","var marked = require('marked');\nvar $__0=    require('../../'),Seq=$__0.Seq;\nvar prism = require('./prism');\nvar collectMemberGroups = require('./collectMemberGroups');\n// Note: intentionally using raw defs, not getTypeDefs to avoid circular ref.\nvar defs = require('../generated/immutable.d.json');\n\nfunction collectAllMembersForAllTypes(defs) {\n  var allMembers = new WeakMap();\n  _collectAllMembersForAllTypes(defs);\n  return allMembers;\n  function _collectAllMembersForAllTypes(defs) {\n    Seq(defs).forEach(function(def)  {\n      if (def.interface) {\n        var groups = collectMemberGroups(def.interface, {\n          showInherited: true,\n        });\n        allMembers.set(\n          def.interface,\n          Seq.Keyed(\n            groups[''].map(function(member)  {return [member.memberName, member.memberDef];})\n          ).toObject()\n        );\n      }\n      if (def.module) {\n        _collectAllMembersForAllTypes(def.module);\n      }\n    });\n    return allMembers;\n  }\n}\n\nvar allMembers = collectAllMembersForAllTypes(defs);\n\n// functions come before keywords\nprism.languages.insertBefore('javascript', 'keyword', {\n  var: /\\b(this)\\b/g,\n  'block-keyword': /\\b(if|else|while|for|function)\\b/g,\n  primitive: /\\b(true|false|null|undefined)\\b/g,\n  function: prism.languages.function,\n});\n\nprism.languages.insertBefore('javascript', {\n  qualifier: /\\b[A-Z][a-z0-9_]+/g,\n});\n\nmarked.setOptions({\n  xhtml: true,\n  highlight: function(code)  {return prism.highlight(code, prism.languages.javascript);},\n});\n\nvar renderer = new marked.Renderer();\n\nconst runkitRegExp = /^<!--\\s*runkit:activate((.|\\n)*)-->(.|\\n)*$/;\nconst runkitContext = { options: '{}', activated: false };\n\nrenderer.html = function (text) {\n  const result = runkitRegExp.exec(text);\n\n  if (!result) return text;\n\n  runkitContext.activated = true;\n  try {\n    runkitContext.options = result[1] ? JSON.parse(result[1]) : {};\n  } catch (e) {\n    runkitContext.options = {};\n  }\n  return text;\n};\n\nrenderer.code = function (code, lang, escaped) {\n  if (this.options.highlight) {\n    var out = this.options.highlight(code, lang);\n    if (out != null && out !== code) {\n      escaped = true;\n      code = out;\n    }\n  }\n\n  const runItButton = runkitContext.activated\n    ? '<a class=\"try-it\" data-options=\"' +\n      escape(JSON.stringify(runkitContext.options)) +\n      '\" onClick=\"runIt(this)\">run it</a>'\n    : '';\n\n  runkitContext.activated = false;\n  runkitContext.options = '{}';\n\n  return (\n    '<code class=\"codeBlock\">' +\n    (escaped ? code : escapeCode(code, true)) +\n    runItButton +\n    '</code>'\n  );\n};\n\nvar METHOD_RX = /^(\\w+)(?:[#.](\\w+))?(?:\\(\\))?$/;\nvar PARAM_RX = /^\\w+$/;\nvar MDN_TYPES = {\n  Array: true,\n  Object: true,\n  JSON: true,\n};\nvar MDN_BASE_URL =\n  'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/';\n\nrenderer.codespan = function (text) {\n  return '<code>' + decorateCodeSpan(text, this.options) + '</code>';\n};\n\nfunction decorateCodeSpan(text, options) {\n  var context = options.context;\n\n  if (\n    context.signatures &&\n    PARAM_RX.test(text) &&\n    context.signatures.some(\n      function(sig)  {return sig.params && sig.params.some(function(param)  {return param.name === text;});}\n    )\n  ) {\n    return '<span class=\"t param\">' + text + '</span>';\n  }\n\n  var method = METHOD_RX.exec(text);\n  if (method) {\n    method = method.slice(1).filter(Boolean);\n    if (MDN_TYPES[method[0]]) {\n      return (\n        '<a href=\"' + MDN_BASE_URL + method.join('/') + '\">' + text + '</a>'\n      );\n    }\n    if (\n      context.typePath &&\n      !arrEndsWith(context.typePath, method) &&\n      !arrEndsWith(context.typePath.slice(0, -1), method)\n    ) {\n      var path = findPath(context, method);\n      if (path) {\n        var relPath = context.relPath || '';\n        return (\n          '<a target=\"_self\" href=\"' +\n          relPath +\n          '#/' +\n          path.slice(1).join('/') +\n          '\">' +\n          text +\n          '</a>'\n        );\n      }\n    }\n  }\n\n  if (options.highlight) {\n    return options.highlight(unescapeCode(text), prism.languages.javascript);\n  }\n\n  return text;\n}\n\nfunction arrEndsWith(arr1, arr2) {\n  for (var ii = 1; ii <= arr2.length; ii++) {\n    if (arr2[arr2.length - ii] !== arr1[arr1.length - ii]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction findPath(context, search) {\n  var relative = context.typePath;\n\n  for (var ii = 0; ii <= relative.length; ii++) {\n    var path = relative.slice(0, relative.length - ii).concat(search);\n    if (\n      path.reduce(\n        function(def, name) \n          {return def &&\n          ((def.module && def.module[name]) ||\n            (def.interface &&\n              allMembers &&\n              allMembers.get(def.interface)[name]) ||\n            undefined);},\n        { module: defs }\n      )\n    ) {\n      return path;\n    }\n  }\n}\n\nfunction escapeCode(code) {\n  return code\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;');\n}\n\nfunction unescapeCode(code) {\n  return code\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&quot;/g, '\"')\n    .replace(/&#39;/g, \"'\")\n    .replace(/&amp;/g, '&');\n}\n\nfunction markdown(content, context) {\n  context || (context = {});\n  return content ? marked(content, { renderer:renderer, context:context }) : content;\n}\n\nmodule.exports = markdown;\n","var $__0=    require('../../'),Seq=$__0.Seq;\nvar markdown = require('./markdown');\n\nfunction markdownDocs(defs) {\n  markdownTypes(defs, []);\n\n  function markdownTypes(typeDefs, path) {\n    Seq(typeDefs).forEach(function(typeDef, typeName)  {\n      var typePath = path.concat(typeName);\n      markdownDoc(typeDef.doc, { typePath:typePath });\n      typeDef.call &&\n        markdownDoc(typeDef.call.doc, {\n          typePath:typePath,\n          signatures: typeDef.call.signatures,\n        });\n      if (typeDef.interface) {\n        markdownDoc(typeDef.interface.doc, { defs:defs, typePath:typePath });\n        Seq(typeDef.interface.groups).forEach(function(group) \n          {return Seq(group.members).forEach(function(member, memberName) \n            {return markdownDoc(member.doc, {\n              typePath: typePath.concat(memberName.slice(1)),\n              signatures: member.signatures,\n            });}\n          );}\n        );\n      }\n      typeDef.module && markdownTypes(typeDef.module, typePath);\n    });\n  }\n}\n\nfunction markdownDoc(doc, context) {\n  if (!doc) {\n    return;\n  }\n  doc.synopsis && (doc.synopsis = markdown(doc.synopsis, context));\n  doc.description && (doc.description = markdown(doc.description, context));\n  doc.notes &&\n    doc.notes.forEach(function(note)  {\n      if (note.name !== 'alias') {\n        note.body = markdown(note.body, context);\n      }\n    });\n}\n\nmodule.exports = markdownDocs;\n","/* eslint-disable */\n\n/* **********************************************\n     Begin prism-core.js\n********************************************** */\n\nself =\n  typeof window !== 'undefined'\n    ? window // if in browser\n    : typeof WorkerGlobalScope !== 'undefined' &&\n      self instanceof WorkerGlobalScope\n    ? self // if in worker\n    : {}; // if in node js\n\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n * MIT license http://www.opensource.org/licenses/mit-license.php/\n * @author Lea Verou http://lea.verou.me\n */\n\nvar Prism = (function () {\n  // Private helper vars\n  var lang = /\\blang(?:uage)?-(?!\\*)(\\w+)\\b/i;\n\n  var _ = (self.Prism = {\n    util: {\n      encode: function (tokens) {\n        if (tokens instanceof Token) {\n          return new Token(\n            tokens.type,\n            _.util.encode(tokens.content),\n            tokens.alias\n          );\n        } else if (_.util.type(tokens) === 'Array') {\n          return tokens.map(_.util.encode);\n        } else {\n          return tokens\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/\\u00a0/g, ' ');\n        }\n      },\n\n      type: function (o) {\n        return Object.prototype.toString.call(o).match(/\\[object (\\w+)\\]/)[1];\n      },\n\n      // Deep clone a language definition (e.g. to extend it)\n      clone: function (o) {\n        var type = _.util.type(o);\n\n        switch (type) {\n          case 'Object':\n            var clone = {};\n\n            for (var key in o) {\n              if (o.hasOwnProperty(key)) {\n                clone[key] = _.util.clone(o[key]);\n              }\n            }\n\n            return clone;\n\n          case 'Array':\n            return o.slice();\n        }\n\n        return o;\n      },\n    },\n\n    languages: {\n      extend: function (id, redef) {\n        var lang = _.util.clone(_.languages[id]);\n\n        for (var key in redef) {\n          lang[key] = redef[key];\n        }\n\n        return lang;\n      },\n\n      /**\n       * Insert a token before another token in a language literal\n       * As this needs to recreate the object (we cannot actually insert before keys in object literals),\n       * we cannot just provide an object, we need anobject and a key.\n       * @param inside The key (or language id) of the parent\n       * @param before The key to insert before. If not provided, the function appends instead.\n       * @param insert Object with the key/value pairs to insert\n       * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.\n       */\n      insertBefore: function (inside, before, insert, root) {\n        root = root || _.languages;\n        var grammar = root[inside];\n\n        if (arguments.length == 2) {\n          insert = arguments[1];\n\n          for (var newToken in insert) {\n            if (insert.hasOwnProperty(newToken)) {\n              grammar[newToken] = insert[newToken];\n            }\n          }\n\n          return grammar;\n        }\n\n        var ret = {};\n\n        for (var token in grammar) {\n          if (grammar.hasOwnProperty(token)) {\n            if (token == before) {\n              for (var newToken in insert) {\n                if (insert.hasOwnProperty(newToken)) {\n                  ret[newToken] = insert[newToken];\n                }\n              }\n            }\n\n            ret[token] = grammar[token];\n          }\n        }\n\n        // Update references in other language definitions\n        _.languages.DFS(_.languages, function (key, value) {\n          if (value === root[inside] && key != inside) {\n            this[key] = ret;\n          }\n        });\n\n        return (root[inside] = ret);\n      },\n\n      // Traverse a language definition with Depth First Search\n      DFS: function (o, callback, type) {\n        for (var i in o) {\n          if (o.hasOwnProperty(i)) {\n            callback.call(o, i, o[i], type || i);\n\n            if (_.util.type(o[i]) === 'Object') {\n              _.languages.DFS(o[i], callback);\n            } else if (_.util.type(o[i]) === 'Array') {\n              _.languages.DFS(o[i], callback, i);\n            }\n          }\n        }\n      },\n    },\n\n    highlightAll: function (async, callback) {\n      var elements = document.querySelectorAll(\n        'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'\n      );\n\n      for (var i = 0, element; (element = elements[i++]); ) {\n        _.highlightElement(element, async === true, callback);\n      }\n    },\n\n    highlightElement: function (element, async, callback) {\n      // Find language\n      var language,\n        grammar,\n        parent = element;\n\n      while (parent && !lang.test(parent.className)) {\n        parent = parent.parentNode;\n      }\n\n      if (parent) {\n        language = (parent.className.match(lang) || [, ''])[1];\n        grammar = _.languages[language];\n      }\n\n      if (!grammar) {\n        return;\n      }\n\n      // Set language on the element, if not present\n      element.className =\n        element.className.replace(lang, '').replace(/\\s+/g, ' ') +\n        ' language-' +\n        language;\n\n      // Set language on the parent, for styling\n      parent = element.parentNode;\n\n      if (/pre/i.test(parent.nodeName)) {\n        parent.className =\n          parent.className.replace(lang, '').replace(/\\s+/g, ' ') +\n          ' language-' +\n          language;\n      }\n\n      var code = element.textContent;\n\n      if (!code) {\n        return;\n      }\n\n      var env = {\n        element: element,\n        language: language,\n        grammar: grammar,\n        code: code,\n      };\n\n      _.hooks.run('before-highlight', env);\n\n      if (async && self.Worker) {\n        var worker = new Worker(_.filename);\n\n        worker.onmessage = function (evt) {\n          env.highlightedCode = Token.stringify(JSON.parse(evt.data), language);\n\n          _.hooks.run('before-insert', env);\n\n          env.element.innerHTML = env.highlightedCode;\n\n          callback && callback.call(env.element);\n          _.hooks.run('after-highlight', env);\n        };\n\n        worker.postMessage(\n          JSON.stringify({\n            language: env.language,\n            code: env.code,\n          })\n        );\n      } else {\n        env.highlightedCode = _.highlight(env.code, env.grammar, env.language);\n\n        _.hooks.run('before-insert', env);\n\n        env.element.innerHTML = env.highlightedCode;\n\n        callback && callback.call(element);\n\n        _.hooks.run('after-highlight', env);\n      }\n    },\n\n    highlight: function (text, grammar, language) {\n      var tokens = _.tokenize(text, grammar);\n      return Token.stringify(_.util.encode(tokens), language);\n    },\n\n    tokenize: function (text, grammar, language) {\n      var Token = _.Token;\n\n      var strarr = [text];\n\n      var rest = grammar.rest;\n\n      if (rest) {\n        for (var token in rest) {\n          grammar[token] = rest[token];\n        }\n\n        delete grammar.rest;\n      }\n\n      tokenloop: for (var token in grammar) {\n        if (!grammar.hasOwnProperty(token) || !grammar[token]) {\n          continue;\n        }\n\n        var patterns = grammar[token];\n        patterns = _.util.type(patterns) === 'Array' ? patterns : [patterns];\n\n        for (var j = 0; j < patterns.length; ++j) {\n          var pattern = patterns[j],\n            inside = pattern.inside,\n            lookbehind = !!pattern.lookbehind,\n            lookbehindLength = 0,\n            alias = pattern.alias;\n\n          pattern = pattern.pattern || pattern;\n\n          for (var i = 0; i < strarr.length; i++) {\n            // Don’t cache length as it changes during the loop\n\n            var str = strarr[i];\n\n            if (strarr.length > text.length) {\n              // Something went terribly wrong, ABORT, ABORT!\n              break tokenloop;\n            }\n\n            if (str instanceof Token) {\n              continue;\n            }\n\n            pattern.lastIndex = 0;\n\n            var match = pattern.exec(str);\n\n            if (match) {\n              if (lookbehind) {\n                lookbehindLength = match[1].length;\n              }\n\n              var from = match.index - 1 + lookbehindLength,\n                match = match[0].slice(lookbehindLength),\n                len = match.length,\n                to = from + len,\n                before = str.slice(0, from + 1),\n                after = str.slice(to + 1);\n\n              var args = [i, 1];\n\n              if (before) {\n                args.push(before);\n              }\n\n              var wrapped = new Token(\n                token,\n                inside ? _.tokenize(match, inside) : match,\n                alias\n              );\n\n              args.push(wrapped);\n\n              if (after) {\n                args.push(after);\n              }\n\n              Array.prototype.splice.apply(strarr, args);\n            }\n          }\n        }\n      }\n\n      return strarr;\n    },\n\n    hooks: {\n      all: {},\n\n      add: function (name, callback) {\n        var hooks = _.hooks.all;\n\n        hooks[name] = hooks[name] || [];\n\n        hooks[name].push(callback);\n      },\n\n      run: function (name, env) {\n        var callbacks = _.hooks.all[name];\n\n        if (!callbacks || !callbacks.length) {\n          return;\n        }\n\n        for (var i = 0, callback; (callback = callbacks[i++]); ) {\n          callback(env);\n        }\n      },\n    },\n  });\n\n  var Token = (_.Token = function (type, content, alias) {\n    this.type = type;\n    this.content = content;\n    this.alias = alias;\n  });\n\n  Token.stringify = function (o, language, parent) {\n    if (typeof o == 'string') {\n      return o;\n    }\n\n    if (Object.prototype.toString.call(o) == '[object Array]') {\n      return o\n        .map(function (element) {\n          return Token.stringify(element, language, o);\n        })\n        .join('');\n    }\n\n    var env = {\n      type: o.type,\n      content: Token.stringify(o.content, language, parent),\n      tag: 'span',\n      classes: ['token', o.type],\n      attributes: {},\n      language: language,\n      parent: parent,\n    };\n\n    if (env.type == 'comment') {\n      env.attributes['spellcheck'] = 'true';\n    }\n\n    if (o.alias) {\n      var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];\n      Array.prototype.push.apply(env.classes, aliases);\n    }\n\n    _.hooks.run('wrap', env);\n\n    var attributes = '';\n\n    for (var name in env.attributes) {\n      attributes += name + '=\"' + (env.attributes[name] || '') + '\"';\n    }\n\n    return (\n      '<' +\n      env.tag +\n      ' class=\"' +\n      env.classes.join(' ') +\n      '\" ' +\n      attributes +\n      '>' +\n      env.content +\n      '</' +\n      env.tag +\n      '>'\n    );\n  };\n\n  if (!self.document) {\n    if (!self.addEventListener) {\n      // in Node.js\n      return self.Prism;\n    }\n    // In worker\n    self.addEventListener(\n      'message',\n      function (evt) {\n        var message = JSON.parse(evt.data),\n          lang = message.language,\n          code = message.code;\n\n        self.postMessage(\n          JSON.stringify(_.util.encode(_.tokenize(code, _.languages[lang])))\n        );\n        self.close();\n      },\n      false\n    );\n\n    return self.Prism;\n  }\n\n  // Get current script and highlight\n  var script = document.getElementsByTagName('script');\n\n  script = script[script.length - 1];\n\n  if (script) {\n    _.filename = script.src;\n\n    if (document.addEventListener && !script.hasAttribute('data-manual')) {\n      document.addEventListener('DOMContentLoaded', _.highlightAll);\n    }\n  }\n\n  return self.Prism;\n})();\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = Prism;\n}\n\n/* **********************************************\n     Begin prism-markup.js\n********************************************** */\n\nPrism.languages.markup = {\n  comment: /<!--[\\w\\W]*?-->/g,\n  prolog: /<\\?.+?\\?>/,\n  doctype: /<!DOCTYPE.+?>/,\n  cdata: /<!\\[CDATA\\[[\\w\\W]*?]]>/i,\n  tag: {\n    pattern:\n      /<\\/?[\\w:-]+\\s*(?:\\s+[\\w:-]+(?:=(?:(\"|')(\\\\?[\\w\\W])*?\\1|[^\\s'\">=]+))?\\s*)*\\/?>/gi,\n    inside: {\n      tag: {\n        pattern: /^<\\/?[\\w:-]+/i,\n        inside: {\n          punctuation: /^<\\/?/,\n          namespace: /^[\\w-]+?:/,\n        },\n      },\n      'attr-value': {\n        pattern: /=(?:('|\")[\\w\\W]*?(\\1)|[^\\s>]+)/gi,\n        inside: {\n          punctuation: /=|>|\"/g,\n        },\n      },\n      punctuation: /\\/?>/g,\n      'attr-name': {\n        pattern: /[\\w:-]+/g,\n        inside: {\n          namespace: /^[\\w-]+?:/,\n        },\n      },\n    },\n  },\n  entity: /\\&#?[\\da-z]{1,8};/gi,\n};\n\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add('wrap', function (env) {\n  if (env.type === 'entity') {\n    env.attributes['title'] = env.content.replace(/&amp;/, '&');\n  }\n});\n\n/* **********************************************\n     Begin prism-css.js\n********************************************** */\n\nPrism.languages.css = {\n  comment: /\\/\\*[\\w\\W]*?\\*\\//g,\n  atrule: {\n    pattern: /@[\\w-]+?.*?(;|(?=\\s*{))/gi,\n    inside: {\n      punctuation: /[;:]/g,\n    },\n  },\n  url: /url\\(([\"']?).*?\\1\\)/gi,\n  selector: /[^\\{\\}\\s][^\\{\\};]*(?=\\s*\\{)/g,\n  property: /(\\b|\\B)[\\w-]+(?=\\s*:)/gi,\n  string: /(\"|')(\\\\?.)*?\\1/g,\n  important: /\\B!important\\b/gi,\n  punctuation: /[\\{\\};:]/g,\n  function: /[-a-z0-9]+(?=\\()/gi,\n};\n\nif (Prism.languages.markup) {\n  Prism.languages.insertBefore('markup', 'tag', {\n    style: {\n      pattern: /<style[\\w\\W]*?>[\\w\\W]*?<\\/style>/gi,\n      inside: {\n        tag: {\n          pattern: /<style[\\w\\W]*?>|<\\/style>/gi,\n          inside: Prism.languages.markup.tag.inside,\n        },\n        rest: Prism.languages.css,\n      },\n      alias: 'language-css',\n    },\n  });\n\n  Prism.languages.insertBefore(\n    'inside',\n    'attr-value',\n    {\n      'style-attr': {\n        pattern: /\\s*style=(\"|').+?\\1/gi,\n        inside: {\n          'attr-name': {\n            pattern: /^\\s*style/gi,\n            inside: Prism.languages.markup.tag.inside,\n          },\n          punctuation: /^\\s*=\\s*['\"]|['\"]\\s*$/,\n          'attr-value': {\n            pattern: /.+/gi,\n            inside: Prism.languages.css,\n          },\n        },\n        alias: 'language-css',\n      },\n    },\n    Prism.languages.markup.tag\n  );\n}\n\n/* **********************************************\n     Begin prism-clike.js\n********************************************** */\n\nPrism.languages.clike = {\n  comment: [\n    {\n      pattern: /(^|[^\\\\])\\/\\*[\\w\\W]*?\\*\\//g,\n      lookbehind: true,\n    },\n    {\n      pattern: /(^|[^\\\\:])\\/\\/.*?(\\r?\\n|$)/g,\n      lookbehind: true,\n    },\n  ],\n  string: /(\"|')(\\\\?.)*?\\1/g,\n  'class-name': {\n    pattern:\n      /((?:(?:class|interface|extends|implements|trait|instanceof|new)\\s+)|(?:catch\\s+\\())[a-z0-9_\\.\\\\]+/gi,\n    lookbehind: true,\n    inside: {\n      punctuation: /(\\.|\\\\)/,\n    },\n  },\n  keyword:\n    /\\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\b/g,\n  boolean: /\\b(true|false)\\b/g,\n  function: {\n    pattern: /[a-z0-9_]+\\(/gi,\n    inside: {\n      punctuation: /\\(/,\n    },\n  },\n  number: /\\b-?(0x[\\dA-Fa-f]+|\\d*\\.?\\d+([Ee]-?\\d+)?)\\b/g,\n  operator: /[-+]{1,2}|!|<=?|>=?|={1,3}|&{1,2}|\\|?\\||\\?|\\*|\\/|\\~|\\^|\\%/g,\n  ignore: /&(lt|gt|amp);/gi,\n  punctuation: /[{}[\\];(),.:]/g,\n};\n\n/* **********************************************\n     Begin prism-javascript.js\n********************************************** */\n\nPrism.languages.javascript = Prism.languages.extend('clike', {\n  keyword:\n    /\\b(break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|get|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|set|static|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\\b/g,\n  number: /\\b-?(0x[\\dA-Fa-f]+|\\d*\\.?\\d+([Ee]-?\\d+)?|NaN|-?Infinity)\\b/g,\n});\n\nPrism.languages.insertBefore('javascript', 'keyword', {\n  regex: {\n    pattern:\n      /(^|[^/])\\/(?!\\/)(\\[.+?]|\\\\.|[^/\\r\\n])+\\/[gim]{0,3}(?=\\s*($|[\\r\\n,.;})]))/g,\n    lookbehind: true,\n  },\n});\n\nif (Prism.languages.markup) {\n  Prism.languages.insertBefore('markup', 'tag', {\n    script: {\n      pattern: /<script[\\w\\W]*?>[\\w\\W]*?<\\/script>/gi,\n      inside: {\n        tag: {\n          pattern: /<script[\\w\\W]*?>|<\\/script>/gi,\n          inside: Prism.languages.markup.tag.inside,\n        },\n        rest: Prism.languages.javascript,\n      },\n      alias: 'language-javascript',\n    },\n  });\n}\n\n/* **********************************************\n     Begin prism-file-highlight.js\n********************************************** */\n\n(function () {\n  if (!self.Prism || !self.document || !document.querySelector) {\n    return;\n  }\n\n  var Extensions = {\n    js: 'javascript',\n    html: 'markup',\n    svg: 'markup',\n    xml: 'markup',\n    py: 'python',\n    rb: 'ruby',\n  };\n\n  Array.prototype.slice\n    .call(document.querySelectorAll('pre[data-src]'))\n    .forEach(function (pre) {\n      var src = pre.getAttribute('data-src');\n      var extension = (src.match(/\\.(\\w+)$/) || [, ''])[1];\n      var language = Extensions[extension] || extension;\n\n      var code = document.createElement('code');\n      code.className = 'language-' + language;\n\n      pre.textContent = '';\n\n      code.textContent = 'Loading…';\n\n      pre.appendChild(code);\n\n      var xhr = new XMLHttpRequest();\n\n      xhr.open('GET', src, true);\n\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState == 4) {\n          if (xhr.status < 400 && xhr.responseText) {\n            code.textContent = xhr.responseText;\n\n            Prism.highlightElement(code);\n          } else if (xhr.status >= 400) {\n            code.textContent =\n              '✖ Error ' +\n              xhr.status +\n              ' while fetching file: ' +\n              xhr.statusText;\n          } else {\n            code.textContent = '✖ Error: File does not exist or is empty';\n          }\n        }\n      };\n\n      xhr.send(null);\n    });\n})();\n","global.runIt = function runIt(button) {\n  if (!global.RunKit) return;\n\n  var container = document.createElement('div');\n  var codeElement = button.parentNode;\n  var parent = codeElement.parentNode;\n\n  parent.insertBefore(container, codeElement);\n  parent.removeChild(codeElement);\n  codeElement.removeChild(button);\n\n  const options = JSON.parse(unescape(button.dataset.options));\n\n  function withCorrectVersion(code) {\n    return code.replace(\n      /require\\('immutable'\\)/g,\n      \"require('immutable@4.0.0-rc.9')\"\n    );\n  }\n\n  global.RunKit.createNotebook({\n    element: container,\n    nodeVersion: options.nodeVersion || '*',\n    preamble: withCorrectVersion(\n      'const assert = (' +\n        makeAssert +\n        \")(require('immutable'));\" +\n        (options.preamble || '')\n    ),\n    source: withCorrectVersion(\n      codeElement.textContent.replace(/\\n(>[^\\n]*\\n?)+$/g, '')\n    ),\n    minHeight: '52px',\n    onLoad: function (notebook) {\n      notebook.evaluate();\n    },\n  });\n};\n\nfunction makeAssert(I) {\n  var isIterable = I.isIterable || I.Iterable.isIterable;\n  var html = (\"\\n    <style>\\n      * {\\n        font-size: 14px;\\n        font-family: monospace;\\n      }\\n\\n      code {\\n        font-family: monospace;\\n        color: #4183C4;\\n        text-decoration: none;\\n        text-decoration: none;\\n        background: rgba(65, 131, 196, 0.1);\\n        border-radius: 2px;\\n        padding: 2px;\\n    }\\n\\n      .success {\\n        color: rgba(84,184,54,1.0);\\n      }\\n\\n      .success:before {\\n        content: \\\"✅\\\";\\n      }\\n\\n      .failure {\\n        color: rgba(220,47,33,1.0);\\n      }\\n\\n      .failure i {\\n        color: rgba(210,44,31,1.0);\\n      }\\n\\n      .failure:before {\\n        content: \\\"❌\\\";\\n      }\\n    </style>\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n);\n\n  function compare(lhs, rhs, same, identical) {\n    var both = !identical && isIterable(lhs) && isIterable(rhs);\n\n    if (both) return lhs.equals(rhs);\n\n    return lhs === rhs;\n  }\n\n  function message(lhs, rhs, same, identical) {\n    var result = compare(lhs, rhs, same, identical);\n    var comparison = result\n      ? identical\n        ? 'strict equal to'\n        : 'does equal'\n      : identical\n      ? 'not strict equal to'\n      : 'does not equal';\n    var className = result === same ? 'success' : 'failure';\n    var lhsString = isIterable(lhs) ? lhs + '' : JSON.stringify(lhs);\n    var rhsString = isIterable(rhs) ? rhs + '' : JSON.stringify(rhs);\n\n    return (html += (\"\\n      <span class=\\\"\" + \nclassName + \"\\\">\\n        <code>\" + \nlhsString + \"</code>\\n        \" + \ncomparison + \"\\n        <code>\" + \nrhsString + \"</code>\\n      </span><br/>\"\n));\n  }\n\n  function equal(lhs, rhs) {\n    return message(lhs, rhs, true);\n  }\n\n  function notEqual(lhs, rhs) {\n    return message(lhs, rhs, false);\n  }\n\n  function strictEqual(lhs, rhs) {\n    return message(lhs, rhs, true, true);\n  }\n\n  function notStrictEqual(lhs, rhs) {\n    return message(lhs, rhs, false, true);\n  }\n\n  return { equal:equal, notEqual:notEqual, strictEqual:strictEqual, notStrictEqual:notStrictEqual };\n}\n","var React = require('react');\nvar CSSCore = require('react/lib/CSSCore');\nvar Router = require('react-router');\nvar $__0=    require('../../../../'),Seq=$__0.Seq;\nvar TypeKind = require('../../../lib/TypeKind');\nvar defs = require('../../../lib/getTypeDefs');\n\nvar InterfaceDef = React.createClass({displayName: \"InterfaceDef\",\n  render:function() {\n    var name = this.props.name;\n    var def = this.props.def;\n    return (\n      React.createElement(\"span\", {className: \"t interfaceDef\"}, \n        React.createElement(\"span\", {className: \"t keyword\"}, \"type \"), \n        React.createElement(\"span\", {className: \"t typeName\"}, name), \n        def.typeParams && [\n          '<',\n          Seq(def.typeParams)\n            .map(function(t, k)  \n              {return React.createElement(\"span\", {className: \"t typeParam\", key: k}, \n                t\n              );}\n            )\n            .interpose(', ')\n            .toArray(),\n          '>',\n        ], \n        def.extends && [\n          React.createElement(\"span\", {className: \"t keyword\"}, \" extends \"),\n          Seq(def.extends)\n            .map(function(e, i)  {return React.createElement(TypeDef, {key: i, type: e});})\n            .interpose(', ')\n            .toArray(),\n        ], \n        def.implements && [\n          React.createElement(\"span\", {className: \"t keyword\"}, \" implements \"),\n          Seq(def.implements)\n            .map(function(e, i)  {return React.createElement(TypeDef, {key: i, type: e});})\n            .interpose(', ')\n            .toArray(),\n        ]\n      )\n    );\n  },\n});\n\nexports.InterfaceDef = InterfaceDef;\n\nvar CallSigDef = React.createClass({displayName: \"CallSigDef\",\n  render:function() {\n    var info = this.props.info;\n    var module = this.props.module;\n    var name = this.props.name;\n    var callSig = this.props.callSig || {};\n\n    var shouldWrap = callSigLength(info, module, name, callSig) > 80;\n\n    return (\n      React.createElement(\"span\", {className: \"t callSig\"}, \n        module && [React.createElement(\"span\", {className: \"t fnQualifier\"}, module), '.'], \n        React.createElement(\"span\", {className: \"t fnName\"}, name), \n        callSig.typeParams && [\n          '<',\n          Seq(callSig.typeParams)\n            .map(function(t)  {return React.createElement(\"span\", {className: \"t typeParam\"}, t);})\n            .interpose(', ')\n            .toArray(),\n          '>',\n        ], \n        '(', \n        callSig && functionParams(info, callSig.params, shouldWrap), \n        ')', \n        callSig.type && [': ', React.createElement(TypeDef, {info: info, type: callSig.type})]\n      )\n    );\n  },\n});\n\nexports.CallSigDef = CallSigDef;\n\nvar TypeDef = React.createClass({displayName: \"TypeDef\",\n  render:function() {\n    var info = this.props.info;\n    var type = this.props.type;\n    var prefix = this.props.prefix;\n    switch (type.k) {\n      case TypeKind.Never:\n        return this.wrap('primitive', 'never');\n      case TypeKind.Any:\n        return this.wrap('primitive', 'any');\n      case TypeKind.Unknown:\n        return this.wrap('primitive', 'unknown');\n      case TypeKind.This:\n        return this.wrap('primitive', 'this');\n      case TypeKind.Undefined:\n        return this.wrap('primitive', 'undefined');\n      case TypeKind.Boolean:\n        return this.wrap('primitive', 'boolean');\n      case TypeKind.Number:\n        return this.wrap('primitive', 'number');\n      case TypeKind.String:\n        return this.wrap('primitive', 'string');\n      case TypeKind.Union:\n        return this.wrap('union', [\n          Seq(type.types)\n            .map(function(t)  {return React.createElement(TypeDef, {info: info, type: t});})\n            .interpose(' | ')\n            .toArray(),\n        ]);\n      case TypeKind.Intersection:\n        return this.wrap('intersection', [\n          Seq(type.types)\n            .map(function(t)  {return React.createElement(TypeDef, {info: info, type: t});})\n            .interpose(' & ')\n            .toArray(),\n        ]);\n      case TypeKind.Tuple:\n        return this.wrap('tuple', [\n          '[',\n          Seq(type.types)\n            .map(function(t)  {return React.createElement(TypeDef, {info: info, type: t});})\n            .interpose(', ')\n            .toArray(),\n          ']',\n        ]);\n      case TypeKind.Object:\n        return this.wrap('object', [\n          '{',\n          Seq(type.members)\n            .map(function(t)  {return React.createElement(MemberDef, {member: t});})\n            .interpose(', ')\n            .toArray(),\n          '}',\n        ]);\n      case TypeKind.Indexed:\n        return this.wrap('indexed', [\n          React.createElement(TypeDef, {info: info, type: type.type}),\n          '[',\n          React.createElement(TypeDef, {info: info, type: type.index}),\n          ']',\n        ]);\n      case TypeKind.Operator:\n        return this.wrap('operator', [\n          this.wrap('primitive', type.operator),\n          ' ',\n          React.createElement(TypeDef, {info: info, type: type.type}),\n        ]);\n      case TypeKind.Array:\n        return this.wrap('array', [\n          React.createElement(TypeDef, {info: info, type: type.type}),\n          '[]',\n        ]);\n      case TypeKind.Function:\n        var shouldWrap = (prefix || 0) + funcLength(info, type) > 78;\n        return this.wrap('function', [\n          type.typeParams && [\n            '<',\n            Seq(type.typeParams)\n              .map(function(t, k)  \n                {return React.createElement(\"span\", {className: \"t typeParam\", key: k}, \n                  t\n                );}\n              )\n              .interpose(', ')\n              .toArray(),\n            '>',\n          ],\n          '(',\n          functionParams(info, type.params, shouldWrap),\n          ') => ',\n          React.createElement(TypeDef, {info: info, type: type.type}),\n        ]);\n      case TypeKind.Param:\n        return info && info.propMap[info.defining + '<' + type.param] ? (\n          React.createElement(TypeDef, {type: info.propMap[info.defining + '<' + type.param]})\n        ) : (\n          this.wrap('typeParam', type.param)\n        );\n      case TypeKind.Type:\n        var qualifiedType = (type.qualifier || []).concat([type.name]);\n        var qualifiedTypeName = qualifiedType.join('.');\n        var def = qualifiedTypeName\n          .split('.')\n          .reduce(\n            function(def, name)  {return def && def.module && def.module[name];},\n            defs.Immutable\n          );\n        var typeNameElement = [\n          type.qualifier && [\n            Seq(type.qualifier)\n              .map(function(q)  {return React.createElement(\"span\", {className: \"t typeQualifier\"}, q);})\n              .interpose('.')\n              .toArray(),\n            '.',\n          ],\n          React.createElement(\"span\", {className: \"t typeName\"}, type.name),\n        ];\n        if (def) {\n          typeNameElement = (\n            React.createElement(Router.Link, {to: '/' + qualifiedTypeName}, \n              typeNameElement\n            )\n          );\n        }\n        return this.wrap('type', [\n          typeNameElement,\n          type.args && [\n            '<',\n            Seq(type.args)\n              .map(function(a)  {return React.createElement(TypeDef, {info: info, type: a});})\n              .interpose(', ')\n              .toArray(),\n            '>',\n          ],\n        ]);\n    }\n    throw new Error('Unknown kind ' + type.k);\n  },\n\n  mouseOver:function(event) {\n    CSSCore.addClass(this.getDOMNode(), 'over');\n    event.stopPropagation();\n  },\n\n  mouseOut:function() {\n    CSSCore.removeClass(this.getDOMNode(), 'over');\n  },\n\n  wrap:function(className, child) {\n    return (\n      React.createElement(\"span\", {\n        className: 't ' + className, \n        onMouseOver: this.mouseOver, \n        onFocus: this.mouseOver, \n        onMouseOut: this.mouseOut, \n        onBlur: this.mouseOut\n      }, \n        child\n      )\n    );\n  },\n});\n\nexports.TypeDef = TypeDef;\n\nvar MemberDef = React.createClass({displayName: \"MemberDef\",\n  render:function() {\n    var module = this.props.module;\n    var member = this.props.member;\n    return (\n      React.createElement(\"span\", {className: \"t member\"}, \n        module && [React.createElement(\"span\", {className: \"t fnQualifier\"}, module), '.'], \n        member.index ? (\n          ['[', functionParams(null, member.params), ']']\n        ) : (\n          React.createElement(\"span\", {className: \"t memberName\"}, member.name)\n        ), \n        member.type && [': ', React.createElement(TypeDef, {type: member.type})]\n      )\n    );\n  },\n});\n\nexports.MemberDef = MemberDef;\n\nfunction functionParams(info, params, shouldWrap) {\n  var elements = Seq(params)\n    .map(function(t)  {return [\n      t.varArgs ? '...' : null,\n      React.createElement(\"span\", {className: \"t param\"}, t.name),\n      t.optional ? '?: ' : ': ',\n      React.createElement(TypeDef, {\n        prefix: t.name.length + (t.varArgs ? 3 : 0) + (t.optional ? 3 : 2), \n        info: info, \n        type: t.type}\n      ),\n    ];})\n    .interpose(shouldWrap ? [',', React.createElement(\"br\", null)] : ', ')\n    .toArray();\n  return shouldWrap ? (\n    React.createElement(\"div\", {className: \"t blockParams\"}, elements)\n  ) : (\n    elements\n  );\n}\n\nfunction callSigLength(info, module, name, sig) {\n  return (module ? module.length + 1 : 0) + name.length + funcLength(info, sig);\n}\n\nfunction funcLength(info, sig) {\n  return (\n    (sig.typeParams ? 2 + sig.typeParams.join(', ').length : 0) +\n    2 +\n    (sig.params ? paramLength(info, sig.params) : 0) +\n    (sig.type ? 2 + typeLength(info, sig.type) : 0)\n  );\n}\n\nfunction paramLength(info, params) {\n  return params.reduce(\n    function(s, p) \n      {return s +\n      (p.varArgs ? 3 : 0) +\n      p.name.length +\n      (p.optional ? 3 : 2) +\n      typeLength(info, p.type);},\n    (params.length - 1) * 2\n  );\n}\n\nfunction memberLength(info, members) {\n  return members.reduce(\n    function(s, m) \n      {return s +\n      (m.index ? paramLength(info, m.params) + 4 : m.name + 2) +\n      typeLength(info, m.type);},\n    (members.length - 1) * 2\n  );\n}\n\nfunction typeLength(info, type) {\n  if (!type) {\n    throw new Error('Expected type');\n  }\n  switch (type.k) {\n    case TypeKind.Never:\n      return 5;\n    case TypeKind.Any:\n      return 3;\n    case TypeKind.Unknown:\n      return 7;\n    case TypeKind.This:\n      return 4;\n    case TypeKind.Undefined:\n      return 9;\n    case TypeKind.Boolean:\n      return 7;\n    case TypeKind.Number:\n      return 6;\n    case TypeKind.String:\n      return 6;\n    case TypeKind.Union:\n    case TypeKind.Intersection:\n      return (\n        type.types.reduce(function(s, t)  {return s + typeLength(info, t);}, 0) +\n        (type.types.length - 1) * 3\n      );\n    case TypeKind.Tuple:\n      return (\n        2 +\n        type.types.reduce(function(s, t)  {return s + typeLength(info, t);}, 0) +\n        (type.types.length - 1) * 2\n      );\n    case TypeKind.Object:\n      return 2 + memberLength(info, type.members);\n    case TypeKind.Indexed:\n      return 2 + typeLength(info, type.type) + typeLength(info, type.index);\n    case TypeKind.Operator:\n      return 1 + type.operator.length + typeLength(info, type.type);\n    case TypeKind.Array:\n      return typeLength(info, type.type) + 2;\n    case TypeKind.Function:\n      return 2 + funcLength(info, type);\n    case TypeKind.Param:\n      return info && info.propMap[info.defining + '<' + type.param]\n        ? typeLength(null, info.propMap[info.defining + '<' + type.param])\n        : type.param.length;\n    case TypeKind.Type:\n      return (\n        (type.qualifier ? 1 + type.qualifier.join('.').length : 0) +\n        type.name.length +\n        (!type.args\n          ? 0\n          : type.args.reduce(\n              function(s, a)  {return s + typeLength(info, a);},\n              type.args.length * 2\n            ))\n      );\n  }\n  throw new Error('Type with unknown kind ' + JSON.stringify(type));\n}\n","var React = require('react');\nvar SVGSet = require('../../src/SVGSet');\nvar Logo = require('../../src/Logo');\nvar packageJson = require('../../../../package.json');\n\nvar DocHeader = React.createClass({displayName: \"DocHeader\",\n  render:function() {\n    return (\n      React.createElement(\"div\", {className: \"header\"}, \n        React.createElement(\"div\", {className: \"miniHeader\"}, \n          React.createElement(\"div\", {className: \"miniHeaderContents\"}, \n            React.createElement(\"a\", {href: \"../\", target: \"_self\", className: \"miniLogo\"}, \n              React.createElement(SVGSet, null, \n                React.createElement(Logo, {color: \"#FC4349\"}), \n                React.createElement(Logo, {color: \"#2C3E50\", inline: true})\n              )\n            ), \n            React.createElement(\"a\", {href: \"./\", target: \"_self\"}, \n              \"Docs (v\", \n              packageJson.version, \")\"\n            ), \n            React.createElement(\"a\", {href: \"https://stackoverflow.com/questions/tagged/immutable.js?sort=votes\"}, \n              \"Questions\"\n            ), \n            React.createElement(\"a\", {href: \"https://github.com/immutable-js/immutable-js/\"}, \"Github\")\n          )\n        )\n      )\n    );\n  },\n});\n\nmodule.exports = DocHeader;\n","var React = require('react');\nvar Router = require('react-router');\nvar $__0=    require('../../../../'),Seq=$__0.Seq;\nvar Markdown = require('./MarkDown');\n\nvar DocOverview = React.createClass({displayName: \"DocOverview\",\n  render:function() {\n    var def = this.props.def;\n    var doc = def.doc;\n\n    return (\n      React.createElement(\"div\", null, \n        doc && (\n          React.createElement(\"section\", null, \n            React.createElement(Markdown, {contents: doc.synopsis}), \n            doc.description && React.createElement(Markdown, {contents: doc.description})\n          )\n        ), \n\n        React.createElement(\"h4\", {className: \"groupTitle\"}, \"API\"), \n\n        Seq(def.module)\n          .map(function(t, name)  {\n            var isFunction = !t.interface && !t.module;\n            if (isFunction) {\n              t = t.call;\n            }\n            return (\n              React.createElement(\"section\", {key: name, className: \"interfaceMember\"}, \n                React.createElement(\"h3\", {className: \"memberLabel\"}, \n                  React.createElement(Router.Link, {to: '/' + name}, \n                    name + (isFunction ? '()' : '')\n                  )\n                ), \n                t.doc && (\n                  React.createElement(Markdown, {className: \"detail\", contents: t.doc.synopsis})\n                )\n              )\n            );\n          })\n          .valueSeq()\n          .toArray()\n      )\n    );\n  },\n});\n\nmodule.exports = DocOverview;\n","var React = require('react');\n\nvar DocSearch = React.createClass({displayName: \"DocSearch\",\n  getInitialState:function() {\n    return { enabled: true };\n  },\n  componentDidMount:function() {\n    var script = document.createElement('script');\n    var firstScript = document.getElementsByTagName('script')[0];\n    script.src =\n      'https://cdn.jsdelivr.net/npm/docsearch.js@2.5.2/dist/cdn/docsearch.min.js';\n    script.addEventListener(\n      'load',\n      function()  {\n        // Initialize Algolia search.\n        if (window.docsearch) {\n          window.docsearch({\n            apiKey: '83f61f865ef4cb682e0432410c2f7809',\n            indexName: 'immutable_js',\n            inputSelector: '#algolia-docsearch',\n          });\n        } else {\n          this.setState({ enabled: false });\n        }\n      }.bind(this),\n      false\n    );\n    firstScript.parentNode.insertBefore(script, firstScript);\n\n    var link = document.createElement('link');\n    var firstLink = document.getElementsByTagName('link')[0];\n    link.rel = 'stylesheet';\n    link.href =\n      'https://cdn.jsdelivr.net/npm/docsearch.js@2.5.2/dist/cdn/docsearch.min.css';\n    firstLink.parentNode.insertBefore(link, firstLink);\n  },\n  render:function() {\n    return this.state.enabled ? (\n      React.createElement(\"input\", {\n        id: \"algolia-docsearch\", \n        className: \"docSearch\", \n        type: \"search\", \n        placeholder: \"Search Immutable.js Documentation\"}\n      )\n    ) : null;\n  },\n});\n\nmodule.exports = DocSearch;\n","var React = require('react');\n\nvar MarkDown = React.createClass({displayName: \"MarkDown\",\n  shouldComponentUpdate:function() {\n    return false;\n  },\n\n  render:function() {\n    var html = this.props.contents;\n    return (\n      React.createElement(\"div\", {\n        className: this.props.className, \n        dangerouslySetInnerHTML: { __html: html}}\n      )\n    );\n  },\n});\n\nmodule.exports = MarkDown;\n","var React = require('react');\nvar ReactTransitionEvents = require('react/lib/ReactTransitionEvents');\nvar Router = require('react-router');\nvar $__0=     require('./Defs'),CallSigDef=$__0.CallSigDef,MemberDef=$__0.MemberDef;\nvar PageDataMixin = require('./PageDataMixin');\nvar isMobile = require('./isMobile');\nvar MarkDown = require('./MarkDown');\n\nvar $__1=    React.addons,TransitionGroup=$__1.TransitionGroup;\n\nvar MemberDoc = React.createClass({displayName: \"MemberDoc\",\n  mixins: [PageDataMixin, Router.Navigation],\n\n  getInitialState:function() {\n    var showDetail = this.props.showDetail;\n    return { detail: showDetail };\n  },\n\n  componentDidMount:function() {\n    if (this.props.showDetail) {\n      var node = this.getDOMNode();\n      var navType = this.getPageData().type;\n      if (navType === 'init' || navType === 'push') {\n        window.scrollTo(window.scrollX, offsetTop(node) - FIXED_HEADER_HEIGHT);\n      }\n    }\n  },\n\n  componentWillReceiveProps:function(nextProps) {\n    if (nextProps.showDetail && !this.props.showDetail) {\n      this.scrollTo = true;\n      this.setState({ detail: true });\n    }\n  },\n\n  componentDidUpdate:function() {\n    if (this.scrollTo) {\n      this.scrollTo = false;\n      var node = this.getDOMNode();\n      var navType = this.getPageData().type;\n      if (navType === 'init' || navType === 'push') {\n        window.scrollTo(window.scrollX, offsetTop(node) - FIXED_HEADER_HEIGHT);\n      }\n    }\n  },\n\n  toggleDetail:function() {\n    // Note: removed this because it drops the URL bar on mobile, and that's\n    // the only place it's currently being used.\n    // var member = this.props.member;\n    // var name = member.memberName;\n    // var typeName = this.props.parentName;\n    // var showDetail = this.props.showDetail;\n    // if (!this.state.detail) {\n    //   this.replaceWith('/' + (typeName ? typeName + '/' : '') + name );\n    // } else if (this.state.detail && showDetail) {\n    //   this.replaceWith('/' + (typeName || '') );\n    // }\n    this.setState({ detail: !this.state.detail });\n  },\n\n  render:function() {\n    var typePropMap = this.props.typePropMap;\n    var member = this.props.member;\n    var module = member.isStatic ? this.props.parentName : null;\n    var name = member.memberName;\n    var def = member.memberDef;\n    var doc = def.doc || {};\n    var isProp = !def.signatures;\n\n    var typeInfo = member.inherited && {\n      propMap: typePropMap,\n      defining: member.inherited.name,\n    };\n\n    var showDetail = isMobile ? this.state.detail : true;\n\n    var memberAnchorLink = this.props.parentName + '/' + name;\n\n    return (\n      React.createElement(\"div\", {className: \"interfaceMember\"}, \n        React.createElement(\"h3\", {className: \"memberLabel\"}, \n          React.createElement(Router.Link, {\n            to: '/' + memberAnchorLink, \n            onClick: isMobile ? this.toggleDetail : null\n          }, \n            (module ? module + '.' : '') + name + (isProp ? '' : '()')\n          )\n        ), \n        React.createElement(TransitionGroup, {childFactory: makeSlideDown}, \n          showDetail && (\n            React.createElement(\"div\", {key: \"detail\", className: \"detail\"}, \n              doc.synopsis && (\n                React.createElement(MarkDown, {className: \"synopsis\", contents: doc.synopsis})\n              ), \n              isProp ? (\n                React.createElement(\"code\", {className: \"codeBlock memberSignature\"}, \n                  React.createElement(MemberDef, {\n                    module: module, \n                    member: { name:name, type: def.type}}\n                  )\n                )\n              ) : (\n                React.createElement(\"code\", {className: \"codeBlock memberSignature\"}, \n                  def.signatures.map(function(callSig, i)  {return [\n                    React.createElement(CallSigDef, {\n                      key: i, \n                      info: typeInfo, \n                      module: module, \n                      name: name, \n                      callSig: callSig}\n                    ),\n                    '\\n',\n                  ];})\n                )\n              ), \n              member.inherited && (\n                React.createElement(\"section\", null, \n                  React.createElement(\"h4\", {className: \"infoHeader\"}, \"Inherited from\"), \n                  React.createElement(\"code\", null, \n                    React.createElement(Router.Link, {to: '/' + member.inherited.name + '/' + name}, \n                      member.inherited.name + '#' + name\n                    )\n                  )\n                )\n              ), \n              member.overrides && (\n                React.createElement(\"section\", null, \n                  React.createElement(\"h4\", {className: \"infoHeader\"}, \"Overrides\"), \n                  React.createElement(\"code\", null, \n                    React.createElement(Router.Link, {to: '/' + member.overrides.name + '/' + name}, \n                      member.overrides.name + '#' + name\n                    )\n                  )\n                )\n              ), \n              doc.notes &&\n                doc.notes.map(function(note, i)  \n                  {return React.createElement(\"section\", {key: i}, \n                    React.createElement(\"h4\", {className: \"infoHeader\"}, note.name), \n                    note.name === 'alias' ? (\n                      React.createElement(\"code\", null, \n                        React.createElement(CallSigDef, {name: note.body})\n                      )\n                    ) : (\n                      React.createElement(MarkDown, {className: \"discussion\", contents: note.body})\n                    )\n                  );}\n                ), \n              doc.description && (\n                React.createElement(\"section\", null, \n                  React.createElement(\"h4\", {className: \"infoHeader\"}, \n                    doc.description.substr(0, 5) === '<code'\n                      ? 'Example'\n                      : 'Discussion'\n                  ), \n                  React.createElement(MarkDown, {className: \"discussion\", contents: doc.description})\n                )\n              )\n            )\n          )\n        )\n      )\n    );\n  },\n});\n\nfunction makeSlideDown(child) {\n  return React.createElement(SlideDown, null, child);\n}\n\nvar SlideDown = React.createClass({displayName: \"SlideDown\",\n  componentWillEnter:function(done) {\n    this.slide(false, done);\n  },\n\n  componentWillLeave:function(done) {\n    this.slide(true, done);\n  },\n\n  slide:function(slidingUp, done) {\n    var node = this.getDOMNode();\n    node.style.height = 'auto';\n    var height = getComputedStyle(node).height;\n    var start = slidingUp ? height : 0;\n    var end = slidingUp ? 0 : height;\n    node.style.transition = '';\n    node.style.height = start;\n    node.style.transition = 'height 0.35s ease-in-out';\n    var endListener = function()  {\n      ReactTransitionEvents.removeEndEventListener(node, endListener);\n      done();\n    };\n    ReactTransitionEvents.addEndEventListener(node, endListener);\n    this.timeout = setTimeout(function()  {\n      node.style.height = end;\n    }, 17);\n  },\n\n  render:function() {\n    return this.props.children;\n  },\n});\n\nvar FIXED_HEADER_HEIGHT = 75;\n\nfunction offsetTop(node) {\n  var top = 0;\n  do {\n    top += node.offsetTop;\n  } while ((node = node.offsetParent));\n  return top;\n}\n\nmodule.exports = MemberDoc;\n","var React = require('react');\n\nmodule.exports = {\n  contextTypes: {\n    getPageData: React.PropTypes.func.isRequired,\n  },\n\n  /**\n   * Returns the most recent change event.\n   */\n  getPageData:function() {\n    return this.context.getPageData();\n  },\n};\n","var React = require('react');\nvar Router = require('react-router');\nvar $__0=     require('../../../../'),Map=$__0.Map,Seq=$__0.Seq;\nvar defs = require('../../../lib/getTypeDefs');\n\nvar SideBar = React.createClass({displayName: \"SideBar\",\n  render:function() {\n    var type = defs.Immutable;\n\n    return (\n      React.createElement(\"div\", {className: \"sideBar\"}, \n        React.createElement(\"div\", {className: \"toolBar\"}, \n          React.createElement(\"div\", {\n            onClick: this.props.toggleShowInGroups, \n            onKeyPress: this.props.toggleShowInGroups\n          }, \n            React.createElement(\"span\", {className: this.props.showInGroups && 'selected'}, \n              \"Grouped\"\n            ), \n            ' • ', \n            React.createElement(\"span\", {className: this.props.showInGroups || 'selected'}, \n              \"Alphabetized\"\n            )\n          ), \n          React.createElement(\"div\", {\n            onClick: this.props.toggleShowInherited, \n            onKeyPress: this.props.toggleShowInherited\n          }, \n            React.createElement(\"span\", {className: this.props.showInherited && 'selected'}, \n              \"Inherited\"\n            ), \n            ' • ', \n            React.createElement(\"span\", {className: this.props.showInherited || 'selected'}, \n              \"Defined\"\n            )\n          )\n        ), \n        React.createElement(\"div\", {className: \"scrollContent\"}, \n          React.createElement(\"h4\", {className: \"groupTitle\"}, \"API\"), \n          Seq(type.module)\n            .flatMap(function(t, name)  {return flattenSubmodules(Map(), t, name);})\n            .map(function(t, name)  {return this.renderSideBarType(name, t);}.bind(this))\n            .valueSeq()\n            .toArray()\n        )\n      )\n    );\n  },\n\n  renderSideBarType:function(typeName, type) {\n    var isFocus = this.props.focus === typeName;\n    var isFunction = !type.interface && !type.module;\n    var call = type.call;\n    var functions = Seq(type.module).filter(function(t)  {return !t.interface && !t.module;});\n\n    var label = typeName + (isFunction ? '()' : '');\n\n    if (!isFocus) {\n      label = React.createElement(Router.Link, {to: '/' + typeName}, label);\n    }\n\n    var memberGroups = this.props.memberGroups;\n\n    var members =\n      !isFocus || isFunction ? null : (\n        React.createElement(\"div\", {className: \"members\"}, \n          call && (\n            React.createElement(\"section\", null, \n              React.createElement(\"h4\", {className: \"groupTitle\"}, \"Construction\"), \n              React.createElement(\"div\", null, \n                React.createElement(Router.Link, {to: '/' + typeName + '/' + typeName}, \n                  typeName + '()'\n                )\n              )\n            )\n          ), \n\n          functions.count() > 0 && (\n            React.createElement(\"section\", null, \n              React.createElement(\"h4\", {className: \"groupTitle\"}, \"Static Methods\"), \n              functions\n                .map(function(t, name)  \n                  {return React.createElement(\"div\", {key: name}, \n                    React.createElement(Router.Link, {to: '/' + typeName + '/' + name}, \n                      typeName + '.' + name + '()'\n                    )\n                  );}\n                )\n                .valueSeq()\n                .toArray()\n            )\n          ), \n\n          React.createElement(\"section\", null, \n            Seq(memberGroups)\n              .map(function(members, title) \n                {return members.length === 0\n                  ? null\n                  : Seq([\n                      React.createElement(\"h4\", {key: title || 'Members', className: \"groupTitle\"}, \n                        title || 'Members'\n                      ),\n                      Seq(members).map(function(member)  \n                        {return React.createElement(\"div\", {key: member.memberName}, \n                          React.createElement(Router.Link, {\n                            to: '/' + typeName + '/' + member.memberName\n                          }, \n                            member.memberName +\n                              (member.memberDef.signatures ? '()' : '')\n                          )\n                        );}\n                      ),\n                    ]);}\n              )\n              .flatten()\n              .valueSeq()\n              .toArray()\n          )\n        )\n      );\n\n    return (\n      React.createElement(\"div\", {key: typeName}, \n        React.createElement(\"h2\", null, label), \n        members\n      )\n    );\n  },\n});\n\nfunction flattenSubmodules(modules, type, name) {\n  modules = modules.set(name, type);\n  return type.module\n    ? Seq(type.module)\n        .filter(function(t)  {return t.interface || t.module;})\n        .reduce(\n          function(modules, subT, subName) \n            {return flattenSubmodules(modules, subT, name + '.' + subName);},\n          modules\n        )\n    : modules;\n}\n\nmodule.exports = SideBar;\n","var React = require('react');\nvar Router = require('react-router');\nvar $__0=    require('../../../../'),Seq=$__0.Seq;\nvar $__1=     require('./Defs'),InterfaceDef=$__1.InterfaceDef,CallSigDef=$__1.CallSigDef;\nvar MemberDoc = require('./MemberDoc');\nvar isMobile = require('./isMobile');\nvar SideBar = require('./SideBar');\nvar MarkDown = require('./MarkDown');\nvar DocOverview = require('./DocOverview');\nvar collectMemberGroups = require('../../../lib/collectMemberGroups');\nvar TypeKind = require('../../../lib/TypeKind');\nvar defs = require('../../../lib/getTypeDefs');\n\nvar typeDefURL =\n  'https://github.com/immutable-js/immutable-js/blob/main/type-definitions/Immutable.d.ts';\nvar issuesURL = 'https://github.com/immutable-js/immutable-js/issues';\n\nvar Disclaimer = function () {\n  return (\n    React.createElement(\"section\", {className: \"disclaimer\"}, \n      \"This documentation is generated from\", ' ', \n      React.createElement(\"a\", {href: typeDefURL}, \"Immutable.d.ts\"), \". Pull requests and\", ' ', \n      React.createElement(\"a\", {href: issuesURL}, \"Issues\"), \" welcome.\"\n    )\n  );\n};\n\nvar TypeDocumentation = React.createClass({displayName: \"TypeDocumentation\",\n  getInitialState:function() {\n    return {\n      showInherited: true,\n      showInGroups: true,\n    };\n  },\n\n  toggleShowInGroups:function() {\n    this.setState({ showInGroups: !this.state.showInGroups });\n  },\n\n  toggleShowInherited:function() {\n    this.setState({ showInherited: !this.state.showInherited });\n  },\n\n  render:function() {\n    var name = this.props.name;\n    var memberName = this.props.memberName;\n    var def = this.props.def;\n\n    var memberGroups = collectMemberGroups(def && def.interface, {\n      showInGroups: this.state.showInGroups,\n      showInherited: this.state.showInherited,\n    });\n\n    return (\n      React.createElement(\"div\", null, \n        isMobile || (\n          React.createElement(SideBar, {\n            focus: name, \n            memberGroups: memberGroups, \n            toggleShowInherited: this.toggleShowInherited, \n            toggleShowInGroups: this.toggleShowInGroups, \n            showInGroups: this.state.showInGroups, \n            showInherited: this.state.showInherited}\n          )\n        ), \n        React.createElement(\"div\", {key: name, className: \"docContents\"}, \n          !def ? (\n            React.createElement(NotFound, null)\n          ) : !name ? (\n            React.createElement(DocOverview, {def: def})\n          ) : !def.interface && !def.module ? (\n            React.createElement(FunctionDoc, {name: name, def: def.call})\n          ) : (\n            React.createElement(TypeDoc, {\n              name: name, \n              def: def, \n              memberName: memberName, \n              memberGroups: memberGroups}\n            )\n          )\n        )\n      )\n    );\n  },\n});\n\nfunction NotFound() {\n  return React.createElement(\"div\", null, \"Not found\");\n}\n\nvar FunctionDoc = React.createClass({displayName: \"FunctionDoc\",\n  render:function() {\n    var name = this.props.name;\n    var def = this.props.def;\n    var doc = def.doc || {};\n\n    return (\n      React.createElement(\"div\", null, \n        React.createElement(\"h1\", {className: \"typeHeader\"}, name + '()'), \n        doc.synopsis && (\n          React.createElement(MarkDown, {className: \"synopsis\", contents: doc.synopsis})\n        ), \n        React.createElement(\"code\", {className: \"codeBlock memberSignature\"}, \n          def.signatures.map(function(callSig, i)  {return [\n            React.createElement(CallSigDef, {key: i, name: name, callSig: callSig}),\n            '\\n',\n          ];})\n        ), \n        doc.notes &&\n          doc.notes.map(function(note, i)  \n            {return React.createElement(\"section\", {key: i}, \n              React.createElement(\"h4\", {className: \"infoHeader\"}, note.name), \n              note.name === 'alias' ? (\n                React.createElement(CallSigDef, {name: note.body})\n              ) : (\n                note.body\n              )\n            );}\n          ), \n        doc.description && (\n          React.createElement(\"section\", null, \n            React.createElement(\"h4\", {className: \"infoHeader\"}, \n              doc.description.substr(0, 5) === '<code'\n                ? 'Example'\n                : 'Discussion'\n            ), \n            React.createElement(MarkDown, {className: \"discussion\", contents: doc.description})\n          )\n        ), \n        React.createElement(Disclaimer, null)\n      )\n    );\n  },\n});\n\nvar TypeDoc = React.createClass({displayName: \"TypeDoc\",\n  render:function() {\n    var name = this.props.name;\n    var def = this.props.def;\n    var memberName = this.props.memberName;\n    var memberGroups = this.props.memberGroups;\n\n    var doc = def.doc || {};\n    var call = def.call;\n    var functions = Seq(def.module).filter(function(t)  {return !t.interface && !t.module;});\n    var types = Seq(def.module).filter(function(t)  {return t.interface || t.module;});\n    var interfaceDef = def.interface;\n    var typePropMap = getTypePropMap(interfaceDef);\n\n    return (\n      React.createElement(\"div\", null, \n        React.createElement(\"h1\", {className: \"typeHeader\"}, name), \n        doc.synopsis && (\n          React.createElement(MarkDown, {className: \"synopsis\", contents: doc.synopsis})\n        ), \n        interfaceDef && (\n          React.createElement(\"code\", {className: \"codeBlock memberSignature\"}, \n            React.createElement(InterfaceDef, {name: name, def: interfaceDef})\n          )\n        ), \n\n        doc.notes &&\n          doc.notes.map(function(note, i)  \n            {return React.createElement(\"section\", {key: i}, \n              React.createElement(\"h4\", {className: \"infoHeader\"}, note.name), \n              note.name === 'alias' ? (\n                React.createElement(CallSigDef, {name: note.body})\n              ) : (\n                note.body\n              )\n            );}\n          ), \n\n        doc.description && (\n          React.createElement(\"section\", null, \n            React.createElement(\"h4\", {className: \"infoHeader\"}, \n              doc.description.substr(0, 5) === '<code'\n                ? 'Example'\n                : 'Discussion'\n            ), \n            React.createElement(MarkDown, {className: \"discussion\", contents: doc.description})\n          )\n        ), \n\n        types.count() > 0 && (\n          React.createElement(\"section\", null, \n            React.createElement(\"h4\", {className: \"groupTitle\"}, \"Sub-types\"), \n            types\n              .map(function(t, typeName)  \n                {return React.createElement(\"div\", {key: typeName}, \n                  React.createElement(Router.Link, {\n                    to: '/' + (name ? name + '.' + typeName : typeName)\n                  }, \n                    name ? name + '.' + typeName : typeName\n                  )\n                );}\n              )\n              .valueSeq()\n              .toArray()\n          )\n        ), \n\n        call && (\n          React.createElement(\"section\", null, \n            React.createElement(\"h4\", {className: \"groupTitle\"}, \"Construction\"), \n            React.createElement(MemberDoc, {\n              showDetail: name === memberName, \n              parentName: name, \n              member: {\n                memberName: name,\n                memberDef: call,\n              }}\n            )\n          )\n        ), \n\n        functions.count() > 0 && (\n          React.createElement(\"section\", null, \n            React.createElement(\"h4\", {className: \"groupTitle\"}, \"Static methods\"), \n            functions\n              .map(function(t, fnName)  \n                {return React.createElement(MemberDoc, {\n                  key: fnName, \n                  showDetail: fnName === memberName, \n                  parentName: name, \n                  member: {\n                    memberName: fnName,\n                    memberDef: t.call,\n                    isStatic: true,\n                  }}\n                );}\n              )\n              .valueSeq()\n              .toArray()\n          )\n        ), \n\n        React.createElement(\"section\", null, \n          Seq(memberGroups)\n            .map(function(members, title) \n              {return members.length === 0\n                ? null\n                : Seq([\n                    React.createElement(\"h4\", {key: title || 'Members', className: \"groupTitle\"}, \n                      title || 'Members'\n                    ),\n                    Seq(members).map(function(member)  \n                      {return React.createElement(MemberDoc, {\n                        typePropMap: typePropMap, \n                        key: member.memberName, \n                        showDetail: member.memberName === memberName, \n                        parentName: name, \n                        member: member}\n                      );}\n                    ),\n                  ]);}\n            )\n            .flatten()\n            .valueSeq()\n            .toArray()\n        ), \n\n        React.createElement(Disclaimer, null)\n      )\n    );\n  },\n});\n\n/**\n * Get a map from super type parameter to concrete type definition. This is\n * used when rendering inherited type definitions to ensure contextually\n * relevant information.\n *\n * Example:\n *\n *   type A<T> implements B<number, T>\n *   type B<K, V> implements C<K, V, V>\n *   type C<X, Y, Z>\n *\n * parse C:\n *   {}\n *\n * parse B:\n *   { C<X: K\n *     C<Y: V\n *     C<Z: V }\n *\n * parse A:\n *   { B<K: number\n *     B<V: T\n *     C<X: number\n *     C<Y: T\n *     C<Z: T }\n */\nfunction getTypePropMap(def) {\n  var map = {};\n  def &&\n    def.extends &&\n    def.extends.forEach(function(e)  {\n      var superModule = defs.Immutable;\n      e.name.split('.').forEach(function(part)  {\n        superModule =\n          superModule && superModule.module && superModule.module[part];\n      });\n      var superInterface = superModule && superModule.interface;\n      if (superInterface) {\n        var interfaceMap = Seq(superInterface.typeParams)\n          .toKeyedSeq()\n          .flip()\n          .map(function(i)  {return e.args[i];})\n          .toObject();\n        Seq(interfaceMap).forEach(function(v, k)  {\n          map[e.name + '<' + k] = v;\n        });\n        var superMap = getTypePropMap(superInterface);\n        Seq(superMap).forEach(function(v, k)  {\n          map[k] = v.k === TypeKind.Param ? interfaceMap[v.param] : v;\n        });\n      }\n    });\n  return map;\n}\n\nmodule.exports = TypeDocumentation;\n","var React = require('react');\nvar assign = require('react/lib/Object.assign');\nvar Router = require('react-router');\nvar DocHeader = require('./DocHeader');\nvar DocSearch = require('./DocSearch.js');\nvar TypeDocumentation = require('./TypeDocumentation');\nvar defs = require('../../../lib/getTypeDefs');\n\nvar $__0=      Router,Route=$__0.Route,DefaultRoute=$__0.DefaultRoute,RouteHandler=$__0.RouteHandler;\n\nrequire('../../../lib/runkit-embed');\n\nvar Documentation = React.createClass({displayName: \"Documentation\",\n  render:function() {\n    return (\n      React.createElement(\"div\", null, \n        React.createElement(DocHeader, null), \n        React.createElement(\"div\", {className: \"pageBody\", id: \"body\"}, \n          React.createElement(\"div\", {className: \"contents\"}, \n            React.createElement(DocSearch, null), \n            React.createElement(RouteHandler, null)\n          )\n        )\n      )\n    );\n  },\n});\n\nvar DocDeterminer = React.createClass({displayName: \"DocDeterminer\",\n  mixins: [Router.State],\n\n  render:function() {\n    var $__0=      determineDoc(this.getPath()),def=$__0.def,name=$__0.name,memberName=$__0.memberName;\n    return React.createElement(TypeDocumentation, {def: def, name: name, memberName: memberName});\n  },\n});\n\nfunction determineDoc(path) {\n  var $__0=    path.split('/'),name=$__0[1],memberName=$__0[2];\n\n  var namePath = name ? name.split('.') : [];\n  var def = namePath.reduce(\n    function(def, subName)  {return def && def.module && def.module[subName];},\n    defs.Immutable\n  );\n\n  return { def:def, name:name, memberName:memberName };\n}\n\nmodule.exports = React.createClass({displayName: \"exports\",\n  childContextTypes: {\n    getPageData: React.PropTypes.func.isRequired,\n  },\n\n  getChildContext:function() {\n    return {\n      getPageData: this.getPageData,\n    };\n  },\n\n  getPageData:function() {\n    return this.pageData;\n  },\n\n  componentWillMount:function() {\n    var location;\n    var scrollBehavior;\n\n    if (window.document) {\n      location = Router.HashLocation;\n      location.addChangeListener(function(change)  {\n        this.pageData = assign({}, change, determineDoc(change.path));\n      }.bind(this));\n\n      this.pageData = !window.document\n        ? {}\n        : assign(\n            {\n              path: location.getCurrentPath(),\n              type: 'init',\n            },\n            determineDoc(location.getCurrentPath())\n          );\n\n      scrollBehavior = {\n        updateScrollPosition: function(position, actionType)  {\n          switch (actionType) {\n            case 'push':\n              return this.getPageData().memberName\n                ? null\n                : window.scrollTo(0, 0);\n            case 'pop':\n              return window.scrollTo(\n                position ? position.x : 0,\n                position ? position.y : 0\n              );\n          }\n        }.bind(this),\n      };\n    }\n\n    Router.create({\n      routes: (\n        React.createElement(Route, {handler: Documentation, path: \"/\"}, \n          React.createElement(DefaultRoute, {handler: DocDeterminer}), \n          React.createElement(Route, {name: \"type\", path: \"/:name\", handler: DocDeterminer}), \n          React.createElement(Route, {\n            name: \"method\", \n            path: \"/:name/:memberName\", \n            handler: DocDeterminer}\n          )\n        )\n      ),\n      location: location,\n      scrollBehavior: scrollBehavior,\n    }).run(function(Handler)  {\n      this.setState({ handler: Handler });\n      if (window.document) {\n        window.document.title = (this.pageData.name + \" — Immutable.js\");\n      }\n    }.bind(this));\n  },\n\n  // TODO: replace this. this is hacky and probably wrong\n\n  componentDidMount:function() {\n    setTimeout(function()  {\n      this.pageData.type = '';\n    }.bind(this), 0);\n  },\n\n  componentDidUpdate:function() {\n    setTimeout(function()  {\n      this.pageData.type = '';\n    }.bind(this), 0);\n  },\n\n  render:function() {\n    var Handler = this.state.handler;\n    return React.createElement(Handler, null);\n  },\n});\n","var isMobile =\n  window.matchMedia && window.matchMedia('(max-device-width: 680px)');\nmodule.exports = false && !!(isMobile && isMobile.matches);\n","var React = require('react');\n\nvar Logo = React.createClass({displayName: \"Logo\",\n  shouldComponentUpdate: function (nextProps) {\n    return nextProps.opacity !== this.props.opacity;\n  },\n\n  render: function () {\n    var opacity = this.props.opacity;\n    if (opacity === undefined) {\n      opacity = 1;\n    }\n    return !this.props.inline ? (\n      React.createElement(\"g\", {fill: this.props.color, style: { opacity: this.props.opacity}}, \n        React.createElement(\"path\", {d: \"M0,0l13.9,0v41.1H0L0,0z\"}), \n        React.createElement(\"path\", {d: \"M18.2,0L29,0l10.7,15.8L50.4,0l10.9,0v41.1H48.1V26.3l-8.4,12.3l-8.4-12.3v14.8H18.2V0z\"}), \n        React.createElement(\"path\", {d: \"M65.5,0l10.9,0L87,15.8L97.7,0l10.9,0v41.1H95.4V26.3L87,38.7l-8.4-12.3v14.8H65.5V0z\"}), \n        React.createElement(\"path\", {\n          d: \"M128.6,42.2c-2.6,0-4.9-0.3-7-1c-2.1-0.7-3.9-1.6-5.4-3c-1.5-1.3-2.6-3-3.4-5c-0.8-2-1.2-4.4-1.2-7.1V0\" + ' ' +\n          \"l13.1,0v25.6c0,1.4,0.3,2.5,0.9,3.3c0.6,0.8,1.6,1.1,3,1.1c1.4,0,2.4-0.4,3-1.1c0.6-0.8,0.9-1.9,0.9-3.3V0l13.2,0v26.1\" + ' ' +\n          \"c0,2.7-0.4,5.1-1.2,7.1c-0.8,2-2,3.7-3.5,5c-1.5,1.3-3.3,2.3-5.4,3C133.5,41.8,131.2,42.2,128.6,42.2z\"}\n        ), \n        React.createElement(\"path\", {d: \"M155.4,10.8h-7.6V0l28.7,0v10.8h-7.6v30.3h-13.6V10.8z\"}), \n        React.createElement(\"path\", {\n          d: \"M186.4,0l9.9,0l15.6,41.1h-12.9l-1.4-3.7h-12.5l-1.4,3.7h-12.9L186.4,0z M194.1,28.4l-2.8-7.2l-2.8,7.2\" + ' ' +\n          \"H194.1z\"}\n        ), \n        React.createElement(\"path\", {\n          d: \"M212.9,0L229,0c2.1,0,3.9,0.2,5.6,0.7c1.7,0.5,3.2,1.2,4.4,2.1s2.2,2.1,2.8,3.5c0.7,1.4,1,3,1,4.8\" + ' ' +\n          \"c0,1.3-0.2,2.4-0.5,3.4c-0.3,0.9-0.7,1.7-1,2.3c-0.5,0.7-1,1.4-1.5,1.8c0.9,0.6,1.7,1.3,2.5,2.2c0.6,0.8,1.2,1.8,1.7,3\" + ' ' +\n          \"c0.5,1.2,0.8,2.7,0.8,4.4c0,2-0.3,3.8-1,5.4c-0.7,1.6-1.7,3-3,4.1c-1.3,1.1-2.9,2-4.7,2.6c-1.9,0.6-4,0.9-6.3,0.9h-16.8V0z\" + ' ' +\n           \"M230.2,12.5c0-1.9-1-2.8-3.1-2.8h-1.5v5.7h1.5C229.2,15.4,230.2,14.4,230.2,12.5z M227.1,31.4c3.1,0,4.7-1.2,4.7-3.6\" + ' ' +\n          \"c0-2.4-1.6-3.6-4.7-3.6h-1.5v7.2H227.1z\"}\n        ), \n        React.createElement(\"path\", {d: \"M248.3,0L262,0v30.3h11.3v10.8h-25V0z\"}), \n        React.createElement(\"path\", {d: \"M275.3,0l24.2,0v10.8h-11.1v4.6h10.9v10.2h-10.9v4.7H300v10.8h-24.7V0z\"})\n      )\n    ) : (\n      React.createElement(\"g\", {fill: this.props.color, style: { opacity: this.props.opacity}}, \n        React.createElement(\"path\", {d: \"M0,0l13.9,0v41.1H0L0,0z M7.8,36.2V4.9H6.2v31.3H7.8z\"}), \n        React.createElement(\"path\", {\n          d: \"M18.2,0L29,0l10.7,15.8L50.4,0l10.9,0v41.1H48.1V26.3l-8.4,12.3l-8.4-12.3v14.8H18.2V0z M25.9,36.2V7.9\" + ' ' +\n          \"L39.7,28L53.5,7.9v28.3h1.6V4.9h-1.6L39.7,25.2L25.9,4.9h-1.6v31.3H25.9z\"}\n        ), \n        React.createElement(\"path\", {\n          d: \"M65.5,0l10.9,0L87,15.8L97.7,0l10.9,0v41.1H95.4V26.3L87,38.7l-8.4-12.3v14.8H65.5V0z M73.2,36.2V7.9\" + ' ' +\n          \"L87,28l13.7-20.1v28.3h1.6V4.9h-1.6L87,25.2L73.2,4.9h-1.6v31.3H73.2z\"}\n        ), \n        React.createElement(\"path\", {\n          d: \"M128.6,42.2c-2.6,0-4.9-0.3-7-1c-2.1-0.7-3.9-1.6-5.4-3c-1.5-1.3-2.6-3-3.4-5c-0.8-2-1.2-4.4-1.2-7.1V0\" + ' ' +\n          \"l13.1,0v25.6c0,1.4,0.3,2.5,0.9,3.3c0.6,0.8,1.6,1.1,3,1.1c1.4,0,2.4-0.4,3-1.1c0.6-0.8,0.9-1.9,0.9-3.3V0l13.2,0v26.1\" + ' ' +\n          \"c0,2.7-0.4,5.1-1.2,7.1c-0.8,2-2,3.7-3.5,5c-1.5,1.3-3.3,2.3-5.4,3C133.5,41.8,131.2,42.2,128.6,42.2z M128.6,34.8\" + ' ' +\n          \"c-6.2,0-9.2-3-9.2-9.1V4.9h-1.6v20.8c0,3.5,0.9,6.1,2.8,7.9c1.9,1.8,4.6,2.7,8,2.7c3.5,0,6.2-0.9,8.1-2.7c1.9-1.8,2.8-4.5,2.8-7.9\" + ' ' +\n          \"V4.9h-1.7v20.8C137.8,31.7,134.8,34.8,128.6,34.8z\"}\n        ), \n        React.createElement(\"path\", {d: \"M155.4,10.8h-7.6V0l28.7,0v10.8h-7.6v30.3h-13.6V10.8z M163,36.2V6.4h8.8V4.9h-19.2v1.5h8.8v29.8H163z\"}), \n        React.createElement(\"path\", {\n          d: \"M186.4,0l9.9,0l15.6,41.1h-12.9l-1.4-3.7h-12.5l-1.4,3.7h-12.9L186.4,0z M180,36.2l1.2-3.1h20.3l1.2,3.1\" + ' ' +\n          \"h1.7L192.5,4.9h-2.3l-11.9,31.3H180z M191.3,6.4l9.6,25.2h-19.2L191.3,6.4z M194.1,28.4l-2.8-7.2l-2.8,7.2H194.1z\"}\n        ), \n        React.createElement(\"path\", {\n          d: \"M212.9,0L229,0c2.1,0,3.9,0.2,5.6,0.7c1.7,0.5,3.2,1.2,4.4,2.1s2.2,2.1,2.8,3.5c0.7,1.4,1,3,1,4.8\" + ' ' +\n          \"c0,1.3-0.2,2.4-0.5,3.4c-0.3,0.9-0.7,1.7-1,2.3c-0.5,0.7-1,1.4-1.5,1.8c0.9,0.6,1.7,1.3,2.5,2.2c0.6,0.8,1.2,1.8,1.7,3\" + ' ' +\n          \"c0.5,1.2,0.8,2.7,0.8,4.4c0,2-0.3,3.8-1,5.4c-0.7,1.6-1.7,3-3,4.1c-1.3,1.1-2.9,2-4.7,2.6c-1.9,0.6-4,0.9-6.3,0.9h-16.8V0z\" + ' ' +\n           \"M228,36.2c3.6,0,6.3-0.8,8-2.3c1.7-1.6,2.6-3.6,2.6-6.2c0-1.7-0.4-3-1.1-4c-0.7-1-1.5-1.8-2.3-2.4c-1-0.7-2.2-1.1-3.4-1.4\" + ' ' +\n          \"c1-0.3,1.9-0.7,2.7-1.4c0.7-0.5,1.3-1.3,1.9-2.2s0.8-2.1,0.8-3.5c0-2.6-0.8-4.5-2.5-5.9c-1.6-1.3-3.9-2-6.7-2h-8.9v31.3H228z\" + ' ' +\n           \"M220.7,19.1V6.4l7.3,0c2.7,0,4.6,0.6,5.8,1.8c1.2,1.2,1.8,2.7,1.8,4.6c0,1.9-0.6,3.4-1.8,4.6c-1.2,1.2-3.1,1.8-5.8,1.8H220.7z\" + ' ' +\n           \"M220.7,34.7V20.6h7.2c1.3,0,2.5,0.1,3.5,0.4c1.1,0.3,2,0.7,2.9,1.2c0.8,0.6,1.5,1.3,1.9,2.2c0.5,0.9,0.7,2,0.7,3.2\" + ' ' +\n          \"c0,2.5-0.8,4.3-2.5,5.4c-1.7,1.1-3.9,1.7-6.6,1.7H220.7z M230.2,12.5c0-1.9-1-2.8-3.1-2.8h-1.5v5.7h1.5\" + ' ' +\n          \"C229.2,15.4,230.2,14.4,230.2,12.5z M227.1,31.4c3.1,0,4.7-1.2,4.7-3.6c0-2.4-1.6-3.6-4.7-3.6h-1.5v7.2H227.1z\"}\n        ), \n        React.createElement(\"path\", {d: \"M248.3,0L262,0v30.3h11.3v10.8h-25V0z M269.9,36.2v-1.5h-13.8V4.9h-1.6v31.3H269.9z\"}), \n        React.createElement(\"path\", {\n          d: \"M275.3,0l24.2,0v10.8h-11.1v4.6h10.9v10.2h-10.9v4.7H300v10.8h-24.7V0z M295.4,36.2v-1.5h-12.3V21.2h11.7\" + ' ' +\n          \"v-1.5h-11.7V6.4h12.3V4.9h-13.9v31.3H295.4z\"}\n        )\n      )\n    );\n  },\n});\n\nmodule.exports = Logo;\n","var React = require('react');\n\nvar SVGSet = React.createClass({displayName: \"SVGSet\",\n  render: function () {\n    return (\n      React.createElement(\"svg\", {className: \"svg\", style: this.props.style, viewBox: \"0 0 300 42.2\"}, \n        this.props.children\n      )\n    );\n  },\n});\n\nmodule.exports = SVGSet;\n","module.exports = global.Immutable;\n","module.exports = global.React;\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi8uLi8uLi9kaXN0L2ltbXV0YWJsZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2FjdGlvbnMvTG9jYXRpb25BY3Rpb25zLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2JlaGF2aW9ycy9JbWl0YXRlQnJvd3NlckJlaGF2aW9yLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2JlaGF2aW9ycy9TY3JvbGxUb1RvcEJlaGF2aW9yLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2NvbXBvbmVudHMvRGVmYXVsdFJvdXRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2NvbXBvbmVudHMvTGluay5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy9jb21wb25lbnRzL05vdEZvdW5kUm91dGUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvY29tcG9uZW50cy9SZWRpcmVjdC5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy9jb21wb25lbnRzL1JvdXRlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2NvbXBvbmVudHMvUm91dGVIYW5kbGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL2xvY2F0aW9ucy9IYXNoTG9jYXRpb24uanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvbG9jYXRpb25zL0hpc3RvcnlMb2NhdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy9sb2NhdGlvbnMvUmVmcmVzaExvY2F0aW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL21peGlucy9GYWtlTm9kZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy9taXhpbnMvTmF2aWdhdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy9taXhpbnMvTmF2aWdhdGlvbkNvbnRleHQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvbWl4aW5zL1JvdXRlSGFuZGxlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy9taXhpbnMvU2Nyb2xsaW5nLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL21peGlucy9TdGF0ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy9taXhpbnMvU3RhdGVDb250ZXh0LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL3V0aWxzL0NhbmNlbGxhdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy91dGlscy9IaXN0b3J5LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL3V0aWxzL1BhdGguanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvdXRpbHMvUHJvbWlzZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy91dGlscy9Qcm9wVHlwZXMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvdXRpbHMvUmVkaXJlY3QuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvdXRpbHMvVHJhbnNpdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbW9kdWxlcy91dGlscy9jcmVhdGVSb3V0ZXIuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvdXRpbHMvY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL3V0aWxzL2dldFdpbmRvd1Njcm9sbFBvc2l0aW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL3V0aWxzL3JldmVyc2VkQXJyYXkuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL21vZHVsZXMvdXRpbHMvcnVuUm91dGVyLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9tb2R1bGVzL3V0aWxzL3N1cHBvcnRzSGlzdG9yeS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL3FzL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvcXMvbGliL2luZGV4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvcXMvbGliL3BhcnNlLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvcXMvbGliL3N0cmluZ2lmeS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL3FzL2xpYi91dGlscy5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL3doZW4vbGliL1Byb21pc2UuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy93aGVuL2xpYi9RdWV1ZS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL3doZW4vbGliL1NjaGVkdWxlci5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvbm9kZV9tb2R1bGVzL3doZW4vbGliL2FzeW5jLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9ub2RlX21vZHVsZXMvd2hlbi9saWIvbWFrZVByb21pc2UuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL0NTU0NvcmUuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9PYmplY3QuYXNzaWduLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFRyYW5zaXRpb25FdmVudHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2N4LmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9pbnZhcmlhbnQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL3dhcm5pbmcuanMiLCIuLi8uLi8uLi9wYWNrYWdlLmpzb24iLCIuLi8uLi9nZW5lcmF0ZWQvaW1tdXRhYmxlLmQuanNvbiIsIi4uLy4uL2xpYi9UeXBlS2luZC5qcyIsIi4uLy4uL2xpYi9jb2xsZWN0TWVtYmVyR3JvdXBzLmpzIiwiLi4vLi4vbGliL2dldFR5cGVEZWZzLmpzIiwiLi4vLi4vbGliL21hcmtkb3duLmpzIiwiLi4vLi4vbGliL21hcmtkb3duRG9jcy5qcyIsIi4uLy4uL2xpYi9wcmlzbS5qcyIsIi4uLy4uL2xpYi9ydW5raXQtZW1iZWQuanMiLCJzcmMvRGVmcy5qcyIsInNyYy9Eb2NIZWFkZXIuanMiLCJzcmMvRG9jT3ZlcnZpZXcuanMiLCJzcmMvRG9jU2VhcmNoLmpzIiwic3JjL01hcmtEb3duLmpzIiwic3JjL01lbWJlckRvYy5qcyIsInNyYy9QYWdlRGF0YU1peGluLmpzIiwic3JjL1NpZGVCYXIuanMiLCJzcmMvVHlwZURvY3VtZW50YXRpb24uanMiLCJzcmMvaW5kZXguanMiLCJzcmMvaXNNb2JpbGUuanMiLCIuLi9zcmMvTG9nby5qcyIsIi4uL3NyYy9TVkdTZXQuanMiLCIuLi8uLi8uLi9yZXNvdXJjZXMvaW1tdXRhYmxlLWdsb2JhbC5qcyIsIi4uLy4uLy4uL3Jlc291cmNlcy9yZWFjdC1nbG9iYWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL3RMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDanZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1eEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9yQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2JBO0FBQ0E7Ozs7O0FDREE7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8qKlxuICogTUlUIExpY2Vuc2VcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIExlZSBCeXJvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuSW1tdXRhYmxlID0ge30pKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgREVMRVRFID0gJ2RlbGV0ZSc7XG5cbiAgLy8gQ29uc3RhbnRzIGRlc2NyaWJpbmcgdGhlIHNpemUgb2YgdHJpZSBub2Rlcy5cbiAgdmFyIFNISUZUID0gNTsgLy8gUmVzdWx0ZWQgaW4gYmVzdCBwZXJmb3JtYW5jZSBhZnRlciBfX19fX18/XG4gIHZhciBTSVpFID0gMSA8PCBTSElGVDtcbiAgdmFyIE1BU0sgPSBTSVpFIC0gMTtcblxuICAvLyBBIGNvbnNpc3RlbnQgc2hhcmVkIHZhbHVlIHJlcHJlc2VudGluZyBcIm5vdCBzZXRcIiB3aGljaCBlcXVhbHMgbm90aGluZyBvdGhlclxuICAvLyB0aGFuIGl0c2VsZiwgYW5kIG5vdGhpbmcgdGhhdCBjb3VsZCBiZSBwcm92aWRlZCBleHRlcm5hbGx5LlxuICB2YXIgTk9UX1NFVCA9IHt9O1xuXG4gIC8vIEJvb2xlYW4gcmVmZXJlbmNlcywgUm91Z2ggZXF1aXZhbGVudCBvZiBgYm9vbCAmYC5cbiAgZnVuY3Rpb24gTWFrZVJlZigpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogZmFsc2UgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFNldFJlZihyZWYpIHtcbiAgICBpZiAocmVmKSB7XG4gICAgICByZWYudmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIEEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIHZhbHVlIHJlcHJlc2VudGluZyBhbiBcIm93bmVyXCIgZm9yIHRyYW5zaWVudCB3cml0ZXNcbiAgLy8gdG8gdHJpZXMuIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBvbmx5IGV2ZXIgZXF1YWwgaXRzZWxmLCBhbmQgd2lsbCBub3QgZXF1YWxcbiAgLy8gdGhlIHJldHVybiBvZiBhbnkgc3Vic2VxdWVudCBjYWxsIG9mIHRoaXMgZnVuY3Rpb24uXG4gIGZ1bmN0aW9uIE93bmVySUQoKSB7fVxuXG4gIGZ1bmN0aW9uIGVuc3VyZVNpemUoaXRlcikge1xuICAgIGlmIChpdGVyLnNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaXRlci5zaXplID0gaXRlci5fX2l0ZXJhdGUocmV0dXJuVHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBpdGVyLnNpemU7XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwSW5kZXgoaXRlciwgaW5kZXgpIHtcbiAgICAvLyBUaGlzIGltcGxlbWVudHMgXCJpcyBhcnJheSBpbmRleFwiIHdoaWNoIHRoZSBFQ01BU3RyaW5nIHNwZWMgZGVmaW5lcyBhczpcbiAgICAvL1xuICAgIC8vICAgICBBIFN0cmluZyBwcm9wZXJ0eSBuYW1lIFAgaXMgYW4gYXJyYXkgaW5kZXggaWYgYW5kIG9ubHkgaWZcbiAgICAvLyAgICAgVG9TdHJpbmcoVG9VaW50MzIoUCkpIGlzIGVxdWFsIHRvIFAgYW5kIFRvVWludDMyKFApIGlzIG5vdCBlcXVhbFxuICAgIC8vICAgICB0byAyXjMy4oiSMS5cbiAgICAvL1xuICAgIC8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1hcnJheS1leG90aWMtb2JqZWN0c1xuICAgIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgdWludDMySW5kZXggPSBpbmRleCA+Pj4gMDsgLy8gTiA+Pj4gMCBpcyBzaG9ydGhhbmQgZm9yIFRvVWludDMyXG4gICAgICBpZiAoJycgKyB1aW50MzJJbmRleCAhPT0gaW5kZXggfHwgdWludDMySW5kZXggPT09IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgIH1cbiAgICAgIGluZGV4ID0gdWludDMySW5kZXg7XG4gICAgfVxuICAgIHJldHVybiBpbmRleCA8IDAgPyBlbnN1cmVTaXplKGl0ZXIpICsgaW5kZXggOiBpbmRleDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiB3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIHNpemUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgKChiZWdpbiA9PT0gMCAmJiAhaXNOZWcoYmVnaW4pKSB8fFxuICAgICAgICAoc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGJlZ2luIDw9IC1zaXplKSkgJiZcbiAgICAgIChlbmQgPT09IHVuZGVmaW5lZCB8fCAoc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGVuZCA+PSBzaXplKSlcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUJlZ2luKGJlZ2luLCBzaXplKSB7XG4gICAgcmV0dXJuIHJlc29sdmVJbmRleChiZWdpbiwgc2l6ZSwgMCk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlRW5kKGVuZCwgc2l6ZSkge1xuICAgIHJldHVybiByZXNvbHZlSW5kZXgoZW5kLCBzaXplLCBzaXplKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVJbmRleChpbmRleCwgc2l6ZSwgZGVmYXVsdEluZGV4KSB7XG4gICAgLy8gU2FuaXRpemUgaW5kaWNlcyB1c2luZyB0aGlzIHNob3J0aGFuZCBmb3IgVG9JbnQzMihhcmd1bWVudClcbiAgICAvLyBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9pbnQzMlxuICAgIHJldHVybiBpbmRleCA9PT0gdW5kZWZpbmVkXG4gICAgICA/IGRlZmF1bHRJbmRleFxuICAgICAgOiBpc05lZyhpbmRleClcbiAgICAgID8gc2l6ZSA9PT0gSW5maW5pdHlcbiAgICAgICAgPyBzaXplXG4gICAgICAgIDogTWF0aC5tYXgoMCwgc2l6ZSArIGluZGV4KSB8IDBcbiAgICAgIDogc2l6ZSA9PT0gdW5kZWZpbmVkIHx8IHNpemUgPT09IGluZGV4XG4gICAgICA/IGluZGV4XG4gICAgICA6IE1hdGgubWluKHNpemUsIGluZGV4KSB8IDA7XG4gIH1cblxuICBmdW5jdGlvbiBpc05lZyh2YWx1ZSkge1xuICAgIC8vIEFjY291bnQgZm9yIC0wIHdoaWNoIGlzIG5lZ2F0aXZlLCBidXQgbm90IGxlc3MgdGhhbiAwLlxuICAgIHJldHVybiB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA9PT0gLUluZmluaXR5KTtcbiAgfVxuXG4gIHZhciBJU19DT0xMRUNUSU9OX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX0lURVJBQkxFX19AQCc7XG5cbiAgZnVuY3Rpb24gaXNDb2xsZWN0aW9uKG1heWJlQ29sbGVjdGlvbikge1xuICAgIHJldHVybiBCb29sZWFuKG1heWJlQ29sbGVjdGlvbiAmJiBtYXliZUNvbGxlY3Rpb25bSVNfQ09MTEVDVElPTl9TWU1CT0xdKTtcbiAgfVxuXG4gIHZhciBJU19LRVlFRF9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9LRVlFRF9fQEAnO1xuXG4gIGZ1bmN0aW9uIGlzS2V5ZWQobWF5YmVLZXllZCkge1xuICAgIHJldHVybiBCb29sZWFuKG1heWJlS2V5ZWQgJiYgbWF5YmVLZXllZFtJU19LRVlFRF9TWU1CT0xdKTtcbiAgfVxuXG4gIHZhciBJU19JTkRFWEVEX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX0lOREVYRURfX0BAJztcblxuICBmdW5jdGlvbiBpc0luZGV4ZWQobWF5YmVJbmRleGVkKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4obWF5YmVJbmRleGVkICYmIG1heWJlSW5kZXhlZFtJU19JTkRFWEVEX1NZTUJPTF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNBc3NvY2lhdGl2ZShtYXliZUFzc29jaWF0aXZlKSB7XG4gICAgcmV0dXJuIGlzS2V5ZWQobWF5YmVBc3NvY2lhdGl2ZSkgfHwgaXNJbmRleGVkKG1heWJlQXNzb2NpYXRpdmUpO1xuICB9XG5cbiAgdmFyIENvbGxlY3Rpb24gPSBmdW5jdGlvbiBDb2xsZWN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQ29sbGVjdGlvbih2YWx1ZSkgPyB2YWx1ZSA6IFNlcSh2YWx1ZSk7XG4gIH07XG5cbiAgdmFyIEtleWVkQ29sbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKENvbGxlY3Rpb24pIHtcbiAgICBmdW5jdGlvbiBLZXllZENvbGxlY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0tleWVkKHZhbHVlKSA/IHZhbHVlIDogS2V5ZWRTZXEodmFsdWUpO1xuICAgIH1cblxuICAgIGlmICggQ29sbGVjdGlvbiApIEtleWVkQ29sbGVjdGlvbi5fX3Byb3RvX18gPSBDb2xsZWN0aW9uO1xuICAgIEtleWVkQ29sbGVjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlICk7XG4gICAgS2V5ZWRDb2xsZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEtleWVkQ29sbGVjdGlvbjtcblxuICAgIHJldHVybiBLZXllZENvbGxlY3Rpb247XG4gIH0oQ29sbGVjdGlvbikpO1xuXG4gIHZhciBJbmRleGVkQ29sbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKENvbGxlY3Rpb24pIHtcbiAgICBmdW5jdGlvbiBJbmRleGVkQ29sbGVjdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzSW5kZXhlZCh2YWx1ZSkgPyB2YWx1ZSA6IEluZGV4ZWRTZXEodmFsdWUpO1xuICAgIH1cblxuICAgIGlmICggQ29sbGVjdGlvbiApIEluZGV4ZWRDb2xsZWN0aW9uLl9fcHJvdG9fXyA9IENvbGxlY3Rpb247XG4gICAgSW5kZXhlZENvbGxlY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZSApO1xuICAgIEluZGV4ZWRDb2xsZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEluZGV4ZWRDb2xsZWN0aW9uO1xuXG4gICAgcmV0dXJuIEluZGV4ZWRDb2xsZWN0aW9uO1xuICB9KENvbGxlY3Rpb24pKTtcblxuICB2YXIgU2V0Q29sbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKENvbGxlY3Rpb24pIHtcbiAgICBmdW5jdGlvbiBTZXRDb2xsZWN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNDb2xsZWN0aW9uKHZhbHVlKSAmJiAhaXNBc3NvY2lhdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IFNldFNlcSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKCBDb2xsZWN0aW9uICkgU2V0Q29sbGVjdGlvbi5fX3Byb3RvX18gPSBDb2xsZWN0aW9uO1xuICAgIFNldENvbGxlY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZSApO1xuICAgIFNldENvbGxlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2V0Q29sbGVjdGlvbjtcblxuICAgIHJldHVybiBTZXRDb2xsZWN0aW9uO1xuICB9KENvbGxlY3Rpb24pKTtcblxuICBDb2xsZWN0aW9uLktleWVkID0gS2V5ZWRDb2xsZWN0aW9uO1xuICBDb2xsZWN0aW9uLkluZGV4ZWQgPSBJbmRleGVkQ29sbGVjdGlvbjtcbiAgQ29sbGVjdGlvbi5TZXQgPSBTZXRDb2xsZWN0aW9uO1xuXG4gIHZhciBJU19TRVFfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfU0VRX19AQCc7XG5cbiAgZnVuY3Rpb24gaXNTZXEobWF5YmVTZXEpIHtcbiAgICByZXR1cm4gQm9vbGVhbihtYXliZVNlcSAmJiBtYXliZVNlcVtJU19TRVFfU1lNQk9MXSk7XG4gIH1cblxuICB2YXIgSVNfUkVDT1JEX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX1JFQ09SRF9fQEAnO1xuXG4gIGZ1bmN0aW9uIGlzUmVjb3JkKG1heWJlUmVjb3JkKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4obWF5YmVSZWNvcmQgJiYgbWF5YmVSZWNvcmRbSVNfUkVDT1JEX1NZTUJPTF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNJbW11dGFibGUobWF5YmVJbW11dGFibGUpIHtcbiAgICByZXR1cm4gaXNDb2xsZWN0aW9uKG1heWJlSW1tdXRhYmxlKSB8fCBpc1JlY29yZChtYXliZUltbXV0YWJsZSk7XG4gIH1cblxuICB2YXIgSVNfT1JERVJFRF9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9PUkRFUkVEX19AQCc7XG5cbiAgZnVuY3Rpb24gaXNPcmRlcmVkKG1heWJlT3JkZXJlZCkge1xuICAgIHJldHVybiBCb29sZWFuKG1heWJlT3JkZXJlZCAmJiBtYXliZU9yZGVyZWRbSVNfT1JERVJFRF9TWU1CT0xdKTtcbiAgfVxuXG4gIHZhciBJVEVSQVRFX0tFWVMgPSAwO1xuICB2YXIgSVRFUkFURV9WQUxVRVMgPSAxO1xuICB2YXIgSVRFUkFURV9FTlRSSUVTID0gMjtcblxuICB2YXIgUkVBTF9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSBSRUFMX0lURVJBVE9SX1NZTUJPTCB8fCBGQVVYX0lURVJBVE9SX1NZTUJPTDtcblxuICB2YXIgSXRlcmF0b3IgPSBmdW5jdGlvbiBJdGVyYXRvcihuZXh0KSB7XG4gICAgdGhpcy5uZXh0ID0gbmV4dDtcbiAgfTtcblxuICBJdGVyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuICdbSXRlcmF0b3JdJztcbiAgfTtcblxuICBJdGVyYXRvci5LRVlTID0gSVRFUkFURV9LRVlTO1xuICBJdGVyYXRvci5WQUxVRVMgPSBJVEVSQVRFX1ZBTFVFUztcbiAgSXRlcmF0b3IuRU5UUklFUyA9IElURVJBVEVfRU5UUklFUztcblxuICBJdGVyYXRvci5wcm90b3R5cGUuaW5zcGVjdCA9IEl0ZXJhdG9yLnByb3RvdHlwZS50b1NvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuICBJdGVyYXRvci5wcm90b3R5cGVbSVRFUkFUT1JfU1lNQk9MXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBmdW5jdGlvbiBpdGVyYXRvclZhbHVlKHR5cGUsIGssIHYsIGl0ZXJhdG9yUmVzdWx0KSB7XG4gICAgdmFyIHZhbHVlID0gdHlwZSA9PT0gMCA/IGsgOiB0eXBlID09PSAxID8gdiA6IFtrLCB2XTtcbiAgICBpdGVyYXRvclJlc3VsdFxuICAgICAgPyAoaXRlcmF0b3JSZXN1bHQudmFsdWUgPSB2YWx1ZSlcbiAgICAgIDogKGl0ZXJhdG9yUmVzdWx0ID0ge1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yUmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gaXRlcmF0b3JEb25lKCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0l0ZXJhdG9yKG1heWJlSXRlcmFibGUpIHtcbiAgICByZXR1cm4gISFnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNJdGVyYXRvcihtYXliZUl0ZXJhdG9yKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3IgJiYgdHlwZW9mIG1heWJlSXRlcmF0b3IubmV4dCA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yKGl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGl0ZXJhYmxlKTtcbiAgICByZXR1cm4gaXRlcmF0b3JGbiAmJiBpdGVyYXRvckZuLmNhbGwoaXRlcmFibGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihpdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID1cbiAgICAgIGl0ZXJhYmxlICYmXG4gICAgICAoKFJFQUxfSVRFUkFUT1JfU1lNQk9MICYmIGl0ZXJhYmxlW1JFQUxfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICAgICAgaXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIHZhbHVlICYmXG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlLmxlbmd0aCkgJiZcbiAgICAgIHZhbHVlLmxlbmd0aCA+PSAwICYmXG4gICAgICAodmFsdWUubGVuZ3RoID09PSAwXG4gICAgICAgID8gLy8gT25seSB7bGVuZ3RoOiAwfSBpcyBjb25zaWRlcmVkIEFycmF5LWxpa2UuXG4gICAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMVxuICAgICAgICA6IC8vIEFuIG9iamVjdCBpcyBvbmx5IEFycmF5LWxpa2UgaWYgaXQgaGFzIGEgcHJvcGVydHkgd2hlcmUgdGhlIGxhc3QgdmFsdWVcbiAgICAgICAgICAvLyBpbiB0aGUgYXJyYXktbGlrZSBtYXkgYmUgZm91bmQgKHdoaWNoIGNvdWxkIGJlIHVuZGVmaW5lZCkuXG4gICAgICAgICAgdmFsdWUuaGFzT3duUHJvcGVydHkodmFsdWUubGVuZ3RoIC0gMSkpXG4gICAgKTtcbiAgfVxuXG4gIHZhciBTZXEgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDb2xsZWN0aW9uKSB7XG4gICAgZnVuY3Rpb24gU2VxKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGVtcHR5U2VxdWVuY2UoKVxuICAgICAgICA6IGlzSW1tdXRhYmxlKHZhbHVlKVxuICAgICAgICA/IHZhbHVlLnRvU2VxKClcbiAgICAgICAgOiBzZXFGcm9tVmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIGlmICggQ29sbGVjdGlvbiApIFNlcS5fX3Byb3RvX18gPSBDb2xsZWN0aW9uO1xuICAgIFNlcS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlICk7XG4gICAgU2VxLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNlcTtcblxuICAgIFNlcS5wcm90b3R5cGUudG9TZXEgPSBmdW5jdGlvbiB0b1NlcSAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgU2VxLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ1NlcSB7JywgJ30nKTtcbiAgICB9O1xuXG4gICAgU2VxLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9IGZ1bmN0aW9uIGNhY2hlUmVzdWx0ICgpIHtcbiAgICAgIGlmICghdGhpcy5fY2FjaGUgJiYgdGhpcy5fX2l0ZXJhdGVVbmNhY2hlZCkge1xuICAgICAgICB0aGlzLl9jYWNoZSA9IHRoaXMuZW50cnlTZXEoKS50b0FycmF5KCk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuX2NhY2hlLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvLyBhYnN0cmFjdCBfX2l0ZXJhdGVVbmNhY2hlZChmbiwgcmV2ZXJzZSlcblxuICAgIFNlcS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGNhY2hlID0gdGhpcy5fY2FjaGU7XG4gICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgdmFyIHNpemUgPSBjYWNoZS5sZW5ndGg7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgIT09IHNpemUpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBjYWNoZVtyZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrK107XG4gICAgICAgICAgaWYgKGZuKGVudHJ5WzFdLCBlbnRyeVswXSwgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdGVVbmNhY2hlZChmbiwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIC8vIGFic3RyYWN0IF9faXRlcmF0b3JVbmNhY2hlZCh0eXBlLCByZXZlcnNlKVxuXG4gICAgU2VxLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGNhY2hlID0gdGhpcy5fY2FjaGU7XG4gICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgdmFyIHNpemUgPSBjYWNoZS5sZW5ndGg7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGkgPT09IHNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVudHJ5ID0gY2FjaGVbcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKytdO1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX19pdGVyYXRvclVuY2FjaGVkKHR5cGUsIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2VxO1xuICB9KENvbGxlY3Rpb24pKTtcblxuICB2YXIgS2V5ZWRTZXEgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTZXEpIHtcbiAgICBmdW5jdGlvbiBLZXllZFNlcSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBlbXB0eVNlcXVlbmNlKCkudG9LZXllZFNlcSgpXG4gICAgICAgIDogaXNDb2xsZWN0aW9uKHZhbHVlKVxuICAgICAgICA/IGlzS2V5ZWQodmFsdWUpXG4gICAgICAgICAgPyB2YWx1ZS50b1NlcSgpXG4gICAgICAgICAgOiB2YWx1ZS5mcm9tRW50cnlTZXEoKVxuICAgICAgICA6IGlzUmVjb3JkKHZhbHVlKVxuICAgICAgICA/IHZhbHVlLnRvU2VxKClcbiAgICAgICAgOiBrZXllZFNlcUZyb21WYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKCBTZXEgKSBLZXllZFNlcS5fX3Byb3RvX18gPSBTZXE7XG4gICAgS2V5ZWRTZXEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2VxICYmIFNlcS5wcm90b3R5cGUgKTtcbiAgICBLZXllZFNlcS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBLZXllZFNlcTtcblxuICAgIEtleWVkU2VxLnByb3RvdHlwZS50b0tleWVkU2VxID0gZnVuY3Rpb24gdG9LZXllZFNlcSAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIEtleWVkU2VxO1xuICB9KFNlcSkpO1xuXG4gIHZhciBJbmRleGVkU2VxID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU2VxKSB7XG4gICAgZnVuY3Rpb24gSW5kZXhlZFNlcSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBlbXB0eVNlcXVlbmNlKClcbiAgICAgICAgOiBpc0NvbGxlY3Rpb24odmFsdWUpXG4gICAgICAgID8gaXNLZXllZCh2YWx1ZSlcbiAgICAgICAgICA/IHZhbHVlLmVudHJ5U2VxKClcbiAgICAgICAgICA6IHZhbHVlLnRvSW5kZXhlZFNlcSgpXG4gICAgICAgIDogaXNSZWNvcmQodmFsdWUpXG4gICAgICAgID8gdmFsdWUudG9TZXEoKS5lbnRyeVNlcSgpXG4gICAgICAgIDogaW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKCBTZXEgKSBJbmRleGVkU2VxLl9fcHJvdG9fXyA9IFNlcTtcbiAgICBJbmRleGVkU2VxLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNlcSAmJiBTZXEucHJvdG90eXBlICk7XG4gICAgSW5kZXhlZFNlcS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbmRleGVkU2VxO1xuXG4gICAgSW5kZXhlZFNlcS5vZiA9IGZ1bmN0aW9uIG9mICgvKi4uLnZhbHVlcyovKSB7XG4gICAgICByZXR1cm4gSW5kZXhlZFNlcShhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBJbmRleGVkU2VxLnByb3RvdHlwZS50b0luZGV4ZWRTZXEgPSBmdW5jdGlvbiB0b0luZGV4ZWRTZXEgKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIEluZGV4ZWRTZXEucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnU2VxIFsnLCAnXScpO1xuICAgIH07XG5cbiAgICByZXR1cm4gSW5kZXhlZFNlcTtcbiAgfShTZXEpKTtcblxuICB2YXIgU2V0U2VxID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU2VxKSB7XG4gICAgZnVuY3Rpb24gU2V0U2VxKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBpc0NvbGxlY3Rpb24odmFsdWUpICYmICFpc0Fzc29jaWF0aXZlKHZhbHVlKSA/IHZhbHVlIDogSW5kZXhlZFNlcSh2YWx1ZSlcbiAgICAgICkudG9TZXRTZXEoKTtcbiAgICB9XG5cbiAgICBpZiAoIFNlcSApIFNldFNlcS5fX3Byb3RvX18gPSBTZXE7XG4gICAgU2V0U2VxLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNlcSAmJiBTZXEucHJvdG90eXBlICk7XG4gICAgU2V0U2VxLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNldFNlcTtcblxuICAgIFNldFNlcS5vZiA9IGZ1bmN0aW9uIG9mICgvKi4uLnZhbHVlcyovKSB7XG4gICAgICByZXR1cm4gU2V0U2VxKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIFNldFNlcS5wcm90b3R5cGUudG9TZXRTZXEgPSBmdW5jdGlvbiB0b1NldFNlcSAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldFNlcTtcbiAgfShTZXEpKTtcblxuICBTZXEuaXNTZXEgPSBpc1NlcTtcbiAgU2VxLktleWVkID0gS2V5ZWRTZXE7XG4gIFNlcS5TZXQgPSBTZXRTZXE7XG4gIFNlcS5JbmRleGVkID0gSW5kZXhlZFNlcTtcblxuICBTZXEucHJvdG90eXBlW0lTX1NFUV9TWU1CT0xdID0gdHJ1ZTtcblxuICAvLyAjcHJhZ21hIFJvb3QgU2VxdWVuY2VzXG5cbiAgdmFyIEFycmF5U2VxID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW5kZXhlZFNlcSkge1xuICAgIGZ1bmN0aW9uIEFycmF5U2VxKGFycmF5KSB7XG4gICAgICB0aGlzLl9hcnJheSA9IGFycmF5O1xuICAgICAgdGhpcy5zaXplID0gYXJyYXkubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmICggSW5kZXhlZFNlcSApIEFycmF5U2VxLl9fcHJvdG9fXyA9IEluZGV4ZWRTZXE7XG4gICAgQXJyYXlTZXEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW5kZXhlZFNlcSAmJiBJbmRleGVkU2VxLnByb3RvdHlwZSApO1xuICAgIEFycmF5U2VxLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFycmF5U2VxO1xuXG4gICAgQXJyYXlTZXEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXMoaW5kZXgpID8gdGhpcy5fYXJyYXlbd3JhcEluZGV4KHRoaXMsIGluZGV4KV0gOiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgQXJyYXlTZXEucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciBhcnJheSA9IHRoaXMuX2FycmF5O1xuICAgICAgdmFyIHNpemUgPSBhcnJheS5sZW5ndGg7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB3aGlsZSAoaSAhPT0gc2l6ZSkge1xuICAgICAgICB2YXIgaWkgPSByZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrKztcbiAgICAgICAgaWYgKGZuKGFycmF5W2lpXSwgaWksIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaTtcbiAgICB9O1xuXG4gICAgQXJyYXlTZXEucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLl9hcnJheTtcbiAgICAgIHZhciBzaXplID0gYXJyYXkubGVuZ3RoO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpID09PSBzaXplKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpaSA9IHJldmVyc2UgPyBzaXplIC0gKytpIDogaSsrO1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpaSwgYXJyYXlbaWldKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gQXJyYXlTZXE7XG4gIH0oSW5kZXhlZFNlcSkpO1xuXG4gIHZhciBPYmplY3RTZXEgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChLZXllZFNlcSkge1xuICAgIGZ1bmN0aW9uIE9iamVjdFNlcShvYmplY3QpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICAgIHRoaXMuX29iamVjdCA9IG9iamVjdDtcbiAgICAgIHRoaXMuX2tleXMgPSBrZXlzO1xuICAgICAgdGhpcy5zaXplID0ga2V5cy5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKCBLZXllZFNlcSApIE9iamVjdFNlcS5fX3Byb3RvX18gPSBLZXllZFNlcTtcbiAgICBPYmplY3RTZXEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggS2V5ZWRTZXEgJiYgS2V5ZWRTZXEucHJvdG90eXBlICk7XG4gICAgT2JqZWN0U2VxLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE9iamVjdFNlcTtcblxuICAgIE9iamVjdFNlcS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgICBpZiAobm90U2V0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhdGhpcy5oYXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gbm90U2V0VmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fb2JqZWN0W2tleV07XG4gICAgfTtcblxuICAgIE9iamVjdFNlcS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX29iamVjdCwga2V5KTtcbiAgICB9O1xuXG4gICAgT2JqZWN0U2VxLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gdGhpcy5fb2JqZWN0O1xuICAgICAgdmFyIGtleXMgPSB0aGlzLl9rZXlzO1xuICAgICAgdmFyIHNpemUgPSBrZXlzLmxlbmd0aDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpICE9PSBzaXplKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW3JldmVyc2UgPyBzaXplIC0gKytpIDogaSsrXTtcbiAgICAgICAgaWYgKGZuKG9iamVjdFtrZXldLCBrZXksIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaTtcbiAgICB9O1xuXG4gICAgT2JqZWN0U2VxLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIG9iamVjdCA9IHRoaXMuX29iamVjdDtcbiAgICAgIHZhciBrZXlzID0gdGhpcy5fa2V5cztcbiAgICAgIHZhciBzaXplID0ga2V5cy5sZW5ndGg7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGkgPT09IHNpemUpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleSA9IGtleXNbcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKytdO1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBrZXksIG9iamVjdFtrZXldKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gT2JqZWN0U2VxO1xuICB9KEtleWVkU2VxKSk7XG4gIE9iamVjdFNlcS5wcm90b3R5cGVbSVNfT1JERVJFRF9TWU1CT0xdID0gdHJ1ZTtcblxuICB2YXIgQ29sbGVjdGlvblNlcSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEluZGV4ZWRTZXEpIHtcbiAgICBmdW5jdGlvbiBDb2xsZWN0aW9uU2VxKGNvbGxlY3Rpb24pIHtcbiAgICAgIHRoaXMuX2NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICAgICAgdGhpcy5zaXplID0gY29sbGVjdGlvbi5sZW5ndGggfHwgY29sbGVjdGlvbi5zaXplO1xuICAgIH1cblxuICAgIGlmICggSW5kZXhlZFNlcSApIENvbGxlY3Rpb25TZXEuX19wcm90b19fID0gSW5kZXhlZFNlcTtcbiAgICBDb2xsZWN0aW9uU2VxLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEluZGV4ZWRTZXEgJiYgSW5kZXhlZFNlcS5wcm90b3R5cGUgKTtcbiAgICBDb2xsZWN0aW9uU2VxLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbGxlY3Rpb25TZXE7XG5cbiAgICBDb2xsZWN0aW9uU2VxLnByb3RvdHlwZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIF9faXRlcmF0ZVVuY2FjaGVkIChmbiwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLl9jb2xsZWN0aW9uO1xuICAgICAgdmFyIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoY29sbGVjdGlvbik7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICBpZiAoaXNJdGVyYXRvcihpdGVyYXRvcikpIHtcbiAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoZm4oc3RlcC52YWx1ZSwgaXRlcmF0aW9ucysrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcblxuICAgIENvbGxlY3Rpb25TZXEucHJvdG90eXBlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uIF9faXRlcmF0b3JVbmNhY2hlZCAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLl9jb2xsZWN0aW9uO1xuICAgICAgdmFyIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoY29sbGVjdGlvbik7XG4gICAgICBpZiAoIWlzSXRlcmF0b3IoaXRlcmF0b3IpKSB7XG4gICAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoaXRlcmF0b3JEb25lKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHN0ZXAuZG9uZSA/IHN0ZXAgOiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgc3RlcC52YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENvbGxlY3Rpb25TZXE7XG4gIH0oSW5kZXhlZFNlcSkpO1xuXG4gIC8vICMgcHJhZ21hIEhlbHBlciBmdW5jdGlvbnNcblxuICB2YXIgRU1QVFlfU0VRO1xuXG4gIGZ1bmN0aW9uIGVtcHR5U2VxdWVuY2UoKSB7XG4gICAgcmV0dXJuIEVNUFRZX1NFUSB8fCAoRU1QVFlfU0VRID0gbmV3IEFycmF5U2VxKFtdKSk7XG4gIH1cblxuICBmdW5jdGlvbiBrZXllZFNlcUZyb21WYWx1ZSh2YWx1ZSkge1xuICAgIHZhciBzZXEgPSBBcnJheS5pc0FycmF5KHZhbHVlKVxuICAgICAgPyBuZXcgQXJyYXlTZXEodmFsdWUpXG4gICAgICA6IGhhc0l0ZXJhdG9yKHZhbHVlKVxuICAgICAgPyBuZXcgQ29sbGVjdGlvblNlcSh2YWx1ZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuICAgIGlmIChzZXEpIHtcbiAgICAgIHJldHVybiBzZXEuZnJvbUVudHJ5U2VxKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gbmV3IE9iamVjdFNlcSh2YWx1ZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnRXhwZWN0ZWQgQXJyYXkgb3IgY29sbGVjdGlvbiBvYmplY3Qgb2YgW2ssIHZdIGVudHJpZXMsIG9yIGtleWVkIG9iamVjdDogJyArXG4gICAgICAgIHZhbHVlXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluZGV4ZWRTZXFGcm9tVmFsdWUodmFsdWUpIHtcbiAgICB2YXIgc2VxID0gbWF5YmVJbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKTtcbiAgICBpZiAoc2VxKSB7XG4gICAgICByZXR1cm4gc2VxO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ0V4cGVjdGVkIEFycmF5IG9yIGNvbGxlY3Rpb24gb2JqZWN0IG9mIHZhbHVlczogJyArIHZhbHVlXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlcUZyb21WYWx1ZSh2YWx1ZSkge1xuICAgIHZhciBzZXEgPSBtYXliZUluZGV4ZWRTZXFGcm9tVmFsdWUodmFsdWUpO1xuICAgIGlmIChzZXEpIHtcbiAgICAgIHJldHVybiBzZXE7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gbmV3IE9iamVjdFNlcSh2YWx1ZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnRXhwZWN0ZWQgQXJyYXkgb3IgY29sbGVjdGlvbiBvYmplY3Qgb2YgdmFsdWVzLCBvciBrZXllZCBvYmplY3Q6ICcgKyB2YWx1ZVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXliZUluZGV4ZWRTZXFGcm9tVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gaXNBcnJheUxpa2UodmFsdWUpXG4gICAgICA/IG5ldyBBcnJheVNlcSh2YWx1ZSlcbiAgICAgIDogaGFzSXRlcmF0b3IodmFsdWUpXG4gICAgICA/IG5ldyBDb2xsZWN0aW9uU2VxKHZhbHVlKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgSVNfTUFQX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX01BUF9fQEAnO1xuXG4gIGZ1bmN0aW9uIGlzTWFwKG1heWJlTWFwKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4obWF5YmVNYXAgJiYgbWF5YmVNYXBbSVNfTUFQX1NZTUJPTF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNPcmRlcmVkTWFwKG1heWJlT3JkZXJlZE1hcCkge1xuICAgIHJldHVybiBpc01hcChtYXliZU9yZGVyZWRNYXApICYmIGlzT3JkZXJlZChtYXliZU9yZGVyZWRNYXApO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNWYWx1ZU9iamVjdChtYXliZVZhbHVlKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oXG4gICAgICBtYXliZVZhbHVlICYmXG4gICAgICAgIHR5cGVvZiBtYXliZVZhbHVlLmVxdWFscyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2YgbWF5YmVWYWx1ZS5oYXNoQ29kZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQW4gZXh0ZW5zaW9uIG9mIHRoZSBcInNhbWUtdmFsdWVcIiBhbGdvcml0aG0gYXMgW2Rlc2NyaWJlZCBmb3IgdXNlIGJ5IEVTNiBNYXBcbiAgICogYW5kIFNldF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWFwI0tleV9lcXVhbGl0eSlcbiAgICpcbiAgICogTmFOIGlzIGNvbnNpZGVyZWQgdGhlIHNhbWUgYXMgTmFOLCBob3dldmVyIC0wIGFuZCAwIGFyZSBjb25zaWRlcmVkIHRoZSBzYW1lXG4gICAqIHZhbHVlLCB3aGljaCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgYWxnb3JpdGhtIGRlc2NyaWJlZCBieVxuICAgKiBbYE9iamVjdC5pc2BdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pcykuXG4gICAqXG4gICAqIFRoaXMgaXMgZXh0ZW5kZWQgZnVydGhlciB0byBhbGxvdyBPYmplY3RzIHRvIGRlc2NyaWJlIHRoZSB2YWx1ZXMgdGhleVxuICAgKiByZXByZXNlbnQsIGJ5IHdheSBvZiBgdmFsdWVPZmAgb3IgYGVxdWFsc2AgKGFuZCBgaGFzaENvZGVgKS5cbiAgICpcbiAgICogTm90ZTogYmVjYXVzZSBvZiB0aGlzIGV4dGVuc2lvbiwgdGhlIGtleSBlcXVhbGl0eSBvZiBJbW11dGFibGUuTWFwIGFuZCB0aGVcbiAgICogdmFsdWUgZXF1YWxpdHkgb2YgSW1tdXRhYmxlLlNldCB3aWxsIGRpZmZlciBmcm9tIEVTNiBNYXAgYW5kIFNldC5cbiAgICpcbiAgICogIyMjIERlZmluaW5nIGN1c3RvbSB2YWx1ZXNcbiAgICpcbiAgICogVGhlIGVhc2llc3Qgd2F5IHRvIGRlc2NyaWJlIHRoZSB2YWx1ZSBhbiBvYmplY3QgcmVwcmVzZW50cyBpcyBieSBpbXBsZW1lbnRpbmdcbiAgICogYHZhbHVlT2ZgLiBGb3IgZXhhbXBsZSwgYERhdGVgIHJlcHJlc2VudHMgYSB2YWx1ZSBieSByZXR1cm5pbmcgYSB1bml4XG4gICAqIHRpbWVzdGFtcCBmb3IgYHZhbHVlT2ZgOlxuICAgKlxuICAgKiAgICAgdmFyIGRhdGUxID0gbmV3IERhdGUoMTIzNDU2Nzg5MDAwMCk7IC8vIEZyaSBGZWIgMTMgMjAwOSAuLi5cbiAgICogICAgIHZhciBkYXRlMiA9IG5ldyBEYXRlKDEyMzQ1Njc4OTAwMDApO1xuICAgKiAgICAgZGF0ZTEudmFsdWVPZigpOyAvLyAxMjM0NTY3ODkwMDAwXG4gICAqICAgICBhc3NlcnQoIGRhdGUxICE9PSBkYXRlMiApO1xuICAgKiAgICAgYXNzZXJ0KCBJbW11dGFibGUuaXMoIGRhdGUxLCBkYXRlMiApICk7XG4gICAqXG4gICAqIE5vdGU6IG92ZXJyaWRpbmcgYHZhbHVlT2ZgIG1heSBoYXZlIG90aGVyIGltcGxpY2F0aW9ucyBpZiB5b3UgdXNlIHRoaXMgb2JqZWN0XG4gICAqIHdoZXJlIEphdmFTY3JpcHQgZXhwZWN0cyBhIHByaW1pdGl2ZSwgc3VjaCBhcyBpbXBsaWNpdCBzdHJpbmcgY29lcmNpb24uXG4gICAqXG4gICAqIEZvciBtb3JlIGNvbXBsZXggdHlwZXMsIGVzcGVjaWFsbHkgY29sbGVjdGlvbnMsIGltcGxlbWVudGluZyBgdmFsdWVPZmAgbWF5XG4gICAqIG5vdCBiZSBwZXJmb3JtYW50LiBBbiBhbHRlcm5hdGl2ZSBpcyB0byBpbXBsZW1lbnQgYGVxdWFsc2AgYW5kIGBoYXNoQ29kZWAuXG4gICAqXG4gICAqIGBlcXVhbHNgIHRha2VzIGFub3RoZXIgb2JqZWN0LCBwcmVzdW1hYmx5IG9mIHNpbWlsYXIgdHlwZSwgYW5kIHJldHVybnMgdHJ1ZVxuICAgKiBpZiBpdCBpcyBlcXVhbC4gRXF1YWxpdHkgaXMgc3ltbWV0cmljYWwsIHNvIHRoZSBzYW1lIHJlc3VsdCBzaG91bGQgYmVcbiAgICogcmV0dXJuZWQgaWYgdGhpcyBhbmQgdGhlIGFyZ3VtZW50IGFyZSBmbGlwcGVkLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0KCBhLmVxdWFscyhiKSA9PT0gYi5lcXVhbHMoYSkgKTtcbiAgICpcbiAgICogYGhhc2hDb2RlYCByZXR1cm5zIGEgMzJiaXQgaW50ZWdlciBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBvYmplY3Qgd2hpY2ggd2lsbFxuICAgKiBiZSB1c2VkIHRvIGRldGVybWluZSBob3cgdG8gc3RvcmUgdGhlIHZhbHVlIG9iamVjdCBpbiBhIE1hcCBvciBTZXQuIFlvdSBtdXN0XG4gICAqIHByb3ZpZGUgYm90aCBvciBuZWl0aGVyIG1ldGhvZHMsIG9uZSBtdXN0IG5vdCBleGlzdCB3aXRob3V0IHRoZSBvdGhlci5cbiAgICpcbiAgICogQWxzbywgYW4gaW1wb3J0YW50IHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHRoZXNlIG1ldGhvZHMgbXVzdCBiZSB1cGhlbGQ6IGlmIHR3b1xuICAgKiB2YWx1ZXMgYXJlIGVxdWFsLCB0aGV5ICptdXN0KiByZXR1cm4gdGhlIHNhbWUgaGFzaENvZGUuIElmIHRoZSB2YWx1ZXMgYXJlIG5vdFxuICAgKiBlcXVhbCwgdGhleSBtaWdodCBoYXZlIHRoZSBzYW1lIGhhc2hDb2RlOyB0aGlzIGlzIGNhbGxlZCBhIGhhc2ggY29sbGlzaW9uLFxuICAgKiBhbmQgd2hpbGUgdW5kZXNpcmFibGUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIGl0IGlzIGFjY2VwdGFibGUuXG4gICAqXG4gICAqICAgICBpZiAoYS5lcXVhbHMoYikpIHtcbiAgICogICAgICAgYXNzZXJ0KCBhLmhhc2hDb2RlKCkgPT09IGIuaGFzaENvZGUoKSApO1xuICAgKiAgICAgfVxuICAgKlxuICAgKiBBbGwgSW1tdXRhYmxlIGNvbGxlY3Rpb25zIGFyZSBWYWx1ZSBPYmplY3RzOiB0aGV5IGltcGxlbWVudCBgZXF1YWxzKClgXG4gICAqIGFuZCBgaGFzaENvZGUoKWAuXG4gICAqL1xuICBmdW5jdGlvbiBpcyh2YWx1ZUEsIHZhbHVlQikge1xuICAgIGlmICh2YWx1ZUEgPT09IHZhbHVlQiB8fCAodmFsdWVBICE9PSB2YWx1ZUEgJiYgdmFsdWVCICE9PSB2YWx1ZUIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZUEgfHwgIXZhbHVlQikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICB0eXBlb2YgdmFsdWVBLnZhbHVlT2YgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZUIudmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgdmFsdWVBID0gdmFsdWVBLnZhbHVlT2YoKTtcbiAgICAgIHZhbHVlQiA9IHZhbHVlQi52YWx1ZU9mKCk7XG4gICAgICBpZiAodmFsdWVBID09PSB2YWx1ZUIgfHwgKHZhbHVlQSAhPT0gdmFsdWVBICYmIHZhbHVlQiAhPT0gdmFsdWVCKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdmFsdWVBIHx8ICF2YWx1ZUIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gISEoXG4gICAgICBpc1ZhbHVlT2JqZWN0KHZhbHVlQSkgJiZcbiAgICAgIGlzVmFsdWVPYmplY3QodmFsdWVCKSAmJlxuICAgICAgdmFsdWVBLmVxdWFscyh2YWx1ZUIpXG4gICAgKTtcbiAgfVxuXG4gIHZhciBpbXVsID1cbiAgICB0eXBlb2YgTWF0aC5pbXVsID09PSAnZnVuY3Rpb24nICYmIE1hdGguaW11bCgweGZmZmZmZmZmLCAyKSA9PT0gLTJcbiAgICAgID8gTWF0aC5pbXVsXG4gICAgICA6IGZ1bmN0aW9uIGltdWwoYSwgYikge1xuICAgICAgICAgIGEgfD0gMDsgLy8gaW50XG4gICAgICAgICAgYiB8PSAwOyAvLyBpbnRcbiAgICAgICAgICB2YXIgYyA9IGEgJiAweGZmZmY7XG4gICAgICAgICAgdmFyIGQgPSBiICYgMHhmZmZmO1xuICAgICAgICAgIC8vIFNoaWZ0IGJ5IDAgZml4ZXMgdGhlIHNpZ24gb24gdGhlIGhpZ2ggcGFydC5cbiAgICAgICAgICByZXR1cm4gKGMgKiBkICsgKCgoKGEgPj4+IDE2KSAqIGQgKyBjICogKGIgPj4+IDE2KSkgPDwgMTYpID4+PiAwKSkgfCAwOyAvLyBpbnRcbiAgICAgICAgfTtcblxuICAvLyB2OCBoYXMgYW4gb3B0aW1pemF0aW9uIGZvciBzdG9yaW5nIDMxLWJpdCBzaWduZWQgbnVtYmVycy5cbiAgLy8gVmFsdWVzIHdoaWNoIGhhdmUgZWl0aGVyIDAwIG9yIDExIGFzIHRoZSBoaWdoIG9yZGVyIGJpdHMgcXVhbGlmeS5cbiAgLy8gVGhpcyBmdW5jdGlvbiBkcm9wcyB0aGUgaGlnaGVzdCBvcmRlciBiaXQgaW4gYSBzaWduZWQgbnVtYmVyLCBtYWludGFpbmluZ1xuICAvLyB0aGUgc2lnbiBiaXQuXG4gIGZ1bmN0aW9uIHNtaShpMzIpIHtcbiAgICByZXR1cm4gKChpMzIgPj4+IDEpICYgMHg0MDAwMDAwMCkgfCAoaTMyICYgMHhiZmZmZmZmZik7XG4gIH1cblxuICB2YXIgZGVmYXVsdFZhbHVlT2YgPSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2Y7XG5cbiAgZnVuY3Rpb24gaGFzaChvKSB7XG4gICAgc3dpdGNoICh0eXBlb2Ygbykge1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIC8vIFRoZSBoYXNoIHZhbHVlcyBmb3IgYnVpbHQtaW4gY29uc3RhbnRzIGFyZSBhIDEgdmFsdWUgZm9yIGVhY2ggNS1ieXRlXG4gICAgICAgIC8vIHNoaWZ0IHJlZ2lvbiBleHBlY3QgZm9yIHRoZSBmaXJzdCwgd2hpY2ggZW5jb2RlcyB0aGUgdmFsdWUuIFRoaXNcbiAgICAgICAgLy8gcmVkdWNlcyB0aGUgb2RkcyBvZiBhIGhhc2ggY29sbGlzaW9uIGZvciB0aGVzZSBjb21tb24gdmFsdWVzLlxuICAgICAgICByZXR1cm4gbyA/IDB4NDIxMDg0MjEgOiAweDQyMTA4NDIwO1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIGhhc2hOdW1iZXIobyk7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gby5sZW5ndGggPiBTVFJJTkdfSEFTSF9DQUNIRV9NSU5fU1RSTEVOXG4gICAgICAgICAgPyBjYWNoZWRIYXNoU3RyaW5nKG8pXG4gICAgICAgICAgOiBoYXNoU3RyaW5nKG8pO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgaWYgKG8gPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gMHg0MjEwODQyMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG8uaGFzaENvZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBEcm9wIGFueSBoaWdoIGJpdHMgZnJvbSBhY2NpZGVudGFsbHkgbG9uZyBoYXNoIGNvZGVzLlxuICAgICAgICAgIHJldHVybiBzbWkoby5oYXNoQ29kZShvKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG8udmFsdWVPZiAhPT0gZGVmYXVsdFZhbHVlT2YgJiYgdHlwZW9mIG8udmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG8gPSBvLnZhbHVlT2Yobyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhc2hKU09iaihvKTtcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiAweDQyMTA4NDIzO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHR5cGVvZiBvLnRvU3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGhhc2hTdHJpbmcoby50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHR5cGUgJyArIHR5cGVvZiBvICsgJyBjYW5ub3QgYmUgaGFzaGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbXByZXNzIGFyYml0cmFyaWx5IGxhcmdlIG51bWJlcnMgaW50byBzbWkgaGFzaGVzLlxuICBmdW5jdGlvbiBoYXNoTnVtYmVyKG4pIHtcbiAgICBpZiAobiAhPT0gbiB8fCBuID09PSBJbmZpbml0eSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHZhciBoYXNoID0gbiB8IDA7XG4gICAgaWYgKGhhc2ggIT09IG4pIHtcbiAgICAgIGhhc2ggXj0gbiAqIDB4ZmZmZmZmZmY7XG4gICAgfVxuICAgIHdoaWxlIChuID4gMHhmZmZmZmZmZikge1xuICAgICAgbiAvPSAweGZmZmZmZmZmO1xuICAgICAgaGFzaCBePSBuO1xuICAgIH1cbiAgICByZXR1cm4gc21pKGhhc2gpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FjaGVkSGFzaFN0cmluZyhzdHJpbmcpIHtcbiAgICB2YXIgaGFzaGVkID0gc3RyaW5nSGFzaENhY2hlW3N0cmluZ107XG4gICAgaWYgKGhhc2hlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBoYXNoZWQgPSBoYXNoU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoU1RSSU5HX0hBU0hfQ0FDSEVfU0laRSA9PT0gU1RSSU5HX0hBU0hfQ0FDSEVfTUFYX1NJWkUpIHtcbiAgICAgICAgU1RSSU5HX0hBU0hfQ0FDSEVfU0laRSA9IDA7XG4gICAgICAgIHN0cmluZ0hhc2hDYWNoZSA9IHt9O1xuICAgICAgfVxuICAgICAgU1RSSU5HX0hBU0hfQ0FDSEVfU0laRSsrO1xuICAgICAgc3RyaW5nSGFzaENhY2hlW3N0cmluZ10gPSBoYXNoZWQ7XG4gICAgfVxuICAgIHJldHVybiBoYXNoZWQ7XG4gIH1cblxuICAvLyBodHRwOi8vanNwZXJmLmNvbS9oYXNoaW5nLXN0cmluZ3NcbiAgZnVuY3Rpb24gaGFzaFN0cmluZyhzdHJpbmcpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBoYXNoIGZyb20gSlZNXG4gICAgLy8gVGhlIGhhc2ggY29kZSBmb3IgYSBzdHJpbmcgaXMgY29tcHV0ZWQgYXNcbiAgICAvLyBzWzBdICogMzEgXiAobiAtIDEpICsgc1sxXSAqIDMxIF4gKG4gLSAyKSArIC4uLiArIHNbbiAtIDFdLFxuICAgIC8vIHdoZXJlIHNbaV0gaXMgdGhlIGl0aCBjaGFyYWN0ZXIgb2YgdGhlIHN0cmluZyBhbmQgbiBpcyB0aGUgbGVuZ3RoIG9mXG4gICAgLy8gdGhlIHN0cmluZy4gV2UgXCJtb2RcIiB0aGUgcmVzdWx0IHRvIG1ha2UgaXQgYmV0d2VlbiAwIChpbmNsdXNpdmUpIGFuZCAyXjMxXG4gICAgLy8gKGV4Y2x1c2l2ZSkgYnkgZHJvcHBpbmcgaGlnaCBiaXRzLlxuICAgIHZhciBoYXNoZWQgPSAwO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBzdHJpbmcubGVuZ3RoOyBpaSsrKSB7XG4gICAgICBoYXNoZWQgPSAoMzEgKiBoYXNoZWQgKyBzdHJpbmcuY2hhckNvZGVBdChpaSkpIHwgMDtcbiAgICB9XG4gICAgcmV0dXJuIHNtaShoYXNoZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzaEpTT2JqKG9iaikge1xuICAgIHZhciBoYXNoZWQ7XG4gICAgaWYgKHVzaW5nV2Vha01hcCkge1xuICAgICAgaGFzaGVkID0gd2Vha01hcC5nZXQob2JqKTtcbiAgICAgIGlmIChoYXNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaGFzaGVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhc2hlZCA9IG9ialtVSURfSEFTSF9LRVldO1xuICAgIGlmIChoYXNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGhhc2hlZDtcbiAgICB9XG5cbiAgICBpZiAoIWNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICBoYXNoZWQgPSBvYmoucHJvcGVydHlJc0VudW1lcmFibGUgJiYgb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlW1VJRF9IQVNIX0tFWV07XG4gICAgICBpZiAoaGFzaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGhhc2hlZDtcbiAgICAgIH1cblxuICAgICAgaGFzaGVkID0gZ2V0SUVOb2RlSGFzaChvYmopO1xuICAgICAgaWYgKGhhc2hlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBoYXNoZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFzaGVkID0gKytvYmpIYXNoVUlEO1xuICAgIGlmIChvYmpIYXNoVUlEICYgMHg0MDAwMDAwMCkge1xuICAgICAgb2JqSGFzaFVJRCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHVzaW5nV2Vha01hcCkge1xuICAgICAgd2Vha01hcC5zZXQob2JqLCBoYXNoZWQpO1xuICAgIH0gZWxzZSBpZiAoaXNFeHRlbnNpYmxlICE9PSB1bmRlZmluZWQgJiYgaXNFeHRlbnNpYmxlKG9iaikgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1leHRlbnNpYmxlIG9iamVjdHMgYXJlIG5vdCBhbGxvd2VkIGFzIGtleXMuJyk7XG4gICAgfSBlbHNlIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgVUlEX0hBU0hfS0VZLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBoYXNoZWQsXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZSA9PT0gb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZVxuICAgICkge1xuICAgICAgLy8gU2luY2Ugd2UgY2FuJ3QgZGVmaW5lIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgb24gdGhlIG9iamVjdFxuICAgICAgLy8gd2UnbGwgaGlqYWNrIG9uZSBvZiB0aGUgbGVzcy11c2VkIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgdG9cbiAgICAgIC8vIHNhdmUgb3VyIGhhc2ggb24gaXQuIFNpbmNlIHRoaXMgaXMgYSBmdW5jdGlvbiBpdCB3aWxsIG5vdCBzaG93IHVwIGluXG4gICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgIHdoaWNoIGlzIHdoYXQgd2Ugd2FudC5cbiAgICAgIG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmFwcGx5KFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgYXJndW1lbnRzXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlW1VJRF9IQVNIX0tFWV0gPSBoYXNoZWQ7XG4gICAgfSBlbHNlIGlmIChvYmoubm9kZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBjb3VsZG4ndCBnZXQgdGhlIElFIGB1bmlxdWVJRGAgdG8gdXNlIGFzIGEgaGFzaFxuICAgICAgLy8gYW5kIHdlIGNvdWxkbid0IHVzZSBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IHRvIGV4cGxvaXQgdGhlXG4gICAgICAvLyBkb250RW51bSBidWcgc28gd2Ugc2ltcGx5IGFkZCB0aGUgYFVJRF9IQVNIX0tFWWAgb24gdGhlIG5vZGVcbiAgICAgIC8vIGl0c2VsZi5cbiAgICAgIG9ialtVSURfSEFTSF9LRVldID0gaGFzaGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBzZXQgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBvbiBvYmplY3QuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc2hlZDtcbiAgfVxuXG4gIC8vIEdldCByZWZlcmVuY2VzIHRvIEVTNSBvYmplY3QgbWV0aG9kcy5cbiAgdmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG5cbiAgLy8gVHJ1ZSBpZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgd29ya3MgYXMgZXhwZWN0ZWQuIElFOCBmYWlscyB0aGlzIHRlc3QuXG4gIHZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ0AnLCB7fSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KSgpO1xuXG4gIC8vIElFIGhhcyBhIGB1bmlxdWVJRGAgcHJvcGVydHkgb24gRE9NIG5vZGVzLiBXZSBjYW4gY29uc3RydWN0IHRoZSBoYXNoIGZyb20gaXRcbiAgLy8gYW5kIGF2b2lkIG1lbW9yeSBsZWFrcyBmcm9tIHRoZSBJRSBjbG9uZU5vZGUgYnVnLlxuICBmdW5jdGlvbiBnZXRJRU5vZGVIYXNoKG5vZGUpIHtcbiAgICBpZiAobm9kZSAmJiBub2RlLm5vZGVUeXBlID4gMCkge1xuICAgICAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgICAgIGNhc2UgMTogLy8gRWxlbWVudFxuICAgICAgICAgIHJldHVybiBub2RlLnVuaXF1ZUlEO1xuICAgICAgICBjYXNlIDk6IC8vIERvY3VtZW50XG4gICAgICAgICAgcmV0dXJuIG5vZGUuZG9jdW1lbnRFbGVtZW50ICYmIG5vZGUuZG9jdW1lbnRFbGVtZW50LnVuaXF1ZUlEO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHBvc3NpYmxlLCB1c2UgYSBXZWFrTWFwLlxuICB2YXIgdXNpbmdXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbic7XG4gIHZhciB3ZWFrTWFwO1xuICBpZiAodXNpbmdXZWFrTWFwKSB7XG4gICAgd2Vha01hcCA9IG5ldyBXZWFrTWFwKCk7XG4gIH1cblxuICB2YXIgb2JqSGFzaFVJRCA9IDA7XG5cbiAgdmFyIFVJRF9IQVNIX0tFWSA9ICdfX2ltbXV0YWJsZWhhc2hfXyc7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gICAgVUlEX0hBU0hfS0VZID0gU3ltYm9sKFVJRF9IQVNIX0tFWSk7XG4gIH1cblxuICB2YXIgU1RSSU5HX0hBU0hfQ0FDSEVfTUlOX1NUUkxFTiA9IDE2O1xuICB2YXIgU1RSSU5HX0hBU0hfQ0FDSEVfTUFYX1NJWkUgPSAyNTU7XG4gIHZhciBTVFJJTkdfSEFTSF9DQUNIRV9TSVpFID0gMDtcbiAgdmFyIHN0cmluZ0hhc2hDYWNoZSA9IHt9O1xuXG4gIHZhciBUb0tleWVkU2VxdWVuY2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChLZXllZFNlcSkge1xuICAgIGZ1bmN0aW9uIFRvS2V5ZWRTZXF1ZW5jZShpbmRleGVkLCB1c2VLZXlzKSB7XG4gICAgICB0aGlzLl9pdGVyID0gaW5kZXhlZDtcbiAgICAgIHRoaXMuX3VzZUtleXMgPSB1c2VLZXlzO1xuICAgICAgdGhpcy5zaXplID0gaW5kZXhlZC5zaXplO1xuICAgIH1cblxuICAgIGlmICggS2V5ZWRTZXEgKSBUb0tleWVkU2VxdWVuY2UuX19wcm90b19fID0gS2V5ZWRTZXE7XG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEtleWVkU2VxICYmIEtleWVkU2VxLnByb3RvdHlwZSApO1xuICAgIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUb0tleWVkU2VxdWVuY2U7XG5cbiAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoa2V5LCBub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuZ2V0KGtleSwgbm90U2V0VmFsdWUpO1xuICAgIH07XG5cbiAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci5oYXMoa2V5KTtcbiAgICB9O1xuXG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS52YWx1ZVNlcSA9IGZ1bmN0aW9uIHZhbHVlU2VxICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLnZhbHVlU2VxKCk7XG4gICAgfTtcblxuICAgIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UgKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHZhciByZXZlcnNlZFNlcXVlbmNlID0gcmV2ZXJzZUZhY3RvcnkodGhpcywgdHJ1ZSk7XG4gICAgICBpZiAoIXRoaXMuX3VzZUtleXMpIHtcbiAgICAgICAgcmV2ZXJzZWRTZXF1ZW5jZS52YWx1ZVNlcSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5faXRlci50b1NlcSgpLnJldmVyc2UoKTsgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXZlcnNlZFNlcXVlbmNlO1xuICAgIH07XG5cbiAgICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCAobWFwcGVyLCBjb250ZXh0KSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdmFyIG1hcHBlZFNlcXVlbmNlID0gbWFwRmFjdG9yeSh0aGlzLCBtYXBwZXIsIGNvbnRleHQpO1xuICAgICAgaWYgKCF0aGlzLl91c2VLZXlzKSB7XG4gICAgICAgIG1hcHBlZFNlcXVlbmNlLnZhbHVlU2VxID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLl9pdGVyLnRvU2VxKCkubWFwKG1hcHBlciwgY29udGV4dCk7IH07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwcGVkU2VxdWVuY2U7XG4gICAgfTtcblxuICAgIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gZm4odiwgaywgdGhpcyQxKTsgfSwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBUb0tleWVkU2VxdWVuY2U7XG4gIH0oS2V5ZWRTZXEpKTtcbiAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZVtJU19PUkRFUkVEX1NZTUJPTF0gPSB0cnVlO1xuXG4gIHZhciBUb0luZGV4ZWRTZXF1ZW5jZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEluZGV4ZWRTZXEpIHtcbiAgICBmdW5jdGlvbiBUb0luZGV4ZWRTZXF1ZW5jZShpdGVyKSB7XG4gICAgICB0aGlzLl9pdGVyID0gaXRlcjtcbiAgICAgIHRoaXMuc2l6ZSA9IGl0ZXIuc2l6ZTtcbiAgICB9XG5cbiAgICBpZiAoIEluZGV4ZWRTZXEgKSBUb0luZGV4ZWRTZXF1ZW5jZS5fX3Byb3RvX18gPSBJbmRleGVkU2VxO1xuICAgIFRvSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEluZGV4ZWRTZXEgJiYgSW5kZXhlZFNlcS5wcm90b3R5cGUgKTtcbiAgICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUb0luZGV4ZWRTZXF1ZW5jZTtcblxuICAgIFRvSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuaW5jbHVkZXModmFsdWUpO1xuICAgIH07XG5cbiAgICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHJldmVyc2UgJiYgZW5zdXJlU2l6ZSh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLl9faXRlcmF0ZShcbiAgICAgICAgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGZuKHYsIHJldmVyc2UgPyB0aGlzJDEuc2l6ZSAtICsraSA6IGkrKywgdGhpcyQxKTsgfSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5faXRlci5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHJldmVyc2UgJiYgZW5zdXJlU2l6ZSh0aGlzKTtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHN0ZXAuZG9uZVxuICAgICAgICAgID8gc3RlcFxuICAgICAgICAgIDogaXRlcmF0b3JWYWx1ZShcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgcmV2ZXJzZSA/IHRoaXMkMS5zaXplIC0gKytpIDogaSsrLFxuICAgICAgICAgICAgICBzdGVwLnZhbHVlLFxuICAgICAgICAgICAgICBzdGVwXG4gICAgICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBUb0luZGV4ZWRTZXF1ZW5jZTtcbiAgfShJbmRleGVkU2VxKSk7XG5cbiAgdmFyIFRvU2V0U2VxdWVuY2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTZXRTZXEpIHtcbiAgICBmdW5jdGlvbiBUb1NldFNlcXVlbmNlKGl0ZXIpIHtcbiAgICAgIHRoaXMuX2l0ZXIgPSBpdGVyO1xuICAgICAgdGhpcy5zaXplID0gaXRlci5zaXplO1xuICAgIH1cblxuICAgIGlmICggU2V0U2VxICkgVG9TZXRTZXF1ZW5jZS5fX3Byb3RvX18gPSBTZXRTZXE7XG4gICAgVG9TZXRTZXF1ZW5jZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTZXRTZXEgJiYgU2V0U2VxLnByb3RvdHlwZSApO1xuICAgIFRvU2V0U2VxdWVuY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9TZXRTZXF1ZW5jZTtcblxuICAgIFRvU2V0U2VxdWVuY2UucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5faXRlci5pbmNsdWRlcyhrZXkpO1xuICAgIH07XG5cbiAgICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uICh2KSB7IHJldHVybiBmbih2LCB2LCB0aGlzJDEpOyB9LCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgVG9TZXRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX2l0ZXIuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUywgcmV2ZXJzZSk7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiBzdGVwLmRvbmVcbiAgICAgICAgICA/IHN0ZXBcbiAgICAgICAgICA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgc3RlcC52YWx1ZSwgc3RlcC52YWx1ZSwgc3RlcCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRvU2V0U2VxdWVuY2U7XG4gIH0oU2V0U2VxKSk7XG5cbiAgdmFyIEZyb21FbnRyaWVzU2VxdWVuY2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChLZXllZFNlcSkge1xuICAgIGZ1bmN0aW9uIEZyb21FbnRyaWVzU2VxdWVuY2UoZW50cmllcykge1xuICAgICAgdGhpcy5faXRlciA9IGVudHJpZXM7XG4gICAgICB0aGlzLnNpemUgPSBlbnRyaWVzLnNpemU7XG4gICAgfVxuXG4gICAgaWYgKCBLZXllZFNlcSApIEZyb21FbnRyaWVzU2VxdWVuY2UuX19wcm90b19fID0gS2V5ZWRTZXE7XG4gICAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBLZXllZFNlcSAmJiBLZXllZFNlcS5wcm90b3R5cGUgKTtcbiAgICBGcm9tRW50cmllc1NlcXVlbmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZyb21FbnRyaWVzU2VxdWVuY2U7XG5cbiAgICBGcm9tRW50cmllc1NlcXVlbmNlLnByb3RvdHlwZS5lbnRyeVNlcSA9IGZ1bmN0aW9uIGVudHJ5U2VxICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVyLnRvU2VxKCk7XG4gICAgfTtcblxuICAgIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5faXRlci5fX2l0ZXJhdGUoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGVudHJ5IGV4aXN0cyBmaXJzdCBzbyBhcnJheSBhY2Nlc3MgZG9lc24ndCB0aHJvdyBmb3IgaG9sZXNcbiAgICAgICAgLy8gaW4gdGhlIHBhcmVudCBpdGVyYXRpb24uXG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHZhbGlkYXRlRW50cnkoZW50cnkpO1xuICAgICAgICAgIHZhciBpbmRleGVkQ29sbGVjdGlvbiA9IGlzQ29sbGVjdGlvbihlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIGZuKFxuICAgICAgICAgICAgaW5kZXhlZENvbGxlY3Rpb24gPyBlbnRyeS5nZXQoMSkgOiBlbnRyeVsxXSxcbiAgICAgICAgICAgIGluZGV4ZWRDb2xsZWN0aW9uID8gZW50cnkuZ2V0KDApIDogZW50cnlbMF0sXG4gICAgICAgICAgICB0aGlzJDFcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX2l0ZXIuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUywgcmV2ZXJzZSk7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAvLyBDaGVjayBpZiBlbnRyeSBleGlzdHMgZmlyc3Qgc28gYXJyYXkgYWNjZXNzIGRvZXNuJ3QgdGhyb3cgZm9yIGhvbGVzXG4gICAgICAgICAgLy8gaW4gdGhlIHBhcmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICAgIHZhciBpbmRleGVkQ29sbGVjdGlvbiA9IGlzQ29sbGVjdGlvbihlbnRyeSk7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZShcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgaW5kZXhlZENvbGxlY3Rpb24gPyBlbnRyeS5nZXQoMCkgOiBlbnRyeVswXSxcbiAgICAgICAgICAgICAgaW5kZXhlZENvbGxlY3Rpb24gPyBlbnRyeS5nZXQoMSkgOiBlbnRyeVsxXSxcbiAgICAgICAgICAgICAgc3RlcFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gRnJvbUVudHJpZXNTZXF1ZW5jZTtcbiAgfShLZXllZFNlcSkpO1xuXG4gIFRvSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9XG4gICAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9XG4gICAgVG9TZXRTZXF1ZW5jZS5wcm90b3R5cGUuY2FjaGVSZXN1bHQgPVxuICAgIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLmNhY2hlUmVzdWx0ID1cbiAgICAgIGNhY2hlUmVzdWx0VGhyb3VnaDtcblxuICBmdW5jdGlvbiBmbGlwRmFjdG9yeShjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGZsaXBTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcbiAgICBmbGlwU2VxdWVuY2UuX2l0ZXIgPSBjb2xsZWN0aW9uO1xuICAgIGZsaXBTZXF1ZW5jZS5zaXplID0gY29sbGVjdGlvbi5zaXplO1xuICAgIGZsaXBTZXF1ZW5jZS5mbGlwID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29sbGVjdGlvbjsgfTtcbiAgICBmbGlwU2VxdWVuY2UucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZXZlcnNlZFNlcXVlbmNlID0gY29sbGVjdGlvbi5yZXZlcnNlLmFwcGx5KHRoaXMpOyAvLyBzdXBlci5yZXZlcnNlKClcbiAgICAgIHJldmVyc2VkU2VxdWVuY2UuZmxpcCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbGxlY3Rpb24ucmV2ZXJzZSgpOyB9O1xuICAgICAgcmV0dXJuIHJldmVyc2VkU2VxdWVuY2U7XG4gICAgfTtcbiAgICBmbGlwU2VxdWVuY2UuaGFzID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gY29sbGVjdGlvbi5pbmNsdWRlcyhrZXkpOyB9O1xuICAgIGZsaXBTZXF1ZW5jZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGNvbGxlY3Rpb24uaGFzKGtleSk7IH07XG4gICAgZmxpcFNlcXVlbmNlLmNhY2hlUmVzdWx0ID0gY2FjaGVSZXN1bHRUaHJvdWdoO1xuICAgIGZsaXBTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gZm4oaywgdiwgdGhpcyQxKSAhPT0gZmFsc2U7IH0sIHJldmVyc2UpO1xuICAgIH07XG4gICAgZmxpcFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGNvbGxlY3Rpb24uX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKCFzdGVwLmRvbmUpIHtcbiAgICAgICAgICAgIHZhciBrID0gc3RlcC52YWx1ZVswXTtcbiAgICAgICAgICAgIHN0ZXAudmFsdWVbMF0gPSBzdGVwLnZhbHVlWzFdO1xuICAgICAgICAgICAgc3RlcC52YWx1ZVsxXSA9IGs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLl9faXRlcmF0b3IoXG4gICAgICAgIHR5cGUgPT09IElURVJBVEVfVkFMVUVTID8gSVRFUkFURV9LRVlTIDogSVRFUkFURV9WQUxVRVMsXG4gICAgICAgIHJldmVyc2VcbiAgICAgICk7XG4gICAgfTtcbiAgICByZXR1cm4gZmxpcFNlcXVlbmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwRmFjdG9yeShjb2xsZWN0aW9uLCBtYXBwZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgbWFwcGVkU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gICAgbWFwcGVkU2VxdWVuY2Uuc2l6ZSA9IGNvbGxlY3Rpb24uc2l6ZTtcbiAgICBtYXBwZWRTZXF1ZW5jZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBjb2xsZWN0aW9uLmhhcyhrZXkpOyB9O1xuICAgIG1hcHBlZFNlcXVlbmNlLmdldCA9IGZ1bmN0aW9uIChrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgICB2YXIgdiA9IGNvbGxlY3Rpb24uZ2V0KGtleSwgTk9UX1NFVCk7XG4gICAgICByZXR1cm4gdiA9PT0gTk9UX1NFVFxuICAgICAgICA/IG5vdFNldFZhbHVlXG4gICAgICAgIDogbWFwcGVyLmNhbGwoY29udGV4dCwgdiwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICB9O1xuICAgIG1hcHBlZFNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uX19pdGVyYXRlKFxuICAgICAgICBmdW5jdGlvbiAodiwgaywgYykgeyByZXR1cm4gZm4obWFwcGVyLmNhbGwoY29udGV4dCwgdiwgaywgYyksIGssIHRoaXMkMSkgIT09IGZhbHNlOyB9LFxuICAgICAgICByZXZlcnNlXG4gICAgICApO1xuICAgIH07XG4gICAgbWFwcGVkU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24gKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGNvbGxlY3Rpb24uX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMsIHJldmVyc2UpO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgdmFyIGtleSA9IGVudHJ5WzBdO1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZShcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBtYXBwZXIuY2FsbChjb250ZXh0LCBlbnRyeVsxXSwga2V5LCBjb2xsZWN0aW9uKSxcbiAgICAgICAgICBzdGVwXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBtYXBwZWRTZXF1ZW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldmVyc2VGYWN0b3J5KGNvbGxlY3Rpb24sIHVzZUtleXMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByZXZlcnNlZFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGNvbGxlY3Rpb24pO1xuICAgIHJldmVyc2VkU2VxdWVuY2UuX2l0ZXIgPSBjb2xsZWN0aW9uO1xuICAgIHJldmVyc2VkU2VxdWVuY2Uuc2l6ZSA9IGNvbGxlY3Rpb24uc2l6ZTtcbiAgICByZXZlcnNlZFNlcXVlbmNlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2xsZWN0aW9uOyB9O1xuICAgIGlmIChjb2xsZWN0aW9uLmZsaXApIHtcbiAgICAgIHJldmVyc2VkU2VxdWVuY2UuZmxpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZsaXBTZXF1ZW5jZSA9IGZsaXBGYWN0b3J5KGNvbGxlY3Rpb24pO1xuICAgICAgICBmbGlwU2VxdWVuY2UucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbGxlY3Rpb24uZmxpcCgpOyB9O1xuICAgICAgICByZXR1cm4gZmxpcFNlcXVlbmNlO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5nZXQgPSBmdW5jdGlvbiAoa2V5LCBub3RTZXRWYWx1ZSkgeyByZXR1cm4gY29sbGVjdGlvbi5nZXQodXNlS2V5cyA/IGtleSA6IC0xIC0ga2V5LCBub3RTZXRWYWx1ZSk7IH07XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBjb2xsZWN0aW9uLmhhcyh1c2VLZXlzID8ga2V5IDogLTEgLSBrZXkpOyB9O1xuICAgIHJldmVyc2VkU2VxdWVuY2UuaW5jbHVkZXMgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGNvbGxlY3Rpb24uaW5jbHVkZXModmFsdWUpOyB9O1xuICAgIHJldmVyc2VkU2VxdWVuY2UuY2FjaGVSZXN1bHQgPSBjYWNoZVJlc3VsdFRocm91Z2g7XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICByZXZlcnNlICYmIGVuc3VyZVNpemUoY29sbGVjdGlvbik7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5fX2l0ZXJhdGUoXG4gICAgICAgIGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBmbih2LCB1c2VLZXlzID8gayA6IHJldmVyc2UgPyB0aGlzJDEuc2l6ZSAtICsraSA6IGkrKywgdGhpcyQxKTsgfSxcbiAgICAgICAgIXJldmVyc2VcbiAgICAgICk7XG4gICAgfTtcbiAgICByZXZlcnNlZFNlcXVlbmNlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgcmV2ZXJzZSAmJiBlbnN1cmVTaXplKGNvbGxlY3Rpb24pO1xuICAgICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgIXJldmVyc2UpO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICB1c2VLZXlzID8gZW50cnlbMF0gOiByZXZlcnNlID8gdGhpcyQxLnNpemUgLSArK2kgOiBpKyssXG4gICAgICAgICAgZW50cnlbMV0sXG4gICAgICAgICAgc3RlcFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gcmV2ZXJzZWRTZXF1ZW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbHRlckZhY3RvcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBjb250ZXh0LCB1c2VLZXlzKSB7XG4gICAgdmFyIGZpbHRlclNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGNvbGxlY3Rpb24pO1xuICAgIGlmICh1c2VLZXlzKSB7XG4gICAgICBmaWx0ZXJTZXF1ZW5jZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB2ID0gY29sbGVjdGlvbi5nZXQoa2V5LCBOT1RfU0VUKTtcbiAgICAgICAgcmV0dXJuIHYgIT09IE5PVF9TRVQgJiYgISFwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICAgIGZpbHRlclNlcXVlbmNlLmdldCA9IGZ1bmN0aW9uIChrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgICAgIHZhciB2ID0gY29sbGVjdGlvbi5nZXQoa2V5LCBOT1RfU0VUKTtcbiAgICAgICAgcmV0dXJuIHYgIT09IE5PVF9TRVQgJiYgcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwga2V5LCBjb2xsZWN0aW9uKVxuICAgICAgICAgID8gdlxuICAgICAgICAgIDogbm90U2V0VmFsdWU7XG4gICAgICB9O1xuICAgIH1cbiAgICBmaWx0ZXJTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIGNvbGxlY3Rpb24uX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrLCBjKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCBjKSkge1xuICAgICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgICByZXR1cm4gZm4odiwgdXNlS2V5cyA/IGsgOiBpdGVyYXRpb25zIC0gMSwgdGhpcyQxKTtcbiAgICAgICAgfVxuICAgICAgfSwgcmV2ZXJzZSk7XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuICAgIGZpbHRlclNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCByZXZlcnNlKTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciBrZXkgPSBlbnRyeVswXTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBlbnRyeVsxXTtcbiAgICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwoY29udGV4dCwgdmFsdWUsIGtleSwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIHVzZUtleXMgPyBrZXkgOiBpdGVyYXRpb25zKyssIHZhbHVlLCBzdGVwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIGZpbHRlclNlcXVlbmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gY291bnRCeUZhY3RvcnkoY29sbGVjdGlvbiwgZ3JvdXBlciwgY29udGV4dCkge1xuICAgIHZhciBncm91cHMgPSBNYXAoKS5hc011dGFibGUoKTtcbiAgICBjb2xsZWN0aW9uLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykge1xuICAgICAgZ3JvdXBzLnVwZGF0ZShncm91cGVyLmNhbGwoY29udGV4dCwgdiwgaywgY29sbGVjdGlvbiksIDAsIGZ1bmN0aW9uIChhKSB7IHJldHVybiBhICsgMTsgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGdyb3Vwcy5hc0ltbXV0YWJsZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ3JvdXBCeUZhY3RvcnkoY29sbGVjdGlvbiwgZ3JvdXBlciwgY29udGV4dCkge1xuICAgIHZhciBpc0tleWVkSXRlciA9IGlzS2V5ZWQoY29sbGVjdGlvbik7XG4gICAgdmFyIGdyb3VwcyA9IChpc09yZGVyZWQoY29sbGVjdGlvbikgPyBPcmRlcmVkTWFwKCkgOiBNYXAoKSkuYXNNdXRhYmxlKCk7XG4gICAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgIGdyb3Vwcy51cGRhdGUoXG4gICAgICAgIGdyb3VwZXIuY2FsbChjb250ZXh0LCB2LCBrLCBjb2xsZWN0aW9uKSxcbiAgICAgICAgZnVuY3Rpb24gKGEpIHsgcmV0dXJuICgoYSA9IGEgfHwgW10pLCBhLnB1c2goaXNLZXllZEl0ZXIgPyBbaywgdl0gOiB2KSwgYSk7IH1cbiAgICAgICk7XG4gICAgfSk7XG4gICAgdmFyIGNvZXJjZSA9IGNvbGxlY3Rpb25DbGFzcyhjb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gZ3JvdXBzLm1hcChmdW5jdGlvbiAoYXJyKSB7IHJldHVybiByZWlmeShjb2xsZWN0aW9uLCBjb2VyY2UoYXJyKSk7IH0pLmFzSW1tdXRhYmxlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBzbGljZUZhY3RvcnkoY29sbGVjdGlvbiwgYmVnaW4sIGVuZCwgdXNlS2V5cykge1xuICAgIHZhciBvcmlnaW5hbFNpemUgPSBjb2xsZWN0aW9uLnNpemU7XG5cbiAgICBpZiAod2hvbGVTbGljZShiZWdpbiwgZW5kLCBvcmlnaW5hbFNpemUpKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgcmVzb2x2ZWRCZWdpbiA9IHJlc29sdmVCZWdpbihiZWdpbiwgb3JpZ2luYWxTaXplKTtcbiAgICB2YXIgcmVzb2x2ZWRFbmQgPSByZXNvbHZlRW5kKGVuZCwgb3JpZ2luYWxTaXplKTtcblxuICAgIC8vIGJlZ2luIG9yIGVuZCB3aWxsIGJlIE5hTiBpZiB0aGV5IHdlcmUgcHJvdmlkZWQgYXMgbmVnYXRpdmUgbnVtYmVycyBhbmRcbiAgICAvLyB0aGlzIGNvbGxlY3Rpb24ncyBzaXplIGlzIHVua25vd24uIEluIHRoYXQgY2FzZSwgY2FjaGUgZmlyc3Qgc28gdGhlcmUgaXNcbiAgICAvLyBhIGtub3duIHNpemUgYW5kIHRoZXNlIGRvIG5vdCByZXNvbHZlIHRvIE5hTi5cbiAgICBpZiAocmVzb2x2ZWRCZWdpbiAhPT0gcmVzb2x2ZWRCZWdpbiB8fCByZXNvbHZlZEVuZCAhPT0gcmVzb2x2ZWRFbmQpIHtcbiAgICAgIHJldHVybiBzbGljZUZhY3RvcnkoY29sbGVjdGlvbi50b1NlcSgpLmNhY2hlUmVzdWx0KCksIGJlZ2luLCBlbmQsIHVzZUtleXMpO1xuICAgIH1cblxuICAgIC8vIE5vdGU6IHJlc29sdmVkRW5kIGlzIHVuZGVmaW5lZCB3aGVuIHRoZSBvcmlnaW5hbCBzZXF1ZW5jZSdzIGxlbmd0aCBpc1xuICAgIC8vIHVua25vd24gYW5kIHRoaXMgc2xpY2UgZGlkIG5vdCBzdXBwbHkgYW4gZW5kIGFuZCBzaG91bGQgY29udGFpbiBhbGxcbiAgICAvLyBlbGVtZW50cyBhZnRlciByZXNvbHZlZEJlZ2luLlxuICAgIC8vIEluIHRoYXQgY2FzZSwgcmVzb2x2ZWRTaXplIHdpbGwgYmUgTmFOIGFuZCBzbGljZVNpemUgd2lsbCByZW1haW4gdW5kZWZpbmVkLlxuICAgIHZhciByZXNvbHZlZFNpemUgPSByZXNvbHZlZEVuZCAtIHJlc29sdmVkQmVnaW47XG4gICAgdmFyIHNsaWNlU2l6ZTtcbiAgICBpZiAocmVzb2x2ZWRTaXplID09PSByZXNvbHZlZFNpemUpIHtcbiAgICAgIHNsaWNlU2l6ZSA9IHJlc29sdmVkU2l6ZSA8IDAgPyAwIDogcmVzb2x2ZWRTaXplO1xuICAgIH1cblxuICAgIHZhciBzbGljZVNlcSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcblxuICAgIC8vIElmIGNvbGxlY3Rpb24uc2l6ZSBpcyB1bmRlZmluZWQsIHRoZSBzaXplIG9mIHRoZSByZWFsaXplZCBzbGljZVNlcSBpc1xuICAgIC8vIHVua25vd24gYXQgdGhpcyBwb2ludCB1bmxlc3MgdGhlIG51bWJlciBvZiBpdGVtcyB0byBzbGljZSBpcyAwXG4gICAgc2xpY2VTZXEuc2l6ZSA9XG4gICAgICBzbGljZVNpemUgPT09IDAgPyBzbGljZVNpemUgOiAoY29sbGVjdGlvbi5zaXplICYmIHNsaWNlU2l6ZSkgfHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKCF1c2VLZXlzICYmIGlzU2VxKGNvbGxlY3Rpb24pICYmIHNsaWNlU2l6ZSA+PSAwKSB7XG4gICAgICBzbGljZVNlcS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID49IDAgJiYgaW5kZXggPCBzbGljZVNpemVcbiAgICAgICAgICA/IGNvbGxlY3Rpb24uZ2V0KGluZGV4ICsgcmVzb2x2ZWRCZWdpbiwgbm90U2V0VmFsdWUpXG4gICAgICAgICAgOiBub3RTZXRWYWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgc2xpY2VTZXEuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbiAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICBpZiAoc2xpY2VTaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIHNraXBwZWQgPSAwO1xuICAgICAgdmFyIGlzU2tpcHBpbmcgPSB0cnVlO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgaWYgKCEoaXNTa2lwcGluZyAmJiAoaXNTa2lwcGluZyA9IHNraXBwZWQrKyA8IHJlc29sdmVkQmVnaW4pKSkge1xuICAgICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZm4odiwgdXNlS2V5cyA/IGsgOiBpdGVyYXRpb25zIC0gMSwgdGhpcyQxKSAhPT0gZmFsc2UgJiZcbiAgICAgICAgICAgIGl0ZXJhdGlvbnMgIT09IHNsaWNlU2l6ZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcblxuICAgIHNsaWNlU2VxLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICBpZiAoc2xpY2VTaXplICE9PSAwICYmIHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgLy8gRG9uJ3QgYm90aGVyIGluc3RhbnRpYXRpbmcgcGFyZW50IGl0ZXJhdG9yIGlmIHRha2luZyAwLlxuICAgICAgaWYgKHNsaWNlU2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGl0ZXJhdG9yRG9uZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICB2YXIgc2tpcHBlZCA9IDA7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKHNraXBwZWQrKyA8IHJlc29sdmVkQmVnaW4pIHtcbiAgICAgICAgICBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCsraXRlcmF0aW9ucyA+IHNsaWNlU2l6ZSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKHVzZUtleXMgfHwgdHlwZSA9PT0gSVRFUkFURV9WQUxVRVMgfHwgc3RlcC5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IElURVJBVEVfS0VZUykge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMgLSAxLCB1bmRlZmluZWQsIHN0ZXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMgLSAxLCBzdGVwLnZhbHVlWzFdLCBzdGVwKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2xpY2VTZXE7XG4gIH1cblxuICBmdW5jdGlvbiB0YWtlV2hpbGVGYWN0b3J5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciB0YWtlU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gICAgdGFrZVNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoXG4gICAgICAgIGZ1bmN0aW9uICh2LCBrLCBjKSB7IHJldHVybiBwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCBjKSAmJiArK2l0ZXJhdGlvbnMgJiYgZm4odiwgaywgdGhpcyQxKTsgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG4gICAgdGFrZVNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgICB2YXIgaXRlcmF0aW5nID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWl0ZXJhdGluZykge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgIHZhciBrID0gZW50cnlbMF07XG4gICAgICAgIHZhciB2ID0gZW50cnlbMV07XG4gICAgICAgIGlmICghcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgdGhpcyQxKSkge1xuICAgICAgICAgIGl0ZXJhdGluZyA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTID8gc3RlcCA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaywgdiwgc3RlcCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiB0YWtlU2VxdWVuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBza2lwV2hpbGVGYWN0b3J5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgY29udGV4dCwgdXNlS2V5cykge1xuICAgIHZhciBza2lwU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gICAgc2tpcFNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xuICAgICAgfVxuICAgICAgdmFyIGlzU2tpcHBpbmcgPSB0cnVlO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGssIGMpIHtcbiAgICAgICAgaWYgKCEoaXNTa2lwcGluZyAmJiAoaXNTa2lwcGluZyA9IHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpKSkpIHtcbiAgICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgICAgcmV0dXJuIGZuKHYsIHVzZUtleXMgPyBrIDogaXRlcmF0aW9ucyAtIDEsIHRoaXMkMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcbiAgICBza2lwU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24gKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCByZXZlcnNlKTtcbiAgICAgIHZhciBza2lwcGluZyA9IHRydWU7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgIHZhciBrO1xuICAgICAgICB2YXIgdjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgICAgaWYgKHVzZUtleXMgfHwgdHlwZSA9PT0gSVRFUkFURV9WQUxVRVMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gSVRFUkFURV9LRVlTKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgdW5kZWZpbmVkLCBzdGVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgc3RlcC52YWx1ZVsxXSwgc3RlcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgayA9IGVudHJ5WzBdO1xuICAgICAgICAgIHYgPSBlbnRyeVsxXTtcbiAgICAgICAgICBza2lwcGluZyAmJiAoc2tpcHBpbmcgPSBwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCB0aGlzJDEpKTtcbiAgICAgICAgfSB3aGlsZSAoc2tpcHBpbmcpO1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTID8gc3RlcCA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgaywgdiwgc3RlcCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBza2lwU2VxdWVuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBjb25jYXRGYWN0b3J5KGNvbGxlY3Rpb24sIHZhbHVlcykge1xuICAgIHZhciBpc0tleWVkQ29sbGVjdGlvbiA9IGlzS2V5ZWQoY29sbGVjdGlvbik7XG4gICAgdmFyIGl0ZXJzID0gW2NvbGxlY3Rpb25dXG4gICAgICAuY29uY2F0KHZhbHVlcylcbiAgICAgIC5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKCFpc0NvbGxlY3Rpb24odikpIHtcbiAgICAgICAgICB2ID0gaXNLZXllZENvbGxlY3Rpb25cbiAgICAgICAgICAgID8ga2V5ZWRTZXFGcm9tVmFsdWUodilcbiAgICAgICAgICAgIDogaW5kZXhlZFNlcUZyb21WYWx1ZShBcnJheS5pc0FycmF5KHYpID8gdiA6IFt2XSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNLZXllZENvbGxlY3Rpb24pIHtcbiAgICAgICAgICB2ID0gS2V5ZWRDb2xsZWN0aW9uKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYuc2l6ZSAhPT0gMDsgfSk7XG5cbiAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgc2luZ2xldG9uID0gaXRlcnNbMF07XG4gICAgICBpZiAoXG4gICAgICAgIHNpbmdsZXRvbiA9PT0gY29sbGVjdGlvbiB8fFxuICAgICAgICAoaXNLZXllZENvbGxlY3Rpb24gJiYgaXNLZXllZChzaW5nbGV0b24pKSB8fFxuICAgICAgICAoaXNJbmRleGVkKGNvbGxlY3Rpb24pICYmIGlzSW5kZXhlZChzaW5nbGV0b24pKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBzaW5nbGV0b247XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNvbmNhdFNlcSA9IG5ldyBBcnJheVNlcShpdGVycyk7XG4gICAgaWYgKGlzS2V5ZWRDb2xsZWN0aW9uKSB7XG4gICAgICBjb25jYXRTZXEgPSBjb25jYXRTZXEudG9LZXllZFNlcSgpO1xuICAgIH0gZWxzZSBpZiAoIWlzSW5kZXhlZChjb2xsZWN0aW9uKSkge1xuICAgICAgY29uY2F0U2VxID0gY29uY2F0U2VxLnRvU2V0U2VxKCk7XG4gICAgfVxuICAgIGNvbmNhdFNlcSA9IGNvbmNhdFNlcS5mbGF0dGVuKHRydWUpO1xuICAgIGNvbmNhdFNlcS5zaXplID0gaXRlcnMucmVkdWNlKGZ1bmN0aW9uIChzdW0sIHNlcSkge1xuICAgICAgaWYgKHN1bSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBzaXplID0gc2VxLnNpemU7XG4gICAgICAgIGlmIChzaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gc3VtICsgc2l6ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIDApO1xuICAgIHJldHVybiBjb25jYXRTZXE7XG4gIH1cblxuICBmdW5jdGlvbiBmbGF0dGVuRmFjdG9yeShjb2xsZWN0aW9uLCBkZXB0aCwgdXNlS2V5cykge1xuICAgIHZhciBmbGF0U2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gICAgZmxhdFNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB2YXIgc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgZnVuY3Rpb24gZmxhdERlZXAoaXRlciwgY3VycmVudERlcHRoKSB7XG4gICAgICAgIGl0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgICAgaWYgKCghZGVwdGggfHwgY3VycmVudERlcHRoIDwgZGVwdGgpICYmIGlzQ29sbGVjdGlvbih2KSkge1xuICAgICAgICAgICAgZmxhdERlZXAodiwgY3VycmVudERlcHRoICsgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgICAgIGlmIChmbih2LCB1c2VLZXlzID8gayA6IGl0ZXJhdGlvbnMgLSAxLCBmbGF0U2VxdWVuY2UpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICFzdG9wcGVkO1xuICAgICAgICB9LCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIGZsYXREZWVwKGNvbGxlY3Rpb24sIDApO1xuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcbiAgICBmbGF0U2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24gKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRvciA9IGNvbGxlY3Rpb24uX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgIHZhciBzdGFjayA9IFtdO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlIChpdGVyYXRvcikge1xuICAgICAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChzdGVwLmRvbmUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpdGVyYXRvciA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB2ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gSVRFUkFURV9FTlRSSUVTKSB7XG4gICAgICAgICAgICB2ID0gdlsxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCghZGVwdGggfHwgc3RhY2subGVuZ3RoIDwgZGVwdGgpICYmIGlzQ29sbGVjdGlvbih2KSkge1xuICAgICAgICAgICAgc3RhY2sucHVzaChpdGVyYXRvcik7XG4gICAgICAgICAgICBpdGVyYXRvciA9IHYuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVzZUtleXMgPyBzdGVwIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHYsIHN0ZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBmbGF0U2VxdWVuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBmbGF0TWFwRmFjdG9yeShjb2xsZWN0aW9uLCBtYXBwZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgY29lcmNlID0gY29sbGVjdGlvbkNsYXNzKGNvbGxlY3Rpb24pO1xuICAgIHJldHVybiBjb2xsZWN0aW9uXG4gICAgICAudG9TZXEoKVxuICAgICAgLm1hcChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gY29lcmNlKG1hcHBlci5jYWxsKGNvbnRleHQsIHYsIGssIGNvbGxlY3Rpb24pKTsgfSlcbiAgICAgIC5mbGF0dGVuKHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJwb3NlRmFjdG9yeShjb2xsZWN0aW9uLCBzZXBhcmF0b3IpIHtcbiAgICB2YXIgaW50ZXJwb3NlZFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGNvbGxlY3Rpb24pO1xuICAgIGludGVycG9zZWRTZXF1ZW5jZS5zaXplID0gY29sbGVjdGlvbi5zaXplICYmIGNvbGxlY3Rpb24uc2l6ZSAqIDIgLSAxO1xuICAgIGludGVycG9zZWRTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIGNvbGxlY3Rpb24uX19pdGVyYXRlKFxuICAgICAgICBmdW5jdGlvbiAodikgeyByZXR1cm4gKCFpdGVyYXRpb25zIHx8IGZuKHNlcGFyYXRvciwgaXRlcmF0aW9ucysrLCB0aGlzJDEpICE9PSBmYWxzZSkgJiZcbiAgICAgICAgICBmbih2LCBpdGVyYXRpb25zKyssIHRoaXMkMSkgIT09IGZhbHNlOyB9LFxuICAgICAgICByZXZlcnNlXG4gICAgICApO1xuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcbiAgICBpbnRlcnBvc2VkU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24gKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGNvbGxlY3Rpb24uX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUywgcmV2ZXJzZSk7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXN0ZXAgfHwgaXRlcmF0aW9ucyAlIDIpIHtcbiAgICAgICAgICBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlcmF0aW9ucyAlIDJcbiAgICAgICAgICA/IGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCBzZXBhcmF0b3IpXG4gICAgICAgICAgOiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgc3RlcC52YWx1ZSwgc3RlcCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBpbnRlcnBvc2VkU2VxdWVuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBzb3J0RmFjdG9yeShjb2xsZWN0aW9uLCBjb21wYXJhdG9yLCBtYXBwZXIpIHtcbiAgICBpZiAoIWNvbXBhcmF0b3IpIHtcbiAgICAgIGNvbXBhcmF0b3IgPSBkZWZhdWx0Q29tcGFyYXRvcjtcbiAgICB9XG4gICAgdmFyIGlzS2V5ZWRDb2xsZWN0aW9uID0gaXNLZXllZChjb2xsZWN0aW9uKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBlbnRyaWVzID0gY29sbGVjdGlvblxuICAgICAgLnRvU2VxKClcbiAgICAgIC5tYXAoZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIFtrLCB2LCBpbmRleCsrLCBtYXBwZXIgPyBtYXBwZXIodiwgaywgY29sbGVjdGlvbikgOiB2XTsgfSlcbiAgICAgIC52YWx1ZVNlcSgpXG4gICAgICAudG9BcnJheSgpO1xuICAgIGVudHJpZXNcbiAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBjb21wYXJhdG9yKGFbM10sIGJbM10pIHx8IGFbMl0gLSBiWzJdOyB9KVxuICAgICAgLmZvckVhY2goXG4gICAgICAgIGlzS2V5ZWRDb2xsZWN0aW9uXG4gICAgICAgICAgPyBmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICAgICAgICBlbnRyaWVzW2ldLmxlbmd0aCA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiBmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICAgICAgICBlbnRyaWVzW2ldID0gdlsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICk7XG4gICAgcmV0dXJuIGlzS2V5ZWRDb2xsZWN0aW9uXG4gICAgICA/IEtleWVkU2VxKGVudHJpZXMpXG4gICAgICA6IGlzSW5kZXhlZChjb2xsZWN0aW9uKVxuICAgICAgPyBJbmRleGVkU2VxKGVudHJpZXMpXG4gICAgICA6IFNldFNlcShlbnRyaWVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heEZhY3RvcnkoY29sbGVjdGlvbiwgY29tcGFyYXRvciwgbWFwcGVyKSB7XG4gICAgaWYgKCFjb21wYXJhdG9yKSB7XG4gICAgICBjb21wYXJhdG9yID0gZGVmYXVsdENvbXBhcmF0b3I7XG4gICAgfVxuICAgIGlmIChtYXBwZXIpIHtcbiAgICAgIHZhciBlbnRyeSA9IGNvbGxlY3Rpb25cbiAgICAgICAgLnRvU2VxKClcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gW3YsIG1hcHBlcih2LCBrLCBjb2xsZWN0aW9uKV07IH0pXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChtYXhDb21wYXJlKGNvbXBhcmF0b3IsIGFbMV0sIGJbMV0pID8gYiA6IGEpOyB9KTtcbiAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeVswXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24ucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAobWF4Q29tcGFyZShjb21wYXJhdG9yLCBhLCBiKSA/IGIgOiBhKTsgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXhDb21wYXJlKGNvbXBhcmF0b3IsIGEsIGIpIHtcbiAgICB2YXIgY29tcCA9IGNvbXBhcmF0b3IoYiwgYSk7XG4gICAgLy8gYiBpcyBjb25zaWRlcmVkIHRoZSBuZXcgbWF4IGlmIHRoZSBjb21wYXJhdG9yIGRlY2xhcmVzIHRoZW0gZXF1YWwsIGJ1dFxuICAgIC8vIHRoZXkgYXJlIG5vdCBlcXVhbCBhbmQgYiBpcyBpbiBmYWN0IGEgbnVsbGlzaCB2YWx1ZS5cbiAgICByZXR1cm4gKFxuICAgICAgKGNvbXAgPT09IDAgJiYgYiAhPT0gYSAmJiAoYiA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IG51bGwgfHwgYiAhPT0gYikpIHx8XG4gICAgICBjb21wID4gMFxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiB6aXBXaXRoRmFjdG9yeShrZXlJdGVyLCB6aXBwZXIsIGl0ZXJzLCB6aXBBbGwpIHtcbiAgICB2YXIgemlwU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2Uoa2V5SXRlcik7XG4gICAgdmFyIHNpemVzID0gbmV3IEFycmF5U2VxKGl0ZXJzKS5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkuc2l6ZTsgfSk7XG4gICAgemlwU2VxdWVuY2Uuc2l6ZSA9IHppcEFsbCA/IHNpemVzLm1heCgpIDogc2l6ZXMubWluKCk7XG4gICAgLy8gTm90ZTogdGhpcyBhIGdlbmVyaWMgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBfX2l0ZXJhdGUgaW4gdGVybXMgb2ZcbiAgICAvLyBfX2l0ZXJhdG9yIHdoaWNoIG1heSBiZSBtb3JlIGdlbmVyaWNhbGx5IHVzZWZ1bCBpbiB0aGUgZnV0dXJlLlxuICAgIHppcFNlcXVlbmNlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIChmbiwgcmV2ZXJzZSkge1xuICAgICAgLyogZ2VuZXJpYzpcbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMsIHJldmVyc2UpO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgaWYgKGZuKHN0ZXAudmFsdWVbMV0sIHN0ZXAudmFsdWVbMF0sIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICAgICovXG4gICAgICAvLyBpbmRleGVkOlxuICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBpZiAoZm4oc3RlcC52YWx1ZSwgaXRlcmF0aW9ucysrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcbiAgICB6aXBTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbiAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGl0ZXJhdG9ycyA9IGl0ZXJzLm1hcChcbiAgICAgICAgZnVuY3Rpb24gKGkpIHsgcmV0dXJuICgoaSA9IENvbGxlY3Rpb24oaSkpLCBnZXRJdGVyYXRvcihyZXZlcnNlID8gaS5yZXZlcnNlKCkgOiBpKSk7IH1cbiAgICAgICk7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB2YXIgaXNEb25lID0gZmFsc2U7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0ZXBzO1xuICAgICAgICBpZiAoIWlzRG9uZSkge1xuICAgICAgICAgIHN0ZXBzID0gaXRlcmF0b3JzLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gaS5uZXh0KCk7IH0pO1xuICAgICAgICAgIGlzRG9uZSA9IHppcEFsbCA/IHN0ZXBzLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLmRvbmU7IH0pIDogc3RlcHMuc29tZShmdW5jdGlvbiAocykgeyByZXR1cm4gcy5kb25lOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEb25lKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgaXRlcmF0aW9ucysrLFxuICAgICAgICAgIHppcHBlci5hcHBseShcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBzdGVwcy5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudmFsdWU7IH0pXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gemlwU2VxdWVuY2U7XG4gIH1cblxuICAvLyAjcHJhZ21hIEhlbHBlciBGdW5jdGlvbnNcblxuICBmdW5jdGlvbiByZWlmeShpdGVyLCBzZXEpIHtcbiAgICByZXR1cm4gaXRlciA9PT0gc2VxID8gaXRlciA6IGlzU2VxKGl0ZXIpID8gc2VxIDogaXRlci5jb25zdHJ1Y3RvcihzZXEpO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVFbnRyeShlbnRyeSkge1xuICAgIGlmIChlbnRyeSAhPT0gT2JqZWN0KGVudHJ5KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgW0ssIFZdIHR1cGxlOiAnICsgZW50cnkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbGxlY3Rpb25DbGFzcyhjb2xsZWN0aW9uKSB7XG4gICAgcmV0dXJuIGlzS2V5ZWQoY29sbGVjdGlvbilcbiAgICAgID8gS2V5ZWRDb2xsZWN0aW9uXG4gICAgICA6IGlzSW5kZXhlZChjb2xsZWN0aW9uKVxuICAgICAgPyBJbmRleGVkQ29sbGVjdGlvblxuICAgICAgOiBTZXRDb2xsZWN0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZVNlcXVlbmNlKGNvbGxlY3Rpb24pIHtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShcbiAgICAgIChpc0tleWVkKGNvbGxlY3Rpb24pXG4gICAgICAgID8gS2V5ZWRTZXFcbiAgICAgICAgOiBpc0luZGV4ZWQoY29sbGVjdGlvbilcbiAgICAgICAgPyBJbmRleGVkU2VxXG4gICAgICAgIDogU2V0U2VxXG4gICAgICApLnByb3RvdHlwZVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBjYWNoZVJlc3VsdFRocm91Z2goKSB7XG4gICAgaWYgKHRoaXMuX2l0ZXIuY2FjaGVSZXN1bHQpIHtcbiAgICAgIHRoaXMuX2l0ZXIuY2FjaGVSZXN1bHQoKTtcbiAgICAgIHRoaXMuc2l6ZSA9IHRoaXMuX2l0ZXIuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU2VxLnByb3RvdHlwZS5jYWNoZVJlc3VsdC5jYWxsKHRoaXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdENvbXBhcmF0b3IoYSwgYikge1xuICAgIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gYXJyQ29weShhcnIsIG9mZnNldCkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgIHZhciBsZW4gPSBNYXRoLm1heCgwLCBhcnIubGVuZ3RoIC0gb2Zmc2V0KTtcbiAgICB2YXIgbmV3QXJyID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGxlbjsgaWkrKykge1xuICAgICAgbmV3QXJyW2lpXSA9IGFycltpaSArIG9mZnNldF07XG4gICAgfVxuICAgIHJldHVybiBuZXdBcnI7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBlcnJvcikge1xuICAgIGlmICghY29uZGl0aW9uKSB7IHRocm93IG5ldyBFcnJvcihlcnJvcik7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vdEluZmluaXRlKHNpemUpIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBzaXplICE9PSBJbmZpbml0eSxcbiAgICAgICdDYW5ub3QgcGVyZm9ybSB0aGlzIGFjdGlvbiB3aXRoIGFuIGluZmluaXRlIHNpemUuJ1xuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBjb2VyY2VLZXlQYXRoKGtleVBhdGgpIHtcbiAgICBpZiAoaXNBcnJheUxpa2Uoa2V5UGF0aCkgJiYgdHlwZW9mIGtleVBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4ga2V5UGF0aDtcbiAgICB9XG4gICAgaWYgKGlzT3JkZXJlZChrZXlQYXRoKSkge1xuICAgICAgcmV0dXJuIGtleVBhdGgudG9BcnJheSgpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ0ludmFsaWQga2V5UGF0aDogZXhwZWN0ZWQgT3JkZXJlZCBDb2xsZWN0aW9uIG9yIEFycmF5OiAnICsga2V5UGF0aFxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBpc1BsYWluT2JqKHZhbHVlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHZhbHVlICYmXG4gICAgICAodHlwZW9mIHZhbHVlLmNvbnN0cnVjdG9yICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIHBvdGVudGlhbGx5LXBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmUsIGVpdGhlclxuICAgKiBwcm92aWRlZCBieSBJbW11dGFibGUuanMgb3IgYSBwbGFpbiBBcnJheSBvciBPYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBpc0RhdGFTdHJ1Y3R1cmUodmFsdWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgKGlzSW1tdXRhYmxlKHZhbHVlKSB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqKHZhbHVlKSlcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gcXVvdGVTdHJpbmcodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgOiBTdHJpbmcodmFsdWUpO1xuICAgIH0gY2F0Y2ggKF9pZ25vcmVFcnJvcikge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYXMoY29sbGVjdGlvbiwga2V5KSB7XG4gICAgcmV0dXJuIGlzSW1tdXRhYmxlKGNvbGxlY3Rpb24pXG4gICAgICA/IGNvbGxlY3Rpb24uaGFzKGtleSlcbiAgICAgIDogaXNEYXRhU3RydWN0dXJlKGNvbGxlY3Rpb24pICYmIGhhc093blByb3BlcnR5LmNhbGwoY29sbGVjdGlvbiwga2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldChjb2xsZWN0aW9uLCBrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIGlzSW1tdXRhYmxlKGNvbGxlY3Rpb24pXG4gICAgICA/IGNvbGxlY3Rpb24uZ2V0KGtleSwgbm90U2V0VmFsdWUpXG4gICAgICA6ICFoYXMoY29sbGVjdGlvbiwga2V5KVxuICAgICAgPyBub3RTZXRWYWx1ZVxuICAgICAgOiB0eXBlb2YgY29sbGVjdGlvbi5nZXQgPT09ICdmdW5jdGlvbidcbiAgICAgID8gY29sbGVjdGlvbi5nZXQoa2V5KVxuICAgICAgOiBjb2xsZWN0aW9uW2tleV07XG4gIH1cblxuICBmdW5jdGlvbiBzaGFsbG93Q29weShmcm9tKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZnJvbSkpIHtcbiAgICAgIHJldHVybiBhcnJDb3B5KGZyb20pO1xuICAgIH1cbiAgICB2YXIgdG8gPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuICAgICAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG87XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmUoY29sbGVjdGlvbiwga2V5KSB7XG4gICAgaWYgKCFpc0RhdGFTdHJ1Y3R1cmUoY29sbGVjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdDYW5ub3QgdXBkYXRlIG5vbi1kYXRhLXN0cnVjdHVyZSB2YWx1ZTogJyArIGNvbGxlY3Rpb25cbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpc0ltbXV0YWJsZShjb2xsZWN0aW9uKSkge1xuICAgICAgaWYgKCFjb2xsZWN0aW9uLnJlbW92ZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdDYW5ub3QgdXBkYXRlIGltbXV0YWJsZSB2YWx1ZSB3aXRob3V0IC5yZW1vdmUoKSBtZXRob2Q6ICcgKyBjb2xsZWN0aW9uXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5yZW1vdmUoa2V5KTtcbiAgICB9XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbGxlY3Rpb24sIGtleSkpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICB2YXIgY29sbGVjdGlvbkNvcHkgPSBzaGFsbG93Q29weShjb2xsZWN0aW9uKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb2xsZWN0aW9uQ29weSkpIHtcbiAgICAgIGNvbGxlY3Rpb25Db3B5LnNwbGljZShrZXksIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgY29sbGVjdGlvbkNvcHlba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb25Db3B5O1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0KGNvbGxlY3Rpb24sIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzRGF0YVN0cnVjdHVyZShjb2xsZWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCB1cGRhdGUgbm9uLWRhdGEtc3RydWN0dXJlIHZhbHVlOiAnICsgY29sbGVjdGlvblxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGlzSW1tdXRhYmxlKGNvbGxlY3Rpb24pKSB7XG4gICAgICBpZiAoIWNvbGxlY3Rpb24uc2V0KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ0Nhbm5vdCB1cGRhdGUgaW1tdXRhYmxlIHZhbHVlIHdpdGhvdXQgLnNldCgpIG1ldGhvZDogJyArIGNvbGxlY3Rpb25cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29sbGVjdGlvbiwga2V5KSAmJiB2YWx1ZSA9PT0gY29sbGVjdGlvbltrZXldKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgdmFyIGNvbGxlY3Rpb25Db3B5ID0gc2hhbGxvd0NvcHkoY29sbGVjdGlvbik7XG4gICAgY29sbGVjdGlvbkNvcHlba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBjb2xsZWN0aW9uQ29weTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUluKGNvbGxlY3Rpb24sIGtleVBhdGgsIG5vdFNldFZhbHVlLCB1cGRhdGVyKSB7XG4gICAgaWYgKCF1cGRhdGVyKSB7XG4gICAgICB1cGRhdGVyID0gbm90U2V0VmFsdWU7XG4gICAgICBub3RTZXRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIHVwZGF0ZWRWYWx1ZSA9IHVwZGF0ZUluRGVlcGx5KFxuICAgICAgaXNJbW11dGFibGUoY29sbGVjdGlvbiksXG4gICAgICBjb2xsZWN0aW9uLFxuICAgICAgY29lcmNlS2V5UGF0aChrZXlQYXRoKSxcbiAgICAgIDAsXG4gICAgICBub3RTZXRWYWx1ZSxcbiAgICAgIHVwZGF0ZXJcbiAgICApO1xuICAgIHJldHVybiB1cGRhdGVkVmFsdWUgPT09IE5PVF9TRVQgPyBub3RTZXRWYWx1ZSA6IHVwZGF0ZWRWYWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUluRGVlcGx5KFxuICAgIGluSW1tdXRhYmxlLFxuICAgIGV4aXN0aW5nLFxuICAgIGtleVBhdGgsXG4gICAgaSxcbiAgICBub3RTZXRWYWx1ZSxcbiAgICB1cGRhdGVyXG4gICkge1xuICAgIHZhciB3YXNOb3RTZXQgPSBleGlzdGluZyA9PT0gTk9UX1NFVDtcbiAgICBpZiAoaSA9PT0ga2V5UGF0aC5sZW5ndGgpIHtcbiAgICAgIHZhciBleGlzdGluZ1ZhbHVlID0gd2FzTm90U2V0ID8gbm90U2V0VmFsdWUgOiBleGlzdGluZztcbiAgICAgIHZhciBuZXdWYWx1ZSA9IHVwZGF0ZXIoZXhpc3RpbmdWYWx1ZSk7XG4gICAgICByZXR1cm4gbmV3VmFsdWUgPT09IGV4aXN0aW5nVmFsdWUgPyBleGlzdGluZyA6IG5ld1ZhbHVlO1xuICAgIH1cbiAgICBpZiAoIXdhc05vdFNldCAmJiAhaXNEYXRhU3RydWN0dXJlKGV4aXN0aW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCB1cGRhdGUgd2l0aGluIG5vbi1kYXRhLXN0cnVjdHVyZSB2YWx1ZSBpbiBwYXRoIFsnICtcbiAgICAgICAgICBrZXlQYXRoLnNsaWNlKDAsIGkpLm1hcChxdW90ZVN0cmluZykgK1xuICAgICAgICAgICddOiAnICtcbiAgICAgICAgICBleGlzdGluZ1xuICAgICAgKTtcbiAgICB9XG4gICAgdmFyIGtleSA9IGtleVBhdGhbaV07XG4gICAgdmFyIG5leHRFeGlzdGluZyA9IHdhc05vdFNldCA/IE5PVF9TRVQgOiBnZXQoZXhpc3RpbmcsIGtleSwgTk9UX1NFVCk7XG4gICAgdmFyIG5leHRVcGRhdGVkID0gdXBkYXRlSW5EZWVwbHkoXG4gICAgICBuZXh0RXhpc3RpbmcgPT09IE5PVF9TRVQgPyBpbkltbXV0YWJsZSA6IGlzSW1tdXRhYmxlKG5leHRFeGlzdGluZyksXG4gICAgICBuZXh0RXhpc3RpbmcsXG4gICAgICBrZXlQYXRoLFxuICAgICAgaSArIDEsXG4gICAgICBub3RTZXRWYWx1ZSxcbiAgICAgIHVwZGF0ZXJcbiAgICApO1xuICAgIHJldHVybiBuZXh0VXBkYXRlZCA9PT0gbmV4dEV4aXN0aW5nXG4gICAgICA/IGV4aXN0aW5nXG4gICAgICA6IG5leHRVcGRhdGVkID09PSBOT1RfU0VUXG4gICAgICA/IHJlbW92ZShleGlzdGluZywga2V5KVxuICAgICAgOiBzZXQoXG4gICAgICAgICAgd2FzTm90U2V0ID8gKGluSW1tdXRhYmxlID8gZW1wdHlNYXAoKSA6IHt9KSA6IGV4aXN0aW5nLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBuZXh0VXBkYXRlZFxuICAgICAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0SW4oY29sbGVjdGlvbiwga2V5UGF0aCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdXBkYXRlSW4oY29sbGVjdGlvbiwga2V5UGF0aCwgTk9UX1NFVCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWU7IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0SW4kMShrZXlQYXRoLCB2KSB7XG4gICAgcmV0dXJuIHNldEluKHRoaXMsIGtleVBhdGgsIHYpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlSW4oY29sbGVjdGlvbiwga2V5UGF0aCkge1xuICAgIHJldHVybiB1cGRhdGVJbihjb2xsZWN0aW9uLCBrZXlQYXRoLCBmdW5jdGlvbiAoKSB7IHJldHVybiBOT1RfU0VUOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUluKGtleVBhdGgpIHtcbiAgICByZXR1cm4gcmVtb3ZlSW4odGhpcywga2V5UGF0aCk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGUoY29sbGVjdGlvbiwga2V5LCBub3RTZXRWYWx1ZSwgdXBkYXRlcikge1xuICAgIHJldHVybiB1cGRhdGVJbihjb2xsZWN0aW9uLCBba2V5XSwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlJDEoa2V5LCBub3RTZXRWYWx1ZSwgdXBkYXRlcikge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgICA/IGtleSh0aGlzKVxuICAgICAgOiB1cGRhdGUodGhpcywga2V5LCBub3RTZXRWYWx1ZSwgdXBkYXRlcik7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVJbiQxKGtleVBhdGgsIG5vdFNldFZhbHVlLCB1cGRhdGVyKSB7XG4gICAgcmV0dXJuIHVwZGF0ZUluKHRoaXMsIGtleVBhdGgsIG5vdFNldFZhbHVlLCB1cGRhdGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlKCkge1xuICAgIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgcmV0dXJuIG1lcmdlSW50b0tleWVkV2l0aCh0aGlzLCBpdGVycyk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZVdpdGgobWVyZ2VyKSB7XG4gICAgdmFyIGl0ZXJzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgIHdoaWxlICggbGVuLS0gPiAwICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgICBpZiAodHlwZW9mIG1lcmdlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtZXJnZXIgZnVuY3Rpb246ICcgKyBtZXJnZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VJbnRvS2V5ZWRXaXRoKHRoaXMsIGl0ZXJzLCBtZXJnZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VJbnRvS2V5ZWRXaXRoKGNvbGxlY3Rpb24sIGNvbGxlY3Rpb25zLCBtZXJnZXIpIHtcbiAgICB2YXIgaXRlcnMgPSBbXTtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgY29sbGVjdGlvbnMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICB2YXIgY29sbGVjdGlvbiQxID0gS2V5ZWRDb2xsZWN0aW9uKGNvbGxlY3Rpb25zW2lpXSk7XG4gICAgICBpZiAoY29sbGVjdGlvbiQxLnNpemUgIT09IDApIHtcbiAgICAgICAgaXRlcnMucHVzaChjb2xsZWN0aW9uJDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgY29sbGVjdGlvbi50b1NlcSgpLnNpemUgPT09IDAgJiZcbiAgICAgICFjb2xsZWN0aW9uLl9fb3duZXJJRCAmJlxuICAgICAgaXRlcnMubGVuZ3RoID09PSAxXG4gICAgKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5jb25zdHJ1Y3RvcihpdGVyc1swXSk7XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBtZXJnZUludG9Db2xsZWN0aW9uID0gbWVyZ2VyXG4gICAgICAgID8gZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIHVwZGF0ZShjb2xsZWN0aW9uLCBrZXksIE5PVF9TRVQsIGZ1bmN0aW9uIChvbGRWYWwpIHsgcmV0dXJuIG9sZFZhbCA9PT0gTk9UX1NFVCA/IHZhbHVlIDogbWVyZ2VyKG9sZFZhbCwgdmFsdWUsIGtleSk7IH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICA6IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICB9O1xuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGl0ZXJzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICBpdGVyc1tpaV0uZm9yRWFjaChtZXJnZUludG9Db2xsZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlJDEoY29sbGVjdGlvbikge1xuICAgIHZhciBzb3VyY2VzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgIHdoaWxlICggbGVuLS0gPiAwICkgc291cmNlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICAgIHJldHVybiBtZXJnZVdpdGhTb3VyY2VzKGNvbGxlY3Rpb24sIHNvdXJjZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VXaXRoJDEobWVyZ2VyLCBjb2xsZWN0aW9uKSB7XG4gICAgdmFyIHNvdXJjZXMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgd2hpbGUgKCBsZW4tLSA+IDAgKSBzb3VyY2VzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMiBdO1xuXG4gICAgcmV0dXJuIG1lcmdlV2l0aFNvdXJjZXMoY29sbGVjdGlvbiwgc291cmNlcywgbWVyZ2VyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcChjb2xsZWN0aW9uKSB7XG4gICAgdmFyIHNvdXJjZXMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKCBsZW4tLSA+IDAgKSBzb3VyY2VzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gICAgcmV0dXJuIG1lcmdlRGVlcFdpdGhTb3VyY2VzKGNvbGxlY3Rpb24sIHNvdXJjZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VEZWVwV2l0aChtZXJnZXIsIGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgc291cmNlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICB3aGlsZSAoIGxlbi0tID4gMCApIHNvdXJjZXNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAyIF07XG5cbiAgICByZXR1cm4gbWVyZ2VEZWVwV2l0aFNvdXJjZXMoY29sbGVjdGlvbiwgc291cmNlcywgbWVyZ2VyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcFdpdGhTb3VyY2VzKGNvbGxlY3Rpb24sIHNvdXJjZXMsIG1lcmdlcikge1xuICAgIHJldHVybiBtZXJnZVdpdGhTb3VyY2VzKGNvbGxlY3Rpb24sIHNvdXJjZXMsIGRlZXBNZXJnZXJXaXRoKG1lcmdlcikpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VXaXRoU291cmNlcyhjb2xsZWN0aW9uLCBzb3VyY2VzLCBtZXJnZXIpIHtcbiAgICBpZiAoIWlzRGF0YVN0cnVjdHVyZShjb2xsZWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCBtZXJnZSBpbnRvIG5vbi1kYXRhLXN0cnVjdHVyZSB2YWx1ZTogJyArIGNvbGxlY3Rpb25cbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpc0ltbXV0YWJsZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBtZXJnZXIgPT09ICdmdW5jdGlvbicgJiYgY29sbGVjdGlvbi5tZXJnZVdpdGhcbiAgICAgICAgPyBjb2xsZWN0aW9uLm1lcmdlV2l0aC5hcHBseShjb2xsZWN0aW9uLCBbIG1lcmdlciBdLmNvbmNhdCggc291cmNlcyApKVxuICAgICAgICA6IGNvbGxlY3Rpb24ubWVyZ2VcbiAgICAgICAgPyBjb2xsZWN0aW9uLm1lcmdlLmFwcGx5KGNvbGxlY3Rpb24sIHNvdXJjZXMpXG4gICAgICAgIDogY29sbGVjdGlvbi5jb25jYXQuYXBwbHkoY29sbGVjdGlvbiwgc291cmNlcyk7XG4gICAgfVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShjb2xsZWN0aW9uKTtcbiAgICB2YXIgbWVyZ2VkID0gY29sbGVjdGlvbjtcbiAgICB2YXIgQ29sbGVjdGlvbiA9IGlzQXJyYXkgPyBJbmRleGVkQ29sbGVjdGlvbiA6IEtleWVkQ29sbGVjdGlvbjtcbiAgICB2YXIgbWVyZ2VJdGVtID0gaXNBcnJheVxuICAgICAgPyBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAvLyBDb3B5IG9uIHdyaXRlXG4gICAgICAgICAgaWYgKG1lcmdlZCA9PT0gY29sbGVjdGlvbikge1xuICAgICAgICAgICAgbWVyZ2VkID0gc2hhbGxvd0NvcHkobWVyZ2VkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWVyZ2VkLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICA6IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgdmFyIGhhc1ZhbCA9IGhhc093blByb3BlcnR5LmNhbGwobWVyZ2VkLCBrZXkpO1xuICAgICAgICAgIHZhciBuZXh0VmFsID1cbiAgICAgICAgICAgIGhhc1ZhbCAmJiBtZXJnZXIgPyBtZXJnZXIobWVyZ2VkW2tleV0sIHZhbHVlLCBrZXkpIDogdmFsdWU7XG4gICAgICAgICAgaWYgKCFoYXNWYWwgfHwgbmV4dFZhbCAhPT0gbWVyZ2VkW2tleV0pIHtcbiAgICAgICAgICAgIC8vIENvcHkgb24gd3JpdGVcbiAgICAgICAgICAgIGlmIChtZXJnZWQgPT09IGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgbWVyZ2VkID0gc2hhbGxvd0NvcHkobWVyZ2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lcmdlZFtrZXldID0gbmV4dFZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBDb2xsZWN0aW9uKHNvdXJjZXNbaV0pLmZvckVhY2gobWVyZ2VJdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZXBNZXJnZXJXaXRoKG1lcmdlcikge1xuICAgIGZ1bmN0aW9uIGRlZXBNZXJnZXIob2xkVmFsdWUsIG5ld1ZhbHVlLCBrZXkpIHtcbiAgICAgIHJldHVybiBpc0RhdGFTdHJ1Y3R1cmUob2xkVmFsdWUpICYmIGlzRGF0YVN0cnVjdHVyZShuZXdWYWx1ZSlcbiAgICAgICAgPyBtZXJnZVdpdGhTb3VyY2VzKG9sZFZhbHVlLCBbbmV3VmFsdWVdLCBkZWVwTWVyZ2VyKVxuICAgICAgICA6IG1lcmdlclxuICAgICAgICA/IG1lcmdlcihvbGRWYWx1ZSwgbmV3VmFsdWUsIGtleSlcbiAgICAgICAgOiBuZXdWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZXBNZXJnZXI7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZURlZXAkMSgpIHtcbiAgICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHJldHVybiBtZXJnZURlZXBXaXRoU291cmNlcyh0aGlzLCBpdGVycyk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZURlZXBXaXRoJDEobWVyZ2VyKSB7XG4gICAgdmFyIGl0ZXJzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICAgIHdoaWxlICggbGVuLS0gPiAwICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgICByZXR1cm4gbWVyZ2VEZWVwV2l0aFNvdXJjZXModGhpcywgaXRlcnMsIG1lcmdlcik7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZUluKGtleVBhdGgpIHtcbiAgICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKCBsZW4tLSA+IDAgKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICAgIHJldHVybiB1cGRhdGVJbih0aGlzLCBrZXlQYXRoLCBlbXB0eU1hcCgpLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gbWVyZ2VXaXRoU291cmNlcyhtLCBpdGVycyk7IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VEZWVwSW4oa2V5UGF0aCkge1xuICAgIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoIGxlbi0tID4gMCApIGl0ZXJzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gICAgcmV0dXJuIHVwZGF0ZUluKHRoaXMsIGtleVBhdGgsIGVtcHR5TWFwKCksIGZ1bmN0aW9uIChtKSB7IHJldHVybiBtZXJnZURlZXBXaXRoU291cmNlcyhtLCBpdGVycyk7IH1cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gd2l0aE11dGF0aW9ucyhmbikge1xuICAgIHZhciBtdXRhYmxlID0gdGhpcy5hc011dGFibGUoKTtcbiAgICBmbihtdXRhYmxlKTtcbiAgICByZXR1cm4gbXV0YWJsZS53YXNBbHRlcmVkKCkgPyBtdXRhYmxlLl9fZW5zdXJlT3duZXIodGhpcy5fX293bmVySUQpIDogdGhpcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzTXV0YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX293bmVySUQgPyB0aGlzIDogdGhpcy5fX2Vuc3VyZU93bmVyKG5ldyBPd25lcklEKCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNJbW11dGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19lbnN1cmVPd25lcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FzQWx0ZXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2FsdGVyZWQ7XG4gIH1cblxuICB2YXIgTWFwID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoS2V5ZWRDb2xsZWN0aW9uKSB7XG4gICAgZnVuY3Rpb24gTWFwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGVtcHR5TWFwKClcbiAgICAgICAgOiBpc01hcCh2YWx1ZSkgJiYgIWlzT3JkZXJlZCh2YWx1ZSlcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IGVtcHR5TWFwKCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICB2YXIgaXRlciA9IEtleWVkQ29sbGVjdGlvbih2YWx1ZSk7XG4gICAgICAgICAgICBhc3NlcnROb3RJbmZpbml0ZShpdGVyLnNpemUpO1xuICAgICAgICAgICAgaXRlci5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBtYXAuc2V0KGssIHYpOyB9KTtcbiAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIEtleWVkQ29sbGVjdGlvbiApIE1hcC5fX3Byb3RvX18gPSBLZXllZENvbGxlY3Rpb247XG4gICAgTWFwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEtleWVkQ29sbGVjdGlvbiAmJiBLZXllZENvbGxlY3Rpb24ucHJvdG90eXBlICk7XG4gICAgTWFwLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1hcDtcblxuICAgIE1hcC5vZiA9IGZ1bmN0aW9uIG9mICgpIHtcbiAgICAgIHZhciBrZXlWYWx1ZXMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBrZXlWYWx1ZXNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgcmV0dXJuIGVtcHR5TWFwKCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5VmFsdWVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgaWYgKGkgKyAxID49IGtleVZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB2YWx1ZSBmb3Iga2V5OiAnICsga2V5VmFsdWVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFwLnNldChrZXlWYWx1ZXNbaV0sIGtleVZhbHVlc1tpICsgMV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ01hcCB7JywgJ30nKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICAgIE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChrLCBub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RcbiAgICAgICAgPyB0aGlzLl9yb290LmdldCgwLCB1bmRlZmluZWQsIGssIG5vdFNldFZhbHVlKVxuICAgICAgICA6IG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG4gICAgTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKGssIHYpIHtcbiAgICAgIHJldHVybiB1cGRhdGVNYXAodGhpcywgaywgdik7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlIChrKSB7XG4gICAgICByZXR1cm4gdXBkYXRlTWFwKHRoaXMsIGssIE5PVF9TRVQpO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLmRlbGV0ZUFsbCA9IGZ1bmN0aW9uIGRlbGV0ZUFsbCAoa2V5cykge1xuICAgICAgdmFyIGNvbGxlY3Rpb24gPSBDb2xsZWN0aW9uKGtleXMpO1xuXG4gICAgICBpZiAoY29sbGVjdGlvbi5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgY29sbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIG1hcC5yZW1vdmUoa2V5KTsgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5TWFwKCk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQ29tcG9zaXRpb25cblxuICAgIE1hcC5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uIHNvcnQgKGNvbXBhcmF0b3IpIHtcbiAgICAgIC8vIExhdGUgYmluZGluZ1xuICAgICAgcmV0dXJuIE9yZGVyZWRNYXAoc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvcikpO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLnNvcnRCeSA9IGZ1bmN0aW9uIHNvcnRCeSAobWFwcGVyLCBjb21wYXJhdG9yKSB7XG4gICAgICAvLyBMYXRlIGJpbmRpbmdcbiAgICAgIHJldHVybiBPcmRlcmVkTWFwKHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IsIG1hcHBlcikpO1xuICAgIH07XG5cbiAgICBNYXAucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCAobWFwcGVyLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgbWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICBtYXAuc2V0KGtleSwgbWFwcGVyLmNhbGwoY29udGV4dCwgdmFsdWUsIGtleSwgbWFwKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTXV0YWJpbGl0eVxuXG4gICAgTWFwLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIG5ldyBNYXBJdGVyYXRvcih0aGlzLCB0eXBlLCByZXZlcnNlKTtcbiAgICB9O1xuXG4gICAgTWFwLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdGhpcy5fcm9vdCAmJlxuICAgICAgICB0aGlzLl9yb290Lml0ZXJhdGUoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICAgIHJldHVybiBmbihlbnRyeVsxXSwgZW50cnlbMF0sIHRoaXMkMSk7XG4gICAgICAgIH0sIHJldmVyc2UpO1xuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcblxuICAgIE1hcC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uIF9fZW5zdXJlT3duZXIgKG93bmVySUQpIHtcbiAgICAgIGlmIChvd25lcklEID09PSB0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICghb3duZXJJRCkge1xuICAgICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGVtcHR5TWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuICAgICAgICB0aGlzLl9fYWx0ZXJlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlTWFwKHRoaXMuc2l6ZSwgdGhpcy5fcm9vdCwgb3duZXJJRCwgdGhpcy5fX2hhc2gpO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWFwO1xuICB9KEtleWVkQ29sbGVjdGlvbikpO1xuXG4gIE1hcC5pc01hcCA9IGlzTWFwO1xuXG4gIHZhciBNYXBQcm90b3R5cGUgPSBNYXAucHJvdG90eXBlO1xuICBNYXBQcm90b3R5cGVbSVNfTUFQX1NZTUJPTF0gPSB0cnVlO1xuICBNYXBQcm90b3R5cGVbREVMRVRFXSA9IE1hcFByb3RvdHlwZS5yZW1vdmU7XG4gIE1hcFByb3RvdHlwZS5yZW1vdmVBbGwgPSBNYXBQcm90b3R5cGUuZGVsZXRlQWxsO1xuICBNYXBQcm90b3R5cGUuc2V0SW4gPSBzZXRJbiQxO1xuICBNYXBQcm90b3R5cGUucmVtb3ZlSW4gPSBNYXBQcm90b3R5cGUuZGVsZXRlSW4gPSBkZWxldGVJbjtcbiAgTWFwUHJvdG90eXBlLnVwZGF0ZSA9IHVwZGF0ZSQxO1xuICBNYXBQcm90b3R5cGUudXBkYXRlSW4gPSB1cGRhdGVJbiQxO1xuICBNYXBQcm90b3R5cGUubWVyZ2UgPSBNYXBQcm90b3R5cGUuY29uY2F0ID0gbWVyZ2U7XG4gIE1hcFByb3RvdHlwZS5tZXJnZVdpdGggPSBtZXJnZVdpdGg7XG4gIE1hcFByb3RvdHlwZS5tZXJnZURlZXAgPSBtZXJnZURlZXAkMTtcbiAgTWFwUHJvdG90eXBlLm1lcmdlRGVlcFdpdGggPSBtZXJnZURlZXBXaXRoJDE7XG4gIE1hcFByb3RvdHlwZS5tZXJnZUluID0gbWVyZ2VJbjtcbiAgTWFwUHJvdG90eXBlLm1lcmdlRGVlcEluID0gbWVyZ2VEZWVwSW47XG4gIE1hcFByb3RvdHlwZS53aXRoTXV0YXRpb25zID0gd2l0aE11dGF0aW9ucztcbiAgTWFwUHJvdG90eXBlLndhc0FsdGVyZWQgPSB3YXNBbHRlcmVkO1xuICBNYXBQcm90b3R5cGUuYXNJbW11dGFibGUgPSBhc0ltbXV0YWJsZTtcbiAgTWFwUHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gTWFwUHJvdG90eXBlLmFzTXV0YWJsZSA9IGFzTXV0YWJsZTtcbiAgTWFwUHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgYXJyKSB7XG4gICAgcmV0dXJuIHJlc3VsdC5zZXQoYXJyWzBdLCBhcnJbMV0pO1xuICB9O1xuICBNYXBQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqLmFzSW1tdXRhYmxlKCk7XG4gIH07XG5cbiAgLy8gI3ByYWdtYSBUcmllIE5vZGVzXG5cbiAgdmFyIEFycmF5TWFwTm9kZSA9IGZ1bmN0aW9uIEFycmF5TWFwTm9kZShvd25lcklELCBlbnRyaWVzKSB7XG4gICAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICB9O1xuXG4gIEFycmF5TWFwTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICAgIGZvciAodmFyIGlpID0gMCwgbGVuID0gZW50cmllcy5sZW5ndGg7IGlpIDwgbGVuOyBpaSsrKSB7XG4gICAgICBpZiAoaXMoa2V5LCBlbnRyaWVzW2lpXVswXSkpIHtcbiAgICAgICAgcmV0dXJuIGVudHJpZXNbaWldWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm90U2V0VmFsdWU7XG4gIH07XG5cbiAgQXJyYXlNYXBOb2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcikge1xuICAgIHZhciByZW1vdmVkID0gdmFsdWUgPT09IE5PVF9TRVQ7XG5cbiAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgICB2YXIgaWR4ID0gMDtcbiAgICB2YXIgbGVuID0gZW50cmllcy5sZW5ndGg7XG4gICAgZm9yICg7IGlkeCA8IGxlbjsgaWR4KyspIHtcbiAgICAgIGlmIChpcyhrZXksIGVudHJpZXNbaWR4XVswXSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBleGlzdHMgPSBpZHggPCBsZW47XG5cbiAgICBpZiAoZXhpc3RzID8gZW50cmllc1tpZHhdWzFdID09PSB2YWx1ZSA6IHJlbW92ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIFNldFJlZihkaWRBbHRlcik7XG4gICAgKHJlbW92ZWQgfHwgIWV4aXN0cykgJiYgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuXG4gICAgaWYgKHJlbW92ZWQgJiYgZW50cmllcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgaWYgKCFleGlzdHMgJiYgIXJlbW92ZWQgJiYgZW50cmllcy5sZW5ndGggPj0gTUFYX0FSUkFZX01BUF9TSVpFKSB7XG4gICAgICByZXR1cm4gY3JlYXRlTm9kZXMob3duZXJJRCwgZW50cmllcywga2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgdmFyIGlzRWRpdGFibGUgPSBvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRDtcbiAgICB2YXIgbmV3RW50cmllcyA9IGlzRWRpdGFibGUgPyBlbnRyaWVzIDogYXJyQ29weShlbnRyaWVzKTtcblxuICAgIGlmIChleGlzdHMpIHtcbiAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgIGlkeCA9PT0gbGVuIC0gMVxuICAgICAgICAgID8gbmV3RW50cmllcy5wb3AoKVxuICAgICAgICAgIDogKG5ld0VudHJpZXNbaWR4XSA9IG5ld0VudHJpZXMucG9wKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3RW50cmllc1tpZHhdID0gW2tleSwgdmFsdWVdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdFbnRyaWVzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICB9XG5cbiAgICBpZiAoaXNFZGl0YWJsZSkge1xuICAgICAgdGhpcy5lbnRyaWVzID0gbmV3RW50cmllcztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQXJyYXlNYXBOb2RlKG93bmVySUQsIG5ld0VudHJpZXMpO1xuICB9O1xuXG4gIHZhciBCaXRtYXBJbmRleGVkTm9kZSA9IGZ1bmN0aW9uIEJpdG1hcEluZGV4ZWROb2RlKG93bmVySUQsIGJpdG1hcCwgbm9kZXMpIHtcbiAgICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xuICAgIHRoaXMuYml0bWFwID0gYml0bWFwO1xuICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgfTtcblxuICBCaXRtYXBJbmRleGVkTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICAgIGlmIChrZXlIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gICAgfVxuICAgIHZhciBiaXQgPSAxIDw8ICgoc2hpZnQgPT09IDAgPyBrZXlIYXNoIDoga2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSyk7XG4gICAgdmFyIGJpdG1hcCA9IHRoaXMuYml0bWFwO1xuICAgIHJldHVybiAoYml0bWFwICYgYml0KSA9PT0gMFxuICAgICAgPyBub3RTZXRWYWx1ZVxuICAgICAgOiB0aGlzLm5vZGVzW3BvcENvdW50KGJpdG1hcCAmIChiaXQgLSAxKSldLmdldChcbiAgICAgICAgICBzaGlmdCArIFNISUZULFxuICAgICAgICAgIGtleUhhc2gsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIG5vdFNldFZhbHVlXG4gICAgICAgICk7XG4gIH07XG5cbiAgQml0bWFwSW5kZXhlZE5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKSB7XG4gICAgaWYgKGtleUhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAga2V5SGFzaCA9IGhhc2goa2V5KTtcbiAgICB9XG4gICAgdmFyIGtleUhhc2hGcmFnID0gKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG4gICAgdmFyIGJpdCA9IDEgPDwga2V5SGFzaEZyYWc7XG4gICAgdmFyIGJpdG1hcCA9IHRoaXMuYml0bWFwO1xuICAgIHZhciBleGlzdHMgPSAoYml0bWFwICYgYml0KSAhPT0gMDtcblxuICAgIGlmICghZXhpc3RzICYmIHZhbHVlID09PSBOT1RfU0VUKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgaWR4ID0gcG9wQ291bnQoYml0bWFwICYgKGJpdCAtIDEpKTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICAgIHZhciBub2RlID0gZXhpc3RzID8gbm9kZXNbaWR4XSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbmV3Tm9kZSA9IHVwZGF0ZU5vZGUoXG4gICAgICBub2RlLFxuICAgICAgb3duZXJJRCxcbiAgICAgIHNoaWZ0ICsgU0hJRlQsXG4gICAgICBrZXlIYXNoLFxuICAgICAga2V5LFxuICAgICAgdmFsdWUsXG4gICAgICBkaWRDaGFuZ2VTaXplLFxuICAgICAgZGlkQWx0ZXJcbiAgICApO1xuXG4gICAgaWYgKG5ld05vZGUgPT09IG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICghZXhpc3RzICYmIG5ld05vZGUgJiYgbm9kZXMubGVuZ3RoID49IE1BWF9CSVRNQVBfSU5ERVhFRF9TSVpFKSB7XG4gICAgICByZXR1cm4gZXhwYW5kTm9kZXMob3duZXJJRCwgbm9kZXMsIGJpdG1hcCwga2V5SGFzaEZyYWcsIG5ld05vZGUpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGV4aXN0cyAmJlxuICAgICAgIW5ld05vZGUgJiZcbiAgICAgIG5vZGVzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgaXNMZWFmTm9kZShub2Rlc1tpZHggXiAxXSlcbiAgICApIHtcbiAgICAgIHJldHVybiBub2Rlc1tpZHggXiAxXTtcbiAgICB9XG5cbiAgICBpZiAoZXhpc3RzICYmIG5ld05vZGUgJiYgbm9kZXMubGVuZ3RoID09PSAxICYmIGlzTGVhZk5vZGUobmV3Tm9kZSkpIHtcbiAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgIH1cblxuICAgIHZhciBpc0VkaXRhYmxlID0gb3duZXJJRCAmJiBvd25lcklEID09PSB0aGlzLm93bmVySUQ7XG4gICAgdmFyIG5ld0JpdG1hcCA9IGV4aXN0cyA/IChuZXdOb2RlID8gYml0bWFwIDogYml0bWFwIF4gYml0KSA6IGJpdG1hcCB8IGJpdDtcbiAgICB2YXIgbmV3Tm9kZXMgPSBleGlzdHNcbiAgICAgID8gbmV3Tm9kZVxuICAgICAgICA/IHNldEF0KG5vZGVzLCBpZHgsIG5ld05vZGUsIGlzRWRpdGFibGUpXG4gICAgICAgIDogc3BsaWNlT3V0KG5vZGVzLCBpZHgsIGlzRWRpdGFibGUpXG4gICAgICA6IHNwbGljZUluKG5vZGVzLCBpZHgsIG5ld05vZGUsIGlzRWRpdGFibGUpO1xuXG4gICAgaWYgKGlzRWRpdGFibGUpIHtcbiAgICAgIHRoaXMuYml0bWFwID0gbmV3Qml0bWFwO1xuICAgICAgdGhpcy5ub2RlcyA9IG5ld05vZGVzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCBuZXdCaXRtYXAsIG5ld05vZGVzKTtcbiAgfTtcblxuICB2YXIgSGFzaEFycmF5TWFwTm9kZSA9IGZ1bmN0aW9uIEhhc2hBcnJheU1hcE5vZGUob3duZXJJRCwgY291bnQsIG5vZGVzKSB7XG4gICAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgICB0aGlzLmNvdW50ID0gY291bnQ7XG4gICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICB9O1xuXG4gIEhhc2hBcnJheU1hcE5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoc2hpZnQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXlIYXNoID0gaGFzaChrZXkpO1xuICAgIH1cbiAgICB2YXIgaWR4ID0gKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVzW2lkeF07XG4gICAgcmV0dXJuIG5vZGVcbiAgICAgID8gbm9kZS5nZXQoc2hpZnQgKyBTSElGVCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSlcbiAgICAgIDogbm90U2V0VmFsdWU7XG4gIH07XG5cbiAgSGFzaEFycmF5TWFwTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXlIYXNoID0gaGFzaChrZXkpO1xuICAgIH1cbiAgICB2YXIgaWR4ID0gKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG4gICAgdmFyIHJlbW92ZWQgPSB2YWx1ZSA9PT0gTk9UX1NFVDtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICAgIHZhciBub2RlID0gbm9kZXNbaWR4XTtcblxuICAgIGlmIChyZW1vdmVkICYmICFub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgbmV3Tm9kZSA9IHVwZGF0ZU5vZGUoXG4gICAgICBub2RlLFxuICAgICAgb3duZXJJRCxcbiAgICAgIHNoaWZ0ICsgU0hJRlQsXG4gICAgICBrZXlIYXNoLFxuICAgICAga2V5LFxuICAgICAgdmFsdWUsXG4gICAgICBkaWRDaGFuZ2VTaXplLFxuICAgICAgZGlkQWx0ZXJcbiAgICApO1xuICAgIGlmIChuZXdOb2RlID09PSBub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgbmV3Q291bnQgPSB0aGlzLmNvdW50O1xuICAgIGlmICghbm9kZSkge1xuICAgICAgbmV3Q291bnQrKztcbiAgICB9IGVsc2UgaWYgKCFuZXdOb2RlKSB7XG4gICAgICBuZXdDb3VudC0tO1xuICAgICAgaWYgKG5ld0NvdW50IDwgTUlOX0hBU0hfQVJSQVlfTUFQX1NJWkUpIHtcbiAgICAgICAgcmV0dXJuIHBhY2tOb2Rlcyhvd25lcklELCBub2RlcywgbmV3Q291bnQsIGlkeCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGlzRWRpdGFibGUgPSBvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRDtcbiAgICB2YXIgbmV3Tm9kZXMgPSBzZXRBdChub2RlcywgaWR4LCBuZXdOb2RlLCBpc0VkaXRhYmxlKTtcblxuICAgIGlmIChpc0VkaXRhYmxlKSB7XG4gICAgICB0aGlzLmNvdW50ID0gbmV3Q291bnQ7XG4gICAgICB0aGlzLm5vZGVzID0gbmV3Tm9kZXM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEhhc2hBcnJheU1hcE5vZGUob3duZXJJRCwgbmV3Q291bnQsIG5ld05vZGVzKTtcbiAgfTtcblxuICB2YXIgSGFzaENvbGxpc2lvbk5vZGUgPSBmdW5jdGlvbiBIYXNoQ29sbGlzaW9uTm9kZShvd25lcklELCBrZXlIYXNoLCBlbnRyaWVzKSB7XG4gICAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgICB0aGlzLmtleUhhc2ggPSBrZXlIYXNoO1xuICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gIH07XG5cbiAgSGFzaENvbGxpc2lvbk5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoc2hpZnQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgICBmb3IgKHZhciBpaSA9IDAsIGxlbiA9IGVudHJpZXMubGVuZ3RoOyBpaSA8IGxlbjsgaWkrKykge1xuICAgICAgaWYgKGlzKGtleSwgZW50cmllc1tpaV1bMF0pKSB7XG4gICAgICAgIHJldHVybiBlbnRyaWVzW2lpXVsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICB9O1xuXG4gIEhhc2hDb2xsaXNpb25Ob2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcikge1xuICAgIGlmIChrZXlIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gICAgfVxuXG4gICAgdmFyIHJlbW92ZWQgPSB2YWx1ZSA9PT0gTk9UX1NFVDtcblxuICAgIGlmIChrZXlIYXNoICE9PSB0aGlzLmtleUhhc2gpIHtcbiAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgU2V0UmVmKGRpZEFsdGVyKTtcbiAgICAgIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcbiAgICAgIHJldHVybiBtZXJnZUludG9Ob2RlKHRoaXMsIG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBba2V5LCB2YWx1ZV0pO1xuICAgIH1cblxuICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICAgIHZhciBpZHggPSAwO1xuICAgIHZhciBsZW4gPSBlbnRyaWVzLmxlbmd0aDtcbiAgICBmb3IgKDsgaWR4IDwgbGVuOyBpZHgrKykge1xuICAgICAgaWYgKGlzKGtleSwgZW50cmllc1tpZHhdWzBdKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGV4aXN0cyA9IGlkeCA8IGxlbjtcblxuICAgIGlmIChleGlzdHMgPyBlbnRyaWVzW2lkeF1bMV0gPT09IHZhbHVlIDogcmVtb3ZlZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgU2V0UmVmKGRpZEFsdGVyKTtcbiAgICAocmVtb3ZlZCB8fCAhZXhpc3RzKSAmJiBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG5cbiAgICBpZiAocmVtb3ZlZCAmJiBsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBuZXcgVmFsdWVOb2RlKG93bmVySUQsIHRoaXMua2V5SGFzaCwgZW50cmllc1tpZHggXiAxXSk7XG4gICAgfVxuXG4gICAgdmFyIGlzRWRpdGFibGUgPSBvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRDtcbiAgICB2YXIgbmV3RW50cmllcyA9IGlzRWRpdGFibGUgPyBlbnRyaWVzIDogYXJyQ29weShlbnRyaWVzKTtcblxuICAgIGlmIChleGlzdHMpIHtcbiAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgIGlkeCA9PT0gbGVuIC0gMVxuICAgICAgICAgID8gbmV3RW50cmllcy5wb3AoKVxuICAgICAgICAgIDogKG5ld0VudHJpZXNbaWR4XSA9IG5ld0VudHJpZXMucG9wKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3RW50cmllc1tpZHhdID0gW2tleSwgdmFsdWVdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdFbnRyaWVzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICB9XG5cbiAgICBpZiAoaXNFZGl0YWJsZSkge1xuICAgICAgdGhpcy5lbnRyaWVzID0gbmV3RW50cmllcztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSGFzaENvbGxpc2lvbk5vZGUob3duZXJJRCwgdGhpcy5rZXlIYXNoLCBuZXdFbnRyaWVzKTtcbiAgfTtcblxuICB2YXIgVmFsdWVOb2RlID0gZnVuY3Rpb24gVmFsdWVOb2RlKG93bmVySUQsIGtleUhhc2gsIGVudHJ5KSB7XG4gICAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgICB0aGlzLmtleUhhc2ggPSBrZXlIYXNoO1xuICAgIHRoaXMuZW50cnkgPSBlbnRyeTtcbiAgfTtcblxuICBWYWx1ZU5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoc2hpZnQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gaXMoa2V5LCB0aGlzLmVudHJ5WzBdKSA/IHRoaXMuZW50cnlbMV0gOiBub3RTZXRWYWx1ZTtcbiAgfTtcblxuICBWYWx1ZU5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAob3duZXJJRCwgc2hpZnQsIGtleUhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZVNpemUsIGRpZEFsdGVyKSB7XG4gICAgdmFyIHJlbW92ZWQgPSB2YWx1ZSA9PT0gTk9UX1NFVDtcbiAgICB2YXIga2V5TWF0Y2ggPSBpcyhrZXksIHRoaXMuZW50cnlbMF0pO1xuICAgIGlmIChrZXlNYXRjaCA/IHZhbHVlID09PSB0aGlzLmVudHJ5WzFdIDogcmVtb3ZlZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgU2V0UmVmKGRpZEFsdGVyKTtcblxuICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG4gICAgICByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGlmIChrZXlNYXRjaCkge1xuICAgICAgaWYgKG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEKSB7XG4gICAgICAgIHRoaXMuZW50cnlbMV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFZhbHVlTm9kZShvd25lcklELCB0aGlzLmtleUhhc2gsIFtrZXksIHZhbHVlXSk7XG4gICAgfVxuXG4gICAgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuICAgIHJldHVybiBtZXJnZUludG9Ob2RlKHRoaXMsIG93bmVySUQsIHNoaWZ0LCBoYXNoKGtleSksIFtrZXksIHZhbHVlXSk7XG4gIH07XG5cbiAgLy8gI3ByYWdtYSBJdGVyYXRvcnNcblxuICBBcnJheU1hcE5vZGUucHJvdG90eXBlLml0ZXJhdGUgPSBIYXNoQ29sbGlzaW9uTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9XG4gICAgZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgICAgIGZvciAodmFyIGlpID0gMCwgbWF4SW5kZXggPSBlbnRyaWVzLmxlbmd0aCAtIDE7IGlpIDw9IG1heEluZGV4OyBpaSsrKSB7XG4gICAgICAgIGlmIChmbihlbnRyaWVzW3JldmVyc2UgPyBtYXhJbmRleCAtIGlpIDogaWldKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gIEJpdG1hcEluZGV4ZWROb2RlLnByb3RvdHlwZS5pdGVyYXRlID0gSGFzaEFycmF5TWFwTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9XG4gICAgZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICAgICAgZm9yICh2YXIgaWkgPSAwLCBtYXhJbmRleCA9IG5vZGVzLmxlbmd0aCAtIDE7IGlpIDw9IG1heEluZGV4OyBpaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbcmV2ZXJzZSA/IG1heEluZGV4IC0gaWkgOiBpaV07XG4gICAgICAgIGlmIChub2RlICYmIG5vZGUuaXRlcmF0ZShmbiwgcmV2ZXJzZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgVmFsdWVOb2RlLnByb3RvdHlwZS5pdGVyYXRlID0gZnVuY3Rpb24gKGZuLCByZXZlcnNlKSB7XG4gICAgcmV0dXJuIGZuKHRoaXMuZW50cnkpO1xuICB9O1xuXG4gIHZhciBNYXBJdGVyYXRvciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEl0ZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gTWFwSXRlcmF0b3IobWFwLCB0eXBlLCByZXZlcnNlKSB7XG4gICAgICB0aGlzLl90eXBlID0gdHlwZTtcbiAgICAgIHRoaXMuX3JldmVyc2UgPSByZXZlcnNlO1xuICAgICAgdGhpcy5fc3RhY2sgPSBtYXAuX3Jvb3QgJiYgbWFwSXRlcmF0b3JGcmFtZShtYXAuX3Jvb3QpO1xuICAgIH1cblxuICAgIGlmICggSXRlcmF0b3IgKSBNYXBJdGVyYXRvci5fX3Byb3RvX18gPSBJdGVyYXRvcjtcbiAgICBNYXBJdGVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJdGVyYXRvciAmJiBJdGVyYXRvci5wcm90b3R5cGUgKTtcbiAgICBNYXBJdGVyYXRvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNYXBJdGVyYXRvcjtcblxuICAgIE1hcEl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gbmV4dCAoKSB7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMuX3R5cGU7XG4gICAgICB2YXIgc3RhY2sgPSB0aGlzLl9zdGFjaztcbiAgICAgIHdoaWxlIChzdGFjaykge1xuICAgICAgICB2YXIgbm9kZSA9IHN0YWNrLm5vZGU7XG4gICAgICAgIHZhciBpbmRleCA9IHN0YWNrLmluZGV4Kys7XG4gICAgICAgIHZhciBtYXhJbmRleCA9ICh2b2lkIDApO1xuICAgICAgICBpZiAobm9kZS5lbnRyeSkge1xuICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcEl0ZXJhdG9yVmFsdWUodHlwZSwgbm9kZS5lbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuZW50cmllcykge1xuICAgICAgICAgIG1heEluZGV4ID0gbm9kZS5lbnRyaWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgaWYgKGluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwSXRlcmF0b3JWYWx1ZShcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgbm9kZS5lbnRyaWVzW3RoaXMuX3JldmVyc2UgPyBtYXhJbmRleCAtIGluZGV4IDogaW5kZXhdXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXhJbmRleCA9IG5vZGUubm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICBpZiAoaW5kZXggPD0gbWF4SW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBzdWJOb2RlID0gbm9kZS5ub2Rlc1t0aGlzLl9yZXZlcnNlID8gbWF4SW5kZXggLSBpbmRleCA6IGluZGV4XTtcbiAgICAgICAgICAgIGlmIChzdWJOb2RlKSB7XG4gICAgICAgICAgICAgIGlmIChzdWJOb2RlLmVudHJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcEl0ZXJhdG9yVmFsdWUodHlwZSwgc3ViTm9kZS5lbnRyeSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhY2sgPSB0aGlzLl9zdGFjayA9IG1hcEl0ZXJhdG9yRnJhbWUoc3ViTm9kZSwgc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrID0gdGhpcy5fc3RhY2sgPSB0aGlzLl9zdGFjay5fX3ByZXY7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBNYXBJdGVyYXRvcjtcbiAgfShJdGVyYXRvcikpO1xuXG4gIGZ1bmN0aW9uIG1hcEl0ZXJhdG9yVmFsdWUodHlwZSwgZW50cnkpIHtcbiAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwSXRlcmF0b3JGcmFtZShub2RlLCBwcmV2KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGU6IG5vZGUsXG4gICAgICBpbmRleDogMCxcbiAgICAgIF9fcHJldjogcHJldixcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZU1hcChzaXplLCByb290LCBvd25lcklELCBoYXNoKSB7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUoTWFwUHJvdG90eXBlKTtcbiAgICBtYXAuc2l6ZSA9IHNpemU7XG4gICAgbWFwLl9yb290ID0gcm9vdDtcbiAgICBtYXAuX19vd25lcklEID0gb3duZXJJRDtcbiAgICBtYXAuX19oYXNoID0gaGFzaDtcbiAgICBtYXAuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuXG4gIHZhciBFTVBUWV9NQVA7XG4gIGZ1bmN0aW9uIGVtcHR5TWFwKCkge1xuICAgIHJldHVybiBFTVBUWV9NQVAgfHwgKEVNUFRZX01BUCA9IG1ha2VNYXAoMCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTWFwKG1hcCwgaywgdikge1xuICAgIHZhciBuZXdSb290O1xuICAgIHZhciBuZXdTaXplO1xuICAgIGlmICghbWFwLl9yb290KSB7XG4gICAgICBpZiAodiA9PT0gTk9UX1NFVCkge1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgfVxuICAgICAgbmV3U2l6ZSA9IDE7XG4gICAgICBuZXdSb290ID0gbmV3IEFycmF5TWFwTm9kZShtYXAuX19vd25lcklELCBbW2ssIHZdXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaWRDaGFuZ2VTaXplID0gTWFrZVJlZigpO1xuICAgICAgdmFyIGRpZEFsdGVyID0gTWFrZVJlZigpO1xuICAgICAgbmV3Um9vdCA9IHVwZGF0ZU5vZGUoXG4gICAgICAgIG1hcC5fcm9vdCxcbiAgICAgICAgbWFwLl9fb3duZXJJRCxcbiAgICAgICAgMCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBrLFxuICAgICAgICB2LFxuICAgICAgICBkaWRDaGFuZ2VTaXplLFxuICAgICAgICBkaWRBbHRlclxuICAgICAgKTtcbiAgICAgIGlmICghZGlkQWx0ZXIudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgIH1cbiAgICAgIG5ld1NpemUgPSBtYXAuc2l6ZSArIChkaWRDaGFuZ2VTaXplLnZhbHVlID8gKHYgPT09IE5PVF9TRVQgPyAtMSA6IDEpIDogMCk7XG4gICAgfVxuICAgIGlmIChtYXAuX19vd25lcklEKSB7XG4gICAgICBtYXAuc2l6ZSA9IG5ld1NpemU7XG4gICAgICBtYXAuX3Jvb3QgPSBuZXdSb290O1xuICAgICAgbWFwLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgIG1hcC5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1Jvb3QgPyBtYWtlTWFwKG5ld1NpemUsIG5ld1Jvb3QpIDogZW1wdHlNYXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZU5vZGUoXG4gICAgbm9kZSxcbiAgICBvd25lcklELFxuICAgIHNoaWZ0LFxuICAgIGtleUhhc2gsXG4gICAga2V5LFxuICAgIHZhbHVlLFxuICAgIGRpZENoYW5nZVNpemUsXG4gICAgZGlkQWx0ZXJcbiAgKSB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IE5PVF9TRVQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICBTZXRSZWYoZGlkQWx0ZXIpO1xuICAgICAgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuICAgICAgcmV0dXJuIG5ldyBWYWx1ZU5vZGUob3duZXJJRCwga2V5SGFzaCwgW2tleSwgdmFsdWVdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUudXBkYXRlKFxuICAgICAgb3duZXJJRCxcbiAgICAgIHNoaWZ0LFxuICAgICAga2V5SGFzaCxcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlLFxuICAgICAgZGlkQ2hhbmdlU2l6ZSxcbiAgICAgIGRpZEFsdGVyXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTGVhZk5vZGUobm9kZSkge1xuICAgIHJldHVybiAoXG4gICAgICBub2RlLmNvbnN0cnVjdG9yID09PSBWYWx1ZU5vZGUgfHwgbm9kZS5jb25zdHJ1Y3RvciA9PT0gSGFzaENvbGxpc2lvbk5vZGVcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VJbnRvTm9kZShub2RlLCBvd25lcklELCBzaGlmdCwga2V5SGFzaCwgZW50cnkpIHtcbiAgICBpZiAobm9kZS5rZXlIYXNoID09PSBrZXlIYXNoKSB7XG4gICAgICByZXR1cm4gbmV3IEhhc2hDb2xsaXNpb25Ob2RlKG93bmVySUQsIGtleUhhc2gsIFtub2RlLmVudHJ5LCBlbnRyeV0pO1xuICAgIH1cblxuICAgIHZhciBpZHgxID0gKHNoaWZ0ID09PSAwID8gbm9kZS5rZXlIYXNoIDogbm9kZS5rZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLO1xuICAgIHZhciBpZHgyID0gKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG5cbiAgICB2YXIgbmV3Tm9kZTtcbiAgICB2YXIgbm9kZXMgPVxuICAgICAgaWR4MSA9PT0gaWR4MlxuICAgICAgICA/IFttZXJnZUludG9Ob2RlKG5vZGUsIG93bmVySUQsIHNoaWZ0ICsgU0hJRlQsIGtleUhhc2gsIGVudHJ5KV1cbiAgICAgICAgOiAoKG5ld05vZGUgPSBuZXcgVmFsdWVOb2RlKG93bmVySUQsIGtleUhhc2gsIGVudHJ5KSksXG4gICAgICAgICAgaWR4MSA8IGlkeDIgPyBbbm9kZSwgbmV3Tm9kZV0gOiBbbmV3Tm9kZSwgbm9kZV0pO1xuXG4gICAgcmV0dXJuIG5ldyBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCAoMSA8PCBpZHgxKSB8ICgxIDw8IGlkeDIpLCBub2Rlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2Rlcyhvd25lcklELCBlbnRyaWVzLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKCFvd25lcklEKSB7XG4gICAgICBvd25lcklEID0gbmV3IE93bmVySUQoKTtcbiAgICB9XG4gICAgdmFyIG5vZGUgPSBuZXcgVmFsdWVOb2RlKG93bmVySUQsIGhhc2goa2V5KSwgW2tleSwgdmFsdWVdKTtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgZW50cmllcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaWldO1xuICAgICAgbm9kZSA9IG5vZGUudXBkYXRlKG93bmVySUQsIDAsIHVuZGVmaW5lZCwgZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBwYWNrTm9kZXMob3duZXJJRCwgbm9kZXMsIGNvdW50LCBleGNsdWRpbmcpIHtcbiAgICB2YXIgYml0bWFwID0gMDtcbiAgICB2YXIgcGFja2VkSUkgPSAwO1xuICAgIHZhciBwYWNrZWROb2RlcyA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yICh2YXIgaWkgPSAwLCBiaXQgPSAxLCBsZW4gPSBub2Rlcy5sZW5ndGg7IGlpIDwgbGVuOyBpaSsrLCBiaXQgPDw9IDEpIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaWldO1xuICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCAmJiBpaSAhPT0gZXhjbHVkaW5nKSB7XG4gICAgICAgIGJpdG1hcCB8PSBiaXQ7XG4gICAgICAgIHBhY2tlZE5vZGVzW3BhY2tlZElJKytdID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCBiaXRtYXAsIHBhY2tlZE5vZGVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cGFuZE5vZGVzKG93bmVySUQsIG5vZGVzLCBiaXRtYXAsIGluY2x1ZGluZywgbm9kZSkge1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGV4cGFuZGVkTm9kZXMgPSBuZXcgQXJyYXkoU0laRSk7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBiaXRtYXAgIT09IDA7IGlpKyssIGJpdG1hcCA+Pj49IDEpIHtcbiAgICAgIGV4cGFuZGVkTm9kZXNbaWldID0gYml0bWFwICYgMSA/IG5vZGVzW2NvdW50KytdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBleHBhbmRlZE5vZGVzW2luY2x1ZGluZ10gPSBub2RlO1xuICAgIHJldHVybiBuZXcgSGFzaEFycmF5TWFwTm9kZShvd25lcklELCBjb3VudCArIDEsIGV4cGFuZGVkTm9kZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wQ291bnQoeCkge1xuICAgIHggLT0gKHggPj4gMSkgJiAweDU1NTU1NTU1O1xuICAgIHggPSAoeCAmIDB4MzMzMzMzMzMpICsgKCh4ID4+IDIpICYgMHgzMzMzMzMzMyk7XG4gICAgeCA9ICh4ICsgKHggPj4gNCkpICYgMHgwZjBmMGYwZjtcbiAgICB4ICs9IHggPj4gODtcbiAgICB4ICs9IHggPj4gMTY7XG4gICAgcmV0dXJuIHggJiAweDdmO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0QXQoYXJyYXksIGlkeCwgdmFsLCBjYW5FZGl0KSB7XG4gICAgdmFyIG5ld0FycmF5ID0gY2FuRWRpdCA/IGFycmF5IDogYXJyQ29weShhcnJheSk7XG4gICAgbmV3QXJyYXlbaWR4XSA9IHZhbDtcbiAgICByZXR1cm4gbmV3QXJyYXk7XG4gIH1cblxuICBmdW5jdGlvbiBzcGxpY2VJbihhcnJheSwgaWR4LCB2YWwsIGNhbkVkaXQpIHtcbiAgICB2YXIgbmV3TGVuID0gYXJyYXkubGVuZ3RoICsgMTtcbiAgICBpZiAoY2FuRWRpdCAmJiBpZHggKyAxID09PSBuZXdMZW4pIHtcbiAgICAgIGFycmF5W2lkeF0gPSB2YWw7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIHZhciBuZXdBcnJheSA9IG5ldyBBcnJheShuZXdMZW4pO1xuICAgIHZhciBhZnRlciA9IDA7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG5ld0xlbjsgaWkrKykge1xuICAgICAgaWYgKGlpID09PSBpZHgpIHtcbiAgICAgICAgbmV3QXJyYXlbaWldID0gdmFsO1xuICAgICAgICBhZnRlciA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3QXJyYXlbaWldID0gYXJyYXlbaWkgKyBhZnRlcl07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNwbGljZU91dChhcnJheSwgaWR4LCBjYW5FZGl0KSB7XG4gICAgdmFyIG5ld0xlbiA9IGFycmF5Lmxlbmd0aCAtIDE7XG4gICAgaWYgKGNhbkVkaXQgJiYgaWR4ID09PSBuZXdMZW4pIHtcbiAgICAgIGFycmF5LnBvcCgpO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgICB2YXIgbmV3QXJyYXkgPSBuZXcgQXJyYXkobmV3TGVuKTtcbiAgICB2YXIgYWZ0ZXIgPSAwO1xuICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBuZXdMZW47IGlpKyspIHtcbiAgICAgIGlmIChpaSA9PT0gaWR4KSB7XG4gICAgICAgIGFmdGVyID0gMTtcbiAgICAgIH1cbiAgICAgIG5ld0FycmF5W2lpXSA9IGFycmF5W2lpICsgYWZ0ZXJdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3QXJyYXk7XG4gIH1cblxuICB2YXIgTUFYX0FSUkFZX01BUF9TSVpFID0gU0laRSAvIDQ7XG4gIHZhciBNQVhfQklUTUFQX0lOREVYRURfU0laRSA9IFNJWkUgLyAyO1xuICB2YXIgTUlOX0hBU0hfQVJSQVlfTUFQX1NJWkUgPSBTSVpFIC8gNDtcblxuICB2YXIgSVNfTElTVF9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9MSVNUX19AQCc7XG5cbiAgZnVuY3Rpb24gaXNMaXN0KG1heWJlTGlzdCkge1xuICAgIHJldHVybiBCb29sZWFuKG1heWJlTGlzdCAmJiBtYXliZUxpc3RbSVNfTElTVF9TWU1CT0xdKTtcbiAgfVxuXG4gIHZhciBMaXN0ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW5kZXhlZENvbGxlY3Rpb24pIHtcbiAgICBmdW5jdGlvbiBMaXN0KHZhbHVlKSB7XG4gICAgICB2YXIgZW1wdHkgPSBlbXB0eUxpc3QoKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBlbXB0eTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0xpc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyID0gSW5kZXhlZENvbGxlY3Rpb24odmFsdWUpO1xuICAgICAgdmFyIHNpemUgPSBpdGVyLnNpemU7XG4gICAgICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgICB9XG4gICAgICBhc3NlcnROb3RJbmZpbml0ZShzaXplKTtcbiAgICAgIGlmIChzaXplID4gMCAmJiBzaXplIDwgU0laRSkge1xuICAgICAgICByZXR1cm4gbWFrZUxpc3QoMCwgc2l6ZSwgU0hJRlQsIG51bGwsIG5ldyBWTm9kZShpdGVyLnRvQXJyYXkoKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5LndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgbGlzdC5zZXRTaXplKHNpemUpO1xuICAgICAgICBpdGVyLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHsgcmV0dXJuIGxpc3Quc2V0KGksIHYpOyB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICggSW5kZXhlZENvbGxlY3Rpb24gKSBMaXN0Ll9fcHJvdG9fXyA9IEluZGV4ZWRDb2xsZWN0aW9uO1xuICAgIExpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW5kZXhlZENvbGxlY3Rpb24gJiYgSW5kZXhlZENvbGxlY3Rpb24ucHJvdG90eXBlICk7XG4gICAgTGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaXN0O1xuXG4gICAgTGlzdC5vZiA9IGZ1bmN0aW9uIG9mICgvKi4uLnZhbHVlcyovKSB7XG4gICAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ0xpc3QgWycsICddJyk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgICBMaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgICAgaW5kZXggPSB3cmFwSW5kZXgodGhpcywgaW5kZXgpO1xuICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLnNpemUpIHtcbiAgICAgICAgaW5kZXggKz0gdGhpcy5fb3JpZ2luO1xuICAgICAgICB2YXIgbm9kZSA9IGxpc3ROb2RlRm9yKHRoaXMsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5hcnJheVtpbmRleCAmIE1BU0tdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG4gICAgTGlzdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0IChpbmRleCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB1cGRhdGVMaXN0KHRoaXMsIGluZGV4LCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoaW5kZXgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5oYXMoaW5kZXgpXG4gICAgICAgID8gdGhpc1xuICAgICAgICA6IGluZGV4ID09PSAwXG4gICAgICAgID8gdGhpcy5zaGlmdCgpXG4gICAgICAgIDogaW5kZXggPT09IHRoaXMuc2l6ZSAtIDFcbiAgICAgICAgPyB0aGlzLnBvcCgpXG4gICAgICAgIDogdGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiBpbnNlcnQgKGluZGV4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3BsaWNlKGluZGV4LCAwLCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICB0aGlzLnNpemUgPSB0aGlzLl9vcmlnaW4gPSB0aGlzLl9jYXBhY2l0eSA9IDA7XG4gICAgICAgIHRoaXMuX2xldmVsID0gU0hJRlQ7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSB0aGlzLl90YWlsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlMaXN0KCk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoICgvKi4uLnZhbHVlcyovKSB7XG4gICAgICB2YXIgdmFsdWVzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIG9sZFNpemUgPSB0aGlzLnNpemU7XG4gICAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgIHNldExpc3RCb3VuZHMobGlzdCwgMCwgb2xkU2l6ZSArIHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdmFsdWVzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgIGxpc3Quc2V0KG9sZFNpemUgKyBpaSwgdmFsdWVzW2lpXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiBwb3AgKCkge1xuICAgICAgcmV0dXJuIHNldExpc3RCb3VuZHModGhpcywgMCwgLTEpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCAoLyouLi52YWx1ZXMqLykge1xuICAgICAgdmFyIHZhbHVlcyA9IGFyZ3VtZW50cztcbiAgICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgc2V0TGlzdEJvdW5kcyhsaXN0LCAtdmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCB2YWx1ZXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgICAgbGlzdC5zZXQoaWksIHZhbHVlc1tpaV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCAoKSB7XG4gICAgICByZXR1cm4gc2V0TGlzdEJvdW5kcyh0aGlzLCAxKTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBDb21wb3NpdGlvblxuXG4gICAgTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0ICgvKi4uLmNvbGxlY3Rpb25zKi8pIHtcbiAgICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgICAgdmFyIHNlcXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhcmd1bWVudCA9IGFyZ3VtZW50cyQxW2ldO1xuICAgICAgICB2YXIgc2VxID0gSW5kZXhlZENvbGxlY3Rpb24oXG4gICAgICAgICAgdHlwZW9mIGFyZ3VtZW50ICE9PSAnc3RyaW5nJyAmJiBoYXNJdGVyYXRvcihhcmd1bWVudClcbiAgICAgICAgICAgID8gYXJndW1lbnRcbiAgICAgICAgICAgIDogW2FyZ3VtZW50XVxuICAgICAgICApO1xuICAgICAgICBpZiAoc2VxLnNpemUgIT09IDApIHtcbiAgICAgICAgICBzZXFzLnB1c2goc2VxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNlcXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCAmJiAhdGhpcy5fX293bmVySUQgJiYgc2Vxcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3Ioc2Vxc1swXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgIHNlcXMuZm9yRWFjaChmdW5jdGlvbiAoc2VxKSB7IHJldHVybiBzZXEuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGxpc3QucHVzaCh2YWx1ZSk7IH0pOyB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24gc2V0U2l6ZSAoc2l6ZSkge1xuICAgICAgcmV0dXJuIHNldExpc3RCb3VuZHModGhpcywgMCwgc2l6ZSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCAobWFwcGVyLCBjb250ZXh0KSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMkMS5zaXplOyBpKyspIHtcbiAgICAgICAgICBsaXN0LnNldChpLCBtYXBwZXIuY2FsbChjb250ZXh0LCBsaXN0LmdldChpKSwgaSwgbGlzdCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gQHByYWdtYSBJdGVyYXRpb25cblxuICAgIExpc3QucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKGJlZ2luLCBlbmQpIHtcbiAgICAgIHZhciBzaXplID0gdGhpcy5zaXplO1xuICAgICAgaWYgKHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgc2l6ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0TGlzdEJvdW5kcyhcbiAgICAgICAgdGhpcyxcbiAgICAgICAgcmVzb2x2ZUJlZ2luKGJlZ2luLCBzaXplKSxcbiAgICAgICAgcmVzb2x2ZUVuZChlbmQsIHNpemUpXG4gICAgICApO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGluZGV4ID0gcmV2ZXJzZSA/IHRoaXMuc2l6ZSA6IDA7XG4gICAgICB2YXIgdmFsdWVzID0gaXRlcmF0ZUxpc3QodGhpcywgcmV2ZXJzZSk7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzKCk7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gRE9ORVxuICAgICAgICAgID8gaXRlcmF0b3JEb25lKClcbiAgICAgICAgICA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgcmV2ZXJzZSA/IC0taW5kZXggOiBpbmRleCsrLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGluZGV4ID0gcmV2ZXJzZSA/IHRoaXMuc2l6ZSA6IDA7XG4gICAgICB2YXIgdmFsdWVzID0gaXRlcmF0ZUxpc3QodGhpcywgcmV2ZXJzZSk7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICB3aGlsZSAoKHZhbHVlID0gdmFsdWVzKCkpICE9PSBET05FKSB7XG4gICAgICAgIGlmIChmbih2YWx1ZSwgcmV2ZXJzZSA/IC0taW5kZXggOiBpbmRleCsrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24gX19lbnN1cmVPd25lciAob3duZXJJRCkge1xuICAgICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKCFvd25lcklEKSB7XG4gICAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZW1wdHlMaXN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuICAgICAgICB0aGlzLl9fYWx0ZXJlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlTGlzdChcbiAgICAgICAgdGhpcy5fb3JpZ2luLFxuICAgICAgICB0aGlzLl9jYXBhY2l0eSxcbiAgICAgICAgdGhpcy5fbGV2ZWwsXG4gICAgICAgIHRoaXMuX3Jvb3QsXG4gICAgICAgIHRoaXMuX3RhaWwsXG4gICAgICAgIG93bmVySUQsXG4gICAgICAgIHRoaXMuX19oYXNoXG4gICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gTGlzdDtcbiAgfShJbmRleGVkQ29sbGVjdGlvbikpO1xuXG4gIExpc3QuaXNMaXN0ID0gaXNMaXN0O1xuXG4gIHZhciBMaXN0UHJvdG90eXBlID0gTGlzdC5wcm90b3R5cGU7XG4gIExpc3RQcm90b3R5cGVbSVNfTElTVF9TWU1CT0xdID0gdHJ1ZTtcbiAgTGlzdFByb3RvdHlwZVtERUxFVEVdID0gTGlzdFByb3RvdHlwZS5yZW1vdmU7XG4gIExpc3RQcm90b3R5cGUubWVyZ2UgPSBMaXN0UHJvdG90eXBlLmNvbmNhdDtcbiAgTGlzdFByb3RvdHlwZS5zZXRJbiA9IHNldEluJDE7XG4gIExpc3RQcm90b3R5cGUuZGVsZXRlSW4gPSBMaXN0UHJvdG90eXBlLnJlbW92ZUluID0gZGVsZXRlSW47XG4gIExpc3RQcm90b3R5cGUudXBkYXRlID0gdXBkYXRlJDE7XG4gIExpc3RQcm90b3R5cGUudXBkYXRlSW4gPSB1cGRhdGVJbiQxO1xuICBMaXN0UHJvdG90eXBlLm1lcmdlSW4gPSBtZXJnZUluO1xuICBMaXN0UHJvdG90eXBlLm1lcmdlRGVlcEluID0gbWVyZ2VEZWVwSW47XG4gIExpc3RQcm90b3R5cGUud2l0aE11dGF0aW9ucyA9IHdpdGhNdXRhdGlvbnM7XG4gIExpc3RQcm90b3R5cGUud2FzQWx0ZXJlZCA9IHdhc0FsdGVyZWQ7XG4gIExpc3RQcm90b3R5cGUuYXNJbW11dGFibGUgPSBhc0ltbXV0YWJsZTtcbiAgTGlzdFByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IExpc3RQcm90b3R5cGUuYXNNdXRhYmxlID0gYXNNdXRhYmxlO1xuICBMaXN0UHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgYXJyKSB7XG4gICAgcmV0dXJuIHJlc3VsdC5wdXNoKGFycik7XG4gIH07XG4gIExpc3RQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqLmFzSW1tdXRhYmxlKCk7XG4gIH07XG5cbiAgdmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUoYXJyYXksIG93bmVySUQpIHtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gICAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgfTtcblxuICAvLyBUT0RPOiBzZWVtcyBsaWtlIHRoZXNlIG1ldGhvZHMgYXJlIHZlcnkgc2ltaWxhclxuXG4gIFZOb2RlLnByb3RvdHlwZS5yZW1vdmVCZWZvcmUgPSBmdW5jdGlvbiByZW1vdmVCZWZvcmUgKG93bmVySUQsIGxldmVsLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gbGV2ZWwgPyAxIDw8IGxldmVsIDogIHRoaXMuYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIG9yaWdpbkluZGV4ID0gKGluZGV4ID4+PiBsZXZlbCkgJiBNQVNLO1xuICAgIGlmIChvcmlnaW5JbmRleCA+PSB0aGlzLmFycmF5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5ldyBWTm9kZShbXSwgb3duZXJJRCk7XG4gICAgfVxuICAgIHZhciByZW1vdmluZ0ZpcnN0ID0gb3JpZ2luSW5kZXggPT09IDA7XG4gICAgdmFyIG5ld0NoaWxkO1xuICAgIGlmIChsZXZlbCA+IDApIHtcbiAgICAgIHZhciBvbGRDaGlsZCA9IHRoaXMuYXJyYXlbb3JpZ2luSW5kZXhdO1xuICAgICAgbmV3Q2hpbGQgPVxuICAgICAgICBvbGRDaGlsZCAmJiBvbGRDaGlsZC5yZW1vdmVCZWZvcmUob3duZXJJRCwgbGV2ZWwgLSBTSElGVCwgaW5kZXgpO1xuICAgICAgaWYgKG5ld0NoaWxkID09PSBvbGRDaGlsZCAmJiByZW1vdmluZ0ZpcnN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVtb3ZpbmdGaXJzdCAmJiAhbmV3Q2hpbGQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgZWRpdGFibGUgPSBlZGl0YWJsZVZOb2RlKHRoaXMsIG93bmVySUQpO1xuICAgIGlmICghcmVtb3ZpbmdGaXJzdCkge1xuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG9yaWdpbkluZGV4OyBpaSsrKSB7XG4gICAgICAgIGVkaXRhYmxlLmFycmF5W2lpXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5ld0NoaWxkKSB7XG4gICAgICBlZGl0YWJsZS5hcnJheVtvcmlnaW5JbmRleF0gPSBuZXdDaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRhYmxlO1xuICB9O1xuXG4gIFZOb2RlLnByb3RvdHlwZS5yZW1vdmVBZnRlciA9IGZ1bmN0aW9uIHJlbW92ZUFmdGVyIChvd25lcklELCBsZXZlbCwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPT09IChsZXZlbCA/IDEgPDwgbGV2ZWwgOiAwKSB8fCB0aGlzLmFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBzaXplSW5kZXggPSAoKGluZGV4IC0gMSkgPj4+IGxldmVsKSAmIE1BU0s7XG4gICAgaWYgKHNpemVJbmRleCA+PSB0aGlzLmFycmF5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIG5ld0NoaWxkO1xuICAgIGlmIChsZXZlbCA+IDApIHtcbiAgICAgIHZhciBvbGRDaGlsZCA9IHRoaXMuYXJyYXlbc2l6ZUluZGV4XTtcbiAgICAgIG5ld0NoaWxkID1cbiAgICAgICAgb2xkQ2hpbGQgJiYgb2xkQ2hpbGQucmVtb3ZlQWZ0ZXIob3duZXJJRCwgbGV2ZWwgLSBTSElGVCwgaW5kZXgpO1xuICAgICAgaWYgKG5ld0NoaWxkID09PSBvbGRDaGlsZCAmJiBzaXplSW5kZXggPT09IHRoaXMuYXJyYXkubGVuZ3RoIC0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZWRpdGFibGUgPSBlZGl0YWJsZVZOb2RlKHRoaXMsIG93bmVySUQpO1xuICAgIGVkaXRhYmxlLmFycmF5LnNwbGljZShzaXplSW5kZXggKyAxKTtcbiAgICBpZiAobmV3Q2hpbGQpIHtcbiAgICAgIGVkaXRhYmxlLmFycmF5W3NpemVJbmRleF0gPSBuZXdDaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRhYmxlO1xuICB9O1xuXG4gIHZhciBET05FID0ge307XG5cbiAgZnVuY3Rpb24gaXRlcmF0ZUxpc3QobGlzdCwgcmV2ZXJzZSkge1xuICAgIHZhciBsZWZ0ID0gbGlzdC5fb3JpZ2luO1xuICAgIHZhciByaWdodCA9IGxpc3QuX2NhcGFjaXR5O1xuICAgIHZhciB0YWlsUG9zID0gZ2V0VGFpbE9mZnNldChyaWdodCk7XG4gICAgdmFyIHRhaWwgPSBsaXN0Ll90YWlsO1xuXG4gICAgcmV0dXJuIGl0ZXJhdGVOb2RlT3JMZWFmKGxpc3QuX3Jvb3QsIGxpc3QuX2xldmVsLCAwKTtcblxuICAgIGZ1bmN0aW9uIGl0ZXJhdGVOb2RlT3JMZWFmKG5vZGUsIGxldmVsLCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBsZXZlbCA9PT0gMFxuICAgICAgICA/IGl0ZXJhdGVMZWFmKG5vZGUsIG9mZnNldClcbiAgICAgICAgOiBpdGVyYXRlTm9kZShub2RlLCBsZXZlbCwgb2Zmc2V0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpdGVyYXRlTGVhZihub2RlLCBvZmZzZXQpIHtcbiAgICAgIHZhciBhcnJheSA9IG9mZnNldCA9PT0gdGFpbFBvcyA/IHRhaWwgJiYgdGFpbC5hcnJheSA6IG5vZGUgJiYgbm9kZS5hcnJheTtcbiAgICAgIHZhciBmcm9tID0gb2Zmc2V0ID4gbGVmdCA/IDAgOiBsZWZ0IC0gb2Zmc2V0O1xuICAgICAgdmFyIHRvID0gcmlnaHQgLSBvZmZzZXQ7XG4gICAgICBpZiAodG8gPiBTSVpFKSB7XG4gICAgICAgIHRvID0gU0laRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgICAgIHJldHVybiBET05FO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpZHggPSByZXZlcnNlID8gLS10byA6IGZyb20rKztcbiAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5W2lkeF07XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGl0ZXJhdGVOb2RlKG5vZGUsIGxldmVsLCBvZmZzZXQpIHtcbiAgICAgIHZhciB2YWx1ZXM7XG4gICAgICB2YXIgYXJyYXkgPSBub2RlICYmIG5vZGUuYXJyYXk7XG4gICAgICB2YXIgZnJvbSA9IG9mZnNldCA+IGxlZnQgPyAwIDogKGxlZnQgLSBvZmZzZXQpID4+IGxldmVsO1xuICAgICAgdmFyIHRvID0gKChyaWdodCAtIG9mZnNldCkgPj4gbGV2ZWwpICsgMTtcbiAgICAgIGlmICh0byA+IFNJWkUpIHtcbiAgICAgICAgdG8gPSBTSVpFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXMoKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gRE9ORSkge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXMgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgICAgIHJldHVybiBET05FO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaWR4ID0gcmV2ZXJzZSA/IC0tdG8gOiBmcm9tKys7XG4gICAgICAgICAgdmFsdWVzID0gaXRlcmF0ZU5vZGVPckxlYWYoXG4gICAgICAgICAgICBhcnJheSAmJiBhcnJheVtpZHhdLFxuICAgICAgICAgICAgbGV2ZWwgLSBTSElGVCxcbiAgICAgICAgICAgIG9mZnNldCArIChpZHggPDwgbGV2ZWwpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlTGlzdChvcmlnaW4sIGNhcGFjaXR5LCBsZXZlbCwgcm9vdCwgdGFpbCwgb3duZXJJRCwgaGFzaCkge1xuICAgIHZhciBsaXN0ID0gT2JqZWN0LmNyZWF0ZShMaXN0UHJvdG90eXBlKTtcbiAgICBsaXN0LnNpemUgPSBjYXBhY2l0eSAtIG9yaWdpbjtcbiAgICBsaXN0Ll9vcmlnaW4gPSBvcmlnaW47XG4gICAgbGlzdC5fY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICBsaXN0Ll9sZXZlbCA9IGxldmVsO1xuICAgIGxpc3QuX3Jvb3QgPSByb290O1xuICAgIGxpc3QuX3RhaWwgPSB0YWlsO1xuICAgIGxpc3QuX19vd25lcklEID0gb3duZXJJRDtcbiAgICBsaXN0Ll9faGFzaCA9IGhhc2g7XG4gICAgbGlzdC5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuXG4gIHZhciBFTVBUWV9MSVNUO1xuICBmdW5jdGlvbiBlbXB0eUxpc3QoKSB7XG4gICAgcmV0dXJuIEVNUFRZX0xJU1QgfHwgKEVNUFRZX0xJU1QgPSBtYWtlTGlzdCgwLCAwLCBTSElGVCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTGlzdChsaXN0LCBpbmRleCwgdmFsdWUpIHtcbiAgICBpbmRleCA9IHdyYXBJbmRleChsaXN0LCBpbmRleCk7XG5cbiAgICBpZiAoaW5kZXggIT09IGluZGV4KSB7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPj0gbGlzdC5zaXplIHx8IGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIGxpc3Qud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICBpbmRleCA8IDBcbiAgICAgICAgICA/IHNldExpc3RCb3VuZHMobGlzdCwgaW5kZXgpLnNldCgwLCB2YWx1ZSlcbiAgICAgICAgICA6IHNldExpc3RCb3VuZHMobGlzdCwgMCwgaW5kZXggKyAxKS5zZXQoaW5kZXgsIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGluZGV4ICs9IGxpc3QuX29yaWdpbjtcblxuICAgIHZhciBuZXdUYWlsID0gbGlzdC5fdGFpbDtcbiAgICB2YXIgbmV3Um9vdCA9IGxpc3QuX3Jvb3Q7XG4gICAgdmFyIGRpZEFsdGVyID0gTWFrZVJlZigpO1xuICAgIGlmIChpbmRleCA+PSBnZXRUYWlsT2Zmc2V0KGxpc3QuX2NhcGFjaXR5KSkge1xuICAgICAgbmV3VGFpbCA9IHVwZGF0ZVZOb2RlKG5ld1RhaWwsIGxpc3QuX19vd25lcklELCAwLCBpbmRleCwgdmFsdWUsIGRpZEFsdGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Um9vdCA9IHVwZGF0ZVZOb2RlKFxuICAgICAgICBuZXdSb290LFxuICAgICAgICBsaXN0Ll9fb3duZXJJRCxcbiAgICAgICAgbGlzdC5fbGV2ZWwsXG4gICAgICAgIGluZGV4LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZGlkQWx0ZXJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFkaWRBbHRlci52YWx1ZSkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgaWYgKGxpc3QuX19vd25lcklEKSB7XG4gICAgICBsaXN0Ll9yb290ID0gbmV3Um9vdDtcbiAgICAgIGxpc3QuX3RhaWwgPSBuZXdUYWlsO1xuICAgICAgbGlzdC5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICBsaXN0Ll9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VMaXN0KGxpc3QuX29yaWdpbiwgbGlzdC5fY2FwYWNpdHksIGxpc3QuX2xldmVsLCBuZXdSb290LCBuZXdUYWlsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVZOb2RlKG5vZGUsIG93bmVySUQsIGxldmVsLCBpbmRleCwgdmFsdWUsIGRpZEFsdGVyKSB7XG4gICAgdmFyIGlkeCA9IChpbmRleCA+Pj4gbGV2ZWwpICYgTUFTSztcbiAgICB2YXIgbm9kZUhhcyA9IG5vZGUgJiYgaWR4IDwgbm9kZS5hcnJheS5sZW5ndGg7XG4gICAgaWYgKCFub2RlSGFzICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIHZhciBuZXdOb2RlO1xuXG4gICAgaWYgKGxldmVsID4gMCkge1xuICAgICAgdmFyIGxvd2VyTm9kZSA9IG5vZGUgJiYgbm9kZS5hcnJheVtpZHhdO1xuICAgICAgdmFyIG5ld0xvd2VyTm9kZSA9IHVwZGF0ZVZOb2RlKFxuICAgICAgICBsb3dlck5vZGUsXG4gICAgICAgIG93bmVySUQsXG4gICAgICAgIGxldmVsIC0gU0hJRlQsXG4gICAgICAgIGluZGV4LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZGlkQWx0ZXJcbiAgICAgICk7XG4gICAgICBpZiAobmV3TG93ZXJOb2RlID09PSBsb3dlck5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICBuZXdOb2RlID0gZWRpdGFibGVWTm9kZShub2RlLCBvd25lcklEKTtcbiAgICAgIG5ld05vZGUuYXJyYXlbaWR4XSA9IG5ld0xvd2VyTm9kZTtcbiAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgIH1cblxuICAgIGlmIChub2RlSGFzICYmIG5vZGUuYXJyYXlbaWR4XSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIGlmIChkaWRBbHRlcikge1xuICAgICAgU2V0UmVmKGRpZEFsdGVyKTtcbiAgICB9XG5cbiAgICBuZXdOb2RlID0gZWRpdGFibGVWTm9kZShub2RlLCBvd25lcklEKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBpZHggPT09IG5ld05vZGUuYXJyYXkubGVuZ3RoIC0gMSkge1xuICAgICAgbmV3Tm9kZS5hcnJheS5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Tm9kZS5hcnJheVtpZHhdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBuZXdOb2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZWRpdGFibGVWTm9kZShub2RlLCBvd25lcklEKSB7XG4gICAgaWYgKG93bmVySUQgJiYgbm9kZSAmJiBvd25lcklEID09PSBub2RlLm93bmVySUQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGUgPyBub2RlLmFycmF5LnNsaWNlKCkgOiBbXSwgb3duZXJJRCk7XG4gIH1cblxuICBmdW5jdGlvbiBsaXN0Tm9kZUZvcihsaXN0LCByYXdJbmRleCkge1xuICAgIGlmIChyYXdJbmRleCA+PSBnZXRUYWlsT2Zmc2V0KGxpc3QuX2NhcGFjaXR5KSkge1xuICAgICAgcmV0dXJuIGxpc3QuX3RhaWw7XG4gICAgfVxuICAgIGlmIChyYXdJbmRleCA8IDEgPDwgKGxpc3QuX2xldmVsICsgU0hJRlQpKSB7XG4gICAgICB2YXIgbm9kZSA9IGxpc3QuX3Jvb3Q7XG4gICAgICB2YXIgbGV2ZWwgPSBsaXN0Ll9sZXZlbDtcbiAgICAgIHdoaWxlIChub2RlICYmIGxldmVsID4gMCkge1xuICAgICAgICBub2RlID0gbm9kZS5hcnJheVsocmF3SW5kZXggPj4+IGxldmVsKSAmIE1BU0tdO1xuICAgICAgICBsZXZlbCAtPSBTSElGVDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldExpc3RCb3VuZHMobGlzdCwgYmVnaW4sIGVuZCkge1xuICAgIC8vIFNhbml0aXplIGJlZ2luICYgZW5kIHVzaW5nIHRoaXMgc2hvcnRoYW5kIGZvciBUb0ludDMyKGFyZ3VtZW50KVxuICAgIC8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2ludDMyXG4gICAgaWYgKGJlZ2luICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJlZ2luIHw9IDA7XG4gICAgfVxuICAgIGlmIChlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZW5kIHw9IDA7XG4gICAgfVxuICAgIHZhciBvd25lciA9IGxpc3QuX19vd25lcklEIHx8IG5ldyBPd25lcklEKCk7XG4gICAgdmFyIG9sZE9yaWdpbiA9IGxpc3QuX29yaWdpbjtcbiAgICB2YXIgb2xkQ2FwYWNpdHkgPSBsaXN0Ll9jYXBhY2l0eTtcbiAgICB2YXIgbmV3T3JpZ2luID0gb2xkT3JpZ2luICsgYmVnaW47XG4gICAgdmFyIG5ld0NhcGFjaXR5ID1cbiAgICAgIGVuZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gb2xkQ2FwYWNpdHlcbiAgICAgICAgOiBlbmQgPCAwXG4gICAgICAgID8gb2xkQ2FwYWNpdHkgKyBlbmRcbiAgICAgICAgOiBvbGRPcmlnaW4gKyBlbmQ7XG4gICAgaWYgKG5ld09yaWdpbiA9PT0gb2xkT3JpZ2luICYmIG5ld0NhcGFjaXR5ID09PSBvbGRDYXBhY2l0eSkge1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgLy8gSWYgaXQncyBnb2luZyB0byBlbmQgYWZ0ZXIgaXQgc3RhcnRzLCBpdCdzIGVtcHR5LlxuICAgIGlmIChuZXdPcmlnaW4gPj0gbmV3Q2FwYWNpdHkpIHtcbiAgICAgIHJldHVybiBsaXN0LmNsZWFyKCk7XG4gICAgfVxuXG4gICAgdmFyIG5ld0xldmVsID0gbGlzdC5fbGV2ZWw7XG4gICAgdmFyIG5ld1Jvb3QgPSBsaXN0Ll9yb290O1xuXG4gICAgLy8gTmV3IG9yaWdpbiBtaWdodCBuZWVkIGNyZWF0aW5nIGEgaGlnaGVyIHJvb3QuXG4gICAgdmFyIG9mZnNldFNoaWZ0ID0gMDtcbiAgICB3aGlsZSAobmV3T3JpZ2luICsgb2Zmc2V0U2hpZnQgPCAwKSB7XG4gICAgICBuZXdSb290ID0gbmV3IFZOb2RlKFxuICAgICAgICBuZXdSb290ICYmIG5ld1Jvb3QuYXJyYXkubGVuZ3RoID8gW3VuZGVmaW5lZCwgbmV3Um9vdF0gOiBbXSxcbiAgICAgICAgb3duZXJcbiAgICAgICk7XG4gICAgICBuZXdMZXZlbCArPSBTSElGVDtcbiAgICAgIG9mZnNldFNoaWZ0ICs9IDEgPDwgbmV3TGV2ZWw7XG4gICAgfVxuICAgIGlmIChvZmZzZXRTaGlmdCkge1xuICAgICAgbmV3T3JpZ2luICs9IG9mZnNldFNoaWZ0O1xuICAgICAgb2xkT3JpZ2luICs9IG9mZnNldFNoaWZ0O1xuICAgICAgbmV3Q2FwYWNpdHkgKz0gb2Zmc2V0U2hpZnQ7XG4gICAgICBvbGRDYXBhY2l0eSArPSBvZmZzZXRTaGlmdDtcbiAgICB9XG5cbiAgICB2YXIgb2xkVGFpbE9mZnNldCA9IGdldFRhaWxPZmZzZXQob2xkQ2FwYWNpdHkpO1xuICAgIHZhciBuZXdUYWlsT2Zmc2V0ID0gZ2V0VGFpbE9mZnNldChuZXdDYXBhY2l0eSk7XG5cbiAgICAvLyBOZXcgc2l6ZSBtaWdodCBuZWVkIGNyZWF0aW5nIGEgaGlnaGVyIHJvb3QuXG4gICAgd2hpbGUgKG5ld1RhaWxPZmZzZXQgPj0gMSA8PCAobmV3TGV2ZWwgKyBTSElGVCkpIHtcbiAgICAgIG5ld1Jvb3QgPSBuZXcgVk5vZGUoXG4gICAgICAgIG5ld1Jvb3QgJiYgbmV3Um9vdC5hcnJheS5sZW5ndGggPyBbbmV3Um9vdF0gOiBbXSxcbiAgICAgICAgb3duZXJcbiAgICAgICk7XG4gICAgICBuZXdMZXZlbCArPSBTSElGVDtcbiAgICB9XG5cbiAgICAvLyBMb2NhdGUgb3IgY3JlYXRlIHRoZSBuZXcgdGFpbC5cbiAgICB2YXIgb2xkVGFpbCA9IGxpc3QuX3RhaWw7XG4gICAgdmFyIG5ld1RhaWwgPVxuICAgICAgbmV3VGFpbE9mZnNldCA8IG9sZFRhaWxPZmZzZXRcbiAgICAgICAgPyBsaXN0Tm9kZUZvcihsaXN0LCBuZXdDYXBhY2l0eSAtIDEpXG4gICAgICAgIDogbmV3VGFpbE9mZnNldCA+IG9sZFRhaWxPZmZzZXRcbiAgICAgICAgPyBuZXcgVk5vZGUoW10sIG93bmVyKVxuICAgICAgICA6IG9sZFRhaWw7XG5cbiAgICAvLyBNZXJnZSBUYWlsIGludG8gdHJlZS5cbiAgICBpZiAoXG4gICAgICBvbGRUYWlsICYmXG4gICAgICBuZXdUYWlsT2Zmc2V0ID4gb2xkVGFpbE9mZnNldCAmJlxuICAgICAgbmV3T3JpZ2luIDwgb2xkQ2FwYWNpdHkgJiZcbiAgICAgIG9sZFRhaWwuYXJyYXkubGVuZ3RoXG4gICAgKSB7XG4gICAgICBuZXdSb290ID0gZWRpdGFibGVWTm9kZShuZXdSb290LCBvd25lcik7XG4gICAgICB2YXIgbm9kZSA9IG5ld1Jvb3Q7XG4gICAgICBmb3IgKHZhciBsZXZlbCA9IG5ld0xldmVsOyBsZXZlbCA+IFNISUZUOyBsZXZlbCAtPSBTSElGVCkge1xuICAgICAgICB2YXIgaWR4ID0gKG9sZFRhaWxPZmZzZXQgPj4+IGxldmVsKSAmIE1BU0s7XG4gICAgICAgIG5vZGUgPSBub2RlLmFycmF5W2lkeF0gPSBlZGl0YWJsZVZOb2RlKG5vZGUuYXJyYXlbaWR4XSwgb3duZXIpO1xuICAgICAgfVxuICAgICAgbm9kZS5hcnJheVsob2xkVGFpbE9mZnNldCA+Pj4gU0hJRlQpICYgTUFTS10gPSBvbGRUYWlsO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBzaXplIGhhcyBiZWVuIHJlZHVjZWQsIHRoZXJlJ3MgYSBjaGFuY2UgdGhlIHRhaWwgbmVlZHMgdG8gYmUgdHJpbW1lZC5cbiAgICBpZiAobmV3Q2FwYWNpdHkgPCBvbGRDYXBhY2l0eSkge1xuICAgICAgbmV3VGFpbCA9IG5ld1RhaWwgJiYgbmV3VGFpbC5yZW1vdmVBZnRlcihvd25lciwgMCwgbmV3Q2FwYWNpdHkpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBuZXcgb3JpZ2luIGlzIHdpdGhpbiB0aGUgdGFpbCwgdGhlbiB3ZSBkbyBub3QgbmVlZCBhIHJvb3QuXG4gICAgaWYgKG5ld09yaWdpbiA+PSBuZXdUYWlsT2Zmc2V0KSB7XG4gICAgICBuZXdPcmlnaW4gLT0gbmV3VGFpbE9mZnNldDtcbiAgICAgIG5ld0NhcGFjaXR5IC09IG5ld1RhaWxPZmZzZXQ7XG4gICAgICBuZXdMZXZlbCA9IFNISUZUO1xuICAgICAgbmV3Um9vdCA9IG51bGw7XG4gICAgICBuZXdUYWlsID0gbmV3VGFpbCAmJiBuZXdUYWlsLnJlbW92ZUJlZm9yZShvd25lciwgMCwgbmV3T3JpZ2luKTtcblxuICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB0aGUgcm9vdCBoYXMgYmVlbiB0cmltbWVkLCBnYXJiYWdlIGNvbGxlY3QuXG4gICAgfSBlbHNlIGlmIChuZXdPcmlnaW4gPiBvbGRPcmlnaW4gfHwgbmV3VGFpbE9mZnNldCA8IG9sZFRhaWxPZmZzZXQpIHtcbiAgICAgIG9mZnNldFNoaWZ0ID0gMDtcblxuICAgICAgLy8gSWRlbnRpZnkgdGhlIG5ldyB0b3Agcm9vdCBub2RlIG9mIHRoZSBzdWJ0cmVlIG9mIHRoZSBvbGQgcm9vdC5cbiAgICAgIHdoaWxlIChuZXdSb290KSB7XG4gICAgICAgIHZhciBiZWdpbkluZGV4ID0gKG5ld09yaWdpbiA+Pj4gbmV3TGV2ZWwpICYgTUFTSztcbiAgICAgICAgaWYgKChiZWdpbkluZGV4ICE9PSBuZXdUYWlsT2Zmc2V0ID4+PiBuZXdMZXZlbCkgJiBNQVNLKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlZ2luSW5kZXgpIHtcbiAgICAgICAgICBvZmZzZXRTaGlmdCArPSAoMSA8PCBuZXdMZXZlbCkgKiBiZWdpbkluZGV4O1xuICAgICAgICB9XG4gICAgICAgIG5ld0xldmVsIC09IFNISUZUO1xuICAgICAgICBuZXdSb290ID0gbmV3Um9vdC5hcnJheVtiZWdpbkluZGV4XTtcbiAgICAgIH1cblxuICAgICAgLy8gVHJpbSB0aGUgbmV3IHNpZGVzIG9mIHRoZSBuZXcgcm9vdC5cbiAgICAgIGlmIChuZXdSb290ICYmIG5ld09yaWdpbiA+IG9sZE9yaWdpbikge1xuICAgICAgICBuZXdSb290ID0gbmV3Um9vdC5yZW1vdmVCZWZvcmUob3duZXIsIG5ld0xldmVsLCBuZXdPcmlnaW4gLSBvZmZzZXRTaGlmdCk7XG4gICAgICB9XG4gICAgICBpZiAobmV3Um9vdCAmJiBuZXdUYWlsT2Zmc2V0IDwgb2xkVGFpbE9mZnNldCkge1xuICAgICAgICBuZXdSb290ID0gbmV3Um9vdC5yZW1vdmVBZnRlcihcbiAgICAgICAgICBvd25lcixcbiAgICAgICAgICBuZXdMZXZlbCxcbiAgICAgICAgICBuZXdUYWlsT2Zmc2V0IC0gb2Zmc2V0U2hpZnRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXRTaGlmdCkge1xuICAgICAgICBuZXdPcmlnaW4gLT0gb2Zmc2V0U2hpZnQ7XG4gICAgICAgIG5ld0NhcGFjaXR5IC09IG9mZnNldFNoaWZ0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsaXN0Ll9fb3duZXJJRCkge1xuICAgICAgbGlzdC5zaXplID0gbmV3Q2FwYWNpdHkgLSBuZXdPcmlnaW47XG4gICAgICBsaXN0Ll9vcmlnaW4gPSBuZXdPcmlnaW47XG4gICAgICBsaXN0Ll9jYXBhY2l0eSA9IG5ld0NhcGFjaXR5O1xuICAgICAgbGlzdC5fbGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgIGxpc3QuX3Jvb3QgPSBuZXdSb290O1xuICAgICAgbGlzdC5fdGFpbCA9IG5ld1RhaWw7XG4gICAgICBsaXN0Ll9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgIGxpc3QuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgICByZXR1cm4gbWFrZUxpc3QobmV3T3JpZ2luLCBuZXdDYXBhY2l0eSwgbmV3TGV2ZWwsIG5ld1Jvb3QsIG5ld1RhaWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGFpbE9mZnNldChzaXplKSB7XG4gICAgcmV0dXJuIHNpemUgPCBTSVpFID8gMCA6ICgoc2l6ZSAtIDEpID4+PiBTSElGVCkgPDwgU0hJRlQ7XG4gIH1cblxuICB2YXIgT3JkZXJlZE1hcCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKE1hcCkge1xuICAgIGZ1bmN0aW9uIE9yZGVyZWRNYXAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gZW1wdHlPcmRlcmVkTWFwKClcbiAgICAgICAgOiBpc09yZGVyZWRNYXAodmFsdWUpXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiBlbXB0eU9yZGVyZWRNYXAoKS53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgIHZhciBpdGVyID0gS2V5ZWRDb2xsZWN0aW9uKHZhbHVlKTtcbiAgICAgICAgICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgICAgICAgICBpdGVyLmZvckVhY2goZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIG1hcC5zZXQoaywgdik7IH0pO1xuICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICggTWFwICkgT3JkZXJlZE1hcC5fX3Byb3RvX18gPSBNYXA7XG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXAgJiYgTWFwLnByb3RvdHlwZSApO1xuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT3JkZXJlZE1hcDtcblxuICAgIE9yZGVyZWRNYXAub2YgPSBmdW5jdGlvbiBvZiAoLyouLi52YWx1ZXMqLykge1xuICAgICAgcmV0dXJuIHRoaXMoYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdPcmRlcmVkTWFwIHsnLCAnfScpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIEFjY2Vzc1xuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChrLCBub3RTZXRWYWx1ZSkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5fbWFwLmdldChrKTtcbiAgICAgIHJldHVybiBpbmRleCAhPT0gdW5kZWZpbmVkID8gdGhpcy5fbGlzdC5nZXQoaW5kZXgpWzFdIDogbm90U2V0VmFsdWU7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgdGhpcy5fbWFwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2xpc3QuY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlPcmRlcmVkTWFwKCk7XG4gICAgfTtcblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoaywgdikge1xuICAgICAgcmV0dXJuIHVwZGF0ZU9yZGVyZWRNYXAodGhpcywgaywgdik7XG4gICAgfTtcblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoaykge1xuICAgICAgcmV0dXJuIHVwZGF0ZU9yZGVyZWRNYXAodGhpcywgaywgTk9UX1NFVCk7XG4gICAgfTtcblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLndhc0FsdGVyZWQgPSBmdW5jdGlvbiB3YXNBbHRlcmVkICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAud2FzQWx0ZXJlZCgpIHx8IHRoaXMuX2xpc3Qud2FzQWx0ZXJlZCgpO1xuICAgIH07XG5cbiAgICBPcmRlcmVkTWFwLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMuX2xpc3QuX19pdGVyYXRlKFxuICAgICAgICBmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5ICYmIGZuKGVudHJ5WzFdLCBlbnRyeVswXSwgdGhpcyQxKTsgfSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZE1hcC5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9saXN0LmZyb21FbnRyeVNlcSgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIE9yZGVyZWRNYXAucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbiBfX2Vuc3VyZU93bmVyIChvd25lcklEKSB7XG4gICAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgbmV3TWFwID0gdGhpcy5fbWFwLl9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gICAgICB2YXIgbmV3TGlzdCA9IHRoaXMuX2xpc3QuX19lbnN1cmVPd25lcihvd25lcklEKTtcbiAgICAgIGlmICghb3duZXJJRCkge1xuICAgICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGVtcHR5T3JkZXJlZE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3TWFwO1xuICAgICAgICB0aGlzLl9saXN0ID0gbmV3TGlzdDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFrZU9yZGVyZWRNYXAobmV3TWFwLCBuZXdMaXN0LCBvd25lcklELCB0aGlzLl9faGFzaCk7XG4gICAgfTtcblxuICAgIHJldHVybiBPcmRlcmVkTWFwO1xuICB9KE1hcCkpO1xuXG4gIE9yZGVyZWRNYXAuaXNPcmRlcmVkTWFwID0gaXNPcmRlcmVkTWFwO1xuXG4gIE9yZGVyZWRNYXAucHJvdG90eXBlW0lTX09SREVSRURfU1lNQk9MXSA9IHRydWU7XG4gIE9yZGVyZWRNYXAucHJvdG90eXBlW0RFTEVURV0gPSBPcmRlcmVkTWFwLnByb3RvdHlwZS5yZW1vdmU7XG5cbiAgZnVuY3Rpb24gbWFrZU9yZGVyZWRNYXAobWFwLCBsaXN0LCBvd25lcklELCBoYXNoKSB7XG4gICAgdmFyIG9tYXAgPSBPYmplY3QuY3JlYXRlKE9yZGVyZWRNYXAucHJvdG90eXBlKTtcbiAgICBvbWFwLnNpemUgPSBtYXAgPyBtYXAuc2l6ZSA6IDA7XG4gICAgb21hcC5fbWFwID0gbWFwO1xuICAgIG9tYXAuX2xpc3QgPSBsaXN0O1xuICAgIG9tYXAuX19vd25lcklEID0gb3duZXJJRDtcbiAgICBvbWFwLl9faGFzaCA9IGhhc2g7XG4gICAgcmV0dXJuIG9tYXA7XG4gIH1cblxuICB2YXIgRU1QVFlfT1JERVJFRF9NQVA7XG4gIGZ1bmN0aW9uIGVtcHR5T3JkZXJlZE1hcCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgRU1QVFlfT1JERVJFRF9NQVAgfHxcbiAgICAgIChFTVBUWV9PUkRFUkVEX01BUCA9IG1ha2VPcmRlcmVkTWFwKGVtcHR5TWFwKCksIGVtcHR5TGlzdCgpKSlcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlT3JkZXJlZE1hcChvbWFwLCBrLCB2KSB7XG4gICAgdmFyIG1hcCA9IG9tYXAuX21hcDtcbiAgICB2YXIgbGlzdCA9IG9tYXAuX2xpc3Q7XG4gICAgdmFyIGkgPSBtYXAuZ2V0KGspO1xuICAgIHZhciBoYXMgPSBpICE9PSB1bmRlZmluZWQ7XG4gICAgdmFyIG5ld01hcDtcbiAgICB2YXIgbmV3TGlzdDtcbiAgICBpZiAodiA9PT0gTk9UX1NFVCkge1xuICAgICAgLy8gcmVtb3ZlZFxuICAgICAgaWYgKCFoYXMpIHtcbiAgICAgICAgcmV0dXJuIG9tYXA7XG4gICAgICB9XG4gICAgICBpZiAobGlzdC5zaXplID49IFNJWkUgJiYgbGlzdC5zaXplID49IG1hcC5zaXplICogMikge1xuICAgICAgICBuZXdMaXN0ID0gbGlzdC5maWx0ZXIoZnVuY3Rpb24gKGVudHJ5LCBpZHgpIHsgcmV0dXJuIGVudHJ5ICE9PSB1bmRlZmluZWQgJiYgaSAhPT0gaWR4OyB9KTtcbiAgICAgICAgbmV3TWFwID0gbmV3TGlzdFxuICAgICAgICAgIC50b0tleWVkU2VxKClcbiAgICAgICAgICAubWFwKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnlbMF07IH0pXG4gICAgICAgICAgLmZsaXAoKVxuICAgICAgICAgIC50b01hcCgpO1xuICAgICAgICBpZiAob21hcC5fX293bmVySUQpIHtcbiAgICAgICAgICBuZXdNYXAuX19vd25lcklEID0gbmV3TGlzdC5fX293bmVySUQgPSBvbWFwLl9fb3duZXJJRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3TWFwID0gbWFwLnJlbW92ZShrKTtcbiAgICAgICAgbmV3TGlzdCA9IGkgPT09IGxpc3Quc2l6ZSAtIDEgPyBsaXN0LnBvcCgpIDogbGlzdC5zZXQoaSwgdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhhcykge1xuICAgICAgaWYgKHYgPT09IGxpc3QuZ2V0KGkpWzFdKSB7XG4gICAgICAgIHJldHVybiBvbWFwO1xuICAgICAgfVxuICAgICAgbmV3TWFwID0gbWFwO1xuICAgICAgbmV3TGlzdCA9IGxpc3Quc2V0KGksIFtrLCB2XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld01hcCA9IG1hcC5zZXQoaywgbGlzdC5zaXplKTtcbiAgICAgIG5ld0xpc3QgPSBsaXN0LnNldChsaXN0LnNpemUsIFtrLCB2XSk7XG4gICAgfVxuICAgIGlmIChvbWFwLl9fb3duZXJJRCkge1xuICAgICAgb21hcC5zaXplID0gbmV3TWFwLnNpemU7XG4gICAgICBvbWFwLl9tYXAgPSBuZXdNYXA7XG4gICAgICBvbWFwLl9saXN0ID0gbmV3TGlzdDtcbiAgICAgIG9tYXAuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIG9tYXA7XG4gICAgfVxuICAgIHJldHVybiBtYWtlT3JkZXJlZE1hcChuZXdNYXAsIG5ld0xpc3QpO1xuICB9XG5cbiAgdmFyIElTX1NUQUNLX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX1NUQUNLX19AQCc7XG5cbiAgZnVuY3Rpb24gaXNTdGFjayhtYXliZVN0YWNrKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4obWF5YmVTdGFjayAmJiBtYXliZVN0YWNrW0lTX1NUQUNLX1NZTUJPTF0pO1xuICB9XG5cbiAgdmFyIFN0YWNrID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW5kZXhlZENvbGxlY3Rpb24pIHtcbiAgICBmdW5jdGlvbiBTdGFjayh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBlbXB0eVN0YWNrKClcbiAgICAgICAgOiBpc1N0YWNrKHZhbHVlKVxuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogZW1wdHlTdGFjaygpLnB1c2hBbGwodmFsdWUpO1xuICAgIH1cblxuICAgIGlmICggSW5kZXhlZENvbGxlY3Rpb24gKSBTdGFjay5fX3Byb3RvX18gPSBJbmRleGVkQ29sbGVjdGlvbjtcbiAgICBTdGFjay5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkQ29sbGVjdGlvbiAmJiBJbmRleGVkQ29sbGVjdGlvbi5wcm90b3R5cGUgKTtcbiAgICBTdGFjay5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdGFjaztcblxuICAgIFN0YWNrLm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ1N0YWNrIFsnLCAnXScpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIEFjY2Vzc1xuXG4gICAgU3RhY2sucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgICBpbmRleCA9IHdyYXBJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgICB3aGlsZSAoaGVhZCAmJiBpbmRleC0tKSB7XG4gICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGVhZCA/IGhlYWQudmFsdWUgOiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuXG4gICAgU3RhY2sucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiBwZWVrICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oZWFkICYmIHRoaXMuX2hlYWQudmFsdWU7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgICBTdGFjay5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKC8qLi4udmFsdWVzKi8pIHtcbiAgICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgbmV3U2l6ZSA9IHRoaXMuc2l6ZSArIGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgICBmb3IgKHZhciBpaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpaSA+PSAwOyBpaS0tKSB7XG4gICAgICAgIGhlYWQgPSB7XG4gICAgICAgICAgdmFsdWU6IGFyZ3VtZW50cyQxW2lpXSxcbiAgICAgICAgICBuZXh0OiBoZWFkLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IG5ld1NpemU7XG4gICAgICAgIHRoaXMuX2hlYWQgPSBoZWFkO1xuICAgICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlU3RhY2sobmV3U2l6ZSwgaGVhZCk7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS5wdXNoQWxsID0gZnVuY3Rpb24gcHVzaEFsbCAoaXRlcikge1xuICAgICAgaXRlciA9IEluZGV4ZWRDb2xsZWN0aW9uKGl0ZXIpO1xuICAgICAgaWYgKGl0ZXIuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDAgJiYgaXNTdGFjayhpdGVyKSkge1xuICAgICAgICByZXR1cm4gaXRlcjtcbiAgICAgIH1cbiAgICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgICB2YXIgbmV3U2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgIHZhciBoZWFkID0gdGhpcy5faGVhZDtcbiAgICAgIGl0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBuZXdTaXplKys7XG4gICAgICAgIGhlYWQgPSB7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIG5leHQ6IGhlYWQsXG4gICAgICAgIH07XG4gICAgICB9LCAvKiByZXZlcnNlICovIHRydWUpO1xuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IG5ld1NpemU7XG4gICAgICAgIHRoaXMuX2hlYWQgPSBoZWFkO1xuICAgICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlU3RhY2sobmV3U2l6ZSwgaGVhZCk7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiBwb3AgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoMSk7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgdGhpcy5faGVhZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlTdGFjaygpO1xuICAgIH07XG5cbiAgICBTdGFjay5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoYmVnaW4sIGVuZCkge1xuICAgICAgaWYgKHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgdGhpcy5zaXplKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciByZXNvbHZlZEJlZ2luID0gcmVzb2x2ZUJlZ2luKGJlZ2luLCB0aGlzLnNpemUpO1xuICAgICAgdmFyIHJlc29sdmVkRW5kID0gcmVzb2x2ZUVuZChlbmQsIHRoaXMuc2l6ZSk7XG4gICAgICBpZiAocmVzb2x2ZWRFbmQgIT09IHRoaXMuc2l6ZSkge1xuICAgICAgICAvLyBzdXBlci5zbGljZShiZWdpbiwgZW5kKTtcbiAgICAgICAgcmV0dXJuIEluZGV4ZWRDb2xsZWN0aW9uLnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1NpemUgPSB0aGlzLnNpemUgLSByZXNvbHZlZEJlZ2luO1xuICAgICAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgICAgd2hpbGUgKHJlc29sdmVkQmVnaW4tLSkge1xuICAgICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IG5ld1NpemU7XG4gICAgICAgIHRoaXMuX2hlYWQgPSBoZWFkO1xuICAgICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlU3RhY2sobmV3U2l6ZSwgaGVhZCk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTXV0YWJpbGl0eVxuXG4gICAgU3RhY2sucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbiBfX2Vuc3VyZU93bmVyIChvd25lcklEKSB7XG4gICAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBlbXB0eVN0YWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuICAgICAgICB0aGlzLl9fYWx0ZXJlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlU3RhY2sodGhpcy5zaXplLCB0aGlzLl9oZWFkLCBvd25lcklELCB0aGlzLl9faGFzaCk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgSXRlcmF0aW9uXG5cbiAgICBTdGFjay5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlTZXEodGhpcy50b0FycmF5KCkpLl9faXRlcmF0ZShcbiAgICAgICAgICBmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gZm4odiwgaywgdGhpcyQxKTsgfSxcbiAgICAgICAgICByZXZlcnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuX2hlYWQ7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAoZm4obm9kZS52YWx1ZSwgaXRlcmF0aW9ucysrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcblxuICAgIFN0YWNrLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheVNlcSh0aGlzLnRvQXJyYXkoKSkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBub2RlID0gdGhpcy5faGVhZDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFN0YWNrO1xuICB9KEluZGV4ZWRDb2xsZWN0aW9uKSk7XG5cbiAgU3RhY2suaXNTdGFjayA9IGlzU3RhY2s7XG5cbiAgdmFyIFN0YWNrUHJvdG90eXBlID0gU3RhY2sucHJvdG90eXBlO1xuICBTdGFja1Byb3RvdHlwZVtJU19TVEFDS19TWU1CT0xdID0gdHJ1ZTtcbiAgU3RhY2tQcm90b3R5cGUuc2hpZnQgPSBTdGFja1Byb3RvdHlwZS5wb3A7XG4gIFN0YWNrUHJvdG90eXBlLnVuc2hpZnQgPSBTdGFja1Byb3RvdHlwZS5wdXNoO1xuICBTdGFja1Byb3RvdHlwZS51bnNoaWZ0QWxsID0gU3RhY2tQcm90b3R5cGUucHVzaEFsbDtcbiAgU3RhY2tQcm90b3R5cGUud2l0aE11dGF0aW9ucyA9IHdpdGhNdXRhdGlvbnM7XG4gIFN0YWNrUHJvdG90eXBlLndhc0FsdGVyZWQgPSB3YXNBbHRlcmVkO1xuICBTdGFja1Byb3RvdHlwZS5hc0ltbXV0YWJsZSA9IGFzSW1tdXRhYmxlO1xuICBTdGFja1Byb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IFN0YWNrUHJvdG90eXBlLmFzTXV0YWJsZSA9IGFzTXV0YWJsZTtcbiAgU3RhY2tQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBhcnIpIHtcbiAgICByZXR1cm4gcmVzdWx0LnVuc2hpZnQoYXJyKTtcbiAgfTtcbiAgU3RhY2tQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqLmFzSW1tdXRhYmxlKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZVN0YWNrKHNpemUsIGhlYWQsIG93bmVySUQsIGhhc2gpIHtcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShTdGFja1Byb3RvdHlwZSk7XG4gICAgbWFwLnNpemUgPSBzaXplO1xuICAgIG1hcC5faGVhZCA9IGhlYWQ7XG4gICAgbWFwLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgbWFwLl9faGFzaCA9IGhhc2g7XG4gICAgbWFwLl9fYWx0ZXJlZCA9IGZhbHNlO1xuICAgIHJldHVybiBtYXA7XG4gIH1cblxuICB2YXIgRU1QVFlfU1RBQ0s7XG4gIGZ1bmN0aW9uIGVtcHR5U3RhY2soKSB7XG4gICAgcmV0dXJuIEVNUFRZX1NUQUNLIHx8IChFTVBUWV9TVEFDSyA9IG1ha2VTdGFjaygwKSk7XG4gIH1cblxuICB2YXIgSVNfU0VUX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX1NFVF9fQEAnO1xuXG4gIGZ1bmN0aW9uIGlzU2V0KG1heWJlU2V0KSB7XG4gICAgcmV0dXJuIEJvb2xlYW4obWF5YmVTZXQgJiYgbWF5YmVTZXRbSVNfU0VUX1NZTUJPTF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNPcmRlcmVkU2V0KG1heWJlT3JkZXJlZFNldCkge1xuICAgIHJldHVybiBpc1NldChtYXliZU9yZGVyZWRTZXQpICYmIGlzT3JkZXJlZChtYXliZU9yZGVyZWRTZXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgIWlzQ29sbGVjdGlvbihiKSB8fFxuICAgICAgKGEuc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGIuc2l6ZSAhPT0gdW5kZWZpbmVkICYmIGEuc2l6ZSAhPT0gYi5zaXplKSB8fFxuICAgICAgKGEuX19oYXNoICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgYi5fX2hhc2ggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBhLl9faGFzaCAhPT0gYi5fX2hhc2gpIHx8XG4gICAgICBpc0tleWVkKGEpICE9PSBpc0tleWVkKGIpIHx8XG4gICAgICBpc0luZGV4ZWQoYSkgIT09IGlzSW5kZXhlZChiKSB8fFxuICAgICAgaXNPcmRlcmVkKGEpICE9PSBpc09yZGVyZWQoYilcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYS5zaXplID09PSAwICYmIGIuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIG5vdEFzc29jaWF0aXZlID0gIWlzQXNzb2NpYXRpdmUoYSk7XG5cbiAgICBpZiAoaXNPcmRlcmVkKGEpKSB7XG4gICAgICB2YXIgZW50cmllcyA9IGEuZW50cmllcygpO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgYi5ldmVyeShmdW5jdGlvbiAodiwgaykge1xuICAgICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXMubmV4dCgpLnZhbHVlO1xuICAgICAgICAgIHJldHVybiBlbnRyeSAmJiBpcyhlbnRyeVsxXSwgdikgJiYgKG5vdEFzc29jaWF0aXZlIHx8IGlzKGVudHJ5WzBdLCBrKSk7XG4gICAgICAgIH0pICYmIGVudHJpZXMubmV4dCgpLmRvbmVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGZsaXBwZWQgPSBmYWxzZTtcblxuICAgIGlmIChhLnNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGIuc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYS5jYWNoZVJlc3VsdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGEuY2FjaGVSZXN1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmxpcHBlZCA9IHRydWU7XG4gICAgICAgIHZhciBfID0gYTtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGIgPSBfO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhbGxFcXVhbCA9IHRydWU7XG4gICAgdmFyIGJTaXplID0gYi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgIGlmIChcbiAgICAgICAgbm90QXNzb2NpYXRpdmVcbiAgICAgICAgICA/ICFhLmhhcyh2KVxuICAgICAgICAgIDogZmxpcHBlZFxuICAgICAgICAgID8gIWlzKHYsIGEuZ2V0KGssIE5PVF9TRVQpKVxuICAgICAgICAgIDogIWlzKGEuZ2V0KGssIE5PVF9TRVQpLCB2KVxuICAgICAgKSB7XG4gICAgICAgIGFsbEVxdWFsID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBhbGxFcXVhbCAmJiBhLnNpemUgPT09IGJTaXplO1xuICB9XG5cbiAgZnVuY3Rpb24gbWl4aW4oY3RvciwgbWV0aG9kcykge1xuICAgIHZhciBrZXlDb3BpZXIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBjdG9yLnByb3RvdHlwZVtrZXldID0gbWV0aG9kc1trZXldO1xuICAgIH07XG4gICAgT2JqZWN0LmtleXMobWV0aG9kcykuZm9yRWFjaChrZXlDb3BpZXIpO1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiZcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobWV0aG9kcykuZm9yRWFjaChrZXlDb3BpZXIpO1xuICAgIHJldHVybiBjdG9yO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9KUyh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoIWlzQ29sbGVjdGlvbih2YWx1ZSkpIHtcbiAgICAgIGlmICghaXNEYXRhU3RydWN0dXJlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IFNlcSh2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChpc0tleWVkKHZhbHVlKSkge1xuICAgICAgdmFyIHJlc3VsdCQxID0ge307XG4gICAgICB2YWx1ZS5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgcmVzdWx0JDFba10gPSB0b0pTKHYpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0JDE7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YWx1ZS5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHRvSlModikpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgU2V0ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU2V0Q29sbGVjdGlvbikge1xuICAgIGZ1bmN0aW9uIFNldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBlbXB0eVNldCgpXG4gICAgICAgIDogaXNTZXQodmFsdWUpICYmICFpc09yZGVyZWQodmFsdWUpXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiBlbXB0eVNldCgpLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKHNldCkge1xuICAgICAgICAgICAgdmFyIGl0ZXIgPSBTZXRDb2xsZWN0aW9uKHZhbHVlKTtcbiAgICAgICAgICAgIGFzc2VydE5vdEluZmluaXRlKGl0ZXIuc2l6ZSk7XG4gICAgICAgICAgICBpdGVyLmZvckVhY2goZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHNldC5hZGQodik7IH0pO1xuICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICggU2V0Q29sbGVjdGlvbiApIFNldC5fX3Byb3RvX18gPSBTZXRDb2xsZWN0aW9uO1xuICAgIFNldC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTZXRDb2xsZWN0aW9uICYmIFNldENvbGxlY3Rpb24ucHJvdG90eXBlICk7XG4gICAgU2V0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNldDtcblxuICAgIFNldC5vZiA9IGZ1bmN0aW9uIG9mICgvKi4uLnZhbHVlcyovKSB7XG4gICAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBTZXQuZnJvbUtleXMgPSBmdW5jdGlvbiBmcm9tS2V5cyAodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzKEtleWVkQ29sbGVjdGlvbih2YWx1ZSkua2V5U2VxKCkpO1xuICAgIH07XG5cbiAgICBTZXQuaW50ZXJzZWN0ID0gZnVuY3Rpb24gaW50ZXJzZWN0IChzZXRzKSB7XG4gICAgICBzZXRzID0gQ29sbGVjdGlvbihzZXRzKS50b0FycmF5KCk7XG4gICAgICByZXR1cm4gc2V0cy5sZW5ndGhcbiAgICAgICAgPyBTZXRQcm90b3R5cGUuaW50ZXJzZWN0LmFwcGx5KFNldChzZXRzLnBvcCgpKSwgc2V0cylcbiAgICAgICAgOiBlbXB0eVNldCgpO1xuICAgIH07XG5cbiAgICBTZXQudW5pb24gPSBmdW5jdGlvbiB1bmlvbiAoc2V0cykge1xuICAgICAgc2V0cyA9IENvbGxlY3Rpb24oc2V0cykudG9BcnJheSgpO1xuICAgICAgcmV0dXJuIHNldHMubGVuZ3RoXG4gICAgICAgID8gU2V0UHJvdG90eXBlLnVuaW9uLmFwcGx5KFNldChzZXRzLnBvcCgpKSwgc2V0cylcbiAgICAgICAgOiBlbXB0eVNldCgpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnU2V0IHsnLCAnfScpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIEFjY2Vzc1xuXG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyh2YWx1ZSk7XG4gICAgfTtcblxuICAgIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAodmFsdWUpIHtcbiAgICAgIHJldHVybiB1cGRhdGVTZXQodGhpcywgdGhpcy5fbWFwLnNldCh2YWx1ZSwgdmFsdWUpKTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdXBkYXRlU2V0KHRoaXMsIHRoaXMuX21hcC5yZW1vdmUodmFsdWUpKTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHJldHVybiB1cGRhdGVTZXQodGhpcywgdGhpcy5fbWFwLmNsZWFyKCkpO1xuICAgIH07XG5cbiAgICAvLyBAcHJhZ21hIENvbXBvc2l0aW9uXG5cbiAgICBTZXQucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCAobWFwcGVyLCBjb250ZXh0KSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdmFyIHJlbW92ZXMgPSBbXTtcbiAgICAgIHZhciBhZGRzID0gW107XG4gICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBtYXBwZWQgPSBtYXBwZXIuY2FsbChjb250ZXh0LCB2YWx1ZSwgdmFsdWUsIHRoaXMkMSk7XG4gICAgICAgIGlmIChtYXBwZWQgIT09IHZhbHVlKSB7XG4gICAgICAgICAgcmVtb3Zlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBhZGRzLnB1c2gobWFwcGVkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgICAgcmVtb3Zlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gc2V0LnJlbW92ZSh2YWx1ZSk7IH0pO1xuICAgICAgICBhZGRzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBzZXQuYWRkKHZhbHVlKTsgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS51bmlvbiA9IGZ1bmN0aW9uIHVuaW9uICgpIHtcbiAgICAgIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIGl0ZXJzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgIGl0ZXJzID0gaXRlcnMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnNpemUgIT09IDA7IH0pO1xuICAgICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDAgJiYgIXRoaXMuX19vd25lcklEICYmIGl0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RvcihpdGVyc1swXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGl0ZXJzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICAgIFNldENvbGxlY3Rpb24oaXRlcnNbaWldKS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gc2V0LmFkZCh2YWx1ZSk7IH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5pbnRlcnNlY3QgPSBmdW5jdGlvbiBpbnRlcnNlY3QgKCkge1xuICAgICAgdmFyIGl0ZXJzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGl0ZXJzID0gaXRlcnMubWFwKGZ1bmN0aW9uIChpdGVyKSB7IHJldHVybiBTZXRDb2xsZWN0aW9uKGl0ZXIpOyB9KTtcbiAgICAgIHZhciB0b1JlbW92ZSA9IFtdO1xuICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIWl0ZXJzLmV2ZXJ5KGZ1bmN0aW9uIChpdGVyKSB7IHJldHVybiBpdGVyLmluY2x1ZGVzKHZhbHVlKTsgfSkpIHtcbiAgICAgICAgICB0b1JlbW92ZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgICAgdG9SZW1vdmUuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBzZXQucmVtb3ZlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0ICgpIHtcbiAgICAgIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIGl0ZXJzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgIGlmIChpdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpdGVycyA9IGl0ZXJzLm1hcChmdW5jdGlvbiAoaXRlcikgeyByZXR1cm4gU2V0Q29sbGVjdGlvbihpdGVyKTsgfSk7XG4gICAgICB2YXIgdG9SZW1vdmUgPSBbXTtcbiAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKGl0ZXJzLnNvbWUoZnVuY3Rpb24gKGl0ZXIpIHsgcmV0dXJuIGl0ZXIuaW5jbHVkZXModmFsdWUpOyB9KSkge1xuICAgICAgICAgIHRvUmVtb3ZlLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKHNldCkge1xuICAgICAgICB0b1JlbW92ZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHNldC5yZW1vdmUodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbiBzb3J0IChjb21wYXJhdG9yKSB7XG4gICAgICAvLyBMYXRlIGJpbmRpbmdcbiAgICAgIHJldHVybiBPcmRlcmVkU2V0KHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IpKTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5zb3J0QnkgPSBmdW5jdGlvbiBzb3J0QnkgKG1hcHBlciwgY29tcGFyYXRvcikge1xuICAgICAgLy8gTGF0ZSBiaW5kaW5nXG4gICAgICByZXR1cm4gT3JkZXJlZFNldChzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yLCBtYXBwZXIpKTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS53YXNBbHRlcmVkID0gZnVuY3Rpb24gd2FzQWx0ZXJlZCAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwLndhc0FsdGVyZWQoKTtcbiAgICB9O1xuXG4gICAgU2V0LnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMuX21hcC5fX2l0ZXJhdGUoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGZuKGssIGssIHRoaXMkMSk7IH0sIHJldmVyc2UpO1xuICAgIH07XG5cbiAgICBTZXQucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFwLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgfTtcblxuICAgIFNldC5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uIF9fZW5zdXJlT3duZXIgKG93bmVySUQpIHtcbiAgICAgIGlmIChvd25lcklEID09PSB0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdNYXAgPSB0aGlzLl9tYXAuX19lbnN1cmVPd25lcihvd25lcklEKTtcbiAgICAgIGlmICghb3duZXJJRCkge1xuICAgICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX19lbXB0eSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3TWFwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9fbWFrZShuZXdNYXAsIG93bmVySUQpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2V0O1xuICB9KFNldENvbGxlY3Rpb24pKTtcblxuICBTZXQuaXNTZXQgPSBpc1NldDtcblxuICB2YXIgU2V0UHJvdG90eXBlID0gU2V0LnByb3RvdHlwZTtcbiAgU2V0UHJvdG90eXBlW0lTX1NFVF9TWU1CT0xdID0gdHJ1ZTtcbiAgU2V0UHJvdG90eXBlW0RFTEVURV0gPSBTZXRQcm90b3R5cGUucmVtb3ZlO1xuICBTZXRQcm90b3R5cGUubWVyZ2UgPSBTZXRQcm90b3R5cGUuY29uY2F0ID0gU2V0UHJvdG90eXBlLnVuaW9uO1xuICBTZXRQcm90b3R5cGUud2l0aE11dGF0aW9ucyA9IHdpdGhNdXRhdGlvbnM7XG4gIFNldFByb3RvdHlwZS5hc0ltbXV0YWJsZSA9IGFzSW1tdXRhYmxlO1xuICBTZXRQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBTZXRQcm90b3R5cGUuYXNNdXRhYmxlID0gYXNNdXRhYmxlO1xuICBTZXRQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBhcnIpIHtcbiAgICByZXR1cm4gcmVzdWx0LmFkZChhcnIpO1xuICB9O1xuICBTZXRQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqLmFzSW1tdXRhYmxlKCk7XG4gIH07XG5cbiAgU2V0UHJvdG90eXBlLl9fZW1wdHkgPSBlbXB0eVNldDtcbiAgU2V0UHJvdG90eXBlLl9fbWFrZSA9IG1ha2VTZXQ7XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2V0KHNldCwgbmV3TWFwKSB7XG4gICAgaWYgKHNldC5fX293bmVySUQpIHtcbiAgICAgIHNldC5zaXplID0gbmV3TWFwLnNpemU7XG4gICAgICBzZXQuX21hcCA9IG5ld01hcDtcbiAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIHJldHVybiBuZXdNYXAgPT09IHNldC5fbWFwXG4gICAgICA/IHNldFxuICAgICAgOiBuZXdNYXAuc2l6ZSA9PT0gMFxuICAgICAgPyBzZXQuX19lbXB0eSgpXG4gICAgICA6IHNldC5fX21ha2UobmV3TWFwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VTZXQobWFwLCBvd25lcklEKSB7XG4gICAgdmFyIHNldCA9IE9iamVjdC5jcmVhdGUoU2V0UHJvdG90eXBlKTtcbiAgICBzZXQuc2l6ZSA9IG1hcCA/IG1hcC5zaXplIDogMDtcbiAgICBzZXQuX21hcCA9IG1hcDtcbiAgICBzZXQuX19vd25lcklEID0gb3duZXJJRDtcbiAgICByZXR1cm4gc2V0O1xuICB9XG5cbiAgdmFyIEVNUFRZX1NFVDtcbiAgZnVuY3Rpb24gZW1wdHlTZXQoKSB7XG4gICAgcmV0dXJuIEVNUFRZX1NFVCB8fCAoRU1QVFlfU0VUID0gbWFrZVNldChlbXB0eU1hcCgpKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxhenkgc2VxIG9mIG51bXMgZnJvbSBzdGFydCAoaW5jbHVzaXZlKSB0byBlbmRcbiAgICogKGV4Y2x1c2l2ZSksIGJ5IHN0ZXAsIHdoZXJlIHN0YXJ0IGRlZmF1bHRzIHRvIDAsIHN0ZXAgdG8gMSwgYW5kIGVuZCB0b1xuICAgKiBpbmZpbml0eS4gV2hlbiBzdGFydCBpcyBlcXVhbCB0byBlbmQsIHJldHVybnMgZW1wdHkgbGlzdC5cbiAgICovXG4gIHZhciBSYW5nZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEluZGV4ZWRTZXEpIHtcbiAgICBmdW5jdGlvbiBSYW5nZShzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCk7XG4gICAgICB9XG4gICAgICBpbnZhcmlhbnQoc3RlcCAhPT0gMCwgJ0Nhbm5vdCBzdGVwIGEgUmFuZ2UgYnkgMCcpO1xuICAgICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuZCA9IEluZmluaXR5O1xuICAgICAgfVxuICAgICAgc3RlcCA9IHN0ZXAgPT09IHVuZGVmaW5lZCA/IDEgOiBNYXRoLmFicyhzdGVwKTtcbiAgICAgIGlmIChlbmQgPCBzdGFydCkge1xuICAgICAgICBzdGVwID0gLXN0ZXA7XG4gICAgICB9XG4gICAgICB0aGlzLl9zdGFydCA9IHN0YXJ0O1xuICAgICAgdGhpcy5fZW5kID0gZW5kO1xuICAgICAgdGhpcy5fc3RlcCA9IHN0ZXA7XG4gICAgICB0aGlzLnNpemUgPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKGVuZCAtIHN0YXJ0KSAvIHN0ZXAgLSAxKSArIDEpO1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBpZiAoRU1QVFlfUkFOR0UpIHtcbiAgICAgICAgICByZXR1cm4gRU1QVFlfUkFOR0U7XG4gICAgICAgIH1cbiAgICAgICAgRU1QVFlfUkFOR0UgPSB0aGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICggSW5kZXhlZFNlcSApIFJhbmdlLl9fcHJvdG9fXyA9IEluZGV4ZWRTZXE7XG4gICAgUmFuZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW5kZXhlZFNlcSAmJiBJbmRleGVkU2VxLnByb3RvdHlwZSApO1xuICAgIFJhbmdlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJhbmdlO1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJ1JhbmdlIFtdJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXG4gICAgICAgICdSYW5nZSBbICcgK1xuICAgICAgICB0aGlzLl9zdGFydCArXG4gICAgICAgICcuLi4nICtcbiAgICAgICAgdGhpcy5fZW5kICtcbiAgICAgICAgKHRoaXMuX3N0ZXAgIT09IDEgPyAnIGJ5ICcgKyB0aGlzLl9zdGVwIDogJycpICtcbiAgICAgICAgJyBdJ1xuICAgICAgKTtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXMoaW5kZXgpXG4gICAgICAgID8gdGhpcy5fc3RhcnQgKyB3cmFwSW5kZXgodGhpcywgaW5kZXgpICogdGhpcy5fc3RlcFxuICAgICAgICA6IG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICBSYW5nZS5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAoc2VhcmNoVmFsdWUpIHtcbiAgICAgIHZhciBwb3NzaWJsZUluZGV4ID0gKHNlYXJjaFZhbHVlIC0gdGhpcy5fc3RhcnQpIC8gdGhpcy5fc3RlcDtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHBvc3NpYmxlSW5kZXggPj0gMCAmJlxuICAgICAgICBwb3NzaWJsZUluZGV4IDwgdGhpcy5zaXplICYmXG4gICAgICAgIHBvc3NpYmxlSW5kZXggPT09IE1hdGguZmxvb3IocG9zc2libGVJbmRleClcbiAgICAgICk7XG4gICAgfTtcblxuICAgIFJhbmdlLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChiZWdpbiwgZW5kKSB7XG4gICAgICBpZiAod2hvbGVTbGljZShiZWdpbiwgZW5kLCB0aGlzLnNpemUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgYmVnaW4gPSByZXNvbHZlQmVnaW4oYmVnaW4sIHRoaXMuc2l6ZSk7XG4gICAgICBlbmQgPSByZXNvbHZlRW5kKGVuZCwgdGhpcy5zaXplKTtcbiAgICAgIGlmIChlbmQgPD0gYmVnaW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZSgwLCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmFuZ2UoXG4gICAgICAgIHRoaXMuZ2V0KGJlZ2luLCB0aGlzLl9lbmQpLFxuICAgICAgICB0aGlzLmdldChlbmQsIHRoaXMuX2VuZCksXG4gICAgICAgIHRoaXMuX3N0ZXBcbiAgICAgICk7XG4gICAgfTtcblxuICAgIFJhbmdlLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAoc2VhcmNoVmFsdWUpIHtcbiAgICAgIHZhciBvZmZzZXRWYWx1ZSA9IHNlYXJjaFZhbHVlIC0gdGhpcy5fc3RhcnQ7XG4gICAgICBpZiAob2Zmc2V0VmFsdWUgJSB0aGlzLl9zdGVwID09PSAwKSB7XG4gICAgICAgIHZhciBpbmRleCA9IG9mZnNldFZhbHVlIC8gdGhpcy5fc3RlcDtcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLnNpemUpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHNlYXJjaFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleE9mKHNlYXJjaFZhbHVlKTtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICAgIHZhciBzaXplID0gdGhpcy5zaXplO1xuICAgICAgdmFyIHN0ZXAgPSB0aGlzLl9zdGVwO1xuICAgICAgdmFyIHZhbHVlID0gcmV2ZXJzZSA/IHRoaXMuX3N0YXJ0ICsgKHNpemUgLSAxKSAqIHN0ZXAgOiB0aGlzLl9zdGFydDtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpICE9PSBzaXplKSB7XG4gICAgICAgIGlmIChmbih2YWx1ZSwgcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKyssIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlICs9IHJldmVyc2UgPyAtc3RlcCA6IHN0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gaTtcbiAgICB9O1xuXG4gICAgUmFuZ2UucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgIHZhciBzdGVwID0gdGhpcy5fc3RlcDtcbiAgICAgIHZhciB2YWx1ZSA9IHJldmVyc2UgPyB0aGlzLl9zdGFydCArIChzaXplIC0gMSkgKiBzdGVwIDogdGhpcy5fc3RhcnQ7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGkgPT09IHNpemUpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHYgPSB2YWx1ZTtcbiAgICAgICAgdmFsdWUgKz0gcmV2ZXJzZSA/IC1zdGVwIDogc3RlcDtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKyssIHYpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFJhbmdlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKG90aGVyKSB7XG4gICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBSYW5nZVxuICAgICAgICA/IHRoaXMuX3N0YXJ0ID09PSBvdGhlci5fc3RhcnQgJiZcbiAgICAgICAgICAgIHRoaXMuX2VuZCA9PT0gb3RoZXIuX2VuZCAmJlxuICAgICAgICAgICAgdGhpcy5fc3RlcCA9PT0gb3RoZXIuX3N0ZXBcbiAgICAgICAgOiBkZWVwRXF1YWwodGhpcywgb3RoZXIpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmFuZ2U7XG4gIH0oSW5kZXhlZFNlcSkpO1xuXG4gIHZhciBFTVBUWV9SQU5HRTtcblxuICBmdW5jdGlvbiBnZXRJbihjb2xsZWN0aW9uLCBzZWFyY2hLZXlQYXRoLCBub3RTZXRWYWx1ZSkge1xuICAgIHZhciBrZXlQYXRoID0gY29lcmNlS2V5UGF0aChzZWFyY2hLZXlQYXRoKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgIT09IGtleVBhdGgubGVuZ3RoKSB7XG4gICAgICBjb2xsZWN0aW9uID0gZ2V0KGNvbGxlY3Rpb24sIGtleVBhdGhbaSsrXSwgTk9UX1NFVCk7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PT0gTk9UX1NFVCkge1xuICAgICAgICByZXR1cm4gbm90U2V0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SW4kMShzZWFyY2hLZXlQYXRoLCBub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiBnZXRJbih0aGlzLCBzZWFyY2hLZXlQYXRoLCBub3RTZXRWYWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNJbihjb2xsZWN0aW9uLCBrZXlQYXRoKSB7XG4gICAgcmV0dXJuIGdldEluKGNvbGxlY3Rpb24sIGtleVBhdGgsIE5PVF9TRVQpICE9PSBOT1RfU0VUO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzSW4kMShzZWFyY2hLZXlQYXRoKSB7XG4gICAgcmV0dXJuIGhhc0luKHRoaXMsIHNlYXJjaEtleVBhdGgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcbiAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgIG9iamVjdFtrXSA9IHY7XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIC8vIE5vdGU6IGFsbCBvZiB0aGVzZSBtZXRob2RzIGFyZSBkZXByZWNhdGVkLlxuICBDb2xsZWN0aW9uLmlzSXRlcmFibGUgPSBpc0NvbGxlY3Rpb247XG4gIENvbGxlY3Rpb24uaXNLZXllZCA9IGlzS2V5ZWQ7XG4gIENvbGxlY3Rpb24uaXNJbmRleGVkID0gaXNJbmRleGVkO1xuICBDb2xsZWN0aW9uLmlzQXNzb2NpYXRpdmUgPSBpc0Fzc29jaWF0aXZlO1xuICBDb2xsZWN0aW9uLmlzT3JkZXJlZCA9IGlzT3JkZXJlZDtcblxuICBDb2xsZWN0aW9uLkl0ZXJhdG9yID0gSXRlcmF0b3I7XG5cbiAgbWl4aW4oQ29sbGVjdGlvbiwge1xuICAgIC8vICMjIyBDb252ZXJzaW9uIHRvIG90aGVyIHR5cGVzXG5cbiAgICB0b0FycmF5OiBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcbiAgICAgIHZhciBhcnJheSA9IG5ldyBBcnJheSh0aGlzLnNpemUgfHwgMCk7XG4gICAgICB2YXIgdXNlVHVwbGVzID0gaXNLZXllZCh0aGlzKTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHRoaXMuX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgIC8vIEtleWVkIGNvbGxlY3Rpb25zIHByb2R1Y2UgYW4gYXJyYXkgb2YgdHVwbGVzLlxuICAgICAgICBhcnJheVtpKytdID0gdXNlVHVwbGVzID8gW2ssIHZdIDogdjtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH0sXG5cbiAgICB0b0luZGV4ZWRTZXE6IGZ1bmN0aW9uIHRvSW5kZXhlZFNlcSgpIHtcbiAgICAgIHJldHVybiBuZXcgVG9JbmRleGVkU2VxdWVuY2UodGhpcyk7XG4gICAgfSxcblxuICAgIHRvSlM6IGZ1bmN0aW9uIHRvSlMkMSgpIHtcbiAgICAgIHJldHVybiB0b0pTKHRoaXMpO1xuICAgIH0sXG5cbiAgICB0b0tleWVkU2VxOiBmdW5jdGlvbiB0b0tleWVkU2VxKCkge1xuICAgICAgcmV0dXJuIG5ldyBUb0tleWVkU2VxdWVuY2UodGhpcywgdHJ1ZSk7XG4gICAgfSxcblxuICAgIHRvTWFwOiBmdW5jdGlvbiB0b01hcCgpIHtcbiAgICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICAgIHJldHVybiBNYXAodGhpcy50b0tleWVkU2VxKCkpO1xuICAgIH0sXG5cbiAgICB0b09iamVjdDogdG9PYmplY3QsXG5cbiAgICB0b09yZGVyZWRNYXA6IGZ1bmN0aW9uIHRvT3JkZXJlZE1hcCgpIHtcbiAgICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICAgIHJldHVybiBPcmRlcmVkTWFwKHRoaXMudG9LZXllZFNlcSgpKTtcbiAgICB9LFxuXG4gICAgdG9PcmRlcmVkU2V0OiBmdW5jdGlvbiB0b09yZGVyZWRTZXQoKSB7XG4gICAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgICByZXR1cm4gT3JkZXJlZFNldChpc0tleWVkKHRoaXMpID8gdGhpcy52YWx1ZVNlcSgpIDogdGhpcyk7XG4gICAgfSxcblxuICAgIHRvU2V0OiBmdW5jdGlvbiB0b1NldCgpIHtcbiAgICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICAgIHJldHVybiBTZXQoaXNLZXllZCh0aGlzKSA/IHRoaXMudmFsdWVTZXEoKSA6IHRoaXMpO1xuICAgIH0sXG5cbiAgICB0b1NldFNlcTogZnVuY3Rpb24gdG9TZXRTZXEoKSB7XG4gICAgICByZXR1cm4gbmV3IFRvU2V0U2VxdWVuY2UodGhpcyk7XG4gICAgfSxcblxuICAgIHRvU2VxOiBmdW5jdGlvbiB0b1NlcSgpIHtcbiAgICAgIHJldHVybiBpc0luZGV4ZWQodGhpcylcbiAgICAgICAgPyB0aGlzLnRvSW5kZXhlZFNlcSgpXG4gICAgICAgIDogaXNLZXllZCh0aGlzKVxuICAgICAgICA/IHRoaXMudG9LZXllZFNlcSgpXG4gICAgICAgIDogdGhpcy50b1NldFNlcSgpO1xuICAgIH0sXG5cbiAgICB0b1N0YWNrOiBmdW5jdGlvbiB0b1N0YWNrKCkge1xuICAgICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgICAgcmV0dXJuIFN0YWNrKGlzS2V5ZWQodGhpcykgPyB0aGlzLnZhbHVlU2VxKCkgOiB0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9MaXN0OiBmdW5jdGlvbiB0b0xpc3QoKSB7XG4gICAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgICByZXR1cm4gTGlzdChpc0tleWVkKHRoaXMpID8gdGhpcy52YWx1ZVNlcSgpIDogdGhpcyk7XG4gICAgfSxcblxuICAgIC8vICMjIyBDb21tb24gSmF2YVNjcmlwdCBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ1tDb2xsZWN0aW9uXSc7XG4gICAgfSxcblxuICAgIF9fdG9TdHJpbmc6IGZ1bmN0aW9uIF9fdG9TdHJpbmcoaGVhZCwgdGFpbCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gKFxuICAgICAgICBoZWFkICtcbiAgICAgICAgJyAnICtcbiAgICAgICAgdGhpcy50b1NlcSgpLm1hcCh0aGlzLl9fdG9TdHJpbmdNYXBwZXIpLmpvaW4oJywgJykgK1xuICAgICAgICAnICcgK1xuICAgICAgICB0YWlsXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvLyAjIyMgRVM2IENvbGxlY3Rpb24gbWV0aG9kcyAoRVM2IEFycmF5IGFuZCBNYXApXG5cbiAgICBjb25jYXQ6IGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSB2YWx1ZXNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGNvbmNhdEZhY3RvcnkodGhpcywgdmFsdWVzKSk7XG4gICAgfSxcblxuICAgIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc29tZShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGlzKHZhbHVlLCBzZWFyY2hWYWx1ZSk7IH0pO1xuICAgIH0sXG5cbiAgICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMpO1xuICAgIH0sXG5cbiAgICBldmVyeTogZnVuY3Rpb24gZXZlcnkocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgICAgdmFyIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrLCBjKSB7XG4gICAgICAgIGlmICghcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgYykpIHtcbiAgICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfSxcblxuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGZpbHRlckZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0LCB0cnVlKSk7XG4gICAgfSxcblxuICAgIGZpbmQ6IGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSkge1xuICAgICAgdmFyIGVudHJ5ID0gdGhpcy5maW5kRW50cnkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBlbnRyeSA/IGVudHJ5WzFdIDogbm90U2V0VmFsdWU7XG4gICAgfSxcblxuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goc2lkZUVmZmVjdCwgY29udGV4dCkge1xuICAgICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcbiAgICAgIHJldHVybiB0aGlzLl9faXRlcmF0ZShjb250ZXh0ID8gc2lkZUVmZmVjdC5iaW5kKGNvbnRleHQpIDogc2lkZUVmZmVjdCk7XG4gICAgfSxcblxuICAgIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7XG4gICAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgICAgc2VwYXJhdG9yID0gc2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyAnJyArIHNlcGFyYXRvciA6ICcsJztcbiAgICAgIHZhciBqb2luZWQgPSAnJztcbiAgICAgIHZhciBpc0ZpcnN0ID0gdHJ1ZTtcbiAgICAgIHRoaXMuX19pdGVyYXRlKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlzRmlyc3QgPyAoaXNGaXJzdCA9IGZhbHNlKSA6IChqb2luZWQgKz0gc2VwYXJhdG9yKTtcbiAgICAgICAgam9pbmVkICs9IHYgIT09IG51bGwgJiYgdiAhPT0gdW5kZWZpbmVkID8gdi50b1N0cmluZygpIDogJyc7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBqb2luZWQ7XG4gICAgfSxcblxuICAgIGtleXM6IGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfS0VZUyk7XG4gICAgfSxcblxuICAgIG1hcDogZnVuY3Rpb24gbWFwKG1hcHBlciwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIG1hcEZhY3RvcnkodGhpcywgbWFwcGVyLCBjb250ZXh0KSk7XG4gICAgfSxcblxuICAgIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlJDEocmVkdWNlciwgaW5pdGlhbFJlZHVjdGlvbiwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlZHVjZShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgcmVkdWNlcixcbiAgICAgICAgaW5pdGlhbFJlZHVjdGlvbixcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA8IDIsXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgIH0sXG5cbiAgICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQocmVkdWNlciwgaW5pdGlhbFJlZHVjdGlvbiwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlZHVjZShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgcmVkdWNlcixcbiAgICAgICAgaW5pdGlhbFJlZHVjdGlvbixcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA8IDIsXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfSxcblxuICAgIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgcmV2ZXJzZUZhY3RvcnkodGhpcywgdHJ1ZSkpO1xuICAgIH0sXG5cbiAgICBzbGljZTogZnVuY3Rpb24gc2xpY2UoYmVnaW4sIGVuZCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHNsaWNlRmFjdG9yeSh0aGlzLCBiZWdpbiwgZW5kLCB0cnVlKSk7XG4gICAgfSxcblxuICAgIHNvbWU6IGZ1bmN0aW9uIHNvbWUocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gIXRoaXMuZXZlcnkobm90KHByZWRpY2F0ZSksIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yKSk7XG4gICAgfSxcblxuICAgIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUyk7XG4gICAgfSxcblxuICAgIC8vICMjIyBNb3JlIHNlcXVlbnRpYWwgbWV0aG9kc1xuXG4gICAgYnV0TGFzdDogZnVuY3Rpb24gYnV0TGFzdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNsaWNlKDAsIC0xKTtcbiAgICB9LFxuXG4gICAgaXNFbXB0eTogZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNpemUgIT09IHVuZGVmaW5lZCA/IHRoaXMuc2l6ZSA9PT0gMCA6ICF0aGlzLnNvbWUoZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG4gICAgfSxcblxuICAgIGNvdW50OiBmdW5jdGlvbiBjb3VudChwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiBlbnN1cmVTaXplKFxuICAgICAgICBwcmVkaWNhdGUgPyB0aGlzLnRvU2VxKCkuZmlsdGVyKHByZWRpY2F0ZSwgY29udGV4dCkgOiB0aGlzXG4gICAgICApO1xuICAgIH0sXG5cbiAgICBjb3VudEJ5OiBmdW5jdGlvbiBjb3VudEJ5KGdyb3VwZXIsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiBjb3VudEJ5RmFjdG9yeSh0aGlzLCBncm91cGVyLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICAgIHJldHVybiBkZWVwRXF1YWwodGhpcywgb3RoZXIpO1xuICAgIH0sXG5cbiAgICBlbnRyeVNlcTogZnVuY3Rpb24gZW50cnlTZXEoKSB7XG4gICAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICBpZiAoY29sbGVjdGlvbi5fY2FjaGUpIHtcbiAgICAgICAgLy8gV2UgY2FjaGUgYXMgYW4gZW50cmllcyBhcnJheSwgc28gd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBjYWNoZSFcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheVNlcShjb2xsZWN0aW9uLl9jYWNoZSk7XG4gICAgICB9XG4gICAgICB2YXIgZW50cmllc1NlcXVlbmNlID0gY29sbGVjdGlvbi50b1NlcSgpLm1hcChlbnRyeU1hcHBlcikudG9JbmRleGVkU2VxKCk7XG4gICAgICBlbnRyaWVzU2VxdWVuY2UuZnJvbUVudHJ5U2VxID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29sbGVjdGlvbi50b1NlcSgpOyB9O1xuICAgICAgcmV0dXJuIGVudHJpZXNTZXF1ZW5jZTtcbiAgICB9LFxuXG4gICAgZmlsdGVyTm90OiBmdW5jdGlvbiBmaWx0ZXJOb3QocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIobm90KHByZWRpY2F0ZSksIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBmaW5kRW50cnk6IGZ1bmN0aW9uIGZpbmRFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQsIG5vdFNldFZhbHVlKSB7XG4gICAgICB2YXIgZm91bmQgPSBub3RTZXRWYWx1ZTtcbiAgICAgIHRoaXMuX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrLCBjKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCBjKSkge1xuICAgICAgICAgIGZvdW5kID0gW2ssIHZdO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfSxcblxuICAgIGZpbmRLZXk6IGZ1bmN0aW9uIGZpbmRLZXkocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgZW50cnkgPSB0aGlzLmZpbmRFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5WzBdO1xuICAgIH0sXG5cbiAgICBmaW5kTGFzdDogZnVuY3Rpb24gZmluZExhc3QocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9LZXllZFNlcSgpLnJldmVyc2UoKS5maW5kKHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpO1xuICAgIH0sXG5cbiAgICBmaW5kTGFzdEVudHJ5OiBmdW5jdGlvbiBmaW5kTGFzdEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvS2V5ZWRTZXEoKVxuICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgIC5maW5kRW50cnkocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSk7XG4gICAgfSxcblxuICAgIGZpbmRMYXN0S2V5OiBmdW5jdGlvbiBmaW5kTGFzdEtleShwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvS2V5ZWRTZXEoKS5yZXZlcnNlKCkuZmluZEtleShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBmaXJzdDogZnVuY3Rpb24gZmlyc3Qobm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmQocmV0dXJuVHJ1ZSwgbnVsbCwgbm90U2V0VmFsdWUpO1xuICAgIH0sXG5cbiAgICBmbGF0TWFwOiBmdW5jdGlvbiBmbGF0TWFwKG1hcHBlciwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGZsYXRNYXBGYWN0b3J5KHRoaXMsIG1hcHBlciwgY29udGV4dCkpO1xuICAgIH0sXG5cbiAgICBmbGF0dGVuOiBmdW5jdGlvbiBmbGF0dGVuKGRlcHRoKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgZmxhdHRlbkZhY3RvcnkodGhpcywgZGVwdGgsIHRydWUpKTtcbiAgICB9LFxuXG4gICAgZnJvbUVudHJ5U2VxOiBmdW5jdGlvbiBmcm9tRW50cnlTZXEoKSB7XG4gICAgICByZXR1cm4gbmV3IEZyb21FbnRyaWVzU2VxdWVuY2UodGhpcyk7XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24gZ2V0KHNlYXJjaEtleSwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmQoZnVuY3Rpb24gKF8sIGtleSkgeyByZXR1cm4gaXMoa2V5LCBzZWFyY2hLZXkpOyB9LCB1bmRlZmluZWQsIG5vdFNldFZhbHVlKTtcbiAgICB9LFxuXG4gICAgZ2V0SW46IGdldEluJDEsXG5cbiAgICBncm91cEJ5OiBmdW5jdGlvbiBncm91cEJ5KGdyb3VwZXIsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiBncm91cEJ5RmFjdG9yeSh0aGlzLCBncm91cGVyLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgaGFzOiBmdW5jdGlvbiBoYXMoc2VhcmNoS2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoc2VhcmNoS2V5LCBOT1RfU0VUKSAhPT0gTk9UX1NFVDtcbiAgICB9LFxuXG4gICAgaGFzSW46IGhhc0luJDEsXG5cbiAgICBpc1N1YnNldDogZnVuY3Rpb24gaXNTdWJzZXQoaXRlcikge1xuICAgICAgaXRlciA9IHR5cGVvZiBpdGVyLmluY2x1ZGVzID09PSAnZnVuY3Rpb24nID8gaXRlciA6IENvbGxlY3Rpb24oaXRlcik7XG4gICAgICByZXR1cm4gdGhpcy5ldmVyeShmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGl0ZXIuaW5jbHVkZXModmFsdWUpOyB9KTtcbiAgICB9LFxuXG4gICAgaXNTdXBlcnNldDogZnVuY3Rpb24gaXNTdXBlcnNldChpdGVyKSB7XG4gICAgICBpdGVyID0gdHlwZW9mIGl0ZXIuaXNTdWJzZXQgPT09ICdmdW5jdGlvbicgPyBpdGVyIDogQ29sbGVjdGlvbihpdGVyKTtcbiAgICAgIHJldHVybiBpdGVyLmlzU3Vic2V0KHRoaXMpO1xuICAgIH0sXG5cbiAgICBrZXlPZjogZnVuY3Rpb24ga2V5T2Yoc2VhcmNoVmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmRLZXkoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBpcyh2YWx1ZSwgc2VhcmNoVmFsdWUpOyB9KTtcbiAgICB9LFxuXG4gICAga2V5U2VxOiBmdW5jdGlvbiBrZXlTZXEoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1NlcSgpLm1hcChrZXlNYXBwZXIpLnRvSW5kZXhlZFNlcSgpO1xuICAgIH0sXG5cbiAgICBsYXN0OiBmdW5jdGlvbiBsYXN0KG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1NlcSgpLnJldmVyc2UoKS5maXJzdChub3RTZXRWYWx1ZSk7XG4gICAgfSxcblxuICAgIGxhc3RLZXlPZjogZnVuY3Rpb24gbGFzdEtleU9mKHNlYXJjaFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0tleWVkU2VxKCkucmV2ZXJzZSgpLmtleU9mKHNlYXJjaFZhbHVlKTtcbiAgICB9LFxuXG4gICAgbWF4OiBmdW5jdGlvbiBtYXgoY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIG1heEZhY3RvcnkodGhpcywgY29tcGFyYXRvcik7XG4gICAgfSxcblxuICAgIG1heEJ5OiBmdW5jdGlvbiBtYXhCeShtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiBtYXhGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IsIG1hcHBlcik7XG4gICAgfSxcblxuICAgIG1pbjogZnVuY3Rpb24gbWluKGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiBtYXhGYWN0b3J5KFxuICAgICAgICB0aGlzLFxuICAgICAgICBjb21wYXJhdG9yID8gbmVnKGNvbXBhcmF0b3IpIDogZGVmYXVsdE5lZ0NvbXBhcmF0b3JcbiAgICAgICk7XG4gICAgfSxcblxuICAgIG1pbkJ5OiBmdW5jdGlvbiBtaW5CeShtYXBwZXIsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiBtYXhGYWN0b3J5KFxuICAgICAgICB0aGlzLFxuICAgICAgICBjb21wYXJhdG9yID8gbmVnKGNvbXBhcmF0b3IpIDogZGVmYXVsdE5lZ0NvbXBhcmF0b3IsXG4gICAgICAgIG1hcHBlclxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgcmVzdDogZnVuY3Rpb24gcmVzdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNsaWNlKDEpO1xuICAgIH0sXG5cbiAgICBza2lwOiBmdW5jdGlvbiBza2lwKGFtb3VudCkge1xuICAgICAgcmV0dXJuIGFtb3VudCA9PT0gMCA/IHRoaXMgOiB0aGlzLnNsaWNlKE1hdGgubWF4KDAsIGFtb3VudCkpO1xuICAgIH0sXG5cbiAgICBza2lwTGFzdDogZnVuY3Rpb24gc2tpcExhc3QoYW1vdW50KSB7XG4gICAgICByZXR1cm4gYW1vdW50ID09PSAwID8gdGhpcyA6IHRoaXMuc2xpY2UoMCwgLU1hdGgubWF4KDAsIGFtb3VudCkpO1xuICAgIH0sXG5cbiAgICBza2lwV2hpbGU6IGZ1bmN0aW9uIHNraXBXaGlsZShwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBza2lwV2hpbGVGYWN0b3J5KHRoaXMsIHByZWRpY2F0ZSwgY29udGV4dCwgdHJ1ZSkpO1xuICAgIH0sXG5cbiAgICBza2lwVW50aWw6IGZ1bmN0aW9uIHNraXBVbnRpbChwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNraXBXaGlsZShub3QocHJlZGljYXRlKSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIHNvcnRCeTogZnVuY3Rpb24gc29ydEJ5KG1hcHBlciwgY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IsIG1hcHBlcikpO1xuICAgIH0sXG5cbiAgICB0YWtlOiBmdW5jdGlvbiB0YWtlKGFtb3VudCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoMCwgTWF0aC5tYXgoMCwgYW1vdW50KSk7XG4gICAgfSxcblxuICAgIHRha2VMYXN0OiBmdW5jdGlvbiB0YWtlTGFzdChhbW91bnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNsaWNlKC1NYXRoLm1heCgwLCBhbW91bnQpKTtcbiAgICB9LFxuXG4gICAgdGFrZVdoaWxlOiBmdW5jdGlvbiB0YWtlV2hpbGUocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgdGFrZVdoaWxlRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQpKTtcbiAgICB9LFxuXG4gICAgdGFrZVVudGlsOiBmdW5jdGlvbiB0YWtlVW50aWwocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy50YWtlV2hpbGUobm90KHByZWRpY2F0ZSksIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShmbikge1xuICAgICAgcmV0dXJuIGZuKHRoaXMpO1xuICAgIH0sXG5cbiAgICB2YWx1ZVNlcTogZnVuY3Rpb24gdmFsdWVTZXEoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0luZGV4ZWRTZXEoKTtcbiAgICB9LFxuXG4gICAgLy8gIyMjIEhhc2hhYmxlIE9iamVjdFxuXG4gICAgaGFzaENvZGU6IGZ1bmN0aW9uIGhhc2hDb2RlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX19oYXNoIHx8ICh0aGlzLl9faGFzaCA9IGhhc2hDb2xsZWN0aW9uKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgLy8gIyMjIEludGVybmFsXG5cbiAgICAvLyBhYnN0cmFjdCBfX2l0ZXJhdGUoZm4sIHJldmVyc2UpXG5cbiAgICAvLyBhYnN0cmFjdCBfX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpXG4gIH0pO1xuXG4gIHZhciBDb2xsZWN0aW9uUHJvdG90eXBlID0gQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIENvbGxlY3Rpb25Qcm90b3R5cGVbSVNfQ09MTEVDVElPTl9TWU1CT0xdID0gdHJ1ZTtcbiAgQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUl9TWU1CT0xdID0gQ29sbGVjdGlvblByb3RvdHlwZS52YWx1ZXM7XG4gIENvbGxlY3Rpb25Qcm90b3R5cGUudG9KU09OID0gQ29sbGVjdGlvblByb3RvdHlwZS50b0FycmF5O1xuICBDb2xsZWN0aW9uUHJvdG90eXBlLl9fdG9TdHJpbmdNYXBwZXIgPSBxdW90ZVN0cmluZztcbiAgQ29sbGVjdGlvblByb3RvdHlwZS5pbnNwZWN0ID0gQ29sbGVjdGlvblByb3RvdHlwZS50b1NvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xuICBDb2xsZWN0aW9uUHJvdG90eXBlLmNoYWluID0gQ29sbGVjdGlvblByb3RvdHlwZS5mbGF0TWFwO1xuICBDb2xsZWN0aW9uUHJvdG90eXBlLmNvbnRhaW5zID0gQ29sbGVjdGlvblByb3RvdHlwZS5pbmNsdWRlcztcblxuICBtaXhpbihLZXllZENvbGxlY3Rpb24sIHtcbiAgICAvLyAjIyMgTW9yZSBzZXF1ZW50aWFsIG1ldGhvZHNcblxuICAgIGZsaXA6IGZ1bmN0aW9uIGZsaXAoKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgZmxpcEZhY3RvcnkodGhpcykpO1xuICAgIH0sXG5cbiAgICBtYXBFbnRyaWVzOiBmdW5jdGlvbiBtYXBFbnRyaWVzKG1hcHBlciwgY29udGV4dCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHJldHVybiByZWlmeShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy50b1NlcSgpXG4gICAgICAgICAgLm1hcChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gbWFwcGVyLmNhbGwoY29udGV4dCwgW2ssIHZdLCBpdGVyYXRpb25zKyssIHRoaXMkMSk7IH0pXG4gICAgICAgICAgLmZyb21FbnRyeVNlcSgpXG4gICAgICApO1xuICAgIH0sXG5cbiAgICBtYXBLZXlzOiBmdW5jdGlvbiBtYXBLZXlzKG1hcHBlciwgY29udGV4dCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiByZWlmeShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy50b1NlcSgpXG4gICAgICAgICAgLmZsaXAoKVxuICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGssIHYpIHsgcmV0dXJuIG1hcHBlci5jYWxsKGNvbnRleHQsIGssIHYsIHRoaXMkMSk7IH0pXG4gICAgICAgICAgLmZsaXAoKVxuICAgICAgKTtcbiAgICB9LFxuICB9KTtcblxuICB2YXIgS2V5ZWRDb2xsZWN0aW9uUHJvdG90eXBlID0gS2V5ZWRDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgS2V5ZWRDb2xsZWN0aW9uUHJvdG90eXBlW0lTX0tFWUVEX1NZTUJPTF0gPSB0cnVlO1xuICBLZXllZENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JfU1lNQk9MXSA9IENvbGxlY3Rpb25Qcm90b3R5cGUuZW50cmllcztcbiAgS2V5ZWRDb2xsZWN0aW9uUHJvdG90eXBlLnRvSlNPTiA9IHRvT2JqZWN0O1xuICBLZXllZENvbGxlY3Rpb25Qcm90b3R5cGUuX190b1N0cmluZ01hcHBlciA9IGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBxdW90ZVN0cmluZyhrKSArICc6ICcgKyBxdW90ZVN0cmluZyh2KTsgfTtcblxuICBtaXhpbihJbmRleGVkQ29sbGVjdGlvbiwge1xuICAgIC8vICMjIyBDb252ZXJzaW9uIHRvIG90aGVyIHR5cGVzXG5cbiAgICB0b0tleWVkU2VxOiBmdW5jdGlvbiB0b0tleWVkU2VxKCkge1xuICAgICAgcmV0dXJuIG5ldyBUb0tleWVkU2VxdWVuY2UodGhpcywgZmFsc2UpO1xuICAgIH0sXG5cbiAgICAvLyAjIyMgRVM2IENvbGxlY3Rpb24gbWV0aG9kcyAoRVM2IEFycmF5IGFuZCBNYXApXG5cbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWlmeSh0aGlzLCBmaWx0ZXJGYWN0b3J5KHRoaXMsIHByZWRpY2F0ZSwgY29udGV4dCwgZmFsc2UpKTtcbiAgICB9LFxuXG4gICAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgZW50cnkgPSB0aGlzLmZpbmRFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIGVudHJ5ID8gZW50cnlbMF0gOiAtMTtcbiAgICB9LFxuXG4gICAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hWYWx1ZSkge1xuICAgICAgdmFyIGtleSA9IHRoaXMua2V5T2Yoc2VhcmNoVmFsdWUpO1xuICAgICAgcmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID8gLTEgOiBrZXk7XG4gICAgfSxcblxuICAgIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hWYWx1ZSkge1xuICAgICAgdmFyIGtleSA9IHRoaXMubGFzdEtleU9mKHNlYXJjaFZhbHVlKTtcbiAgICAgIHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/IC0xIDoga2V5O1xuICAgIH0sXG5cbiAgICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHJldmVyc2VGYWN0b3J5KHRoaXMsIGZhbHNlKSk7XG4gICAgfSxcblxuICAgIHNsaWNlOiBmdW5jdGlvbiBzbGljZShiZWdpbiwgZW5kKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgc2xpY2VGYWN0b3J5KHRoaXMsIGJlZ2luLCBlbmQsIGZhbHNlKSk7XG4gICAgfSxcblxuICAgIHNwbGljZTogZnVuY3Rpb24gc3BsaWNlKGluZGV4LCByZW1vdmVOdW0gLyosIC4uLnZhbHVlcyovKSB7XG4gICAgICB2YXIgbnVtQXJncyA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICByZW1vdmVOdW0gPSBNYXRoLm1heChyZW1vdmVOdW0gfHwgMCwgMCk7XG4gICAgICBpZiAobnVtQXJncyA9PT0gMCB8fCAobnVtQXJncyA9PT0gMiAmJiAhcmVtb3ZlTnVtKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIC8vIElmIGluZGV4IGlzIG5lZ2F0aXZlLCBpdCBzaG91bGQgcmVzb2x2ZSByZWxhdGl2ZSB0byB0aGUgc2l6ZSBvZiB0aGVcbiAgICAgIC8vIGNvbGxlY3Rpb24uIEhvd2V2ZXIgc2l6ZSBtYXkgYmUgZXhwZW5zaXZlIHRvIGNvbXB1dGUgaWYgbm90IGNhY2hlZCwgc29cbiAgICAgIC8vIG9ubHkgY2FsbCBjb3VudCgpIGlmIHRoZSBudW1iZXIgaXMgaW4gZmFjdCBuZWdhdGl2ZS5cbiAgICAgIGluZGV4ID0gcmVzb2x2ZUJlZ2luKGluZGV4LCBpbmRleCA8IDAgPyB0aGlzLmNvdW50KCkgOiB0aGlzLnNpemUpO1xuICAgICAgdmFyIHNwbGljZWQgPSB0aGlzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgIHJldHVybiByZWlmeShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgbnVtQXJncyA9PT0gMVxuICAgICAgICAgID8gc3BsaWNlZFxuICAgICAgICAgIDogc3BsaWNlZC5jb25jYXQoYXJyQ29weShhcmd1bWVudHMsIDIpLCB0aGlzLnNsaWNlKGluZGV4ICsgcmVtb3ZlTnVtKSlcbiAgICAgICk7XG4gICAgfSxcblxuICAgIC8vICMjIyBNb3JlIGNvbGxlY3Rpb24gbWV0aG9kc1xuXG4gICAgZmluZExhc3RJbmRleDogZnVuY3Rpb24gZmluZExhc3RJbmRleChwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBlbnRyeSA9IHRoaXMuZmluZExhc3RFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIGVudHJ5ID8gZW50cnlbMF0gOiAtMTtcbiAgICB9LFxuXG4gICAgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0KG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoMCwgbm90U2V0VmFsdWUpO1xuICAgIH0sXG5cbiAgICBmbGF0dGVuOiBmdW5jdGlvbiBmbGF0dGVuKGRlcHRoKSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgZmxhdHRlbkZhY3RvcnkodGhpcywgZGVwdGgsIGZhbHNlKSk7XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24gZ2V0KGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgICAgaW5kZXggPSB3cmFwSW5kZXgodGhpcywgaW5kZXgpO1xuICAgICAgcmV0dXJuIGluZGV4IDwgMCB8fFxuICAgICAgICB0aGlzLnNpemUgPT09IEluZmluaXR5IHx8XG4gICAgICAgICh0aGlzLnNpemUgIT09IHVuZGVmaW5lZCAmJiBpbmRleCA+IHRoaXMuc2l6ZSlcbiAgICAgICAgPyBub3RTZXRWYWx1ZVxuICAgICAgICA6IHRoaXMuZmluZChmdW5jdGlvbiAoXywga2V5KSB7IHJldHVybiBrZXkgPT09IGluZGV4OyB9LCB1bmRlZmluZWQsIG5vdFNldFZhbHVlKTtcbiAgICB9LFxuXG4gICAgaGFzOiBmdW5jdGlvbiBoYXMoaW5kZXgpIHtcbiAgICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGluZGV4ID49IDAgJiZcbiAgICAgICAgKHRoaXMuc2l6ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyB0aGlzLnNpemUgPT09IEluZmluaXR5IHx8IGluZGV4IDwgdGhpcy5zaXplXG4gICAgICAgICAgOiB0aGlzLmluZGV4T2YoaW5kZXgpICE9PSAtMSlcbiAgICAgICk7XG4gICAgfSxcblxuICAgIGludGVycG9zZTogZnVuY3Rpb24gaW50ZXJwb3NlKHNlcGFyYXRvcikge1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGludGVycG9zZUZhY3RvcnkodGhpcywgc2VwYXJhdG9yKSk7XG4gICAgfSxcblxuICAgIGludGVybGVhdmU6IGZ1bmN0aW9uIGludGVybGVhdmUoLyouLi5jb2xsZWN0aW9ucyovKSB7XG4gICAgICB2YXIgY29sbGVjdGlvbnMgPSBbdGhpc10uY29uY2F0KGFyckNvcHkoYXJndW1lbnRzKSk7XG4gICAgICB2YXIgemlwcGVkID0gemlwV2l0aEZhY3RvcnkodGhpcy50b1NlcSgpLCBJbmRleGVkU2VxLm9mLCBjb2xsZWN0aW9ucyk7XG4gICAgICB2YXIgaW50ZXJsZWF2ZWQgPSB6aXBwZWQuZmxhdHRlbih0cnVlKTtcbiAgICAgIGlmICh6aXBwZWQuc2l6ZSkge1xuICAgICAgICBpbnRlcmxlYXZlZC5zaXplID0gemlwcGVkLnNpemUgKiBjb2xsZWN0aW9ucy5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgaW50ZXJsZWF2ZWQpO1xuICAgIH0sXG5cbiAgICBrZXlTZXE6IGZ1bmN0aW9uIGtleVNlcSgpIHtcbiAgICAgIHJldHVybiBSYW5nZSgwLCB0aGlzLnNpemUpO1xuICAgIH0sXG5cbiAgICBsYXN0OiBmdW5jdGlvbiBsYXN0KG5vdFNldFZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoLTEsIG5vdFNldFZhbHVlKTtcbiAgICB9LFxuXG4gICAgc2tpcFdoaWxlOiBmdW5jdGlvbiBza2lwV2hpbGUocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVpZnkodGhpcywgc2tpcFdoaWxlRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQsIGZhbHNlKSk7XG4gICAgfSxcblxuICAgIHppcDogZnVuY3Rpb24gemlwKC8qLCAuLi5jb2xsZWN0aW9ucyAqLykge1xuICAgICAgdmFyIGNvbGxlY3Rpb25zID0gW3RoaXNdLmNvbmNhdChhcnJDb3B5KGFyZ3VtZW50cykpO1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHppcFdpdGhGYWN0b3J5KHRoaXMsIGRlZmF1bHRaaXBwZXIsIGNvbGxlY3Rpb25zKSk7XG4gICAgfSxcblxuICAgIHppcEFsbDogZnVuY3Rpb24gemlwQWxsKC8qLCAuLi5jb2xsZWN0aW9ucyAqLykge1xuICAgICAgdmFyIGNvbGxlY3Rpb25zID0gW3RoaXNdLmNvbmNhdChhcnJDb3B5KGFyZ3VtZW50cykpO1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHppcFdpdGhGYWN0b3J5KHRoaXMsIGRlZmF1bHRaaXBwZXIsIGNvbGxlY3Rpb25zLCB0cnVlKSk7XG4gICAgfSxcblxuICAgIHppcFdpdGg6IGZ1bmN0aW9uIHppcFdpdGgoemlwcGVyIC8qLCAuLi5jb2xsZWN0aW9ucyAqLykge1xuICAgICAgdmFyIGNvbGxlY3Rpb25zID0gYXJyQ29weShhcmd1bWVudHMpO1xuICAgICAgY29sbGVjdGlvbnNbMF0gPSB0aGlzO1xuICAgICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHppcFdpdGhGYWN0b3J5KHRoaXMsIHppcHBlciwgY29sbGVjdGlvbnMpKTtcbiAgICB9LFxuICB9KTtcblxuICB2YXIgSW5kZXhlZENvbGxlY3Rpb25Qcm90b3R5cGUgPSBJbmRleGVkQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIEluZGV4ZWRDb2xsZWN0aW9uUHJvdG90eXBlW0lTX0lOREVYRURfU1lNQk9MXSA9IHRydWU7XG4gIEluZGV4ZWRDb2xsZWN0aW9uUHJvdG90eXBlW0lTX09SREVSRURfU1lNQk9MXSA9IHRydWU7XG5cbiAgbWl4aW4oU2V0Q29sbGVjdGlvbiwge1xuICAgIC8vICMjIyBFUzYgQ29sbGVjdGlvbiBtZXRob2RzIChFUzYgQXJyYXkgYW5kIE1hcClcblxuICAgIGdldDogZnVuY3Rpb24gZ2V0KHZhbHVlLCBub3RTZXRWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKHZhbHVlKSA/IHZhbHVlIDogbm90U2V0VmFsdWU7XG4gICAgfSxcblxuICAgIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzKHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLy8gIyMjIE1vcmUgc2VxdWVudGlhbCBtZXRob2RzXG5cbiAgICBrZXlTZXE6IGZ1bmN0aW9uIGtleVNlcSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlU2VxKCk7XG4gICAgfSxcbiAgfSk7XG5cbiAgU2V0Q29sbGVjdGlvbi5wcm90b3R5cGUuaGFzID0gQ29sbGVjdGlvblByb3RvdHlwZS5pbmNsdWRlcztcbiAgU2V0Q29sbGVjdGlvbi5wcm90b3R5cGUuY29udGFpbnMgPSBTZXRDb2xsZWN0aW9uLnByb3RvdHlwZS5pbmNsdWRlcztcblxuICAvLyBNaXhpbiBzdWJjbGFzc2VzXG5cbiAgbWl4aW4oS2V5ZWRTZXEsIEtleWVkQ29sbGVjdGlvbi5wcm90b3R5cGUpO1xuICBtaXhpbihJbmRleGVkU2VxLCBJbmRleGVkQ29sbGVjdGlvbi5wcm90b3R5cGUpO1xuICBtaXhpbihTZXRTZXEsIFNldENvbGxlY3Rpb24ucHJvdG90eXBlKTtcblxuICAvLyAjcHJhZ21hIEhlbHBlciBmdW5jdGlvbnNcblxuICBmdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgcmVkdWNlciwgcmVkdWN0aW9uLCBjb250ZXh0LCB1c2VGaXJzdCwgcmV2ZXJzZSkge1xuICAgIGFzc2VydE5vdEluZmluaXRlKGNvbGxlY3Rpb24uc2l6ZSk7XG4gICAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGssIGMpIHtcbiAgICAgIGlmICh1c2VGaXJzdCkge1xuICAgICAgICB1c2VGaXJzdCA9IGZhbHNlO1xuICAgICAgICByZWR1Y3Rpb24gPSB2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVkdWN0aW9uID0gcmVkdWNlci5jYWxsKGNvbnRleHQsIHJlZHVjdGlvbiwgdiwgaywgYyk7XG4gICAgICB9XG4gICAgfSwgcmV2ZXJzZSk7XG4gICAgcmV0dXJuIHJlZHVjdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGtleU1hcHBlcih2LCBrKSB7XG4gICAgcmV0dXJuIGs7XG4gIH1cblxuICBmdW5jdGlvbiBlbnRyeU1hcHBlcih2LCBrKSB7XG4gICAgcmV0dXJuIFtrLCB2XTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdChwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbmVnKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gLXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0WmlwcGVyKCkge1xuICAgIHJldHVybiBhcnJDb3B5KGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0TmVnQ29tcGFyYXRvcihhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiID8gMSA6IGEgPiBiID8gLTEgOiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzaENvbGxlY3Rpb24oY29sbGVjdGlvbikge1xuICAgIGlmIChjb2xsZWN0aW9uLnNpemUgPT09IEluZmluaXR5KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIG9yZGVyZWQgPSBpc09yZGVyZWQoY29sbGVjdGlvbik7XG4gICAgdmFyIGtleWVkID0gaXNLZXllZChjb2xsZWN0aW9uKTtcbiAgICB2YXIgaCA9IG9yZGVyZWQgPyAxIDogMDtcbiAgICB2YXIgc2l6ZSA9IGNvbGxlY3Rpb24uX19pdGVyYXRlKFxuICAgICAga2V5ZWRcbiAgICAgICAgPyBvcmRlcmVkXG4gICAgICAgICAgPyBmdW5jdGlvbiAodiwgaykge1xuICAgICAgICAgICAgICBoID0gKDMxICogaCArIGhhc2hNZXJnZShoYXNoKHYpLCBoYXNoKGspKSkgfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIDogZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICAgICAgaCA9IChoICsgaGFzaE1lcmdlKGhhc2godiksIGhhc2goaykpKSB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIDogb3JkZXJlZFxuICAgICAgICA/IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBoID0gKDMxICogaCArIGhhc2godikpIHwgMDtcbiAgICAgICAgICB9XG4gICAgICAgIDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGggPSAoaCArIGhhc2godikpIHwgMDtcbiAgICAgICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gbXVybXVySGFzaE9mU2l6ZShzaXplLCBoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG11cm11ckhhc2hPZlNpemUoc2l6ZSwgaCkge1xuICAgIGggPSBpbXVsKGgsIDB4Y2M5ZTJkNTEpO1xuICAgIGggPSBpbXVsKChoIDw8IDE1KSB8IChoID4+PiAtMTUpLCAweDFiODczNTkzKTtcbiAgICBoID0gaW11bCgoaCA8PCAxMykgfCAoaCA+Pj4gLTEzKSwgNSk7XG4gICAgaCA9ICgoaCArIDB4ZTY1NDZiNjQpIHwgMCkgXiBzaXplO1xuICAgIGggPSBpbXVsKGggXiAoaCA+Pj4gMTYpLCAweDg1ZWJjYTZiKTtcbiAgICBoID0gaW11bChoIF4gKGggPj4+IDEzKSwgMHhjMmIyYWUzNSk7XG4gICAgaCA9IHNtaShoIF4gKGggPj4+IDE2KSk7XG4gICAgcmV0dXJuIGg7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNoTWVyZ2UoYSwgYikge1xuICAgIHJldHVybiAoYSBeIChiICsgMHg5ZTM3NzliOSArIChhIDw8IDYpICsgKGEgPj4gMikpKSB8IDA7IC8vIGludFxuICB9XG5cbiAgdmFyIE9yZGVyZWRTZXQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTZXQpIHtcbiAgICBmdW5jdGlvbiBPcmRlcmVkU2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGVtcHR5T3JkZXJlZFNldCgpXG4gICAgICAgIDogaXNPcmRlcmVkU2V0KHZhbHVlKVxuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogZW1wdHlPcmRlcmVkU2V0KCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgICAgICB2YXIgaXRlciA9IFNldENvbGxlY3Rpb24odmFsdWUpO1xuICAgICAgICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICAgICAgICAgIGl0ZXIuZm9yRWFjaChmdW5jdGlvbiAodikgeyByZXR1cm4gc2V0LmFkZCh2KTsgfSk7XG4gICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCBTZXQgKSBPcmRlcmVkU2V0Ll9fcHJvdG9fXyA9IFNldDtcbiAgICBPcmRlcmVkU2V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNldCAmJiBTZXQucHJvdG90eXBlICk7XG4gICAgT3JkZXJlZFNldC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPcmRlcmVkU2V0O1xuXG4gICAgT3JkZXJlZFNldC5vZiA9IGZ1bmN0aW9uIG9mICgvKi4uLnZhbHVlcyovKSB7XG4gICAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBPcmRlcmVkU2V0LmZyb21LZXlzID0gZnVuY3Rpb24gZnJvbUtleXMgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcyhLZXllZENvbGxlY3Rpb24odmFsdWUpLmtleVNlcSgpKTtcbiAgICB9O1xuXG4gICAgT3JkZXJlZFNldC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdPcmRlcmVkU2V0IHsnLCAnfScpO1xuICAgIH07XG5cbiAgICByZXR1cm4gT3JkZXJlZFNldDtcbiAgfShTZXQpKTtcblxuICBPcmRlcmVkU2V0LmlzT3JkZXJlZFNldCA9IGlzT3JkZXJlZFNldDtcblxuICB2YXIgT3JkZXJlZFNldFByb3RvdHlwZSA9IE9yZGVyZWRTZXQucHJvdG90eXBlO1xuICBPcmRlcmVkU2V0UHJvdG90eXBlW0lTX09SREVSRURfU1lNQk9MXSA9IHRydWU7XG4gIE9yZGVyZWRTZXRQcm90b3R5cGUuemlwID0gSW5kZXhlZENvbGxlY3Rpb25Qcm90b3R5cGUuemlwO1xuICBPcmRlcmVkU2V0UHJvdG90eXBlLnppcFdpdGggPSBJbmRleGVkQ29sbGVjdGlvblByb3RvdHlwZS56aXBXaXRoO1xuXG4gIE9yZGVyZWRTZXRQcm90b3R5cGUuX19lbXB0eSA9IGVtcHR5T3JkZXJlZFNldDtcbiAgT3JkZXJlZFNldFByb3RvdHlwZS5fX21ha2UgPSBtYWtlT3JkZXJlZFNldDtcblxuICBmdW5jdGlvbiBtYWtlT3JkZXJlZFNldChtYXAsIG93bmVySUQpIHtcbiAgICB2YXIgc2V0ID0gT2JqZWN0LmNyZWF0ZShPcmRlcmVkU2V0UHJvdG90eXBlKTtcbiAgICBzZXQuc2l6ZSA9IG1hcCA/IG1hcC5zaXplIDogMDtcbiAgICBzZXQuX21hcCA9IG1hcDtcbiAgICBzZXQuX19vd25lcklEID0gb3duZXJJRDtcbiAgICByZXR1cm4gc2V0O1xuICB9XG5cbiAgdmFyIEVNUFRZX09SREVSRURfU0VUO1xuICBmdW5jdGlvbiBlbXB0eU9yZGVyZWRTZXQoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIEVNUFRZX09SREVSRURfU0VUIHx8IChFTVBUWV9PUkRFUkVEX1NFVCA9IG1ha2VPcmRlcmVkU2V0KGVtcHR5T3JkZXJlZE1hcCgpKSlcbiAgICApO1xuICB9XG5cbiAgdmFyIFJlY29yZCA9IGZ1bmN0aW9uIFJlY29yZChkZWZhdWx0VmFsdWVzLCBuYW1lKSB7XG4gICAgdmFyIGhhc0luaXRpYWxpemVkO1xuXG4gICAgdmFyIFJlY29yZFR5cGUgPSBmdW5jdGlvbiBSZWNvcmQodmFsdWVzKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIFJlY29yZFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgIH1cbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWNvcmRUeXBlKSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlY29yZFR5cGUodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGlmICghaGFzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgaGFzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRlZmF1bHRWYWx1ZXMpO1xuICAgICAgICB2YXIgaW5kaWNlcyA9IChSZWNvcmRUeXBlUHJvdG90eXBlLl9pbmRpY2VzID0ge30pO1xuICAgICAgICAvLyBEZXByZWNhdGVkOiBsZWZ0IHRvIGF0dGVtcHQgbm90IHRvIGJyZWFrIGFueSBleHRlcm5hbCBjb2RlIHdoaWNoXG4gICAgICAgIC8vIHJlbGllcyBvbiBhIC5fbmFtZSBwcm9wZXJ0eSBleGlzdGluZyBvbiByZWNvcmQgaW5zdGFuY2VzLlxuICAgICAgICAvLyBVc2UgUmVjb3JkLmdldERlc2NyaXB0aXZlTmFtZSgpIGluc3RlYWRcbiAgICAgICAgUmVjb3JkVHlwZVByb3RvdHlwZS5fbmFtZSA9IG5hbWU7XG4gICAgICAgIFJlY29yZFR5cGVQcm90b3R5cGUuX2tleXMgPSBrZXlzO1xuICAgICAgICBSZWNvcmRUeXBlUHJvdG90eXBlLl9kZWZhdWx0VmFsdWVzID0gZGVmYXVsdFZhbHVlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHByb3BOYW1lID0ga2V5c1tpXTtcbiAgICAgICAgICBpbmRpY2VzW3Byb3BOYW1lXSA9IGk7XG4gICAgICAgICAgaWYgKFJlY29yZFR5cGVQcm90b3R5cGVbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgICAgICB0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuICYmXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAnQ2Fubm90IGRlZmluZSAnICtcbiAgICAgICAgICAgICAgICAgIHJlY29yZE5hbWUodGhpcykgK1xuICAgICAgICAgICAgICAgICAgJyB3aXRoIHByb3BlcnR5IFwiJyArXG4gICAgICAgICAgICAgICAgICBwcm9wTmFtZSArXG4gICAgICAgICAgICAgICAgICAnXCIgc2luY2UgdGhhdCBwcm9wZXJ0eSBuYW1lIGlzIHBhcnQgb2YgdGhlIFJlY29yZCBBUEkuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFByb3AoUmVjb3JkVHlwZVByb3RvdHlwZSwgcHJvcE5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fX293bmVySUQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl92YWx1ZXMgPSBMaXN0KCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobCkge1xuICAgICAgICBsLnNldFNpemUodGhpcyQxLl9rZXlzLmxlbmd0aCk7XG4gICAgICAgIEtleWVkQ29sbGVjdGlvbih2YWx1ZXMpLmZvckVhY2goZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICBsLnNldCh0aGlzJDEuX2luZGljZXNba10sIHYgPT09IHRoaXMkMS5fZGVmYXVsdFZhbHVlc1trXSA/IHVuZGVmaW5lZCA6IHYpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgUmVjb3JkVHlwZVByb3RvdHlwZSA9IChSZWNvcmRUeXBlLnByb3RvdHlwZSA9XG4gICAgICBPYmplY3QuY3JlYXRlKFJlY29yZFByb3RvdHlwZSkpO1xuICAgIFJlY29yZFR5cGVQcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZWNvcmRUeXBlO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFJlY29yZFR5cGUuZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgIH1cblxuICAgIHJldHVybiBSZWNvcmRUeXBlO1xuICB9O1xuXG4gIFJlY29yZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgdmFyIHN0ciA9IHJlY29yZE5hbWUodGhpcykgKyAnIHsgJztcbiAgICB2YXIga2V5cyA9IHRoaXMuX2tleXM7XG4gICAgdmFyIGs7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSAhPT0gbDsgaSsrKSB7XG4gICAgICBrID0ga2V5c1tpXTtcbiAgICAgIHN0ciArPSAoaSA/ICcsICcgOiAnJykgKyBrICsgJzogJyArIHF1b3RlU3RyaW5nKHRoaXMuZ2V0KGspKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0ciArICcgfSc7XG4gIH07XG5cbiAgUmVjb3JkLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKG90aGVyKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMgPT09IG90aGVyIHx8XG4gICAgICAob3RoZXIgJiZcbiAgICAgICAgdGhpcy5fa2V5cyA9PT0gb3RoZXIuX2tleXMgJiZcbiAgICAgICAgcmVjb3JkU2VxKHRoaXMpLmVxdWFscyhyZWNvcmRTZXEob3RoZXIpKSlcbiAgICApO1xuICB9O1xuXG4gIFJlY29yZC5wcm90b3R5cGUuaGFzaENvZGUgPSBmdW5jdGlvbiBoYXNoQ29kZSAoKSB7XG4gICAgcmV0dXJuIHJlY29yZFNlcSh0aGlzKS5oYXNoQ29kZSgpO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgUmVjb3JkLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGspIHtcbiAgICByZXR1cm4gdGhpcy5faW5kaWNlcy5oYXNPd25Qcm9wZXJ0eShrKTtcbiAgfTtcblxuICBSZWNvcmQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaywgbm90U2V0VmFsdWUpIHtcbiAgICBpZiAoIXRoaXMuaGFzKGspKSB7XG4gICAgICByZXR1cm4gbm90U2V0VmFsdWU7XG4gICAgfVxuICAgIHZhciBpbmRleCA9IHRoaXMuX2luZGljZXNba107XG4gICAgdmFyIHZhbHVlID0gdGhpcy5fdmFsdWVzLmdldChpbmRleCk7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB0aGlzLl9kZWZhdWx0VmFsdWVzW2tdIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICBSZWNvcmQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoaywgdikge1xuICAgIGlmICh0aGlzLmhhcyhrKSkge1xuICAgICAgdmFyIG5ld1ZhbHVlcyA9IHRoaXMuX3ZhbHVlcy5zZXQoXG4gICAgICAgIHRoaXMuX2luZGljZXNba10sXG4gICAgICAgIHYgPT09IHRoaXMuX2RlZmF1bHRWYWx1ZXNba10gPyB1bmRlZmluZWQgOiB2XG4gICAgICApO1xuICAgICAgaWYgKG5ld1ZhbHVlcyAhPT0gdGhpcy5fdmFsdWVzICYmICF0aGlzLl9fb3duZXJJRCkge1xuICAgICAgICByZXR1cm4gbWFrZVJlY29yZCh0aGlzLCBuZXdWYWx1ZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBSZWNvcmQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoaykge1xuICAgIHJldHVybiB0aGlzLnNldChrKTtcbiAgfTtcblxuICBSZWNvcmQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgIHZhciBuZXdWYWx1ZXMgPSB0aGlzLl92YWx1ZXMuY2xlYXIoKS5zZXRTaXplKHRoaXMuX2tleXMubGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5fX293bmVySUQgPyB0aGlzIDogbWFrZVJlY29yZCh0aGlzLCBuZXdWYWx1ZXMpO1xuICB9O1xuXG4gIFJlY29yZC5wcm90b3R5cGUud2FzQWx0ZXJlZCA9IGZ1bmN0aW9uIHdhc0FsdGVyZWQgKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZXMud2FzQWx0ZXJlZCgpO1xuICB9O1xuXG4gIFJlY29yZC5wcm90b3R5cGUudG9TZXEgPSBmdW5jdGlvbiB0b1NlcSAoKSB7XG4gICAgcmV0dXJuIHJlY29yZFNlcSh0aGlzKTtcbiAgfTtcblxuICBSZWNvcmQucHJvdG90eXBlLnRvSlMgPSBmdW5jdGlvbiB0b0pTJDEgKCkge1xuICAgIHJldHVybiB0b0pTKHRoaXMpO1xuICB9O1xuXG4gIFJlY29yZC5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uIGVudHJpZXMgKCkge1xuICAgIHJldHVybiB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTKTtcbiAgfTtcblxuICBSZWNvcmQucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgcmV0dXJuIHJlY29yZFNlcSh0aGlzKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICB9O1xuXG4gIFJlY29yZC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHJldHVybiByZWNvcmRTZXEodGhpcykuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgfTtcblxuICBSZWNvcmQucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbiBfX2Vuc3VyZU93bmVyIChvd25lcklEKSB7XG4gICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIG5ld1ZhbHVlcyA9IHRoaXMuX3ZhbHVlcy5fX2Vuc3VyZU93bmVyKG93bmVySUQpO1xuICAgIGlmICghb3duZXJJRCkge1xuICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuICAgICAgdGhpcy5fdmFsdWVzID0gbmV3VmFsdWVzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBtYWtlUmVjb3JkKHRoaXMsIG5ld1ZhbHVlcywgb3duZXJJRCk7XG4gIH07XG5cbiAgUmVjb3JkLmlzUmVjb3JkID0gaXNSZWNvcmQ7XG4gIFJlY29yZC5nZXREZXNjcmlwdGl2ZU5hbWUgPSByZWNvcmROYW1lO1xuICB2YXIgUmVjb3JkUHJvdG90eXBlID0gUmVjb3JkLnByb3RvdHlwZTtcbiAgUmVjb3JkUHJvdG90eXBlW0lTX1JFQ09SRF9TWU1CT0xdID0gdHJ1ZTtcbiAgUmVjb3JkUHJvdG90eXBlW0RFTEVURV0gPSBSZWNvcmRQcm90b3R5cGUucmVtb3ZlO1xuICBSZWNvcmRQcm90b3R5cGUuZGVsZXRlSW4gPSBSZWNvcmRQcm90b3R5cGUucmVtb3ZlSW4gPSBkZWxldGVJbjtcbiAgUmVjb3JkUHJvdG90eXBlLmdldEluID0gZ2V0SW4kMTtcbiAgUmVjb3JkUHJvdG90eXBlLmhhc0luID0gQ29sbGVjdGlvblByb3RvdHlwZS5oYXNJbjtcbiAgUmVjb3JkUHJvdG90eXBlLm1lcmdlID0gbWVyZ2U7XG4gIFJlY29yZFByb3RvdHlwZS5tZXJnZVdpdGggPSBtZXJnZVdpdGg7XG4gIFJlY29yZFByb3RvdHlwZS5tZXJnZUluID0gbWVyZ2VJbjtcbiAgUmVjb3JkUHJvdG90eXBlLm1lcmdlRGVlcCA9IG1lcmdlRGVlcCQxO1xuICBSZWNvcmRQcm90b3R5cGUubWVyZ2VEZWVwV2l0aCA9IG1lcmdlRGVlcFdpdGgkMTtcbiAgUmVjb3JkUHJvdG90eXBlLm1lcmdlRGVlcEluID0gbWVyZ2VEZWVwSW47XG4gIFJlY29yZFByb3RvdHlwZS5zZXRJbiA9IHNldEluJDE7XG4gIFJlY29yZFByb3RvdHlwZS51cGRhdGUgPSB1cGRhdGUkMTtcbiAgUmVjb3JkUHJvdG90eXBlLnVwZGF0ZUluID0gdXBkYXRlSW4kMTtcbiAgUmVjb3JkUHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSB3aXRoTXV0YXRpb25zO1xuICBSZWNvcmRQcm90b3R5cGUuYXNNdXRhYmxlID0gYXNNdXRhYmxlO1xuICBSZWNvcmRQcm90b3R5cGUuYXNJbW11dGFibGUgPSBhc0ltbXV0YWJsZTtcbiAgUmVjb3JkUHJvdG90eXBlW0lURVJBVE9SX1NZTUJPTF0gPSBSZWNvcmRQcm90b3R5cGUuZW50cmllcztcbiAgUmVjb3JkUHJvdG90eXBlLnRvSlNPTiA9IFJlY29yZFByb3RvdHlwZS50b09iamVjdCA9XG4gICAgQ29sbGVjdGlvblByb3RvdHlwZS50b09iamVjdDtcbiAgUmVjb3JkUHJvdG90eXBlLmluc3BlY3QgPSBSZWNvcmRQcm90b3R5cGUudG9Tb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlUmVjb3JkKGxpa2VSZWNvcmQsIHZhbHVlcywgb3duZXJJRCkge1xuICAgIHZhciByZWNvcmQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihsaWtlUmVjb3JkKSk7XG4gICAgcmVjb3JkLl92YWx1ZXMgPSB2YWx1ZXM7XG4gICAgcmVjb3JkLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgcmV0dXJuIHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29yZE5hbWUocmVjb3JkKSB7XG4gICAgcmV0dXJuIHJlY29yZC5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCByZWNvcmQuY29uc3RydWN0b3IubmFtZSB8fCAnUmVjb3JkJztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29yZFNlcShyZWNvcmQpIHtcbiAgICByZXR1cm4ga2V5ZWRTZXFGcm9tVmFsdWUocmVjb3JkLl9rZXlzLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gW2ssIHJlY29yZC5nZXQoayldOyB9KSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRQcm9wKHByb3RvdHlwZSwgbmFtZSkge1xuICAgIHRyeSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBuYW1lLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldChuYW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpbnZhcmlhbnQodGhpcy5fX293bmVySUQsICdDYW5ub3Qgc2V0IG9uIGFuIGltbXV0YWJsZSByZWNvcmQuJyk7XG4gICAgICAgICAgdGhpcy5zZXQobmFtZSwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBmYWlsZWQuIFByb2JhYmx5IElFOC5cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxhenkgU2VxIG9mIGB2YWx1ZWAgcmVwZWF0ZWQgYHRpbWVzYCB0aW1lcy4gV2hlbiBgdGltZXNgIGlzXG4gICAqIHVuZGVmaW5lZCwgcmV0dXJucyBhbiBpbmZpbml0ZSBzZXF1ZW5jZSBvZiBgdmFsdWVgLlxuICAgKi9cbiAgdmFyIFJlcGVhdCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEluZGV4ZWRTZXEpIHtcbiAgICBmdW5jdGlvbiBSZXBlYXQodmFsdWUsIHRpbWVzKSB7XG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVwZWF0KSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlcGVhdCh2YWx1ZSwgdGltZXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuc2l6ZSA9IHRpbWVzID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IE1hdGgubWF4KDAsIHRpbWVzKTtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgaWYgKEVNUFRZX1JFUEVBVCkge1xuICAgICAgICAgIHJldHVybiBFTVBUWV9SRVBFQVQ7XG4gICAgICAgIH1cbiAgICAgICAgRU1QVFlfUkVQRUFUID0gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIEluZGV4ZWRTZXEgKSBSZXBlYXQuX19wcm90b19fID0gSW5kZXhlZFNlcTtcbiAgICBSZXBlYXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW5kZXhlZFNlcSAmJiBJbmRleGVkU2VxLnByb3RvdHlwZSApO1xuICAgIFJlcGVhdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXBlYXQ7XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJ1JlcGVhdCBbXSc7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1JlcGVhdCBbICcgKyB0aGlzLl92YWx1ZSArICcgJyArIHRoaXMuc2l6ZSArICcgdGltZXMgXSc7XG4gICAgfTtcblxuICAgIFJlcGVhdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhcyhpbmRleCkgPyB0aGlzLl92YWx1ZSA6IG5vdFNldFZhbHVlO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHNlYXJjaFZhbHVlKSB7XG4gICAgICByZXR1cm4gaXModGhpcy5fdmFsdWUsIHNlYXJjaFZhbHVlKTtcbiAgICB9O1xuXG4gICAgUmVwZWF0LnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChiZWdpbiwgZW5kKSB7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgIHJldHVybiB3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIHNpemUpXG4gICAgICAgID8gdGhpc1xuICAgICAgICA6IG5ldyBSZXBlYXQoXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSxcbiAgICAgICAgICAgIHJlc29sdmVFbmQoZW5kLCBzaXplKSAtIHJlc29sdmVCZWdpbihiZWdpbiwgc2l6ZSlcbiAgICAgICAgICApO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mIChzZWFyY2hWYWx1ZSkge1xuICAgICAgaWYgKGlzKHRoaXMuX3ZhbHVlLCBzZWFyY2hWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuICAgIFJlcGVhdC5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAoc2VhcmNoVmFsdWUpIHtcbiAgICAgIGlmIChpcyh0aGlzLl92YWx1ZSwgc2VhcmNoVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemU7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcblxuICAgIFJlcGVhdC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB3aGlsZSAoaSAhPT0gc2l6ZSkge1xuICAgICAgICBpZiAoZm4odGhpcy5fdmFsdWUsIHJldmVyc2UgPyBzaXplIC0gKytpIDogaSsrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGk7XG4gICAgfTtcblxuICAgIFJlcGVhdC5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkgeyByZXR1cm4gaSA9PT0gc2l6ZVxuICAgICAgICAgID8gaXRlcmF0b3JEb25lKClcbiAgICAgICAgICA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKyssIHRoaXMkMS5fdmFsdWUpOyB9XG4gICAgICApO1xuICAgIH07XG5cbiAgICBSZXBlYXQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAob3RoZXIpIHtcbiAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFJlcGVhdFxuICAgICAgICA/IGlzKHRoaXMuX3ZhbHVlLCBvdGhlci5fdmFsdWUpXG4gICAgICAgIDogZGVlcEVxdWFsKG90aGVyKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlcGVhdDtcbiAgfShJbmRleGVkU2VxKSk7XG5cbiAgdmFyIEVNUFRZX1JFUEVBVDtcblxuICBmdW5jdGlvbiBmcm9tSlModmFsdWUsIGNvbnZlcnRlcikge1xuICAgIHJldHVybiBmcm9tSlNXaXRoKFxuICAgICAgW10sXG4gICAgICBjb252ZXJ0ZXIgfHwgZGVmYXVsdENvbnZlcnRlcixcbiAgICAgIHZhbHVlLFxuICAgICAgJycsXG4gICAgICBjb252ZXJ0ZXIgJiYgY29udmVydGVyLmxlbmd0aCA+IDIgPyBbXSA6IHVuZGVmaW5lZCxcbiAgICAgIHsgJyc6IHZhbHVlIH1cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJvbUpTV2l0aChzdGFjaywgY29udmVydGVyLCB2YWx1ZSwga2V5LCBrZXlQYXRoLCBwYXJlbnRWYWx1ZSkge1xuICAgIHZhciB0b1NlcSA9IEFycmF5LmlzQXJyYXkodmFsdWUpXG4gICAgICA/IEluZGV4ZWRTZXFcbiAgICAgIDogaXNQbGFpbk9iaih2YWx1ZSlcbiAgICAgID8gS2V5ZWRTZXFcbiAgICAgIDogbnVsbDtcbiAgICBpZiAodG9TZXEpIHtcbiAgICAgIGlmICh+c3RhY2suaW5kZXhPZih2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEltbXV0YWJsZScpO1xuICAgICAgfVxuICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICBrZXlQYXRoICYmIGtleSAhPT0gJycgJiYga2V5UGF0aC5wdXNoKGtleSk7XG4gICAgICB2YXIgY29udmVydGVkID0gY29udmVydGVyLmNhbGwoXG4gICAgICAgIHBhcmVudFZhbHVlLFxuICAgICAgICBrZXksXG4gICAgICAgIHRvU2VxKHZhbHVlKS5tYXAoZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIGZyb21KU1dpdGgoc3RhY2ssIGNvbnZlcnRlciwgdiwgaywga2V5UGF0aCwgdmFsdWUpOyB9XG4gICAgICAgICksXG4gICAgICAgIGtleVBhdGggJiYga2V5UGF0aC5zbGljZSgpXG4gICAgICApO1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgICBrZXlQYXRoICYmIGtleVBhdGgucG9wKCk7XG4gICAgICByZXR1cm4gY29udmVydGVkO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0Q29udmVydGVyKGssIHYpIHtcbiAgICByZXR1cm4gaXNLZXllZCh2KSA/IHYudG9NYXAoKSA6IHYudG9MaXN0KCk7XG4gIH1cblxuICB2YXIgdmVyc2lvbiA9IFwiNC4wLjAtcmMuMTJcIjtcblxuICB2YXIgSW1tdXRhYmxlID0ge1xuICAgIHZlcnNpb246IHZlcnNpb24sXG5cbiAgICBDb2xsZWN0aW9uOiBDb2xsZWN0aW9uLFxuICAgIC8vIE5vdGU6IEl0ZXJhYmxlIGlzIGRlcHJlY2F0ZWRcbiAgICBJdGVyYWJsZTogQ29sbGVjdGlvbixcblxuICAgIFNlcTogU2VxLFxuICAgIE1hcDogTWFwLFxuICAgIE9yZGVyZWRNYXA6IE9yZGVyZWRNYXAsXG4gICAgTGlzdDogTGlzdCxcbiAgICBTdGFjazogU3RhY2ssXG4gICAgU2V0OiBTZXQsXG4gICAgT3JkZXJlZFNldDogT3JkZXJlZFNldCxcblxuICAgIFJlY29yZDogUmVjb3JkLFxuICAgIFJhbmdlOiBSYW5nZSxcbiAgICBSZXBlYXQ6IFJlcGVhdCxcblxuICAgIGlzOiBpcyxcbiAgICBmcm9tSlM6IGZyb21KUyxcbiAgICBoYXNoOiBoYXNoLFxuXG4gICAgaXNJbW11dGFibGU6IGlzSW1tdXRhYmxlLFxuICAgIGlzQ29sbGVjdGlvbjogaXNDb2xsZWN0aW9uLFxuICAgIGlzS2V5ZWQ6IGlzS2V5ZWQsXG4gICAgaXNJbmRleGVkOiBpc0luZGV4ZWQsXG4gICAgaXNBc3NvY2lhdGl2ZTogaXNBc3NvY2lhdGl2ZSxcbiAgICBpc09yZGVyZWQ6IGlzT3JkZXJlZCxcbiAgICBpc1ZhbHVlT2JqZWN0OiBpc1ZhbHVlT2JqZWN0LFxuICAgIGlzU2VxOiBpc1NlcSxcbiAgICBpc0xpc3Q6IGlzTGlzdCxcbiAgICBpc01hcDogaXNNYXAsXG4gICAgaXNPcmRlcmVkTWFwOiBpc09yZGVyZWRNYXAsXG4gICAgaXNTdGFjazogaXNTdGFjayxcbiAgICBpc1NldDogaXNTZXQsXG4gICAgaXNPcmRlcmVkU2V0OiBpc09yZGVyZWRTZXQsXG4gICAgaXNSZWNvcmQ6IGlzUmVjb3JkLFxuXG4gICAgZ2V0OiBnZXQsXG4gICAgZ2V0SW46IGdldEluLFxuICAgIGhhczogaGFzLFxuICAgIGhhc0luOiBoYXNJbixcbiAgICBtZXJnZTogbWVyZ2UkMSxcbiAgICBtZXJnZURlZXA6IG1lcmdlRGVlcCxcbiAgICBtZXJnZVdpdGg6IG1lcmdlV2l0aCQxLFxuICAgIG1lcmdlRGVlcFdpdGg6IG1lcmdlRGVlcFdpdGgsXG4gICAgcmVtb3ZlOiByZW1vdmUsXG4gICAgcmVtb3ZlSW46IHJlbW92ZUluLFxuICAgIHNldDogc2V0LFxuICAgIHNldEluOiBzZXRJbixcbiAgICB1cGRhdGU6IHVwZGF0ZSxcbiAgICB1cGRhdGVJbjogdXBkYXRlSW4sXG4gIH07XG5cbiAgLy8gTm90ZTogSXRlcmFibGUgaXMgZGVwcmVjYXRlZFxuICB2YXIgSXRlcmFibGUgPSBDb2xsZWN0aW9uO1xuXG4gIGV4cG9ydHMuQ29sbGVjdGlvbiA9IENvbGxlY3Rpb247XG4gIGV4cG9ydHMuSXRlcmFibGUgPSBJdGVyYWJsZTtcbiAgZXhwb3J0cy5MaXN0ID0gTGlzdDtcbiAgZXhwb3J0cy5NYXAgPSBNYXA7XG4gIGV4cG9ydHMuT3JkZXJlZE1hcCA9IE9yZGVyZWRNYXA7XG4gIGV4cG9ydHMuT3JkZXJlZFNldCA9IE9yZGVyZWRTZXQ7XG4gIGV4cG9ydHMuUmFuZ2UgPSBSYW5nZTtcbiAgZXhwb3J0cy5SZWNvcmQgPSBSZWNvcmQ7XG4gIGV4cG9ydHMuUmVwZWF0ID0gUmVwZWF0O1xuICBleHBvcnRzLlNlcSA9IFNlcTtcbiAgZXhwb3J0cy5TZXQgPSBTZXQ7XG4gIGV4cG9ydHMuU3RhY2sgPSBTdGFjaztcbiAgZXhwb3J0cy5kZWZhdWx0ID0gSW1tdXRhYmxlO1xuICBleHBvcnRzLmZyb21KUyA9IGZyb21KUztcbiAgZXhwb3J0cy5nZXQgPSBnZXQ7XG4gIGV4cG9ydHMuZ2V0SW4gPSBnZXRJbjtcbiAgZXhwb3J0cy5oYXMgPSBoYXM7XG4gIGV4cG9ydHMuaGFzSW4gPSBoYXNJbjtcbiAgZXhwb3J0cy5oYXNoID0gaGFzaDtcbiAgZXhwb3J0cy5pcyA9IGlzO1xuICBleHBvcnRzLmlzQXNzb2NpYXRpdmUgPSBpc0Fzc29jaWF0aXZlO1xuICBleHBvcnRzLmlzQ29sbGVjdGlvbiA9IGlzQ29sbGVjdGlvbjtcbiAgZXhwb3J0cy5pc0ltbXV0YWJsZSA9IGlzSW1tdXRhYmxlO1xuICBleHBvcnRzLmlzSW5kZXhlZCA9IGlzSW5kZXhlZDtcbiAgZXhwb3J0cy5pc0tleWVkID0gaXNLZXllZDtcbiAgZXhwb3J0cy5pc09yZGVyZWQgPSBpc09yZGVyZWQ7XG4gIGV4cG9ydHMuaXNWYWx1ZU9iamVjdCA9IGlzVmFsdWVPYmplY3Q7XG4gIGV4cG9ydHMubWVyZ2UgPSBtZXJnZSQxO1xuICBleHBvcnRzLm1lcmdlRGVlcCA9IG1lcmdlRGVlcDtcbiAgZXhwb3J0cy5tZXJnZURlZXBXaXRoID0gbWVyZ2VEZWVwV2l0aDtcbiAgZXhwb3J0cy5tZXJnZVdpdGggPSBtZXJnZVdpdGgkMTtcbiAgZXhwb3J0cy5yZW1vdmUgPSByZW1vdmU7XG4gIGV4cG9ydHMucmVtb3ZlSW4gPSByZW1vdmVJbjtcbiAgZXhwb3J0cy5zZXQgPSBzZXQ7XG4gIGV4cG9ydHMuc2V0SW4gPSBzZXRJbjtcbiAgZXhwb3J0cy51cGRhdGUgPSB1cGRhdGU7XG4gIGV4cG9ydHMudXBkYXRlSW4gPSB1cGRhdGVJbjtcbiAgZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKFxuICAgICAgdWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKVxuICAgICkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHsgX19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAhPSBudWxsICYmXG4gICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdmFyIGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICAgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aFxuICAgIClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5CdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG5CdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2UgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCIvKipcbiAqIG1hcmtlZCAtIGEgbWFya2Rvd24gcGFyc2VyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAyMCwgQ2hyaXN0b3BoZXIgSmVmZnJleS4gKE1JVCBMaWNlbnNlZClcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZWRqcy9tYXJrZWRcbiAqL1xuXG4vKipcbiAqIERPIE5PVCBFRElUIFRISVMgRklMRVxuICogVGhlIGNvZGUgaW4gdGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIGZpbGVzIGluIC4vc3JjL1xuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwubWFya2VkID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgICBpZiAoIW8pIHJldHVybjtcbiAgICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICAgIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgICB2YXIgaXQ7XG5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgICB9XG5cbiAgICBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIHJldHVybiBpdC5uZXh0LmJpbmQoaXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIG1vZHVsZSkge1xuICBcdHJldHVybiBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbiAgfVxuXG4gIHZhciBkZWZhdWx0cyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICBmdW5jdGlvbiBnZXREZWZhdWx0cygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhc2VVcmw6IG51bGwsXG4gICAgICAgIGJyZWFrczogZmFsc2UsXG4gICAgICAgIGdmbTogdHJ1ZSxcbiAgICAgICAgaGVhZGVySWRzOiB0cnVlLFxuICAgICAgICBoZWFkZXJQcmVmaXg6ICcnLFxuICAgICAgICBoaWdobGlnaHQ6IG51bGwsXG4gICAgICAgIGxhbmdQcmVmaXg6ICdsYW5ndWFnZS0nLFxuICAgICAgICBtYW5nbGU6IHRydWUsXG4gICAgICAgIHBlZGFudGljOiBmYWxzZSxcbiAgICAgICAgcmVuZGVyZXI6IG51bGwsXG4gICAgICAgIHNhbml0aXplOiBmYWxzZSxcbiAgICAgICAgc2FuaXRpemVyOiBudWxsLFxuICAgICAgICBzaWxlbnQ6IGZhbHNlLFxuICAgICAgICBzbWFydExpc3RzOiBmYWxzZSxcbiAgICAgICAgc21hcnR5cGFudHM6IGZhbHNlLFxuICAgICAgICB0b2tlbml6ZXI6IG51bGwsXG4gICAgICAgIHdhbGtUb2tlbnM6IG51bGwsXG4gICAgICAgIHhodG1sOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGFuZ2VEZWZhdWx0cyhuZXdEZWZhdWx0cykge1xuICAgICAgbW9kdWxlLmV4cG9ydHMuZGVmYXVsdHMgPSBuZXdEZWZhdWx0cztcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgIGRlZmF1bHRzOiBnZXREZWZhdWx0cygpLFxuICAgICAgZ2V0RGVmYXVsdHM6IGdldERlZmF1bHRzLFxuICAgICAgY2hhbmdlRGVmYXVsdHM6IGNoYW5nZURlZmF1bHRzXG4gICAgfTtcbiAgfSk7XG4gIHZhciBkZWZhdWx0c18xID0gZGVmYXVsdHMuZGVmYXVsdHM7XG4gIHZhciBkZWZhdWx0c18yID0gZGVmYXVsdHMuZ2V0RGVmYXVsdHM7XG4gIHZhciBkZWZhdWx0c18zID0gZGVmYXVsdHMuY2hhbmdlRGVmYXVsdHM7XG5cbiAgLyoqXG4gICAqIEhlbHBlcnNcbiAgICovXG4gIHZhciBlc2NhcGVUZXN0ID0gL1smPD5cIiddLztcbiAgdmFyIGVzY2FwZVJlcGxhY2UgPSAvWyY8PlwiJ10vZztcbiAgdmFyIGVzY2FwZVRlc3ROb0VuY29kZSA9IC9bPD5cIiddfCYoPyEjP1xcdys7KS87XG4gIHZhciBlc2NhcGVSZXBsYWNlTm9FbmNvZGUgPSAvWzw+XCInXXwmKD8hIz9cXHcrOykvZztcbiAgdmFyIGVzY2FwZVJlcGxhY2VtZW50cyA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmIzM5OydcbiAgfTtcblxuICB2YXIgZ2V0RXNjYXBlUmVwbGFjZW1lbnQgPSBmdW5jdGlvbiBnZXRFc2NhcGVSZXBsYWNlbWVudChjaCkge1xuICAgIHJldHVybiBlc2NhcGVSZXBsYWNlbWVudHNbY2hdO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGVzY2FwZShodG1sLCBlbmNvZGUpIHtcbiAgICBpZiAoZW5jb2RlKSB7XG4gICAgICBpZiAoZXNjYXBlVGVzdC50ZXN0KGh0bWwpKSB7XG4gICAgICAgIHJldHVybiBodG1sLnJlcGxhY2UoZXNjYXBlUmVwbGFjZSwgZ2V0RXNjYXBlUmVwbGFjZW1lbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZXNjYXBlVGVzdE5vRW5jb2RlLnRlc3QoaHRtbCkpIHtcbiAgICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZShlc2NhcGVSZXBsYWNlTm9FbmNvZGUsIGdldEVzY2FwZVJlcGxhY2VtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaHRtbDtcbiAgfVxuXG4gIHZhciB1bmVzY2FwZVRlc3QgPSAvJigjKD86XFxkKyl8KD86I3hbMC05QS1GYS1mXSspfCg/OlxcdyspKTs/L2lnO1xuXG4gIGZ1bmN0aW9uIHVuZXNjYXBlKGh0bWwpIHtcbiAgICAvLyBleHBsaWNpdGx5IG1hdGNoIGRlY2ltYWwsIGhleCwgYW5kIG5hbWVkIEhUTUwgZW50aXRpZXNcbiAgICByZXR1cm4gaHRtbC5yZXBsYWNlKHVuZXNjYXBlVGVzdCwgZnVuY3Rpb24gKF8sIG4pIHtcbiAgICAgIG4gPSBuLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobiA9PT0gJ2NvbG9uJykgcmV0dXJuICc6JztcblxuICAgICAgaWYgKG4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgcmV0dXJuIG4uY2hhckF0KDEpID09PSAneCcgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KG4uc3Vic3RyaW5nKDIpLCAxNikpIDogU3RyaW5nLmZyb21DaGFyQ29kZSgrbi5zdWJzdHJpbmcoMSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJyc7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgY2FyZXQgPSAvKF58W15cXFtdKVxcXi9nO1xuXG4gIGZ1bmN0aW9uIGVkaXQocmVnZXgsIG9wdCkge1xuICAgIHJlZ2V4ID0gcmVnZXguc291cmNlIHx8IHJlZ2V4O1xuICAgIG9wdCA9IG9wdCB8fCAnJztcbiAgICB2YXIgb2JqID0ge1xuICAgICAgcmVwbGFjZTogZnVuY3Rpb24gcmVwbGFjZShuYW1lLCB2YWwpIHtcbiAgICAgICAgdmFsID0gdmFsLnNvdXJjZSB8fCB2YWw7XG4gICAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKGNhcmV0LCAnJDEnKTtcbiAgICAgICAgcmVnZXggPSByZWdleC5yZXBsYWNlKG5hbWUsIHZhbCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9LFxuICAgICAgZ2V0UmVnZXg6IGZ1bmN0aW9uIGdldFJlZ2V4KCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleCwgb3B0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgbm9uV29yZEFuZENvbG9uVGVzdCA9IC9bXlxcdzpdL2c7XG4gIHZhciBvcmlnaW5JbmRlcGVuZGVudFVybCA9IC9eJHxeW2Etel1bYS16MC05Ky4tXSo6fF5bPyNdL2k7XG5cbiAgZnVuY3Rpb24gY2xlYW5Vcmwoc2FuaXRpemUsIGJhc2UsIGhyZWYpIHtcbiAgICBpZiAoc2FuaXRpemUpIHtcbiAgICAgIHZhciBwcm90O1xuXG4gICAgICB0cnkge1xuICAgICAgICBwcm90ID0gZGVjb2RlVVJJQ29tcG9uZW50KHVuZXNjYXBlKGhyZWYpKS5yZXBsYWNlKG5vbldvcmRBbmRDb2xvblRlc3QsICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3QuaW5kZXhPZignamF2YXNjcmlwdDonKSA9PT0gMCB8fCBwcm90LmluZGV4T2YoJ3Zic2NyaXB0OicpID09PSAwIHx8IHByb3QuaW5kZXhPZignZGF0YTonKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmFzZSAmJiAhb3JpZ2luSW5kZXBlbmRlbnRVcmwudGVzdChocmVmKSkge1xuICAgICAgaHJlZiA9IHJlc29sdmVVcmwoYmFzZSwgaHJlZik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGhyZWYgPSBlbmNvZGVVUkkoaHJlZikucmVwbGFjZSgvJTI1L2csICclJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhyZWY7XG4gIH1cblxuICB2YXIgYmFzZVVybHMgPSB7fTtcbiAgdmFyIGp1c3REb21haW4gPSAvXlteOl0rOlxcLypbXi9dKiQvO1xuICB2YXIgcHJvdG9jb2wgPSAvXihbXjpdKzopW1xcc1xcU10qJC87XG4gIHZhciBkb21haW4gPSAvXihbXjpdKzpcXC8qW14vXSopW1xcc1xcU10qJC87XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVVybChiYXNlLCBocmVmKSB7XG4gICAgaWYgKCFiYXNlVXJsc1snICcgKyBiYXNlXSkge1xuICAgICAgLy8gd2UgY2FuIGlnbm9yZSBldmVyeXRoaW5nIGluIGJhc2UgYWZ0ZXIgdGhlIGxhc3Qgc2xhc2ggb2YgaXRzIHBhdGggY29tcG9uZW50LFxuICAgICAgLy8gYnV0IHdlIG1pZ2h0IG5lZWQgdG8gYWRkIF90aGF0X1xuICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zXG4gICAgICBpZiAoanVzdERvbWFpbi50ZXN0KGJhc2UpKSB7XG4gICAgICAgIGJhc2VVcmxzWycgJyArIGJhc2VdID0gYmFzZSArICcvJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VVcmxzWycgJyArIGJhc2VdID0gcnRyaW0oYmFzZSwgJy8nLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBiYXNlID0gYmFzZVVybHNbJyAnICsgYmFzZV07XG4gICAgdmFyIHJlbGF0aXZlQmFzZSA9IGJhc2UuaW5kZXhPZignOicpID09PSAtMTtcblxuICAgIGlmIChocmVmLnN1YnN0cmluZygwLCAyKSA9PT0gJy8vJykge1xuICAgICAgaWYgKHJlbGF0aXZlQmFzZSkge1xuICAgICAgICByZXR1cm4gaHJlZjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhc2UucmVwbGFjZShwcm90b2NvbCwgJyQxJykgKyBocmVmO1xuICAgIH0gZWxzZSBpZiAoaHJlZi5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgaWYgKHJlbGF0aXZlQmFzZSkge1xuICAgICAgICByZXR1cm4gaHJlZjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhc2UucmVwbGFjZShkb21haW4sICckMScpICsgaHJlZjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJhc2UgKyBocmVmO1xuICAgIH1cbiAgfVxuXG4gIHZhciBub29wVGVzdCA9IHtcbiAgICBleGVjOiBmdW5jdGlvbiBub29wVGVzdCgpIHt9XG4gIH07XG5cbiAgZnVuY3Rpb24gbWVyZ2Uob2JqKSB7XG4gICAgdmFyIGkgPSAxLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGtleTtcblxuICAgIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0YXJnZXQgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAoa2V5IGluIHRhcmdldCkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSkge1xuICAgICAgICAgIG9ialtrZXldID0gdGFyZ2V0W2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gc3BsaXRDZWxscyh0YWJsZVJvdywgY291bnQpIHtcbiAgICAvLyBlbnN1cmUgdGhhdCBldmVyeSBjZWxsLWRlbGltaXRpbmcgcGlwZSBoYXMgYSBzcGFjZVxuICAgIC8vIGJlZm9yZSBpdCB0byBkaXN0aW5ndWlzaCBpdCBmcm9tIGFuIGVzY2FwZWQgcGlwZVxuICAgIHZhciByb3cgPSB0YWJsZVJvdy5yZXBsYWNlKC9cXHwvZywgZnVuY3Rpb24gKG1hdGNoLCBvZmZzZXQsIHN0cikge1xuICAgICAgdmFyIGVzY2FwZWQgPSBmYWxzZSxcbiAgICAgICAgICBjdXJyID0gb2Zmc2V0O1xuXG4gICAgICB3aGlsZSAoLS1jdXJyID49IDAgJiYgc3RyW2N1cnJdID09PSAnXFxcXCcpIHtcbiAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgICAvLyBvZGQgbnVtYmVyIG9mIHNsYXNoZXMgbWVhbnMgfCBpcyBlc2NhcGVkXG4gICAgICAgIC8vIHNvIHdlIGxlYXZlIGl0IGFsb25lXG4gICAgICAgIHJldHVybiAnfCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhZGQgc3BhY2UgYmVmb3JlIHVuZXNjYXBlZCB8XG4gICAgICAgIHJldHVybiAnIHwnO1xuICAgICAgfVxuICAgIH0pLFxuICAgICAgICBjZWxscyA9IHJvdy5zcGxpdCgvIFxcfC8pO1xuICAgIHZhciBpID0gMDtcblxuICAgIGlmIChjZWxscy5sZW5ndGggPiBjb3VudCkge1xuICAgICAgY2VsbHMuc3BsaWNlKGNvdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKGNlbGxzLmxlbmd0aCA8IGNvdW50KSB7XG4gICAgICAgIGNlbGxzLnB1c2goJycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIGxlYWRpbmcgb3IgdHJhaWxpbmcgd2hpdGVzcGFjZSBpcyBpZ25vcmVkIHBlciB0aGUgZ2ZtIHNwZWNcbiAgICAgIGNlbGxzW2ldID0gY2VsbHNbaV0udHJpbSgpLnJlcGxhY2UoL1xcXFxcXHwvZywgJ3wnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2VsbHM7XG4gIH0gLy8gUmVtb3ZlIHRyYWlsaW5nICdjJ3MuIEVxdWl2YWxlbnQgdG8gc3RyLnJlcGxhY2UoL2MqJC8sICcnKS5cbiAgLy8gL2MqJC8gaXMgdnVsbmVyYWJsZSB0byBSRURPUy5cbiAgLy8gaW52ZXJ0OiBSZW1vdmUgc3VmZml4IG9mIG5vbi1jIGNoYXJzIGluc3RlYWQuIERlZmF1bHQgZmFsc2V5LlxuXG5cbiAgZnVuY3Rpb24gcnRyaW0oc3RyLCBjLCBpbnZlcnQpIHtcbiAgICB2YXIgbCA9IHN0ci5sZW5ndGg7XG5cbiAgICBpZiAobCA9PT0gMCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gLy8gTGVuZ3RoIG9mIHN1ZmZpeCBtYXRjaGluZyB0aGUgaW52ZXJ0IGNvbmRpdGlvbi5cblxuXG4gICAgdmFyIHN1ZmZMZW4gPSAwOyAvLyBTdGVwIGxlZnQgdW50aWwgd2UgZmFpbCB0byBtYXRjaCB0aGUgaW52ZXJ0IGNvbmRpdGlvbi5cblxuICAgIHdoaWxlIChzdWZmTGVuIDwgbCkge1xuICAgICAgdmFyIGN1cnJDaGFyID0gc3RyLmNoYXJBdChsIC0gc3VmZkxlbiAtIDEpO1xuXG4gICAgICBpZiAoY3VyckNoYXIgPT09IGMgJiYgIWludmVydCkge1xuICAgICAgICBzdWZmTGVuKys7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJDaGFyICE9PSBjICYmIGludmVydCkge1xuICAgICAgICBzdWZmTGVuKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyLnN1YnN0cigwLCBsIC0gc3VmZkxlbik7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kQ2xvc2luZ0JyYWNrZXQoc3RyLCBiKSB7XG4gICAgaWYgKHN0ci5pbmRleE9mKGJbMV0pID09PSAtMSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHZhciBsID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgbGV2ZWwgPSAwLFxuICAgICAgICBpID0gMDtcblxuICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoc3RyW2ldID09PSAnXFxcXCcpIHtcbiAgICAgICAgaSsrO1xuICAgICAgfSBlbHNlIGlmIChzdHJbaV0gPT09IGJbMF0pIHtcbiAgICAgICAgbGV2ZWwrKztcbiAgICAgIH0gZWxzZSBpZiAoc3RyW2ldID09PSBiWzFdKSB7XG4gICAgICAgIGxldmVsLS07XG5cbiAgICAgICAgaWYgKGxldmVsIDwgMCkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tTYW5pdGl6ZURlcHJlY2F0aW9uKG9wdCkge1xuICAgIGlmIChvcHQgJiYgb3B0LnNhbml0aXplICYmICFvcHQuc2lsZW50KSB7XG4gICAgICBjb25zb2xlLndhcm4oJ21hcmtlZCgpOiBzYW5pdGl6ZSBhbmQgc2FuaXRpemVyIHBhcmFtZXRlcnMgYXJlIGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAwLjcuMCwgc2hvdWxkIG5vdCBiZSB1c2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS4gUmVhZCBtb3JlIGhlcmU6IGh0dHBzOi8vbWFya2VkLmpzLm9yZy8jL1VTSU5HX0FEVkFOQ0VELm1kI29wdGlvbnMnKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaGVscGVycyA9IHtcbiAgICBlc2NhcGU6IGVzY2FwZSxcbiAgICB1bmVzY2FwZTogdW5lc2NhcGUsXG4gICAgZWRpdDogZWRpdCxcbiAgICBjbGVhblVybDogY2xlYW5VcmwsXG4gICAgcmVzb2x2ZVVybDogcmVzb2x2ZVVybCxcbiAgICBub29wVGVzdDogbm9vcFRlc3QsXG4gICAgbWVyZ2U6IG1lcmdlLFxuICAgIHNwbGl0Q2VsbHM6IHNwbGl0Q2VsbHMsXG4gICAgcnRyaW06IHJ0cmltLFxuICAgIGZpbmRDbG9zaW5nQnJhY2tldDogZmluZENsb3NpbmdCcmFja2V0LFxuICAgIGNoZWNrU2FuaXRpemVEZXByZWNhdGlvbjogY2hlY2tTYW5pdGl6ZURlcHJlY2F0aW9uXG4gIH07XG5cbiAgdmFyIGRlZmF1bHRzJDEgPSBkZWZhdWx0cy5kZWZhdWx0cztcbiAgdmFyIHJ0cmltJDEgPSBoZWxwZXJzLnJ0cmltLFxuICAgICAgc3BsaXRDZWxscyQxID0gaGVscGVycy5zcGxpdENlbGxzLFxuICAgICAgX2VzY2FwZSA9IGhlbHBlcnMuZXNjYXBlLFxuICAgICAgZmluZENsb3NpbmdCcmFja2V0JDEgPSBoZWxwZXJzLmZpbmRDbG9zaW5nQnJhY2tldDtcblxuICBmdW5jdGlvbiBvdXRwdXRMaW5rKGNhcCwgbGluaywgcmF3KSB7XG4gICAgdmFyIGhyZWYgPSBsaW5rLmhyZWY7XG4gICAgdmFyIHRpdGxlID0gbGluay50aXRsZSA/IF9lc2NhcGUobGluay50aXRsZSkgOiBudWxsO1xuICAgIHZhciB0ZXh0ID0gY2FwWzFdLnJlcGxhY2UoL1xcXFwoW1xcW1xcXV0pL2csICckMScpO1xuXG4gICAgaWYgKGNhcFswXS5jaGFyQXQoMCkgIT09ICchJykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgICByYXc6IHJhdyxcbiAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuICAgICAgICByYXc6IHJhdyxcbiAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICB0ZXh0OiBfZXNjYXBlKHRleHQpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluZGVudENvZGVDb21wZW5zYXRpb24ocmF3LCB0ZXh0KSB7XG4gICAgdmFyIG1hdGNoSW5kZW50VG9Db2RlID0gcmF3Lm1hdGNoKC9eKFxccyspKD86YGBgKS8pO1xuXG4gICAgaWYgKG1hdGNoSW5kZW50VG9Db2RlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG5cbiAgICB2YXIgaW5kZW50VG9Db2RlID0gbWF0Y2hJbmRlbnRUb0NvZGVbMV07XG4gICAgcmV0dXJuIHRleHQuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIG1hdGNoSW5kZW50SW5Ob2RlID0gbm9kZS5tYXRjaCgvXlxccysvKTtcblxuICAgICAgaWYgKG1hdGNoSW5kZW50SW5Ob2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5kZW50SW5Ob2RlID0gbWF0Y2hJbmRlbnRJbk5vZGVbMF07XG5cbiAgICAgIGlmIChpbmRlbnRJbk5vZGUubGVuZ3RoID49IGluZGVudFRvQ29kZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuc2xpY2UoaW5kZW50VG9Db2RlLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pLmpvaW4oJ1xcbicpO1xuICB9XG4gIC8qKlxuICAgKiBUb2tlbml6ZXJcbiAgICovXG5cblxuICB2YXIgVG9rZW5pemVyXzEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRva2VuaXplcihvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzJDE7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IFRva2VuaXplci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uc3BhY2UgPSBmdW5jdGlvbiBzcGFjZShzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLm5ld2xpbmUuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIGlmIChjYXBbMF0ubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnc3BhY2UnLFxuICAgICAgICAgICAgcmF3OiBjYXBbMF1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByYXc6ICdcXG4nXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5jb2RlID0gZnVuY3Rpb24gY29kZShzcmMsIHRva2Vucykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2suY29kZS5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgdmFyIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07IC8vIEFuIGluZGVudGVkIGNvZGUgYmxvY2sgY2Fubm90IGludGVycnVwdCBhIHBhcmFncmFwaC5cblxuICAgICAgICBpZiAobGFzdFRva2VuICYmIGxhc3RUb2tlbi50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgIHRleHQ6IGNhcFswXS50cmltUmlnaHQoKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGV4dCA9IGNhcFswXS5yZXBsYWNlKC9eIHs0fS9nbSwgJycpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICBjb2RlQmxvY2tTdHlsZTogJ2luZGVudGVkJyxcbiAgICAgICAgICB0ZXh0OiAhdGhpcy5vcHRpb25zLnBlZGFudGljID8gcnRyaW0kMSh0ZXh0LCAnXFxuJykgOiB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5mZW5jZXMgPSBmdW5jdGlvbiBmZW5jZXMoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5mZW5jZXMuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciByYXcgPSBjYXBbMF07XG4gICAgICAgIHZhciB0ZXh0ID0gaW5kZW50Q29kZUNvbXBlbnNhdGlvbihyYXcsIGNhcFszXSB8fCAnJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgIHJhdzogcmF3LFxuICAgICAgICAgIGxhbmc6IGNhcFsyXSA/IGNhcFsyXS50cmltKCkgOiBjYXBbMl0sXG4gICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uaGVhZGluZyA9IGZ1bmN0aW9uIGhlYWRpbmcoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oZWFkaW5nLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICBkZXB0aDogY2FwWzFdLmxlbmd0aCxcbiAgICAgICAgICB0ZXh0OiBjYXBbMl1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLm5wdGFibGUgPSBmdW5jdGlvbiBucHRhYmxlKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2subnB0YWJsZS5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgdHlwZTogJ3RhYmxlJyxcbiAgICAgICAgICBoZWFkZXI6IHNwbGl0Q2VsbHMkMShjYXBbMV0ucmVwbGFjZSgvXiAqfCAqXFx8ICokL2csICcnKSksXG4gICAgICAgICAgYWxpZ246IGNhcFsyXS5yZXBsYWNlKC9eICp8XFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICAgIGNlbGxzOiBjYXBbM10gPyBjYXBbM10ucmVwbGFjZSgvXFxuJC8sICcnKS5zcGxpdCgnXFxuJykgOiBbXSxcbiAgICAgICAgICByYXc6IGNhcFswXVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpdGVtLmhlYWRlci5sZW5ndGggPT09IGl0ZW0uYWxpZ24ubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGwgPSBpdGVtLmFsaWduLmxlbmd0aDtcbiAgICAgICAgICB2YXIgaTtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgvXiAqLSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAncmlnaHQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2NlbnRlcic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSsgKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdsZWZ0JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGwgPSBpdGVtLmNlbGxzLmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0uY2VsbHNbaV0gPSBzcGxpdENlbGxzJDEoaXRlbS5jZWxsc1tpXSwgaXRlbS5oZWFkZXIubGVuZ3RoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uaHIgPSBmdW5jdGlvbiBocihzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmhyLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdocicsXG4gICAgICAgICAgcmF3OiBjYXBbMF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmJsb2NrcXVvdGUgPSBmdW5jdGlvbiBibG9ja3F1b3RlKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2suYmxvY2txdW90ZS5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgdmFyIHRleHQgPSBjYXBbMF0ucmVwbGFjZSgvXiAqPiA/L2dtLCAnJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2Jsb2NrcXVvdGUnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmxpc3QgPSBmdW5jdGlvbiBsaXN0KHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2subGlzdC5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgdmFyIHJhdyA9IGNhcFswXTtcbiAgICAgICAgdmFyIGJ1bGwgPSBjYXBbMl07XG4gICAgICAgIHZhciBpc29yZGVyZWQgPSBidWxsLmxlbmd0aCA+IDE7XG4gICAgICAgIHZhciBpc3BhcmVuID0gYnVsbFtidWxsLmxlbmd0aCAtIDFdID09PSAnKSc7XG4gICAgICAgIHZhciBsaXN0ID0ge1xuICAgICAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgICAgICByYXc6IHJhdyxcbiAgICAgICAgICBvcmRlcmVkOiBpc29yZGVyZWQsXG4gICAgICAgICAgc3RhcnQ6IGlzb3JkZXJlZCA/ICtidWxsLnNsaWNlKDAsIC0xKSA6ICcnLFxuICAgICAgICAgIGxvb3NlOiBmYWxzZSxcbiAgICAgICAgICBpdGVtczogW11cbiAgICAgICAgfTsgLy8gR2V0IGVhY2ggdG9wLWxldmVsIGl0ZW0uXG5cbiAgICAgICAgdmFyIGl0ZW1NYXRjaCA9IGNhcFswXS5tYXRjaCh0aGlzLnJ1bGVzLmJsb2NrLml0ZW0pO1xuICAgICAgICB2YXIgbmV4dCA9IGZhbHNlLFxuICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgIHNwYWNlLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGFkZEJhY2ssXG4gICAgICAgICAgICBsb29zZSxcbiAgICAgICAgICAgIGlzdGFzayxcbiAgICAgICAgICAgIGlzY2hlY2tlZDtcbiAgICAgICAgdmFyIGwgPSBpdGVtTWF0Y2gubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaXRlbSA9IGl0ZW1NYXRjaFtpXTtcbiAgICAgICAgICByYXcgPSBpdGVtOyAvLyBSZW1vdmUgdGhlIGxpc3QgaXRlbSdzIGJ1bGxldFxuICAgICAgICAgIC8vIHNvIGl0IGlzIHNlZW4gYXMgdGhlIG5leHQgdG9rZW4uXG5cbiAgICAgICAgICBzcGFjZSA9IGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgIGl0ZW0gPSBpdGVtLnJlcGxhY2UoL14gKihbKistXXxcXGQrWy4pXSkgKi8sICcnKTsgLy8gT3V0ZGVudCB3aGF0ZXZlciB0aGVcbiAgICAgICAgICAvLyBsaXN0IGl0ZW0gY29udGFpbnMuIEhhY2t5LlxuXG4gICAgICAgICAgaWYgKH5pdGVtLmluZGV4T2YoJ1xcbiAnKSkge1xuICAgICAgICAgICAgc3BhY2UgLT0gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgICBpdGVtID0gIXRoaXMub3B0aW9ucy5wZWRhbnRpYyA/IGl0ZW0ucmVwbGFjZShuZXcgUmVnRXhwKCdeIHsxLCcgKyBzcGFjZSArICd9JywgJ2dtJyksICcnKSA6IGl0ZW0ucmVwbGFjZSgvXiB7MSw0fS9nbSwgJycpO1xuICAgICAgICAgIH0gLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIG5leHQgbGlzdCBpdGVtIGJlbG9uZ3MgaGVyZS5cbiAgICAgICAgICAvLyBCYWNrcGVkYWwgaWYgaXQgZG9lcyBub3QgYmVsb25nIGluIHRoaXMgbGlzdC5cblxuXG4gICAgICAgICAgaWYgKGkgIT09IGwgLSAxKSB7XG4gICAgICAgICAgICBiID0gdGhpcy5ydWxlcy5ibG9jay5idWxsZXQuZXhlYyhpdGVtTWF0Y2hbaSArIDFdKVswXTtcblxuICAgICAgICAgICAgaWYgKGlzb3JkZXJlZCA/IGIubGVuZ3RoID09PSAxIHx8ICFpc3BhcmVuICYmIGJbYi5sZW5ndGggLSAxXSA9PT0gJyknIDogYi5sZW5ndGggPiAxIHx8IHRoaXMub3B0aW9ucy5zbWFydExpc3RzICYmIGIgIT09IGJ1bGwpIHtcbiAgICAgICAgICAgICAgYWRkQmFjayA9IGl0ZW1NYXRjaC5zbGljZShpICsgMSkuam9pbignXFxuJyk7XG4gICAgICAgICAgICAgIGxpc3QucmF3ID0gbGlzdC5yYXcuc3Vic3RyaW5nKDAsIGxpc3QucmF3Lmxlbmd0aCAtIGFkZEJhY2subGVuZ3RoKTtcbiAgICAgICAgICAgICAgaSA9IGwgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gRGV0ZXJtaW5lIHdoZXRoZXIgaXRlbSBpcyBsb29zZSBvciBub3QuXG4gICAgICAgICAgLy8gVXNlOiAvKF58XFxuKSg/ISApW15cXG5dK1xcblxcbig/IVxccyokKS9cbiAgICAgICAgICAvLyBmb3IgZGlzY291bnQgYmVoYXZpb3IuXG5cblxuICAgICAgICAgIGxvb3NlID0gbmV4dCB8fCAvXFxuXFxuKD8hXFxzKiQpLy50ZXN0KGl0ZW0pO1xuXG4gICAgICAgICAgaWYgKGkgIT09IGwgLSAxKSB7XG4gICAgICAgICAgICBuZXh0ID0gaXRlbS5jaGFyQXQoaXRlbS5sZW5ndGggLSAxKSA9PT0gJ1xcbic7XG4gICAgICAgICAgICBpZiAoIWxvb3NlKSBsb29zZSA9IG5leHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxvb3NlKSB7XG4gICAgICAgICAgICBsaXN0Lmxvb3NlID0gdHJ1ZTtcbiAgICAgICAgICB9IC8vIENoZWNrIGZvciB0YXNrIGxpc3QgaXRlbXNcblxuXG4gICAgICAgICAgaXN0YXNrID0gL15cXFtbIHhYXVxcXSAvLnRlc3QoaXRlbSk7XG4gICAgICAgICAgaXNjaGVja2VkID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKGlzdGFzaykge1xuICAgICAgICAgICAgaXNjaGVja2VkID0gaXRlbVsxXSAhPT0gJyAnO1xuICAgICAgICAgICAgaXRlbSA9IGl0ZW0ucmVwbGFjZSgvXlxcW1sgeFhdXFxdICsvLCAnJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdC5pdGVtcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdsaXN0X2l0ZW0nLFxuICAgICAgICAgICAgcmF3OiByYXcsXG4gICAgICAgICAgICB0YXNrOiBpc3Rhc2ssXG4gICAgICAgICAgICBjaGVja2VkOiBpc2NoZWNrZWQsXG4gICAgICAgICAgICBsb29zZTogbG9vc2UsXG4gICAgICAgICAgICB0ZXh0OiBpdGVtXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmh0bWwgPSBmdW5jdGlvbiBodG1sKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2suaHRtbC5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiB0aGlzLm9wdGlvbnMuc2FuaXRpemUgPyAncGFyYWdyYXBoJyA6ICdodG1sJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICBwcmU6ICF0aGlzLm9wdGlvbnMuc2FuaXRpemVyICYmIChjYXBbMV0gPT09ICdwcmUnIHx8IGNhcFsxXSA9PT0gJ3NjcmlwdCcgfHwgY2FwWzFdID09PSAnc3R5bGUnKSxcbiAgICAgICAgICB0ZXh0OiB0aGlzLm9wdGlvbnMuc2FuaXRpemUgPyB0aGlzLm9wdGlvbnMuc2FuaXRpemVyID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pIDogX2VzY2FwZShjYXBbMF0pIDogY2FwWzBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5kZWYgPSBmdW5jdGlvbiBkZWYoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5kZWYuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIGlmIChjYXBbM10pIGNhcFszXSA9IGNhcFszXS5zdWJzdHJpbmcoMSwgY2FwWzNdLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgdGFnID0gY2FwWzFdLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIGhyZWY6IGNhcFsyXSxcbiAgICAgICAgICB0aXRsZTogY2FwWzNdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by50YWJsZSA9IGZ1bmN0aW9uIHRhYmxlKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2sudGFibGUuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICAgICAgaGVhZGVyOiBzcGxpdENlbGxzJDEoY2FwWzFdLnJlcGxhY2UoL14gKnwgKlxcfCAqJC9nLCAnJykpLFxuICAgICAgICAgIGFsaWduOiBjYXBbMl0ucmVwbGFjZSgvXiAqfFxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgICBjZWxsczogY2FwWzNdID8gY2FwWzNdLnJlcGxhY2UoL1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpIDogW11cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaXRlbS5oZWFkZXIubGVuZ3RoID09PSBpdGVtLmFsaWduLmxlbmd0aCkge1xuICAgICAgICAgIGl0ZW0ucmF3ID0gY2FwWzBdO1xuICAgICAgICAgIHZhciBsID0gaXRlbS5hbGlnbi5sZW5ndGg7XG4gICAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ3JpZ2h0JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL14gKjotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdjZW50ZXInO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnbGVmdCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsID0gaXRlbS5jZWxscy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtLmNlbGxzW2ldID0gc3BsaXRDZWxscyQxKGl0ZW0uY2VsbHNbaV0ucmVwbGFjZSgvXiAqXFx8ICp8ICpcXHwgKiQvZywgJycpLCBpdGVtLmhlYWRlci5sZW5ndGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5saGVhZGluZyA9IGZ1bmN0aW9uIGxoZWFkaW5nKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2subGhlYWRpbmcuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIGRlcHRoOiBjYXBbMl0uY2hhckF0KDApID09PSAnPScgPyAxIDogMixcbiAgICAgICAgICB0ZXh0OiBjYXBbMV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLnBhcmFncmFwaCA9IGZ1bmN0aW9uIHBhcmFncmFwaChzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLnBhcmFncmFwaC5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICB0ZXh0OiBjYXBbMV0uY2hhckF0KGNhcFsxXS5sZW5ndGggLSAxKSA9PT0gJ1xcbicgPyBjYXBbMV0uc2xpY2UoMCwgLTEpIDogY2FwWzFdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by50ZXh0ID0gZnVuY3Rpb24gdGV4dChzcmMsIHRva2Vucykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2sudGV4dC5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgdmFyIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgdGV4dDogY2FwWzBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIHRleHQ6IGNhcFswXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uZXNjYXBlID0gZnVuY3Rpb24gZXNjYXBlKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmVzY2FwZS5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnZXNjYXBlJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICB0ZXh0OiBfZXNjYXBlKGNhcFsxXSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLnRhZyA9IGZ1bmN0aW9uIHRhZyhzcmMsIGluTGluaywgaW5SYXdCbG9jaykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnRhZy5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgaWYgKCFpbkxpbmsgJiYgL148YSAvaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgICBpbkxpbmsgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGluTGluayAmJiAvXjxcXC9hPi9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICAgIGluTGluayA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpblJhd0Jsb2NrICYmIC9ePChwcmV8Y29kZXxrYmR8c2NyaXB0KShcXHN8PikvaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgICBpblJhd0Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpblJhd0Jsb2NrICYmIC9ePFxcLyhwcmV8Y29kZXxrYmR8c2NyaXB0KShcXHN8PikvaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgICBpblJhd0Jsb2NrID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IHRoaXMub3B0aW9ucy5zYW5pdGl6ZSA/ICd0ZXh0JyA6ICdodG1sJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICBpbkxpbms6IGluTGluayxcbiAgICAgICAgICBpblJhd0Jsb2NrOiBpblJhd0Jsb2NrLFxuICAgICAgICAgIHRleHQ6IHRoaXMub3B0aW9ucy5zYW5pdGl6ZSA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIgPyB0aGlzLm9wdGlvbnMuc2FuaXRpemVyKGNhcFswXSkgOiBfZXNjYXBlKGNhcFswXSkgOiBjYXBbMF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmxpbmsgPSBmdW5jdGlvbiBsaW5rKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmxpbmsuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciBsYXN0UGFyZW5JbmRleCA9IGZpbmRDbG9zaW5nQnJhY2tldCQxKGNhcFsyXSwgJygpJyk7XG5cbiAgICAgICAgaWYgKGxhc3RQYXJlbkluZGV4ID4gLTEpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBjYXBbMF0uaW5kZXhPZignIScpID09PSAwID8gNSA6IDQ7XG4gICAgICAgICAgdmFyIGxpbmtMZW4gPSBzdGFydCArIGNhcFsxXS5sZW5ndGggKyBsYXN0UGFyZW5JbmRleDtcbiAgICAgICAgICBjYXBbMl0gPSBjYXBbMl0uc3Vic3RyaW5nKDAsIGxhc3RQYXJlbkluZGV4KTtcbiAgICAgICAgICBjYXBbMF0gPSBjYXBbMF0uc3Vic3RyaW5nKDAsIGxpbmtMZW4pLnRyaW0oKTtcbiAgICAgICAgICBjYXBbM10gPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBocmVmID0gY2FwWzJdO1xuICAgICAgICB2YXIgdGl0bGUgPSAnJztcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgdmFyIGxpbmsgPSAvXihbXidcIl0qW15cXHNdKVxccysoWydcIl0pKC4qKVxcMi8uZXhlYyhocmVmKTtcblxuICAgICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICBocmVmID0gbGlua1sxXTtcbiAgICAgICAgICAgIHRpdGxlID0gbGlua1szXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGl0bGUgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGl0bGUgPSBjYXBbM10gPyBjYXBbM10uc2xpY2UoMSwgLTEpIDogJyc7XG4gICAgICAgIH1cblxuICAgICAgICBocmVmID0gaHJlZi50cmltKCkucmVwbGFjZSgvXjwoW1xcc1xcU10qKT4kLywgJyQxJyk7XG4gICAgICAgIHZhciB0b2tlbiA9IG91dHB1dExpbmsoY2FwLCB7XG4gICAgICAgICAgaHJlZjogaHJlZiA/IGhyZWYucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5fZXNjYXBlcywgJyQxJykgOiBocmVmLFxuICAgICAgICAgIHRpdGxlOiB0aXRsZSA/IHRpdGxlLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuX2VzY2FwZXMsICckMScpIDogdGl0bGVcbiAgICAgICAgfSwgY2FwWzBdKTtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8ucmVmbGluayA9IGZ1bmN0aW9uIHJlZmxpbmsoc3JjLCBsaW5rcykge1xuICAgICAgdmFyIGNhcDtcblxuICAgICAgaWYgKChjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5yZWZsaW5rLmV4ZWMoc3JjKSkgfHwgKGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLm5vbGluay5leGVjKHNyYykpKSB7XG4gICAgICAgIHZhciBsaW5rID0gKGNhcFsyXSB8fCBjYXBbMV0pLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgICAgbGluayA9IGxpbmtzW2xpbmsudG9Mb3dlckNhc2UoKV07XG5cbiAgICAgICAgaWYgKCFsaW5rIHx8ICFsaW5rLmhyZWYpIHtcbiAgICAgICAgICB2YXIgdGV4dCA9IGNhcFswXS5jaGFyQXQoMCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRva2VuID0gb3V0cHV0TGluayhjYXAsIGxpbmssIGNhcFswXSk7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLnN0cm9uZyA9IGZ1bmN0aW9uIHN0cm9uZyhzcmMsIG1hc2tlZFNyYywgcHJldkNoYXIpIHtcbiAgICAgIGlmIChwcmV2Q2hhciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHByZXZDaGFyID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXRjaCA9IHRoaXMucnVsZXMuaW5saW5lLnN0cm9uZy5zdGFydC5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChtYXRjaCAmJiAoIW1hdGNoWzFdIHx8IG1hdGNoWzFdICYmIChwcmV2Q2hhciA9PT0gJycgfHwgdGhpcy5ydWxlcy5pbmxpbmUucHVuY3R1YXRpb24uZXhlYyhwcmV2Q2hhcikpKSkge1xuICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoLTEgKiBzcmMubGVuZ3RoKTtcbiAgICAgICAgdmFyIGVuZFJlZyA9IG1hdGNoWzBdID09PSAnKionID8gdGhpcy5ydWxlcy5pbmxpbmUuc3Ryb25nLmVuZEFzdCA6IHRoaXMucnVsZXMuaW5saW5lLnN0cm9uZy5lbmRVbmQ7XG4gICAgICAgIGVuZFJlZy5sYXN0SW5kZXggPSAwO1xuICAgICAgICB2YXIgY2FwO1xuXG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSBlbmRSZWcuZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuc3Ryb25nLm1pZGRsZS5leGVjKG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCArIDMpKTtcblxuICAgICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdzdHJvbmcnLFxuICAgICAgICAgICAgICByYXc6IHNyYy5zbGljZSgwLCBjYXBbMF0ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgdGV4dDogc3JjLnNsaWNlKDIsIGNhcFswXS5sZW5ndGggLSAyKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmVtID0gZnVuY3Rpb24gZW0oc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyKSB7XG4gICAgICBpZiAocHJldkNoYXIgPT09IHZvaWQgMCkge1xuICAgICAgICBwcmV2Q2hhciA9ICcnO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0Y2ggPSB0aGlzLnJ1bGVzLmlubGluZS5lbS5zdGFydC5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChtYXRjaCAmJiAoIW1hdGNoWzFdIHx8IG1hdGNoWzFdICYmIChwcmV2Q2hhciA9PT0gJycgfHwgdGhpcy5ydWxlcy5pbmxpbmUucHVuY3R1YXRpb24uZXhlYyhwcmV2Q2hhcikpKSkge1xuICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoLTEgKiBzcmMubGVuZ3RoKTtcbiAgICAgICAgdmFyIGVuZFJlZyA9IG1hdGNoWzBdID09PSAnKicgPyB0aGlzLnJ1bGVzLmlubGluZS5lbS5lbmRBc3QgOiB0aGlzLnJ1bGVzLmlubGluZS5lbS5lbmRVbmQ7XG4gICAgICAgIGVuZFJlZy5sYXN0SW5kZXggPSAwO1xuICAgICAgICB2YXIgY2FwO1xuXG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSBlbmRSZWcuZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuZW0ubWlkZGxlLmV4ZWMobWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4ICsgMikpO1xuXG4gICAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2VtJyxcbiAgICAgICAgICAgICAgcmF3OiBzcmMuc2xpY2UoMCwgY2FwWzBdLmxlbmd0aCksXG4gICAgICAgICAgICAgIHRleHQ6IHNyYy5zbGljZSgxLCBjYXBbMF0ubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5jb2Rlc3BhbiA9IGZ1bmN0aW9uIGNvZGVzcGFuKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmNvZGUuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gY2FwWzJdLnJlcGxhY2UoL1xcbi9nLCAnICcpO1xuICAgICAgICB2YXIgaGFzTm9uU3BhY2VDaGFycyA9IC9bXiBdLy50ZXN0KHRleHQpO1xuICAgICAgICB2YXIgaGFzU3BhY2VDaGFyc09uQm90aEVuZHMgPSB0ZXh0LnN0YXJ0c1dpdGgoJyAnKSAmJiB0ZXh0LmVuZHNXaXRoKCcgJyk7XG5cbiAgICAgICAgaWYgKGhhc05vblNwYWNlQ2hhcnMgJiYgaGFzU3BhY2VDaGFyc09uQm90aEVuZHMpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMSwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRleHQgPSBfZXNjYXBlKHRleHQsIHRydWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdjb2Rlc3BhbicsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uYnIgPSBmdW5jdGlvbiBicihzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5ici5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnYnInLFxuICAgICAgICAgIHJhdzogY2FwWzBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5kZWwgPSBmdW5jdGlvbiBkZWwoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuZGVsLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdkZWwnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIHRleHQ6IGNhcFsxXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uYXV0b2xpbmsgPSBmdW5jdGlvbiBhdXRvbGluayhzcmMsIG1hbmdsZSkge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmF1dG9saW5rLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgdGV4dCwgaHJlZjtcblxuICAgICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZSh0aGlzLm9wdGlvbnMubWFuZ2xlID8gbWFuZ2xlKGNhcFsxXSkgOiBjYXBbMV0pO1xuICAgICAgICAgIGhyZWYgPSAnbWFpbHRvOicgKyB0ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHQgPSBfZXNjYXBlKGNhcFsxXSk7XG4gICAgICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgICAgdG9rZW5zOiBbe1xuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgcmF3OiB0ZXh0LFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by51cmwgPSBmdW5jdGlvbiB1cmwoc3JjLCBtYW5nbGUpIHtcbiAgICAgIHZhciBjYXA7XG5cbiAgICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS51cmwuZXhlYyhzcmMpKSB7XG4gICAgICAgIHZhciB0ZXh0LCBocmVmO1xuXG4gICAgICAgIGlmIChjYXBbMl0gPT09ICdAJykge1xuICAgICAgICAgIHRleHQgPSBfZXNjYXBlKHRoaXMub3B0aW9ucy5tYW5nbGUgPyBtYW5nbGUoY2FwWzBdKSA6IGNhcFswXSk7XG4gICAgICAgICAgaHJlZiA9ICdtYWlsdG86JyArIHRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZG8gZXh0ZW5kZWQgYXV0b2xpbmsgcGF0aCB2YWxpZGF0aW9uXG4gICAgICAgICAgdmFyIHByZXZDYXBaZXJvO1xuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgcHJldkNhcFplcm8gPSBjYXBbMF07XG4gICAgICAgICAgICBjYXBbMF0gPSB0aGlzLnJ1bGVzLmlubGluZS5fYmFja3BlZGFsLmV4ZWMoY2FwWzBdKVswXTtcbiAgICAgICAgICB9IHdoaWxlIChwcmV2Q2FwWmVybyAhPT0gY2FwWzBdKTtcblxuICAgICAgICAgIHRleHQgPSBfZXNjYXBlKGNhcFswXSk7XG5cbiAgICAgICAgICBpZiAoY2FwWzFdID09PSAnd3d3LicpIHtcbiAgICAgICAgICAgIGhyZWYgPSAnaHR0cDovLycgKyB0ZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBocmVmID0gdGV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgICAgdG9rZW5zOiBbe1xuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgcmF3OiB0ZXh0LFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5pbmxpbmVUZXh0ID0gZnVuY3Rpb24gaW5saW5lVGV4dChzcmMsIGluUmF3QmxvY2ssIHNtYXJ0eXBhbnRzKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudGV4dC5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgdmFyIHRleHQ7XG5cbiAgICAgICAgaWYgKGluUmF3QmxvY2spIHtcbiAgICAgICAgICB0ZXh0ID0gdGhpcy5vcHRpb25zLnNhbml0aXplID8gdGhpcy5vcHRpb25zLnNhbml0aXplciA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIoY2FwWzBdKSA6IF9lc2NhcGUoY2FwWzBdKSA6IGNhcFswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZSh0aGlzLm9wdGlvbnMuc21hcnR5cGFudHMgPyBzbWFydHlwYW50cyhjYXBbMF0pIDogY2FwWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFRva2VuaXplcjtcbiAgfSgpO1xuXG4gIHZhciBub29wVGVzdCQxID0gaGVscGVycy5ub29wVGVzdCxcbiAgICAgIGVkaXQkMSA9IGhlbHBlcnMuZWRpdCxcbiAgICAgIG1lcmdlJDEgPSBoZWxwZXJzLm1lcmdlO1xuICAvKipcbiAgICogQmxvY2stTGV2ZWwgR3JhbW1hclxuICAgKi9cblxuICB2YXIgYmxvY2sgPSB7XG4gICAgbmV3bGluZTogL15cXG4rLyxcbiAgICBjb2RlOiAvXiggezR9W15cXG5dK1xcbiopKy8sXG4gICAgZmVuY2VzOiAvXiB7MCwzfShgezMsfSg/PVteYFxcbl0qXFxuKXx+ezMsfSkoW15cXG5dKilcXG4oPzp8KFtcXHNcXFNdKj8pXFxuKSg/OiB7MCwzfVxcMVt+YF0qICooPzpcXG4rfCQpfCQpLyxcbiAgICBocjogL14gezAsM30oKD86LSAqKXszLH18KD86XyAqKXszLH18KD86XFwqICopezMsfSkoPzpcXG4rfCQpLyxcbiAgICBoZWFkaW5nOiAvXiB7MCwzfSgjezEsNn0pICsoW15cXG5dKj8pKD86ICsjKyk/ICooPzpcXG4rfCQpLyxcbiAgICBibG9ja3F1b3RlOiAvXiggezAsM30+ID8ocGFyYWdyYXBofFteXFxuXSopKD86XFxufCQpKSsvLFxuICAgIGxpc3Q6IC9eKCB7MCwzfSkoYnVsbCkgW1xcc1xcU10rPyg/OmhyfGRlZnxcXG57Mix9KD8hICkoPyFcXDFidWxsIClcXG4qfFxccyokKS8sXG4gICAgaHRtbDogJ14gezAsM30oPzonIC8vIG9wdGlvbmFsIGluZGVudGF0aW9uXG4gICAgKyAnPChzY3JpcHR8cHJlfHN0eWxlKVtcXFxccz5dW1xcXFxzXFxcXFNdKj8oPzo8L1xcXFwxPlteXFxcXG5dKlxcXFxuK3wkKScgLy8gKDEpXG4gICAgKyAnfGNvbW1lbnRbXlxcXFxuXSooXFxcXG4rfCQpJyAvLyAoMilcbiAgICArICd8PFxcXFw/W1xcXFxzXFxcXFNdKj8oPzpcXFxcPz5cXFxcbip8JCknIC8vICgzKVxuICAgICsgJ3w8IVtBLVpdW1xcXFxzXFxcXFNdKj8oPzo+XFxcXG4qfCQpJyAvLyAoNClcbiAgICArICd8PCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qPyg/OlxcXFxdXFxcXF0+XFxcXG4qfCQpJyAvLyAoNSlcbiAgICArICd8PC8/KHRhZykoPzogK3xcXFxcbnwvPz4pW1xcXFxzXFxcXFNdKj8oPzpcXFxcbnsyLH18JCknIC8vICg2KVxuICAgICsgJ3w8KD8hc2NyaXB0fHByZXxzdHlsZSkoW2Etel1bXFxcXHctXSopKD86YXR0cmlidXRlKSo/ICovPz4oPz1bIFxcXFx0XSooPzpcXFxcbnwkKSlbXFxcXHNcXFxcU10qPyg/OlxcXFxuezIsfXwkKScgLy8gKDcpIG9wZW4gdGFnXG4gICAgKyAnfDwvKD8hc2NyaXB0fHByZXxzdHlsZSlbYS16XVtcXFxcdy1dKlxcXFxzKj4oPz1bIFxcXFx0XSooPzpcXFxcbnwkKSlbXFxcXHNcXFxcU10qPyg/OlxcXFxuezIsfXwkKScgLy8gKDcpIGNsb3NpbmcgdGFnXG4gICAgKyAnKScsXG4gICAgZGVmOiAvXiB7MCwzfVxcWyhsYWJlbClcXF06ICpcXG4/ICo8PyhbXlxccz5dKyk+Pyg/Oig/OiArXFxuPyAqfCAqXFxuICopKHRpdGxlKSk/ICooPzpcXG4rfCQpLyxcbiAgICBucHRhYmxlOiBub29wVGVzdCQxLFxuICAgIHRhYmxlOiBub29wVGVzdCQxLFxuICAgIGxoZWFkaW5nOiAvXihbXlxcbl0rKVxcbiB7MCwzfSg9K3wtKykgKig/Olxcbit8JCkvLFxuICAgIC8vIHJlZ2V4IHRlbXBsYXRlLCBwbGFjZWhvbGRlcnMgd2lsbCBiZSByZXBsYWNlZCBhY2NvcmRpbmcgdG8gZGlmZmVyZW50IHBhcmFncmFwaFxuICAgIC8vIGludGVycnVwdGlvbiBydWxlcyBvZiBjb21tb25tYXJrIGFuZCB0aGUgb3JpZ2luYWwgbWFya2Rvd24gc3BlYzpcbiAgICBfcGFyYWdyYXBoOiAvXihbXlxcbl0rKD86XFxuKD8haHJ8aGVhZGluZ3xsaGVhZGluZ3xibG9ja3F1b3RlfGZlbmNlc3xsaXN0fGh0bWwpW15cXG5dKykqKS8sXG4gICAgdGV4dDogL15bXlxcbl0rL1xuICB9O1xuICBibG9jay5fbGFiZWwgPSAvKD8hXFxzKlxcXSkoPzpcXFxcW1xcW1xcXV18W15cXFtcXF1dKSsvO1xuICBibG9jay5fdGl0bGUgPSAvKD86XCIoPzpcXFxcXCI/fFteXCJcXFxcXSkqXCJ8J1teJ1xcbl0qKD86XFxuW14nXFxuXSspKlxcbj8nfFxcKFteKCldKlxcKSkvO1xuICBibG9jay5kZWYgPSBlZGl0JDEoYmxvY2suZGVmKS5yZXBsYWNlKCdsYWJlbCcsIGJsb2NrLl9sYWJlbCkucmVwbGFjZSgndGl0bGUnLCBibG9jay5fdGl0bGUpLmdldFJlZ2V4KCk7XG4gIGJsb2NrLmJ1bGxldCA9IC8oPzpbKistXXxcXGR7MSw5fVsuKV0pLztcbiAgYmxvY2suaXRlbSA9IC9eKCAqKShidWxsKSA/W15cXG5dKig/Olxcbig/IVxcMWJ1bGwgPylbXlxcbl0qKSovO1xuICBibG9jay5pdGVtID0gZWRpdCQxKGJsb2NrLml0ZW0sICdnbScpLnJlcGxhY2UoL2J1bGwvZywgYmxvY2suYnVsbGV0KS5nZXRSZWdleCgpO1xuICBibG9jay5saXN0ID0gZWRpdCQxKGJsb2NrLmxpc3QpLnJlcGxhY2UoL2J1bGwvZywgYmxvY2suYnVsbGV0KS5yZXBsYWNlKCdocicsICdcXFxcbisoPz1cXFxcMT8oPzooPzotICopezMsfXwoPzpfICopezMsfXwoPzpcXFxcKiAqKXszLH0pKD86XFxcXG4rfCQpKScpLnJlcGxhY2UoJ2RlZicsICdcXFxcbisoPz0nICsgYmxvY2suZGVmLnNvdXJjZSArICcpJykuZ2V0UmVnZXgoKTtcbiAgYmxvY2suX3RhZyA9ICdhZGRyZXNzfGFydGljbGV8YXNpZGV8YmFzZXxiYXNlZm9udHxibG9ja3F1b3RlfGJvZHl8Y2FwdGlvbicgKyAnfGNlbnRlcnxjb2x8Y29sZ3JvdXB8ZGR8ZGV0YWlsc3xkaWFsb2d8ZGlyfGRpdnxkbHxkdHxmaWVsZHNldHxmaWdjYXB0aW9uJyArICd8ZmlndXJlfGZvb3Rlcnxmb3JtfGZyYW1lfGZyYW1lc2V0fGhbMS02XXxoZWFkfGhlYWRlcnxocnxodG1sfGlmcmFtZScgKyAnfGxlZ2VuZHxsaXxsaW5rfG1haW58bWVudXxtZW51aXRlbXxtZXRhfG5hdnxub2ZyYW1lc3xvbHxvcHRncm91cHxvcHRpb24nICsgJ3xwfHBhcmFtfHNlY3Rpb258c291cmNlfHN1bW1hcnl8dGFibGV8dGJvZHl8dGR8dGZvb3R8dGh8dGhlYWR8dGl0bGV8dHInICsgJ3x0cmFja3x1bCc7XG4gIGJsb2NrLl9jb21tZW50ID0gLzwhLS0oPyEtPz4pW1xcc1xcU10qPyg/Oi0tPnwkKS87XG4gIGJsb2NrLmh0bWwgPSBlZGl0JDEoYmxvY2suaHRtbCwgJ2knKS5yZXBsYWNlKCdjb21tZW50JywgYmxvY2suX2NvbW1lbnQpLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpLnJlcGxhY2UoJ2F0dHJpYnV0ZScsIC8gK1thLXpBLVo6X11bXFx3LjotXSooPzogKj0gKlwiW15cIlxcbl0qXCJ8ICo9IConW14nXFxuXSonfCAqPSAqW15cXHNcIic9PD5gXSspPy8pLmdldFJlZ2V4KCk7XG4gIGJsb2NrLnBhcmFncmFwaCA9IGVkaXQkMShibG9jay5fcGFyYWdyYXBoKS5yZXBsYWNlKCdocicsIGJsb2NrLmhyKS5yZXBsYWNlKCdoZWFkaW5nJywgJyB7MCwzfSN7MSw2fSAnKS5yZXBsYWNlKCd8bGhlYWRpbmcnLCAnJykgLy8gc2V0ZXggaGVhZGluZ3MgZG9uJ3QgaW50ZXJydXB0IGNvbW1vbm1hcmsgcGFyYWdyYXBoc1xuICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JykucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbiAgLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8IS0tKScpLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpIC8vIHBhcnMgY2FuIGJlIGludGVycnVwdGVkIGJ5IHR5cGUgKDYpIGh0bWwgYmxvY2tzXG4gIC5nZXRSZWdleCgpO1xuICBibG9jay5ibG9ja3F1b3RlID0gZWRpdCQxKGJsb2NrLmJsb2NrcXVvdGUpLnJlcGxhY2UoJ3BhcmFncmFwaCcsIGJsb2NrLnBhcmFncmFwaCkuZ2V0UmVnZXgoKTtcbiAgLyoqXG4gICAqIE5vcm1hbCBCbG9jayBHcmFtbWFyXG4gICAqL1xuXG4gIGJsb2NrLm5vcm1hbCA9IG1lcmdlJDEoe30sIGJsb2NrKTtcbiAgLyoqXG4gICAqIEdGTSBCbG9jayBHcmFtbWFyXG4gICAqL1xuXG4gIGJsb2NrLmdmbSA9IG1lcmdlJDEoe30sIGJsb2NrLm5vcm1hbCwge1xuICAgIG5wdGFibGU6ICdeICooW158XFxcXG4gXS4qXFxcXHwuKilcXFxcbicgLy8gSGVhZGVyXG4gICAgKyAnIHswLDN9KFstOl0rICpcXFxcfFstfCA6XSopJyAvLyBBbGlnblxuICAgICsgJyg/OlxcXFxuKCg/Oig/IVxcXFxufGhyfGhlYWRpbmd8YmxvY2txdW90ZXxjb2RlfGZlbmNlc3xsaXN0fGh0bWwpLiooPzpcXFxcbnwkKSkqKVxcXFxuKnwkKScsXG4gICAgLy8gQ2VsbHNcbiAgICB0YWJsZTogJ14gKlxcXFx8KC4rKVxcXFxuJyAvLyBIZWFkZXJcbiAgICArICcgezAsM31cXFxcfD8oICpbLTpdK1stfCA6XSopJyAvLyBBbGlnblxuICAgICsgJyg/OlxcXFxuICooKD86KD8hXFxcXG58aHJ8aGVhZGluZ3xibG9ja3F1b3RlfGNvZGV8ZmVuY2VzfGxpc3R8aHRtbCkuKig/OlxcXFxufCQpKSopXFxcXG4qfCQpJyAvLyBDZWxsc1xuXG4gIH0pO1xuICBibG9jay5nZm0ubnB0YWJsZSA9IGVkaXQkMShibG9jay5nZm0ubnB0YWJsZSkucmVwbGFjZSgnaHInLCBibG9jay5ocikucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0gJykucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JykucmVwbGFjZSgnY29kZScsICcgezR9W15cXFxcbl0nKS5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJykucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXwhLS0pJykucmVwbGFjZSgndGFnJywgYmxvY2suX3RhZykgLy8gdGFibGVzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAuZ2V0UmVnZXgoKTtcbiAgYmxvY2suZ2ZtLnRhYmxlID0gZWRpdCQxKGJsb2NrLmdmbS50YWJsZSkucmVwbGFjZSgnaHInLCBibG9jay5ocikucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0gJykucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JykucmVwbGFjZSgnY29kZScsICcgezR9W15cXFxcbl0nKS5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJykucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXwhLS0pJykucmVwbGFjZSgndGFnJywgYmxvY2suX3RhZykgLy8gdGFibGVzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAuZ2V0UmVnZXgoKTtcbiAgLyoqXG4gICAqIFBlZGFudGljIGdyYW1tYXIgKG9yaWdpbmFsIEpvaG4gR3J1YmVyJ3MgbG9vc2UgbWFya2Rvd24gc3BlY2lmaWNhdGlvbilcbiAgICovXG5cbiAgYmxvY2sucGVkYW50aWMgPSBtZXJnZSQxKHt9LCBibG9jay5ub3JtYWwsIHtcbiAgICBodG1sOiBlZGl0JDEoJ14gKig/OmNvbW1lbnQgKig/OlxcXFxufFxcXFxzKiQpJyArICd8PCh0YWcpW1xcXFxzXFxcXFNdKz88L1xcXFwxPiAqKD86XFxcXG57Mix9fFxcXFxzKiQpJyAvLyBjbG9zZWQgdGFnXG4gICAgKyAnfDx0YWcoPzpcIlteXCJdKlwifFxcJ1teXFwnXSpcXCd8XFxcXHNbXlxcJ1wiLz5cXFxcc10qKSo/Lz8+ICooPzpcXFxcbnsyLH18XFxcXHMqJCkpJykucmVwbGFjZSgnY29tbWVudCcsIGJsb2NrLl9jb21tZW50KS5yZXBsYWNlKC90YWcvZywgJyg/ISg/OicgKyAnYXxlbXxzdHJvbmd8c21hbGx8c3xjaXRlfHF8ZGZufGFiYnJ8ZGF0YXx0aW1lfGNvZGV8dmFyfHNhbXB8a2JkfHN1YicgKyAnfHN1cHxpfGJ8dXxtYXJrfHJ1Ynl8cnR8cnB8YmRpfGJkb3xzcGFufGJyfHdicnxpbnN8ZGVsfGltZyknICsgJ1xcXFxiKVxcXFx3Kyg/ITp8W15cXFxcd1xcXFxzQF0qQClcXFxcYicpLmdldFJlZ2V4KCksXG4gICAgZGVmOiAvXiAqXFxbKFteXFxdXSspXFxdOiAqPD8oW15cXHM+XSspPj8oPzogKyhbXCIoXVteXFxuXStbXCIpXSkpPyAqKD86XFxuK3wkKS8sXG4gICAgaGVhZGluZzogL14gKigjezEsNn0pICooW15cXG5dKz8pICooPzojKyAqKT8oPzpcXG4rfCQpLyxcbiAgICBmZW5jZXM6IG5vb3BUZXN0JDEsXG4gICAgLy8gZmVuY2VzIG5vdCBzdXBwb3J0ZWRcbiAgICBwYXJhZ3JhcGg6IGVkaXQkMShibG9jay5ub3JtYWwuX3BhcmFncmFwaCkucmVwbGFjZSgnaHInLCBibG9jay5ocikucmVwbGFjZSgnaGVhZGluZycsICcgKiN7MSw2fSAqW15cXG5dJykucmVwbGFjZSgnbGhlYWRpbmcnLCBibG9jay5saGVhZGluZykucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JykucmVwbGFjZSgnfGZlbmNlcycsICcnKS5yZXBsYWNlKCd8bGlzdCcsICcnKS5yZXBsYWNlKCd8aHRtbCcsICcnKS5nZXRSZWdleCgpXG4gIH0pO1xuICAvKipcbiAgICogSW5saW5lLUxldmVsIEdyYW1tYXJcbiAgICovXG5cbiAgdmFyIGlubGluZSA9IHtcbiAgICBlc2NhcGU6IC9eXFxcXChbIVwiIyQlJicoKSorLFxcLS4vOjs8PT4/QFxcW1xcXVxcXFxeX2B7fH1+XSkvLFxuICAgIGF1dG9saW5rOiAvXjwoc2NoZW1lOlteXFxzXFx4MDAtXFx4MWY8Pl0qfGVtYWlsKT4vLFxuICAgIHVybDogbm9vcFRlc3QkMSxcbiAgICB0YWc6ICdeY29tbWVudCcgKyAnfF48L1thLXpBLVpdW1xcXFx3Oi1dKlxcXFxzKj4nIC8vIHNlbGYtY2xvc2luZyB0YWdcbiAgICArICd8XjxbYS16QS1aXVtcXFxcdy1dKig/OmF0dHJpYnV0ZSkqP1xcXFxzKi8/PicgLy8gb3BlbiB0YWdcbiAgICArICd8XjxcXFxcP1tcXFxcc1xcXFxTXSo/XFxcXD8+JyAvLyBwcm9jZXNzaW5nIGluc3RydWN0aW9uLCBlLmcuIDw/cGhwID8+XG4gICAgKyAnfF48IVthLXpBLVpdK1xcXFxzW1xcXFxzXFxcXFNdKj8+JyAvLyBkZWNsYXJhdGlvbiwgZS5nLiA8IURPQ1RZUEUgaHRtbD5cbiAgICArICd8XjwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj9cXFxcXVxcXFxdPicsXG4gICAgLy8gQ0RBVEEgc2VjdGlvblxuICAgIGxpbms6IC9eIT9cXFsobGFiZWwpXFxdXFwoXFxzKihocmVmKSg/OlxccysodGl0bGUpKT9cXHMqXFwpLyxcbiAgICByZWZsaW5rOiAvXiE/XFxbKGxhYmVsKVxcXVxcWyg/IVxccypcXF0pKCg/OlxcXFxbXFxbXFxdXT98W15cXFtcXF1cXFxcXSkrKVxcXS8sXG4gICAgbm9saW5rOiAvXiE/XFxbKD8hXFxzKlxcXSkoKD86XFxbW15cXFtcXF1dKlxcXXxcXFxcW1xcW1xcXV18W15cXFtcXF1dKSopXFxdKD86XFxbXFxdKT8vLFxuICAgIHJlZmxpbmtTZWFyY2g6ICdyZWZsaW5rfG5vbGluayg/IVxcXFwoKScsXG4gICAgc3Ryb25nOiB7XG4gICAgICBzdGFydDogL14oPzooXFwqXFwqKD89WypwdW5jdHVhdGlvbl0pKXxcXCpcXCopKD8hW1xcc10pfF9fLyxcbiAgICAgIC8vICgxKSByZXR1cm5zIGlmIHN0YXJ0cyB3LyBwdW5jdHVhdGlvblxuICAgICAgbWlkZGxlOiAvXlxcKlxcKig/Oig/Oig/IW92ZXJsYXBTa2lwKSg/OlteKl18XFxcXFxcKil8b3ZlcmxhcFNraXApfFxcKig/Oig/IW92ZXJsYXBTa2lwKSg/OlteKl18XFxcXFxcKil8b3ZlcmxhcFNraXApKj9cXCopKz9cXCpcXCokfF5fXyg/IVtcXHNdKSgoPzooPzooPyFvdmVybGFwU2tpcCkoPzpbXl9dfFxcXFxfKXxvdmVybGFwU2tpcCl8Xyg/Oig/IW92ZXJsYXBTa2lwKSg/OlteX118XFxcXF8pfG92ZXJsYXBTa2lwKSo/XykrPylfXyQvLFxuICAgICAgZW5kQXN0OiAvW15wdW5jdHVhdGlvblxcc11cXCpcXCooPyFcXCopfFtwdW5jdHVhdGlvbl1cXCpcXCooPyFcXCopKD86KD89W3B1bmN0dWF0aW9uX1xcc118JCkpLyxcbiAgICAgIC8vIGxhc3QgY2hhciBjYW4ndCBiZSBwdW5jdCwgb3IgZmluYWwgKiBtdXN0IGFsc28gYmUgZm9sbG93ZWQgYnkgcHVuY3QgKG9yIGVuZGxpbmUpXG4gICAgICBlbmRVbmQ6IC9bXlxcc11fXyg/IV8pKD86KD89W3B1bmN0dWF0aW9uKlxcc10pfCQpLyAvLyBsYXN0IGNoYXIgY2FuJ3QgYmUgYSBzcGFjZSwgYW5kIGZpbmFsIF8gbXVzdCBwcmVjZWVkIHB1bmN0IG9yIFxccyAob3IgZW5kbGluZSlcblxuICAgIH0sXG4gICAgZW06IHtcbiAgICAgIHN0YXJ0OiAvXig/OihcXCooPz1bcHVuY3R1YXRpb25dKSl8XFwqKSg/IVsqXFxzXSl8Xy8sXG4gICAgICAvLyAoMSkgcmV0dXJucyBpZiBzdGFydHMgdy8gcHVuY3R1YXRpb25cbiAgICAgIG1pZGRsZTogL15cXCooPzooPzooPyFvdmVybGFwU2tpcCkoPzpbXipdfFxcXFxcXCopfG92ZXJsYXBTa2lwKXxcXCooPzooPyFvdmVybGFwU2tpcCkoPzpbXipdfFxcXFxcXCopfG92ZXJsYXBTa2lwKSo/XFwqKSs/XFwqJHxeXyg/IVtfXFxzXSkoPzooPzooPyFvdmVybGFwU2tpcCkoPzpbXl9dfFxcXFxfKXxvdmVybGFwU2tpcCl8Xyg/Oig/IW92ZXJsYXBTa2lwKSg/OlteX118XFxcXF8pfG92ZXJsYXBTa2lwKSo/XykrP18kLyxcbiAgICAgIGVuZEFzdDogL1tecHVuY3R1YXRpb25cXHNdXFwqKD8hXFwqKXxbcHVuY3R1YXRpb25dXFwqKD8hXFwqKSg/Oig/PVtwdW5jdHVhdGlvbl9cXHNdfCQpKS8sXG4gICAgICAvLyBsYXN0IGNoYXIgY2FuJ3QgYmUgcHVuY3QsIG9yIGZpbmFsICogbXVzdCBhbHNvIGJlIGZvbGxvd2VkIGJ5IHB1bmN0IChvciBlbmRsaW5lKVxuICAgICAgZW5kVW5kOiAvW15cXHNdXyg/IV8pKD86KD89W3B1bmN0dWF0aW9uKlxcc10pfCQpLyAvLyBsYXN0IGNoYXIgY2FuJ3QgYmUgYSBzcGFjZSwgYW5kIGZpbmFsIF8gbXVzdCBwcmVjZWVkIHB1bmN0IG9yIFxccyAob3IgZW5kbGluZSlcblxuICAgIH0sXG4gICAgY29kZTogL14oYCspKFteYF18W15gXVtcXHNcXFNdKj9bXmBdKVxcMSg/IWApLyxcbiAgICBicjogL14oIHsyLH18XFxcXClcXG4oPyFcXHMqJCkvLFxuICAgIGRlbDogbm9vcFRlc3QkMSxcbiAgICB0ZXh0OiAvXihgK3xbXmBdKSg/Oig/PSB7Mix9XFxuKXxbXFxzXFxTXSo/KD86KD89W1xcXFw8IVxcW2AqXXxcXGJffCQpfFteIF0oPz0gezIsfVxcbikpKS8sXG4gICAgcHVuY3R1YXRpb246IC9eKFtcXHMqcHVuY3R1YXRpb25dKS9cbiAgfTsgLy8gbGlzdCBvZiBwdW5jdHVhdGlvbiBtYXJrcyBmcm9tIGNvbW1vbiBtYXJrIHNwZWNcbiAgLy8gd2l0aG91dCAqIGFuZCBfIHRvIHdvcmthcm91bmQgY2FzZXMgd2l0aCBkb3VibGUgZW1waGFzaXNcblxuICBpbmxpbmUuX3B1bmN0dWF0aW9uID0gJyFcIiMkJSZcXCcoKStcXFxcLS4sLzo7PD0+P0BcXFxcW1xcXFxdYF57fH1+JztcbiAgaW5saW5lLnB1bmN0dWF0aW9uID0gZWRpdCQxKGlubGluZS5wdW5jdHVhdGlvbikucmVwbGFjZSgvcHVuY3R1YXRpb24vZywgaW5saW5lLl9wdW5jdHVhdGlvbikuZ2V0UmVnZXgoKTsgLy8gc2VxdWVuY2VzIGVtIHNob3VsZCBza2lwIG92ZXIgW3RpdGxlXShsaW5rKSwgYGNvZGVgLCA8aHRtbD5cblxuICBpbmxpbmUuX2Jsb2NrU2tpcCA9ICdcXFxcW1teXFxcXF1dKj9cXFxcXVxcXFwoW15cXFxcKV0qP1xcXFwpfGBbXmBdKj9gfDxbXj5dKj8+JztcbiAgaW5saW5lLl9vdmVybGFwU2tpcCA9ICdfX1teX10qP19ffFxcXFwqXFxcXCpcXFxcW15cXFxcKlxcXFxdKj9cXFxcKlxcXFwqJztcbiAgaW5saW5lLl9jb21tZW50ID0gZWRpdCQxKGJsb2NrLl9jb21tZW50KS5yZXBsYWNlKCcoPzotLT58JCknLCAnLS0+JykuZ2V0UmVnZXgoKTtcbiAgaW5saW5lLmVtLnN0YXJ0ID0gZWRpdCQxKGlubGluZS5lbS5zdGFydCkucmVwbGFjZSgvcHVuY3R1YXRpb24vZywgaW5saW5lLl9wdW5jdHVhdGlvbikuZ2V0UmVnZXgoKTtcbiAgaW5saW5lLmVtLm1pZGRsZSA9IGVkaXQkMShpbmxpbmUuZW0ubWlkZGxlKS5yZXBsYWNlKC9wdW5jdHVhdGlvbi9nLCBpbmxpbmUuX3B1bmN0dWF0aW9uKS5yZXBsYWNlKC9vdmVybGFwU2tpcC9nLCBpbmxpbmUuX292ZXJsYXBTa2lwKS5nZXRSZWdleCgpO1xuICBpbmxpbmUuZW0uZW5kQXN0ID0gZWRpdCQxKGlubGluZS5lbS5lbmRBc3QsICdnJykucmVwbGFjZSgvcHVuY3R1YXRpb24vZywgaW5saW5lLl9wdW5jdHVhdGlvbikuZ2V0UmVnZXgoKTtcbiAgaW5saW5lLmVtLmVuZFVuZCA9IGVkaXQkMShpbmxpbmUuZW0uZW5kVW5kLCAnZycpLnJlcGxhY2UoL3B1bmN0dWF0aW9uL2csIGlubGluZS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG4gIGlubGluZS5zdHJvbmcuc3RhcnQgPSBlZGl0JDEoaW5saW5lLnN0cm9uZy5zdGFydCkucmVwbGFjZSgvcHVuY3R1YXRpb24vZywgaW5saW5lLl9wdW5jdHVhdGlvbikuZ2V0UmVnZXgoKTtcbiAgaW5saW5lLnN0cm9uZy5taWRkbGUgPSBlZGl0JDEoaW5saW5lLnN0cm9uZy5taWRkbGUpLnJlcGxhY2UoL3B1bmN0dWF0aW9uL2csIGlubGluZS5fcHVuY3R1YXRpb24pLnJlcGxhY2UoL292ZXJsYXBTa2lwL2csIGlubGluZS5fb3ZlcmxhcFNraXApLmdldFJlZ2V4KCk7XG4gIGlubGluZS5zdHJvbmcuZW5kQXN0ID0gZWRpdCQxKGlubGluZS5zdHJvbmcuZW5kQXN0LCAnZycpLnJlcGxhY2UoL3B1bmN0dWF0aW9uL2csIGlubGluZS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG4gIGlubGluZS5zdHJvbmcuZW5kVW5kID0gZWRpdCQxKGlubGluZS5zdHJvbmcuZW5kVW5kLCAnZycpLnJlcGxhY2UoL3B1bmN0dWF0aW9uL2csIGlubGluZS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG4gIGlubGluZS5ibG9ja1NraXAgPSBlZGl0JDEoaW5saW5lLl9ibG9ja1NraXAsICdnJykuZ2V0UmVnZXgoKTtcbiAgaW5saW5lLm92ZXJsYXBTa2lwID0gZWRpdCQxKGlubGluZS5fb3ZlcmxhcFNraXAsICdnJykuZ2V0UmVnZXgoKTtcbiAgaW5saW5lLl9lc2NhcGVzID0gL1xcXFwoWyFcIiMkJSYnKCkqKyxcXC0uLzo7PD0+P0BcXFtcXF1cXFxcXl9ge3x9fl0pL2c7XG4gIGlubGluZS5fc2NoZW1lID0gL1thLXpBLVpdW2EtekEtWjAtOSsuLV17MSwzMX0vO1xuICBpbmxpbmUuX2VtYWlsID0gL1thLXpBLVowLTkuISMkJSYnKisvPT9eX2B7fH1+LV0rKEApW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSsoPyFbLV9dKS87XG4gIGlubGluZS5hdXRvbGluayA9IGVkaXQkMShpbmxpbmUuYXV0b2xpbmspLnJlcGxhY2UoJ3NjaGVtZScsIGlubGluZS5fc2NoZW1lKS5yZXBsYWNlKCdlbWFpbCcsIGlubGluZS5fZW1haWwpLmdldFJlZ2V4KCk7XG4gIGlubGluZS5fYXR0cmlidXRlID0gL1xccytbYS16QS1aOl9dW1xcdy46LV0qKD86XFxzKj1cXHMqXCJbXlwiXSpcInxcXHMqPVxccyonW14nXSonfFxccyo9XFxzKlteXFxzXCInPTw+YF0rKT8vO1xuICBpbmxpbmUudGFnID0gZWRpdCQxKGlubGluZS50YWcpLnJlcGxhY2UoJ2NvbW1lbnQnLCBpbmxpbmUuX2NvbW1lbnQpLnJlcGxhY2UoJ2F0dHJpYnV0ZScsIGlubGluZS5fYXR0cmlidXRlKS5nZXRSZWdleCgpO1xuICBpbmxpbmUuX2xhYmVsID0gLyg/OlxcWyg/OlxcXFwufFteXFxbXFxdXFxcXF0pKlxcXXxcXFxcLnxgW15gXSpgfFteXFxbXFxdXFxcXGBdKSo/LztcbiAgaW5saW5lLl9ocmVmID0gLzwoPzpcXFxcWzw+XT98W15cXHM8PlxcXFxdKSo+fFteXFxzXFx4MDAtXFx4MWZdKi87XG4gIGlubGluZS5fdGl0bGUgPSAvXCIoPzpcXFxcXCI/fFteXCJcXFxcXSkqXCJ8Jyg/OlxcXFwnP3xbXidcXFxcXSkqJ3xcXCgoPzpcXFxcXFwpP3xbXilcXFxcXSkqXFwpLztcbiAgaW5saW5lLmxpbmsgPSBlZGl0JDEoaW5saW5lLmxpbmspLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lLl9sYWJlbCkucmVwbGFjZSgnaHJlZicsIGlubGluZS5faHJlZikucmVwbGFjZSgndGl0bGUnLCBpbmxpbmUuX3RpdGxlKS5nZXRSZWdleCgpO1xuICBpbmxpbmUucmVmbGluayA9IGVkaXQkMShpbmxpbmUucmVmbGluaykucmVwbGFjZSgnbGFiZWwnLCBpbmxpbmUuX2xhYmVsKS5nZXRSZWdleCgpO1xuICBpbmxpbmUucmVmbGlua1NlYXJjaCA9IGVkaXQkMShpbmxpbmUucmVmbGlua1NlYXJjaCwgJ2cnKS5yZXBsYWNlKCdyZWZsaW5rJywgaW5saW5lLnJlZmxpbmspLnJlcGxhY2UoJ25vbGluaycsIGlubGluZS5ub2xpbmspLmdldFJlZ2V4KCk7XG4gIC8qKlxuICAgKiBOb3JtYWwgSW5saW5lIEdyYW1tYXJcbiAgICovXG5cbiAgaW5saW5lLm5vcm1hbCA9IG1lcmdlJDEoe30sIGlubGluZSk7XG4gIC8qKlxuICAgKiBQZWRhbnRpYyBJbmxpbmUgR3JhbW1hclxuICAgKi9cblxuICBpbmxpbmUucGVkYW50aWMgPSBtZXJnZSQxKHt9LCBpbmxpbmUubm9ybWFsLCB7XG4gICAgc3Ryb25nOiB7XG4gICAgICBzdGFydDogL15fX3xcXCpcXCovLFxuICAgICAgbWlkZGxlOiAvXl9fKD89XFxTKShbXFxzXFxTXSo/XFxTKV9fKD8hXyl8XlxcKlxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCpcXCooPyFcXCopLyxcbiAgICAgIGVuZEFzdDogL1xcKlxcKig/IVxcKikvZyxcbiAgICAgIGVuZFVuZDogL19fKD8hXykvZ1xuICAgIH0sXG4gICAgZW06IHtcbiAgICAgIHN0YXJ0OiAvXl98XFwqLyxcbiAgICAgIG1pZGRsZTogL14oKVxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCooPyFcXCopfF5fKD89XFxTKShbXFxzXFxTXSo/XFxTKV8oPyFfKS8sXG4gICAgICBlbmRBc3Q6IC9cXCooPyFcXCopL2csXG4gICAgICBlbmRVbmQ6IC9fKD8hXykvZ1xuICAgIH0sXG4gICAgbGluazogZWRpdCQxKC9eIT9cXFsobGFiZWwpXFxdXFwoKC4qPylcXCkvKS5yZXBsYWNlKCdsYWJlbCcsIGlubGluZS5fbGFiZWwpLmdldFJlZ2V4KCksXG4gICAgcmVmbGluazogZWRpdCQxKC9eIT9cXFsobGFiZWwpXFxdXFxzKlxcWyhbXlxcXV0qKVxcXS8pLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lLl9sYWJlbCkuZ2V0UmVnZXgoKVxuICB9KTtcbiAgLyoqXG4gICAqIEdGTSBJbmxpbmUgR3JhbW1hclxuICAgKi9cblxuICBpbmxpbmUuZ2ZtID0gbWVyZ2UkMSh7fSwgaW5saW5lLm5vcm1hbCwge1xuICAgIGVzY2FwZTogZWRpdCQxKGlubGluZS5lc2NhcGUpLnJlcGxhY2UoJ10pJywgJ358XSknKS5nZXRSZWdleCgpLFxuICAgIF9leHRlbmRlZF9lbWFpbDogL1tBLVphLXowLTkuXystXSsoQClbYS16QS1aMC05LV9dKyg/OlxcLlthLXpBLVowLTktX10qW2EtekEtWjAtOV0pKyg/IVstX10pLyxcbiAgICB1cmw6IC9eKCg/OmZ0cHxodHRwcz8pOlxcL1xcL3x3d3dcXC4pKD86W2EtekEtWjAtOVxcLV0rXFwuPykrW15cXHM8XSp8XmVtYWlsLyxcbiAgICBfYmFja3BlZGFsOiAvKD86W14/IS4sOjsqX34oKSZdK3xcXChbXildKlxcKXwmKD8hW2EtekEtWjAtOV0rOyQpfFs/IS4sOjsqX34pXSsoPyEkKSkrLyxcbiAgICBkZWw6IC9efisoPz1cXFMpKFtcXHNcXFNdKj9cXFMpfisvLFxuICAgIHRleHQ6IC9eKGArfFteYF0pKD86KD89IHsyLH1cXG4pfFtcXHNcXFNdKj8oPzooPz1bXFxcXDwhXFxbYCp+XXxcXGJffGh0dHBzPzpcXC9cXC98ZnRwOlxcL1xcL3x3d3dcXC58JCl8W14gXSg/PSB7Mix9XFxuKXxbXmEtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXSg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCkpfCg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCkpL1xuICB9KTtcbiAgaW5saW5lLmdmbS51cmwgPSBlZGl0JDEoaW5saW5lLmdmbS51cmwsICdpJykucmVwbGFjZSgnZW1haWwnLCBpbmxpbmUuZ2ZtLl9leHRlbmRlZF9lbWFpbCkuZ2V0UmVnZXgoKTtcbiAgLyoqXG4gICAqIEdGTSArIExpbmUgQnJlYWtzIElubGluZSBHcmFtbWFyXG4gICAqL1xuXG4gIGlubGluZS5icmVha3MgPSBtZXJnZSQxKHt9LCBpbmxpbmUuZ2ZtLCB7XG4gICAgYnI6IGVkaXQkMShpbmxpbmUuYnIpLnJlcGxhY2UoJ3syLH0nLCAnKicpLmdldFJlZ2V4KCksXG4gICAgdGV4dDogZWRpdCQxKGlubGluZS5nZm0udGV4dCkucmVwbGFjZSgnXFxcXGJfJywgJ1xcXFxiX3wgezIsfVxcXFxuJykucmVwbGFjZSgvXFx7MixcXH0vZywgJyonKS5nZXRSZWdleCgpXG4gIH0pO1xuICB2YXIgcnVsZXMgPSB7XG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGlubGluZTogaW5saW5lXG4gIH07XG5cbiAgdmFyIGRlZmF1bHRzJDIgPSBkZWZhdWx0cy5kZWZhdWx0cztcbiAgdmFyIGJsb2NrJDEgPSBydWxlcy5ibG9jayxcbiAgICAgIGlubGluZSQxID0gcnVsZXMuaW5saW5lO1xuICAvKipcbiAgICogc21hcnR5cGFudHMgdGV4dCByZXBsYWNlbWVudFxuICAgKi9cblxuICBmdW5jdGlvbiBzbWFydHlwYW50cyh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQgLy8gZW0tZGFzaGVzXG4gICAgLnJlcGxhY2UoLy0tLS9nLCBcIlxcdTIwMTRcIikgLy8gZW4tZGFzaGVzXG4gICAgLnJlcGxhY2UoLy0tL2csIFwiXFx1MjAxM1wiKSAvLyBvcGVuaW5nIHNpbmdsZXNcbiAgICAucmVwbGFjZSgvKF58Wy1cXHUyMDE0LyhcXFt7XCJcXHNdKScvZywgXCIkMVxcdTIwMThcIikgLy8gY2xvc2luZyBzaW5nbGVzICYgYXBvc3Ryb3BoZXNcbiAgICAucmVwbGFjZSgvJy9nLCBcIlxcdTIwMTlcIikgLy8gb3BlbmluZyBkb3VibGVzXG4gICAgLnJlcGxhY2UoLyhefFstXFx1MjAxNC8oXFxbe1xcdTIwMThcXHNdKVwiL2csIFwiJDFcXHUyMDFDXCIpIC8vIGNsb3NpbmcgZG91Ymxlc1xuICAgIC5yZXBsYWNlKC9cIi9nLCBcIlxcdTIwMURcIikgLy8gZWxsaXBzZXNcbiAgICAucmVwbGFjZSgvXFwuezN9L2csIFwiXFx1MjAyNlwiKTtcbiAgfVxuICAvKipcbiAgICogbWFuZ2xlIGVtYWlsIGFkZHJlc3Nlc1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG1hbmdsZSh0ZXh0KSB7XG4gICAgdmFyIG91dCA9ICcnLFxuICAgICAgICBpLFxuICAgICAgICBjaDtcbiAgICB2YXIgbCA9IHRleHQubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgY2ggPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAgICAgIGNoID0gJ3gnICsgY2gudG9TdHJpbmcoMTYpO1xuICAgICAgfVxuXG4gICAgICBvdXQgKz0gJyYjJyArIGNoICsgJzsnO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgLyoqXG4gICAqIEJsb2NrIExleGVyXG4gICAqL1xuXG5cbiAgdmFyIExleGVyXzEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExleGVyKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgICB0aGlzLnRva2Vucy5saW5rcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzJDI7XG4gICAgICB0aGlzLm9wdGlvbnMudG9rZW5pemVyID0gdGhpcy5vcHRpb25zLnRva2VuaXplciB8fCBuZXcgVG9rZW5pemVyXzEoKTtcbiAgICAgIHRoaXMudG9rZW5pemVyID0gdGhpcy5vcHRpb25zLnRva2VuaXplcjtcbiAgICAgIHRoaXMudG9rZW5pemVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgcnVsZXMgPSB7XG4gICAgICAgIGJsb2NrOiBibG9jayQxLm5vcm1hbCxcbiAgICAgICAgaW5saW5lOiBpbmxpbmUkMS5ub3JtYWxcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgcnVsZXMuYmxvY2sgPSBibG9jayQxLnBlZGFudGljO1xuICAgICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUkMS5wZWRhbnRpYztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgICAgICBydWxlcy5ibG9jayA9IGJsb2NrJDEuZ2ZtO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYnJlYWtzKSB7XG4gICAgICAgICAgcnVsZXMuaW5saW5lID0gaW5saW5lJDEuYnJlYWtzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZSQxLmdmbTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnRva2VuaXplci5ydWxlcyA9IHJ1bGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBvc2UgUnVsZXNcbiAgICAgKi9cblxuXG4gICAgLyoqXG4gICAgICogU3RhdGljIExleCBNZXRob2RcbiAgICAgKi9cbiAgICBMZXhlci5sZXggPSBmdW5jdGlvbiBsZXgoc3JjLCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGV4ZXIgPSBuZXcgTGV4ZXIob3B0aW9ucyk7XG4gICAgICByZXR1cm4gbGV4ZXIubGV4KHNyYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBMZXggSW5saW5lIE1ldGhvZFxuICAgICAqL1xuICAgIDtcblxuICAgIExleGVyLmxleElubGluZSA9IGZ1bmN0aW9uIGxleElubGluZShzcmMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZXhlciA9IG5ldyBMZXhlcihvcHRpb25zKTtcbiAgICAgIHJldHVybiBsZXhlci5pbmxpbmVUb2tlbnMoc3JjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcHJvY2Vzc2luZ1xuICAgICAqL1xuICAgIDtcblxuICAgIHZhciBfcHJvdG8gPSBMZXhlci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8ubGV4ID0gZnVuY3Rpb24gbGV4KHNyYykge1xuICAgICAgc3JjID0gc3JjLnJlcGxhY2UoL1xcclxcbnxcXHIvZywgJ1xcbicpLnJlcGxhY2UoL1xcdC9nLCAnICAgICcpO1xuICAgICAgdGhpcy5ibG9ja1Rva2VucyhzcmMsIHRoaXMudG9rZW5zLCB0cnVlKTtcbiAgICAgIHRoaXMuaW5saW5lKHRoaXMudG9rZW5zKTtcbiAgICAgIHJldHVybiB0aGlzLnRva2VucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGV4aW5nXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmJsb2NrVG9rZW5zID0gZnVuY3Rpb24gYmxvY2tUb2tlbnMoc3JjLCB0b2tlbnMsIHRvcCkge1xuICAgICAgaWYgKHRva2VucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRva2VucyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9wID09PSB2b2lkIDApIHtcbiAgICAgICAgdG9wID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgc3JjID0gc3JjLnJlcGxhY2UoL14gKyQvZ20sICcnKTtcbiAgICAgIHZhciB0b2tlbiwgaSwgbCwgbGFzdFRva2VuO1xuXG4gICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgIC8vIG5ld2xpbmVcbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuc3BhY2Uoc3JjKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG5cbiAgICAgICAgICBpZiAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGNvZGVcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmNvZGUoc3JjLCB0b2tlbnMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcblxuICAgICAgICAgIGlmICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGZlbmNlc1xuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZmVuY2VzKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBoZWFkaW5nXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5oZWFkaW5nKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyB0YWJsZSBubyBsZWFkaW5nIHBpcGUgKGdmbSlcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLm5wdGFibGUoc3JjKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGhyXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5ocihzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gYmxvY2txdW90ZVxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuYmxvY2txdW90ZShzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbi50b2tlbnMgPSB0aGlzLmJsb2NrVG9rZW5zKHRva2VuLnRleHQsIFtdLCB0b3ApO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBsaXN0XG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5saXN0KHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIGwgPSB0b2tlbi5pdGVtcy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbi5pdGVtc1tpXS50b2tlbnMgPSB0aGlzLmJsb2NrVG9rZW5zKHRva2VuLml0ZW1zW2ldLnRleHQsIFtdLCBmYWxzZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGh0bWxcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmh0bWwoc3JjKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGRlZlxuXG5cbiAgICAgICAgaWYgKHRvcCAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5kZWYoc3JjKSkpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLnRva2Vucy5saW5rc1t0b2tlbi50YWddKSB7XG4gICAgICAgICAgICB0aGlzLnRva2Vucy5saW5rc1t0b2tlbi50YWddID0ge1xuICAgICAgICAgICAgICBocmVmOiB0b2tlbi5ocmVmLFxuICAgICAgICAgICAgICB0aXRsZTogdG9rZW4udGl0bGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gdGFibGUgKGdmbSlcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRhYmxlKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBsaGVhZGluZ1xuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGhlYWRpbmcoc3JjKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHRvcC1sZXZlbCBwYXJhZ3JhcGhcblxuXG4gICAgICAgIGlmICh0b3AgJiYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIucGFyYWdyYXBoKHNyYykpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gdGV4dFxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudGV4dChzcmMsIHRva2VucykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuXG4gICAgICAgICAgaWYgKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgdmFyIGVyck1zZyA9ICdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKTtcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfTtcblxuICAgIF9wcm90by5pbmxpbmUgPSBmdW5jdGlvbiBpbmxpbmUodG9rZW5zKSB7XG4gICAgICB2YXIgaSwgaiwgaywgbDIsIHJvdywgdG9rZW47XG4gICAgICB2YXIgbCA9IHRva2Vucy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgY2FzZSAncGFyYWdyYXBoJzpcbiAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICBjYXNlICdoZWFkaW5nJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdG9rZW4udG9rZW5zID0gW107XG4gICAgICAgICAgICAgIHRoaXMuaW5saW5lVG9rZW5zKHRva2VuLnRleHQsIHRva2VuLnRva2Vucyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0b2tlbi50b2tlbnMgPSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyOiBbXSxcbiAgICAgICAgICAgICAgICBjZWxsczogW11cbiAgICAgICAgICAgICAgfTsgLy8gaGVhZGVyXG5cbiAgICAgICAgICAgICAgbDIgPSB0b2tlbi5oZWFkZXIubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4udG9rZW5zLmhlYWRlcltqXSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lVG9rZW5zKHRva2VuLmhlYWRlcltqXSwgdG9rZW4udG9rZW5zLmhlYWRlcltqXSk7XG4gICAgICAgICAgICAgIH0gLy8gY2VsbHNcblxuXG4gICAgICAgICAgICAgIGwyID0gdG9rZW4uY2VsbHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgcm93ID0gdG9rZW4uY2VsbHNbal07XG4gICAgICAgICAgICAgICAgdG9rZW4udG9rZW5zLmNlbGxzW2pdID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgcm93Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICB0b2tlbi50b2tlbnMuY2VsbHNbal1ba10gPSBbXTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lVG9rZW5zKHJvd1trXSwgdG9rZW4udG9rZW5zLmNlbGxzW2pdW2tdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aGlzLmlubGluZSh0b2tlbi50b2tlbnMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBsMiA9IHRva2VuLml0ZW1zLmxlbmd0aDtcblxuICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDI7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lKHRva2VuLml0ZW1zW2pdLnRva2Vucyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZXhpbmcvQ29tcGlsaW5nXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmlubGluZVRva2VucyA9IGZ1bmN0aW9uIGlubGluZVRva2VucyhzcmMsIHRva2VucywgaW5MaW5rLCBpblJhd0Jsb2NrLCBwcmV2Q2hhcikge1xuICAgICAgaWYgKHRva2VucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRva2VucyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5MaW5rID09PSB2b2lkIDApIHtcbiAgICAgICAgaW5MaW5rID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChpblJhd0Jsb2NrID09PSB2b2lkIDApIHtcbiAgICAgICAgaW5SYXdCbG9jayA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJldkNoYXIgPT09IHZvaWQgMCkge1xuICAgICAgICBwcmV2Q2hhciA9ICcnO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG9rZW47IC8vIFN0cmluZyB3aXRoIGxpbmtzIG1hc2tlZCB0byBhdm9pZCBpbnRlcmZlcmVuY2Ugd2l0aCBlbSBhbmQgc3Ryb25nXG5cbiAgICAgIHZhciBtYXNrZWRTcmMgPSBzcmM7XG4gICAgICB2YXIgbWF0Y2g7IC8vIE1hc2sgb3V0IHJlZmxpbmtzXG5cbiAgICAgIGlmICh0aGlzLnRva2Vucy5saW5rcykge1xuICAgICAgICB2YXIgbGlua3MgPSBPYmplY3Qua2V5cyh0aGlzLnRva2Vucy5saW5rcyk7XG5cbiAgICAgICAgaWYgKGxpbmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gdGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLnJlZmxpbmtTZWFyY2guZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobGlua3MuaW5jbHVkZXMobWF0Y2hbMF0uc2xpY2UobWF0Y2hbMF0ubGFzdEluZGV4T2YoJ1snKSArIDEsIC0xKSkpIHtcbiAgICAgICAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICdbJyArICdhJy5yZXBlYXQobWF0Y2hbMF0ubGVuZ3RoIC0gMikgKyAnXScgKyBtYXNrZWRTcmMuc2xpY2UodGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLnJlZmxpbmtTZWFyY2gubGFzdEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gTWFzayBvdXQgb3RoZXIgYmxvY2tzXG5cblxuICAgICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5ibG9ja1NraXAuZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnWycgKyAnYScucmVwZWF0KG1hdGNoWzBdLmxlbmd0aCAtIDIpICsgJ10nICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5ibG9ja1NraXAubGFzdEluZGV4KTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHNyYykge1xuICAgICAgICAvLyBlc2NhcGVcbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZXNjYXBlKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyB0YWdcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRhZyhzcmMsIGluTGluaywgaW5SYXdCbG9jaykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIGluTGluayA9IHRva2VuLmluTGluaztcbiAgICAgICAgICBpblJhd0Jsb2NrID0gdG9rZW4uaW5SYXdCbG9jaztcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gbGlua1xuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGluayhzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcblxuICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnbGluaycpIHtcbiAgICAgICAgICAgIHRva2VuLnRva2VucyA9IHRoaXMuaW5saW5lVG9rZW5zKHRva2VuLnRleHQsIFtdLCB0cnVlLCBpblJhd0Jsb2NrKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gcmVmbGluaywgbm9saW5rXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5yZWZsaW5rKHNyYywgdGhpcy50b2tlbnMubGlua3MpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcblxuICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnbGluaycpIHtcbiAgICAgICAgICAgIHRva2VuLnRva2VucyA9IHRoaXMuaW5saW5lVG9rZW5zKHRva2VuLnRleHQsIFtdLCB0cnVlLCBpblJhd0Jsb2NrKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gc3Ryb25nXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5zdHJvbmcoc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW4udG9rZW5zID0gdGhpcy5pbmxpbmVUb2tlbnModG9rZW4udGV4dCwgW10sIGluTGluaywgaW5SYXdCbG9jayk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGVtXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5lbShzcmMsIG1hc2tlZFNyYywgcHJldkNoYXIpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbi50b2tlbnMgPSB0aGlzLmlubGluZVRva2Vucyh0b2tlbi50ZXh0LCBbXSwgaW5MaW5rLCBpblJhd0Jsb2NrKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gY29kZVxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuY29kZXNwYW4oc3JjKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGJyXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5icihzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gZGVsIChnZm0pXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5kZWwoc3JjKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW4udG9rZW5zID0gdGhpcy5pbmxpbmVUb2tlbnModG9rZW4udGV4dCwgW10sIGluTGluaywgaW5SYXdCbG9jayk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGF1dG9saW5rXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5hdXRvbGluayhzcmMsIG1hbmdsZSkpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyB1cmwgKGdmbSlcblxuXG4gICAgICAgIGlmICghaW5MaW5rICYmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnVybChzcmMsIG1hbmdsZSkpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gdGV4dFxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaW5saW5lVGV4dChzcmMsIGluUmF3QmxvY2ssIHNtYXJ0eXBhbnRzKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgcHJldkNoYXIgPSB0b2tlbi5yYXcuc2xpY2UoLTEpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICB2YXIgZXJyTXNnID0gJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApO1xuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKExleGVyLCBudWxsLCBbe1xuICAgICAga2V5OiBcInJ1bGVzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBibG9jazogYmxvY2skMSxcbiAgICAgICAgICBpbmxpbmU6IGlubGluZSQxXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIExleGVyO1xuICB9KCk7XG5cbiAgdmFyIGRlZmF1bHRzJDMgPSBkZWZhdWx0cy5kZWZhdWx0cztcbiAgdmFyIGNsZWFuVXJsJDEgPSBoZWxwZXJzLmNsZWFuVXJsLFxuICAgICAgZXNjYXBlJDEgPSBoZWxwZXJzLmVzY2FwZTtcbiAgLyoqXG4gICAqIFJlbmRlcmVyXG4gICAqL1xuXG4gIHZhciBSZW5kZXJlcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzJDM7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IFJlbmRlcmVyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5jb2RlID0gZnVuY3Rpb24gY29kZShfY29kZSwgaW5mb3N0cmluZywgZXNjYXBlZCkge1xuICAgICAgdmFyIGxhbmcgPSAoaW5mb3N0cmluZyB8fCAnJykubWF0Y2goL1xcUyovKVswXTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICAgICAgdmFyIG91dCA9IHRoaXMub3B0aW9ucy5oaWdobGlnaHQoX2NvZGUsIGxhbmcpO1xuXG4gICAgICAgIGlmIChvdXQgIT0gbnVsbCAmJiBvdXQgIT09IF9jb2RlKSB7XG4gICAgICAgICAgZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgX2NvZGUgPSBvdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFsYW5nKSB7XG4gICAgICAgIHJldHVybiAnPHByZT48Y29kZT4nICsgKGVzY2FwZWQgPyBfY29kZSA6IGVzY2FwZSQxKF9jb2RlLCB0cnVlKSkgKyAnPC9jb2RlPjwvcHJlPlxcbic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnPHByZT48Y29kZSBjbGFzcz1cIicgKyB0aGlzLm9wdGlvbnMubGFuZ1ByZWZpeCArIGVzY2FwZSQxKGxhbmcsIHRydWUpICsgJ1wiPicgKyAoZXNjYXBlZCA/IF9jb2RlIDogZXNjYXBlJDEoX2NvZGUsIHRydWUpKSArICc8L2NvZGU+PC9wcmU+XFxuJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmJsb2NrcXVvdGUgPSBmdW5jdGlvbiBibG9ja3F1b3RlKHF1b3RlKSB7XG4gICAgICByZXR1cm4gJzxibG9ja3F1b3RlPlxcbicgKyBxdW90ZSArICc8L2Jsb2NrcXVvdGU+XFxuJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmh0bWwgPSBmdW5jdGlvbiBodG1sKF9odG1sKSB7XG4gICAgICByZXR1cm4gX2h0bWw7XG4gICAgfTtcblxuICAgIF9wcm90by5oZWFkaW5nID0gZnVuY3Rpb24gaGVhZGluZyh0ZXh0LCBsZXZlbCwgcmF3LCBzbHVnZ2VyKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRlcklkcykge1xuICAgICAgICByZXR1cm4gJzxoJyArIGxldmVsICsgJyBpZD1cIicgKyB0aGlzLm9wdGlvbnMuaGVhZGVyUHJlZml4ICsgc2x1Z2dlci5zbHVnKHJhdykgKyAnXCI+JyArIHRleHQgKyAnPC9oJyArIGxldmVsICsgJz5cXG4nO1xuICAgICAgfSAvLyBpZ25vcmUgSURzXG5cblxuICAgICAgcmV0dXJuICc8aCcgKyBsZXZlbCArICc+JyArIHRleHQgKyAnPC9oJyArIGxldmVsICsgJz5cXG4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8uaHIgPSBmdW5jdGlvbiBocigpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMueGh0bWwgPyAnPGhyLz5cXG4nIDogJzxocj5cXG4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8ubGlzdCA9IGZ1bmN0aW9uIGxpc3QoYm9keSwgb3JkZXJlZCwgc3RhcnQpIHtcbiAgICAgIHZhciB0eXBlID0gb3JkZXJlZCA/ICdvbCcgOiAndWwnLFxuICAgICAgICAgIHN0YXJ0YXR0ID0gb3JkZXJlZCAmJiBzdGFydCAhPT0gMSA/ICcgc3RhcnQ9XCInICsgc3RhcnQgKyAnXCInIDogJyc7XG4gICAgICByZXR1cm4gJzwnICsgdHlwZSArIHN0YXJ0YXR0ICsgJz5cXG4nICsgYm9keSArICc8LycgKyB0eXBlICsgJz5cXG4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8ubGlzdGl0ZW0gPSBmdW5jdGlvbiBsaXN0aXRlbSh0ZXh0KSB7XG4gICAgICByZXR1cm4gJzxsaT4nICsgdGV4dCArICc8L2xpPlxcbic7XG4gICAgfTtcblxuICAgIF9wcm90by5jaGVja2JveCA9IGZ1bmN0aW9uIGNoZWNrYm94KGNoZWNrZWQpIHtcbiAgICAgIHJldHVybiAnPGlucHV0ICcgKyAoY2hlY2tlZCA/ICdjaGVja2VkPVwiXCIgJyA6ICcnKSArICdkaXNhYmxlZD1cIlwiIHR5cGU9XCJjaGVja2JveFwiJyArICh0aGlzLm9wdGlvbnMueGh0bWwgPyAnIC8nIDogJycpICsgJz4gJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLnBhcmFncmFwaCA9IGZ1bmN0aW9uIHBhcmFncmFwaCh0ZXh0KSB7XG4gICAgICByZXR1cm4gJzxwPicgKyB0ZXh0ICsgJzwvcD5cXG4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8udGFibGUgPSBmdW5jdGlvbiB0YWJsZShoZWFkZXIsIGJvZHkpIHtcbiAgICAgIGlmIChib2R5KSBib2R5ID0gJzx0Ym9keT4nICsgYm9keSArICc8L3Rib2R5Pic7XG4gICAgICByZXR1cm4gJzx0YWJsZT5cXG4nICsgJzx0aGVhZD5cXG4nICsgaGVhZGVyICsgJzwvdGhlYWQ+XFxuJyArIGJvZHkgKyAnPC90YWJsZT5cXG4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8udGFibGVyb3cgPSBmdW5jdGlvbiB0YWJsZXJvdyhjb250ZW50KSB7XG4gICAgICByZXR1cm4gJzx0cj5cXG4nICsgY29udGVudCArICc8L3RyPlxcbic7XG4gICAgfTtcblxuICAgIF9wcm90by50YWJsZWNlbGwgPSBmdW5jdGlvbiB0YWJsZWNlbGwoY29udGVudCwgZmxhZ3MpIHtcbiAgICAgIHZhciB0eXBlID0gZmxhZ3MuaGVhZGVyID8gJ3RoJyA6ICd0ZCc7XG4gICAgICB2YXIgdGFnID0gZmxhZ3MuYWxpZ24gPyAnPCcgKyB0eXBlICsgJyBhbGlnbj1cIicgKyBmbGFncy5hbGlnbiArICdcIj4nIDogJzwnICsgdHlwZSArICc+JztcbiAgICAgIHJldHVybiB0YWcgKyBjb250ZW50ICsgJzwvJyArIHR5cGUgKyAnPlxcbic7XG4gICAgfSAvLyBzcGFuIGxldmVsIHJlbmRlcmVyXG4gICAgO1xuXG4gICAgX3Byb3RvLnN0cm9uZyA9IGZ1bmN0aW9uIHN0cm9uZyh0ZXh0KSB7XG4gICAgICByZXR1cm4gJzxzdHJvbmc+JyArIHRleHQgKyAnPC9zdHJvbmc+JztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmVtID0gZnVuY3Rpb24gZW0odGV4dCkge1xuICAgICAgcmV0dXJuICc8ZW0+JyArIHRleHQgKyAnPC9lbT4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8uY29kZXNwYW4gPSBmdW5jdGlvbiBjb2Rlc3Bhbih0ZXh0KSB7XG4gICAgICByZXR1cm4gJzxjb2RlPicgKyB0ZXh0ICsgJzwvY29kZT4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8uYnIgPSBmdW5jdGlvbiBicigpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMueGh0bWwgPyAnPGJyLz4nIDogJzxicj4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8uZGVsID0gZnVuY3Rpb24gZGVsKHRleHQpIHtcbiAgICAgIHJldHVybiAnPGRlbD4nICsgdGV4dCArICc8L2RlbD4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8ubGluayA9IGZ1bmN0aW9uIGxpbmsoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgIGhyZWYgPSBjbGVhblVybCQxKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSwgdGhpcy5vcHRpb25zLmJhc2VVcmwsIGhyZWYpO1xuXG4gICAgICBpZiAoaHJlZiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dCA9ICc8YSBocmVmPVwiJyArIGVzY2FwZSQxKGhyZWYpICsgJ1wiJztcblxuICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgICAgIH1cblxuICAgICAgb3V0ICs9ICc+JyArIHRleHQgKyAnPC9hPic7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH07XG5cbiAgICBfcHJvdG8uaW1hZ2UgPSBmdW5jdGlvbiBpbWFnZShocmVmLCB0aXRsZSwgdGV4dCkge1xuICAgICAgaHJlZiA9IGNsZWFuVXJsJDEodGhpcy5vcHRpb25zLnNhbml0aXplLCB0aGlzLm9wdGlvbnMuYmFzZVVybCwgaHJlZik7XG5cbiAgICAgIGlmIChocmVmID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgfVxuXG4gICAgICB2YXIgb3V0ID0gJzxpbWcgc3JjPVwiJyArIGhyZWYgKyAnXCIgYWx0PVwiJyArIHRleHQgKyAnXCInO1xuXG4gICAgICBpZiAodGl0bGUpIHtcbiAgICAgICAgb3V0ICs9ICcgdGl0bGU9XCInICsgdGl0bGUgKyAnXCInO1xuICAgICAgfVxuXG4gICAgICBvdXQgKz0gdGhpcy5vcHRpb25zLnhodG1sID8gJy8+JyA6ICc+JztcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcblxuICAgIF9wcm90by50ZXh0ID0gZnVuY3Rpb24gdGV4dChfdGV4dCkge1xuICAgICAgcmV0dXJuIF90ZXh0O1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVuZGVyZXI7XG4gIH0oKTtcblxuICAvKipcbiAgICogVGV4dFJlbmRlcmVyXG4gICAqIHJldHVybnMgb25seSB0aGUgdGV4dHVhbCBwYXJ0IG9mIHRoZSB0b2tlblxuICAgKi9cbiAgdmFyIFRleHRSZW5kZXJlcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZXh0UmVuZGVyZXIoKSB7fVxuXG4gICAgdmFyIF9wcm90byA9IFRleHRSZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgICAvLyBubyBuZWVkIGZvciBibG9jayBsZXZlbCByZW5kZXJlcnNcbiAgICBfcHJvdG8uc3Ryb25nID0gZnVuY3Rpb24gc3Ryb25nKHRleHQpIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG5cbiAgICBfcHJvdG8uZW0gPSBmdW5jdGlvbiBlbSh0ZXh0KSB7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmNvZGVzcGFuID0gZnVuY3Rpb24gY29kZXNwYW4odGV4dCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by5kZWwgPSBmdW5jdGlvbiBkZWwodGV4dCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by5odG1sID0gZnVuY3Rpb24gaHRtbCh0ZXh0KSB7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnRleHQgPSBmdW5jdGlvbiB0ZXh0KF90ZXh0KSB7XG4gICAgICByZXR1cm4gX3RleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by5saW5rID0gZnVuY3Rpb24gbGluayhocmVmLCB0aXRsZSwgdGV4dCkge1xuICAgICAgcmV0dXJuICcnICsgdGV4dDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmltYWdlID0gZnVuY3Rpb24gaW1hZ2UoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgIHJldHVybiAnJyArIHRleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by5iciA9IGZ1bmN0aW9uIGJyKCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH07XG5cbiAgICByZXR1cm4gVGV4dFJlbmRlcmVyO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIFNsdWdnZXIgZ2VuZXJhdGVzIGhlYWRlciBpZFxuICAgKi9cbiAgdmFyIFNsdWdnZXJfMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2x1Z2dlcigpIHtcbiAgICAgIHRoaXMuc2VlbiA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBTbHVnZ2VyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKSAvLyByZW1vdmUgaHRtbCB0YWdzXG4gICAgICAucmVwbGFjZSgvPFshXFwvYS16XS4qPz4vaWcsICcnKSAvLyByZW1vdmUgdW53YW50ZWQgY2hhcnNcbiAgICAgIC5yZXBsYWNlKC9bXFx1MjAwMC1cXHUyMDZGXFx1MkUwMC1cXHUyRTdGXFxcXCchXCIjJCUmKCkqKywuLzo7PD0+P0BbXFxdXmB7fH1+XS9nLCAnJykucmVwbGFjZSgvXFxzL2csICctJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBuZXh0IHNhZmUgKHVuaXF1ZSkgc2x1ZyB0byB1c2VcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uZ2V0TmV4dFNhZmVTbHVnID0gZnVuY3Rpb24gZ2V0TmV4dFNhZmVTbHVnKG9yaWdpbmFsU2x1ZywgaXNEcnlSdW4pIHtcbiAgICAgIHZhciBzbHVnID0gb3JpZ2luYWxTbHVnO1xuICAgICAgdmFyIG9jY3VyZW5jZUFjY3VtdWxhdG9yID0gMDtcblxuICAgICAgaWYgKHRoaXMuc2Vlbi5oYXNPd25Qcm9wZXJ0eShzbHVnKSkge1xuICAgICAgICBvY2N1cmVuY2VBY2N1bXVsYXRvciA9IHRoaXMuc2VlbltvcmlnaW5hbFNsdWddO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBvY2N1cmVuY2VBY2N1bXVsYXRvcisrO1xuICAgICAgICAgIHNsdWcgPSBvcmlnaW5hbFNsdWcgKyAnLScgKyBvY2N1cmVuY2VBY2N1bXVsYXRvcjtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5zZWVuLmhhc093blByb3BlcnR5KHNsdWcpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0RyeVJ1bikge1xuICAgICAgICB0aGlzLnNlZW5bb3JpZ2luYWxTbHVnXSA9IG9jY3VyZW5jZUFjY3VtdWxhdG9yO1xuICAgICAgICB0aGlzLnNlZW5bc2x1Z10gPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2x1ZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBzdHJpbmcgdG8gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuZHJ5cnVuIEdlbmVyYXRlcyB0aGUgbmV4dCB1bmlxdWUgc2x1ZyB3aXRob3V0IHVwZGF0aW5nIHRoZSBpbnRlcm5hbCBhY2N1bXVsYXRvci5cbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uc2x1ZyA9IGZ1bmN0aW9uIHNsdWcodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgc2x1ZyA9IHRoaXMuc2VyaWFsaXplKHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzLmdldE5leHRTYWZlU2x1ZyhzbHVnLCBvcHRpb25zLmRyeXJ1bik7XG4gICAgfTtcblxuICAgIHJldHVybiBTbHVnZ2VyO1xuICB9KCk7XG5cbiAgdmFyIGRlZmF1bHRzJDQgPSBkZWZhdWx0cy5kZWZhdWx0cztcbiAgdmFyIHVuZXNjYXBlJDEgPSBoZWxwZXJzLnVuZXNjYXBlO1xuICAvKipcbiAgICogUGFyc2luZyAmIENvbXBpbGluZ1xuICAgKi9cblxuICB2YXIgUGFyc2VyXzEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcnNlcihvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzJDQ7XG4gICAgICB0aGlzLm9wdGlvbnMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgbmV3IFJlbmRlcmVyXzEoKTtcbiAgICAgIHRoaXMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXI7XG4gICAgICB0aGlzLnJlbmRlcmVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICB0aGlzLnRleHRSZW5kZXJlciA9IG5ldyBUZXh0UmVuZGVyZXJfMSgpO1xuICAgICAgdGhpcy5zbHVnZ2VyID0gbmV3IFNsdWdnZXJfMSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgUGFyc2UgTWV0aG9kXG4gICAgICovXG5cblxuICAgIFBhcnNlci5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRva2Vucywgb3B0aW9ucykge1xuICAgICAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgICByZXR1cm4gcGFyc2VyLnBhcnNlKHRva2Vucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBQYXJzZSBJbmxpbmUgTWV0aG9kXG4gICAgICovXG4gICAgO1xuXG4gICAgUGFyc2VyLnBhcnNlSW5saW5lID0gZnVuY3Rpb24gcGFyc2VJbmxpbmUodG9rZW5zLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcihvcHRpb25zKTtcbiAgICAgIHJldHVybiBwYXJzZXIucGFyc2VJbmxpbmUodG9rZW5zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgTG9vcFxuICAgICAqL1xuICAgIDtcblxuICAgIHZhciBfcHJvdG8gPSBQYXJzZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UodG9rZW5zLCB0b3ApIHtcbiAgICAgIGlmICh0b3AgPT09IHZvaWQgMCkge1xuICAgICAgICB0b3AgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3V0ID0gJycsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBqLFxuICAgICAgICAgIGssXG4gICAgICAgICAgbDIsXG4gICAgICAgICAgbDMsXG4gICAgICAgICAgcm93LFxuICAgICAgICAgIGNlbGwsXG4gICAgICAgICAgaGVhZGVyLFxuICAgICAgICAgIGJvZHksXG4gICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICBsb29zZSxcbiAgICAgICAgICBpdGVtQm9keSxcbiAgICAgICAgICBpdGVtLFxuICAgICAgICAgIGNoZWNrZWQsXG4gICAgICAgICAgdGFzayxcbiAgICAgICAgICBjaGVja2JveDtcbiAgICAgIHZhciBsID0gdG9rZW5zLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnaHInOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5ocigpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2hlYWRpbmcnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5oZWFkaW5nKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zKSwgdG9rZW4uZGVwdGgsIHVuZXNjYXBlJDEodGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMsIHRoaXMudGV4dFJlbmRlcmVyKSksIHRoaXMuc2x1Z2dlcik7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnY29kZSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmNvZGUodG9rZW4udGV4dCwgdG9rZW4ubGFuZywgdG9rZW4uZXNjYXBlZCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBoZWFkZXIgPSAnJzsgLy8gaGVhZGVyXG5cbiAgICAgICAgICAgICAgY2VsbCA9ICcnO1xuICAgICAgICAgICAgICBsMiA9IHRva2VuLmhlYWRlci5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGwyOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zLmhlYWRlcltqXSksIHtcbiAgICAgICAgICAgICAgICAgIGhlYWRlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGFsaWduOiB0b2tlbi5hbGlnbltqXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaGVhZGVyICs9IHRoaXMucmVuZGVyZXIudGFibGVyb3coY2VsbCk7XG4gICAgICAgICAgICAgIGJvZHkgPSAnJztcbiAgICAgICAgICAgICAgbDIgPSB0b2tlbi5jZWxscy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGwyOyBqKyspIHtcbiAgICAgICAgICAgICAgICByb3cgPSB0b2tlbi50b2tlbnMuY2VsbHNbal07XG4gICAgICAgICAgICAgICAgY2VsbCA9ICcnO1xuICAgICAgICAgICAgICAgIGwzID0gcm93Lmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBsMzsgaysrKSB7XG4gICAgICAgICAgICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKHRoaXMucGFyc2VJbmxpbmUocm93W2tdKSwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhbGlnbjogdG9rZW4uYWxpZ25ba11cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlKGhlYWRlciwgYm9keSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnYmxvY2txdW90ZSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGJvZHkgPSB0aGlzLnBhcnNlKHRva2VuLnRva2Vucyk7XG4gICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmJsb2NrcXVvdGUoYm9keSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG9yZGVyZWQgPSB0b2tlbi5vcmRlcmVkO1xuICAgICAgICAgICAgICBzdGFydCA9IHRva2VuLnN0YXJ0O1xuICAgICAgICAgICAgICBsb29zZSA9IHRva2VuLmxvb3NlO1xuICAgICAgICAgICAgICBsMiA9IHRva2VuLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgICAgICAgYm9keSA9ICcnO1xuXG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHRva2VuLml0ZW1zW2pdO1xuICAgICAgICAgICAgICAgIGNoZWNrZWQgPSBpdGVtLmNoZWNrZWQ7XG4gICAgICAgICAgICAgICAgdGFzayA9IGl0ZW0udGFzaztcbiAgICAgICAgICAgICAgICBpdGVtQm9keSA9ICcnO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udGFzaykge1xuICAgICAgICAgICAgICAgICAgY2hlY2tib3ggPSB0aGlzLnJlbmRlcmVyLmNoZWNrYm94KGNoZWNrZWQpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAobG9vc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW5zLmxlbmd0aCA+IDAgJiYgaXRlbS50b2tlbnNbMF0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaXRlbS50b2tlbnNbMF0udGV4dCA9IGNoZWNrYm94ICsgJyAnICsgaXRlbS50b2tlbnNbMF0udGV4dDtcblxuICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRva2Vuc1swXS50b2tlbnMgJiYgaXRlbS50b2tlbnNbMF0udG9rZW5zLmxlbmd0aCA+IDAgJiYgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnRleHQgPSBjaGVja2JveCArICcgJyArIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRva2Vucy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNoZWNrYm94XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1Cb2R5ICs9IGNoZWNrYm94O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl0ZW1Cb2R5ICs9IHRoaXMucGFyc2UoaXRlbS50b2tlbnMsIGxvb3NlKTtcbiAgICAgICAgICAgICAgICBib2R5ICs9IHRoaXMucmVuZGVyZXIubGlzdGl0ZW0oaXRlbUJvZHksIHRhc2ssIGNoZWNrZWQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIubGlzdChib2R5LCBvcmRlcmVkLCBzdGFydCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIFRPRE8gcGFyc2UgaW5saW5lIGNvbnRlbnQgaWYgcGFyYW1ldGVyIG1hcmtkb3duPTFcbiAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaHRtbCh0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdwYXJhZ3JhcGgnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgodGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMpKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYm9keSA9IHRva2VuLnRva2VucyA/IHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zKSA6IHRva2VuLnRleHQ7XG5cbiAgICAgICAgICAgICAgd2hpbGUgKGkgKyAxIDwgbCAmJiB0b2tlbnNbaSArIDFdLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5zWysraV07XG4gICAgICAgICAgICAgICAgYm9keSArPSAnXFxuJyArICh0b2tlbi50b2tlbnMgPyB0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucykgOiB0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG91dCArPSB0b3AgPyB0aGlzLnJlbmRlcmVyLnBhcmFncmFwaChib2R5KSA6IGJvZHk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGVyck1zZyA9ICdUb2tlbiB3aXRoIFwiJyArIHRva2VuLnR5cGUgKyAnXCIgdHlwZSB3YXMgbm90IGZvdW5kLic7XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgSW5saW5lIFRva2Vuc1xuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIHBhcnNlSW5saW5lKHRva2VucywgcmVuZGVyZXIpIHtcbiAgICAgIHJlbmRlcmVyID0gcmVuZGVyZXIgfHwgdGhpcy5yZW5kZXJlcjtcbiAgICAgIHZhciBvdXQgPSAnJyxcbiAgICAgICAgICBpLFxuICAgICAgICAgIHRva2VuO1xuICAgICAgdmFyIGwgPSB0b2tlbnMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2VzY2FwZSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci50ZXh0KHRva2VuLnRleHQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuaHRtbCh0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdsaW5rJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmxpbmsodG9rZW4uaHJlZiwgdG9rZW4udGl0bGUsIHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zLCByZW5kZXJlcikpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmltYWdlKHRva2VuLmhyZWYsIHRva2VuLnRpdGxlLCB0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdzdHJvbmcnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuc3Ryb25nKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zLCByZW5kZXJlcikpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2VtJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmVtKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zLCByZW5kZXJlcikpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2NvZGVzcGFuJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmNvZGVzcGFuKHRva2VuLnRleHQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2JyJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmJyKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZGVsJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmRlbCh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLnRleHQodG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGVyck1zZyA9ICdUb2tlbiB3aXRoIFwiJyArIHRva2VuLnR5cGUgKyAnXCIgdHlwZSB3YXMgbm90IGZvdW5kLic7XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFBhcnNlcjtcbiAgfSgpO1xuXG4gIHZhciBtZXJnZSQyID0gaGVscGVycy5tZXJnZSxcbiAgICAgIGNoZWNrU2FuaXRpemVEZXByZWNhdGlvbiQxID0gaGVscGVycy5jaGVja1Nhbml0aXplRGVwcmVjYXRpb24sXG4gICAgICBlc2NhcGUkMiA9IGhlbHBlcnMuZXNjYXBlO1xuICB2YXIgZ2V0RGVmYXVsdHMgPSBkZWZhdWx0cy5nZXREZWZhdWx0cyxcbiAgICAgIGNoYW5nZURlZmF1bHRzID0gZGVmYXVsdHMuY2hhbmdlRGVmYXVsdHMsXG4gICAgICBkZWZhdWx0cyQ1ID0gZGVmYXVsdHMuZGVmYXVsdHM7XG4gIC8qKlxuICAgKiBNYXJrZWRcbiAgICovXG5cbiAgZnVuY3Rpb24gbWFya2VkKHNyYywgb3B0LCBjYWxsYmFjaykge1xuICAgIC8vIHRocm93IGVycm9yIGluIGNhc2Ugb2Ygbm9uIHN0cmluZyBpbnB1dFxuICAgIGlmICh0eXBlb2Ygc3JjID09PSAndW5kZWZpbmVkJyB8fCBzcmMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFya2VkKCk6IGlucHV0IHBhcmFtZXRlciBpcyB1bmRlZmluZWQgb3IgbnVsbCcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXJrZWQoKTogaW5wdXQgcGFyYW1ldGVyIGlzIG9mIHR5cGUgJyArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzcmMpICsgJywgc3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0O1xuICAgICAgb3B0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBvcHQgPSBtZXJnZSQyKHt9LCBtYXJrZWQuZGVmYXVsdHMsIG9wdCB8fCB7fSk7XG4gICAgY2hlY2tTYW5pdGl6ZURlcHJlY2F0aW9uJDEob3B0KTtcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdmFyIGhpZ2hsaWdodCA9IG9wdC5oaWdobGlnaHQ7XG4gICAgICB2YXIgdG9rZW5zO1xuXG4gICAgICB0cnkge1xuICAgICAgICB0b2tlbnMgPSBMZXhlcl8xLmxleChzcmMsIG9wdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbiBkb25lKGVycikge1xuICAgICAgICB2YXIgb3V0O1xuXG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG91dCA9IFBhcnNlcl8xLnBhcnNlKHRva2Vucywgb3B0KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnIgPSBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9wdC5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG4gICAgICAgIHJldHVybiBlcnIgPyBjYWxsYmFjayhlcnIpIDogY2FsbGJhY2sobnVsbCwgb3V0KTtcbiAgICAgIH07XG5cbiAgICAgIGlmICghaGlnaGxpZ2h0IHx8IGhpZ2hsaWdodC5sZW5ndGggPCAzKSB7XG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBvcHQuaGlnaGxpZ2h0O1xuICAgICAgaWYgKCF0b2tlbnMubGVuZ3RoKSByZXR1cm4gZG9uZSgpO1xuICAgICAgdmFyIHBlbmRpbmcgPSAwO1xuICAgICAgbWFya2VkLndhbGtUb2tlbnModG9rZW5zLCBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdjb2RlJykge1xuICAgICAgICAgIHBlbmRpbmcrKztcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGhpZ2hsaWdodCh0b2tlbi50ZXh0LCB0b2tlbi5sYW5nLCBmdW5jdGlvbiAoZXJyLCBjb2RlKSB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCAmJiBjb2RlICE9PSB0b2tlbi50ZXh0KSB7XG4gICAgICAgICAgICAgICAgdG9rZW4udGV4dCA9IGNvZGU7XG4gICAgICAgICAgICAgICAgdG9rZW4uZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBwZW5kaW5nLS07XG5cbiAgICAgICAgICAgICAgaWYgKHBlbmRpbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHBlbmRpbmcgPT09IDApIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBfdG9rZW5zID0gTGV4ZXJfMS5sZXgoc3JjLCBvcHQpO1xuXG4gICAgICBpZiAob3B0LndhbGtUb2tlbnMpIHtcbiAgICAgICAgbWFya2VkLndhbGtUb2tlbnMoX3Rva2Vucywgb3B0LndhbGtUb2tlbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUGFyc2VyXzEucGFyc2UoX3Rva2Vucywgb3B0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlLm1lc3NhZ2UgKz0gJ1xcblBsZWFzZSByZXBvcnQgdGhpcyB0byBodHRwczovL2dpdGh1Yi5jb20vbWFya2VkanMvbWFya2VkLic7XG5cbiAgICAgIGlmIChvcHQuc2lsZW50KSB7XG4gICAgICAgIHJldHVybiAnPHA+QW4gZXJyb3Igb2NjdXJyZWQ6PC9wPjxwcmU+JyArIGVzY2FwZSQyKGUubWVzc2FnZSArICcnLCB0cnVlKSArICc8L3ByZT4nO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogT3B0aW9uc1xuICAgKi9cblxuXG4gIG1hcmtlZC5vcHRpb25zID0gbWFya2VkLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0KSB7XG4gICAgbWVyZ2UkMihtYXJrZWQuZGVmYXVsdHMsIG9wdCk7XG4gICAgY2hhbmdlRGVmYXVsdHMobWFya2VkLmRlZmF1bHRzKTtcbiAgICByZXR1cm4gbWFya2VkO1xuICB9O1xuXG4gIG1hcmtlZC5nZXREZWZhdWx0cyA9IGdldERlZmF1bHRzO1xuICBtYXJrZWQuZGVmYXVsdHMgPSBkZWZhdWx0cyQ1O1xuICAvKipcbiAgICogVXNlIEV4dGVuc2lvblxuICAgKi9cblxuICBtYXJrZWQudXNlID0gZnVuY3Rpb24gKGV4dGVuc2lvbikge1xuICAgIHZhciBvcHRzID0gbWVyZ2UkMih7fSwgZXh0ZW5zaW9uKTtcblxuICAgIGlmIChleHRlbnNpb24ucmVuZGVyZXIpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IG1hcmtlZC5kZWZhdWx0cy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXJfMSgpO1xuXG4gICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHByb3ApIHtcbiAgICAgICAgICB2YXIgcHJldlJlbmRlcmVyID0gcmVuZGVyZXJbcHJvcF07XG5cbiAgICAgICAgICByZW5kZXJlcltwcm9wXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmV0ID0gZXh0ZW5zaW9uLnJlbmRlcmVyW3Byb3BdLmFwcGx5KHJlbmRlcmVyLCBhcmdzKTtcblxuICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgcmV0ID0gcHJldlJlbmRlcmVyLmFwcGx5KHJlbmRlcmVyLCBhcmdzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gZXh0ZW5zaW9uLnJlbmRlcmVyKSB7XG4gICAgICAgICAgX2xvb3AocHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICB9KSgpO1xuICAgIH1cblxuICAgIGlmIChleHRlbnNpb24udG9rZW5pemVyKSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG9rZW5pemVyID0gbWFya2VkLmRlZmF1bHRzLnRva2VuaXplciB8fCBuZXcgVG9rZW5pemVyXzEoKTtcblxuICAgICAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKHByb3ApIHtcbiAgICAgICAgICB2YXIgcHJldlRva2VuaXplciA9IHRva2VuaXplcltwcm9wXTtcblxuICAgICAgICAgIHRva2VuaXplcltwcm9wXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXQgPSBleHRlbnNpb24udG9rZW5pemVyW3Byb3BdLmFwcGx5KHRva2VuaXplciwgYXJncyk7XG5cbiAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHJldCA9IHByZXZUb2tlbml6ZXIuYXBwbHkodG9rZW5pemVyLCBhcmdzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gZXh0ZW5zaW9uLnRva2VuaXplcikge1xuICAgICAgICAgIF9sb29wMihwcm9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdHMudG9rZW5pemVyID0gdG9rZW5pemVyO1xuICAgICAgfSkoKTtcbiAgICB9XG5cbiAgICBpZiAoZXh0ZW5zaW9uLndhbGtUb2tlbnMpIHtcbiAgICAgIHZhciB3YWxrVG9rZW5zID0gbWFya2VkLmRlZmF1bHRzLndhbGtUb2tlbnM7XG5cbiAgICAgIG9wdHMud2Fsa1Rva2VucyA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICBleHRlbnNpb24ud2Fsa1Rva2Vucyh0b2tlbik7XG5cbiAgICAgICAgaWYgKHdhbGtUb2tlbnMpIHtcbiAgICAgICAgICB3YWxrVG9rZW5zKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBtYXJrZWQuc2V0T3B0aW9ucyhvcHRzKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJ1biBjYWxsYmFjayBmb3IgZXZlcnkgdG9rZW5cbiAgICovXG5cblxuICBtYXJrZWQud2Fsa1Rva2VucyA9IGZ1bmN0aW9uICh0b2tlbnMsIGNhbGxiYWNrKSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSh0b2tlbnMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgdmFyIHRva2VuID0gX3N0ZXAudmFsdWU7XG4gICAgICBjYWxsYmFjayh0b2tlbik7XG5cbiAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodG9rZW4udG9rZW5zLmhlYWRlciksIF9zdGVwMjsgIShfc3RlcDIgPSBfaXRlcmF0b3IyKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBjZWxsID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgICAgICBtYXJrZWQud2Fsa1Rva2VucyhjZWxsLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHRva2VuLnRva2Vucy5jZWxscyksIF9zdGVwMzsgIShfc3RlcDMgPSBfaXRlcmF0b3IzKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciByb3cgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2Uocm93KSwgX3N0ZXA0OyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQoKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICB2YXIgX2NlbGwgPSBfc3RlcDQudmFsdWU7XG4gICAgICAgICAgICAgICAgbWFya2VkLndhbGtUb2tlbnMoX2NlbGwsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgbWFya2VkLndhbGtUb2tlbnModG9rZW4uaXRlbXMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0b2tlbi50b2tlbnMpIHtcbiAgICAgICAgICAgICAgbWFya2VkLndhbGtUb2tlbnModG9rZW4udG9rZW5zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFBhcnNlIElubGluZVxuICAgKi9cblxuXG4gIG1hcmtlZC5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIChzcmMsIG9wdCkge1xuICAgIC8vIHRocm93IGVycm9yIGluIGNhc2Ugb2Ygbm9uIHN0cmluZyBpbnB1dFxuICAgIGlmICh0eXBlb2Ygc3JjID09PSAndW5kZWZpbmVkJyB8fCBzcmMgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFya2VkLnBhcnNlSW5saW5lKCk6IGlucHV0IHBhcmFtZXRlciBpcyB1bmRlZmluZWQgb3IgbnVsbCcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXJrZWQucGFyc2VJbmxpbmUoKTogaW5wdXQgcGFyYW1ldGVyIGlzIG9mIHR5cGUgJyArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzcmMpICsgJywgc3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgb3B0ID0gbWVyZ2UkMih7fSwgbWFya2VkLmRlZmF1bHRzLCBvcHQgfHwge30pO1xuICAgIGNoZWNrU2FuaXRpemVEZXByZWNhdGlvbiQxKG9wdCk7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHRva2VucyA9IExleGVyXzEubGV4SW5saW5lKHNyYywgb3B0KTtcblxuICAgICAgaWYgKG9wdC53YWxrVG9rZW5zKSB7XG4gICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKHRva2Vucywgb3B0LndhbGtUb2tlbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUGFyc2VyXzEucGFyc2VJbmxpbmUodG9rZW5zLCBvcHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUubWVzc2FnZSArPSAnXFxuUGxlYXNlIHJlcG9ydCB0aGlzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZWRqcy9tYXJrZWQuJztcblxuICAgICAgaWYgKG9wdC5zaWxlbnQpIHtcbiAgICAgICAgcmV0dXJuICc8cD5BbiBlcnJvciBvY2N1cnJlZDo8L3A+PHByZT4nICsgZXNjYXBlJDIoZS5tZXNzYWdlICsgJycsIHRydWUpICsgJzwvcHJlPic7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogRXhwb3NlXG4gICAqL1xuXG5cbiAgbWFya2VkLlBhcnNlciA9IFBhcnNlcl8xO1xuICBtYXJrZWQucGFyc2VyID0gUGFyc2VyXzEucGFyc2U7XG4gIG1hcmtlZC5SZW5kZXJlciA9IFJlbmRlcmVyXzE7XG4gIG1hcmtlZC5UZXh0UmVuZGVyZXIgPSBUZXh0UmVuZGVyZXJfMTtcbiAgbWFya2VkLkxleGVyID0gTGV4ZXJfMTtcbiAgbWFya2VkLmxleGVyID0gTGV4ZXJfMS5sZXg7XG4gIG1hcmtlZC5Ub2tlbml6ZXIgPSBUb2tlbml6ZXJfMTtcbiAgbWFya2VkLlNsdWdnZXIgPSBTbHVnZ2VyXzE7XG4gIG1hcmtlZC5wYXJzZSA9IG1hcmtlZDtcbiAgdmFyIG1hcmtlZF8xID0gbWFya2VkO1xuXG4gIHJldHVybiBtYXJrZWRfMTtcblxufSkpKTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKipcbiAqIEFjdGlvbnMgdGhhdCBtb2RpZnkgdGhlIFVSTC5cbiAqL1xudmFyIExvY2F0aW9uQWN0aW9ucyA9IHtcblxuICAvKipcbiAgICogSW5kaWNhdGVzIGEgbmV3IGxvY2F0aW9uIGlzIGJlaW5nIHB1c2hlZCB0byB0aGUgaGlzdG9yeSBzdGFjay5cbiAgICovXG4gIFBVU0g6ICdwdXNoJyxcblxuICAvKipcbiAgICogSW5kaWNhdGVzIHRoZSBjdXJyZW50IGxvY2F0aW9uIHNob3VsZCBiZSByZXBsYWNlZC5cbiAgICovXG4gIFJFUExBQ0U6ICdyZXBsYWNlJyxcblxuICAvKipcbiAgICogSW5kaWNhdGVzIHRoZSBtb3N0IHJlY2VudCBlbnRyeSBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIHRoZSBoaXN0b3J5IHN0YWNrLlxuICAgKi9cbiAgUE9QOiAncG9wJ1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvY2F0aW9uQWN0aW9ucztcbiIsInZhciBMb2NhdGlvbkFjdGlvbnMgPSByZXF1aXJlKCcuLi9hY3Rpb25zL0xvY2F0aW9uQWN0aW9ucycpO1xuXG4vKipcbiAqIEEgc2Nyb2xsIGJlaGF2aW9yIHRoYXQgYXR0ZW1wdHMgdG8gaW1pdGF0ZSB0aGUgZGVmYXVsdCBiZWhhdmlvclxuICogb2YgbW9kZXJuIGJyb3dzZXJzLlxuICovXG52YXIgSW1pdGF0ZUJyb3dzZXJCZWhhdmlvciA9IHtcblxuICB1cGRhdGVTY3JvbGxQb3NpdGlvbjogZnVuY3Rpb24gKHBvc2l0aW9uLCBhY3Rpb25UeXBlKSB7XG4gICAgc3dpdGNoIChhY3Rpb25UeXBlKSB7XG4gICAgICBjYXNlIExvY2F0aW9uQWN0aW9ucy5QVVNIOlxuICAgICAgY2FzZSBMb2NhdGlvbkFjdGlvbnMuUkVQTEFDRTpcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTG9jYXRpb25BY3Rpb25zLlBPUDpcbiAgICAgICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICAgICAgd2luZG93LnNjcm9sbFRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbWl0YXRlQnJvd3NlckJlaGF2aW9yO1xuIiwiLyoqXG4gKiBBIHNjcm9sbCBiZWhhdmlvciB0aGF0IGFsd2F5cyBzY3JvbGxzIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2VcbiAqIGFmdGVyIGEgdHJhbnNpdGlvbi5cbiAqL1xudmFyIFNjcm9sbFRvVG9wQmVoYXZpb3IgPSB7XG5cbiAgdXBkYXRlU2Nyb2xsUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY3JvbGxUb1RvcEJlaGF2aW9yO1xuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBGYWtlTm9kZSA9IHJlcXVpcmUoJy4uL21peGlucy9GYWtlTm9kZScpO1xudmFyIFByb3BUeXBlcyA9IHJlcXVpcmUoJy4uL3V0aWxzL1Byb3BUeXBlcycpO1xuXG4vKipcbiAqIEEgPERlZmF1bHRSb3V0ZT4gY29tcG9uZW50IGlzIGEgc3BlY2lhbCBraW5kIG9mIDxSb3V0ZT4gdGhhdFxuICogcmVuZGVycyB3aGVuIGl0cyBwYXJlbnQgbWF0Y2hlcyBidXQgbm9uZSBvZiBpdHMgc2libGluZ3MgZG8uXG4gKiBPbmx5IG9uZSBzdWNoIHJvdXRlIG1heSBiZSB1c2VkIGF0IGFueSBnaXZlbiBsZXZlbCBpbiB0aGVcbiAqIHJvdXRlIGhpZXJhcmNoeS5cbiAqL1xudmFyIERlZmF1bHRSb3V0ZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICBkaXNwbGF5TmFtZTogJ0RlZmF1bHRSb3V0ZScsXG5cbiAgbWl4aW5zOiBbIEZha2VOb2RlIF0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgbmFtZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBwYXRoOiBQcm9wVHlwZXMuZmFsc3ksXG4gICAgaGFuZGxlcjogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlZmF1bHRSb3V0ZTtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgY2xhc3NTZXQgPSByZXF1aXJlKCdyZWFjdC9saWIvY3gnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdyZWFjdC9saWIvT2JqZWN0LmFzc2lnbicpO1xudmFyIE5hdmlnYXRpb24gPSByZXF1aXJlKCcuLi9taXhpbnMvTmF2aWdhdGlvbicpO1xudmFyIFN0YXRlID0gcmVxdWlyZSgnLi4vbWl4aW5zL1N0YXRlJyk7XG5cbmZ1bmN0aW9uIGlzTGVmdENsaWNrRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LmJ1dHRvbiA9PT0gMDtcbn1cblxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAhIShldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KTtcbn1cblxuLyoqXG4gKiA8TGluaz4gY29tcG9uZW50cyBhcmUgdXNlZCB0byBjcmVhdGUgYW4gPGE+IGVsZW1lbnQgdGhhdCBsaW5rcyB0byBhIHJvdXRlLlxuICogV2hlbiB0aGF0IHJvdXRlIGlzIGFjdGl2ZSwgdGhlIGxpbmsgZ2V0cyBhbiBcImFjdGl2ZVwiIGNsYXNzIG5hbWUgKG9yIHRoZVxuICogdmFsdWUgb2YgaXRzIGBhY3RpdmVDbGFzc05hbWVgIHByb3ApLlxuICpcbiAqIEZvciBleGFtcGxlLCBhc3N1bWluZyB5b3UgaGF2ZSB0aGUgZm9sbG93aW5nIHJvdXRlOlxuICpcbiAqICAgPFJvdXRlIG5hbWU9XCJzaG93UG9zdFwiIHBhdGg9XCIvcG9zdHMvOnBvc3RJRFwiIGhhbmRsZXI9e1Bvc3R9Lz5cbiAqXG4gKiBZb3UgY291bGQgdXNlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50IHRvIGxpbmsgdG8gdGhhdCByb3V0ZTpcbiAqXG4gKiAgIDxMaW5rIHRvPVwic2hvd1Bvc3RcIiBwYXJhbXM9e3sgcG9zdElEOiBcIjEyM1wiIH19IC8+XG4gKlxuICogSW4gYWRkaXRpb24gdG8gcGFyYW1zLCBsaW5rcyBtYXkgcGFzcyBhbG9uZyBxdWVyeSBzdHJpbmcgcGFyYW1ldGVyc1xuICogdXNpbmcgdGhlIGBxdWVyeWAgcHJvcC5cbiAqXG4gKiAgIDxMaW5rIHRvPVwic2hvd1Bvc3RcIiBwYXJhbXM9e3sgcG9zdElEOiBcIjEyM1wiIH19IHF1ZXJ5PXt7IHNob3c6dHJ1ZSB9fS8+XG4gKi9cbnZhciBMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gIGRpc3BsYXlOYW1lOiAnTGluaycsXG5cbiAgbWl4aW5zOiBbIE5hdmlnYXRpb24sIFN0YXRlIF0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgYWN0aXZlQ2xhc3NOYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgdG86IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBwYXJhbXM6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgcXVlcnk6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QsXG4gICAgb25DbGljazogUmVhY3QuUHJvcFR5cGVzLmZ1bmNcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWN0aXZlQ2xhc3NOYW1lOiAnYWN0aXZlJ1xuICAgIH07XG4gIH0sXG5cbiAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBhbGxvd1RyYW5zaXRpb24gPSB0cnVlO1xuICAgIHZhciBjbGlja1Jlc3VsdDtcblxuICAgIGlmICh0aGlzLnByb3BzLm9uQ2xpY2spXG4gICAgICBjbGlja1Jlc3VsdCA9IHRoaXMucHJvcHMub25DbGljayhldmVudCk7XG5cbiAgICBpZiAoaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB8fCAhaXNMZWZ0Q2xpY2tFdmVudChldmVudCkpXG4gICAgICByZXR1cm47XG5cbiAgICBpZiAoY2xpY2tSZXN1bHQgPT09IGZhbHNlIHx8IGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgPT09IHRydWUpXG4gICAgICBhbGxvd1RyYW5zaXRpb24gPSBmYWxzZTtcblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBpZiAoYWxsb3dUcmFuc2l0aW9uKVxuICAgICAgdGhpcy50cmFuc2l0aW9uVG8odGhpcy5wcm9wcy50bywgdGhpcy5wcm9wcy5wYXJhbXMsIHRoaXMucHJvcHMucXVlcnkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgXCJocmVmXCIgYXR0cmlidXRlIHRvIHVzZSBvbiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqL1xuICBnZXRIcmVmOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFrZUhyZWYodGhpcy5wcm9wcy50bywgdGhpcy5wcm9wcy5wYXJhbXMsIHRoaXMucHJvcHMucXVlcnkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgXCJjbGFzc1wiIGF0dHJpYnV0ZSB0byB1c2Ugb24gdGhlIERPTSBlbGVtZW50LCB3aGljaCBjb250YWluc1xuICAgKiB0aGUgdmFsdWUgb2YgdGhlIGFjdGl2ZUNsYXNzTmFtZSBwcm9wZXJ0eSB3aGVuIHRoaXMgPExpbms+IGlzIGFjdGl2ZS5cbiAgICovXG4gIGdldENsYXNzTmFtZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbGFzc05hbWVzID0ge307XG5cbiAgICBpZiAodGhpcy5wcm9wcy5jbGFzc05hbWUpXG4gICAgICBjbGFzc05hbWVzW3RoaXMucHJvcHMuY2xhc3NOYW1lXSA9IHRydWU7XG5cbiAgICBpZiAodGhpcy5pc0FjdGl2ZSh0aGlzLnByb3BzLnRvLCB0aGlzLnByb3BzLnBhcmFtcywgdGhpcy5wcm9wcy5xdWVyeSkpXG4gICAgICBjbGFzc05hbWVzW3RoaXMucHJvcHMuYWN0aXZlQ2xhc3NOYW1lXSA9IHRydWU7XG5cbiAgICByZXR1cm4gY2xhc3NTZXQoY2xhc3NOYW1lcyk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb3BzID0gYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7XG4gICAgICBocmVmOiB0aGlzLmdldEhyZWYoKSxcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5nZXRDbGFzc05hbWUoKSxcbiAgICAgIG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ2xpY2tcbiAgICB9KTtcblxuICAgIHJldHVybiBSZWFjdC5ET00uYShwcm9wcywgdGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGluaztcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgRmFrZU5vZGUgPSByZXF1aXJlKCcuLi9taXhpbnMvRmFrZU5vZGUnKTtcbnZhciBQcm9wVHlwZXMgPSByZXF1aXJlKCcuLi91dGlscy9Qcm9wVHlwZXMnKTtcblxuLyoqXG4gKiBBIDxOb3RGb3VuZFJvdXRlPiBpcyBhIHNwZWNpYWwga2luZCBvZiA8Um91dGU+IHRoYXRcbiAqIHJlbmRlcnMgd2hlbiB0aGUgYmVnaW5uaW5nIG9mIGl0cyBwYXJlbnQncyBwYXRoIG1hdGNoZXNcbiAqIGJ1dCBub25lIG9mIGl0cyBzaWJsaW5ncyBkbywgaW5jbHVkaW5nIGFueSA8RGVmYXVsdFJvdXRlPi5cbiAqIE9ubHkgb25lIHN1Y2ggcm91dGUgbWF5IGJlIHVzZWQgYXQgYW55IGdpdmVuIGxldmVsIGluIHRoZVxuICogcm91dGUgaGllcmFyY2h5LlxuICovXG52YXIgTm90Rm91bmRSb3V0ZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICBkaXNwbGF5TmFtZTogJ05vdEZvdW5kUm91dGUnLFxuXG4gIG1peGluczogWyBGYWtlTm9kZSBdLFxuXG4gIHByb3BUeXBlczoge1xuICAgIG5hbWU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgcGF0aDogUHJvcFR5cGVzLmZhbHN5LFxuICAgIGhhbmRsZXI6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBOb3RGb3VuZFJvdXRlO1xuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBGYWtlTm9kZSA9IHJlcXVpcmUoJy4uL21peGlucy9GYWtlTm9kZScpO1xudmFyIFByb3BUeXBlcyA9IHJlcXVpcmUoJy4uL3V0aWxzL1Byb3BUeXBlcycpO1xuXG4vKipcbiAqIEEgPFJlZGlyZWN0PiBjb21wb25lbnQgaXMgYSBzcGVjaWFsIGtpbmQgb2YgPFJvdXRlPiB0aGF0IGFsd2F5c1xuICogcmVkaXJlY3RzIHRvIGFub3RoZXIgcm91dGUgd2hlbiBpdCBtYXRjaGVzLlxuICovXG52YXIgUmVkaXJlY3QgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgZGlzcGxheU5hbWU6ICdSZWRpcmVjdCcsXG5cbiAgbWl4aW5zOiBbIEZha2VOb2RlIF0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgcGF0aDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBmcm9tOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLCAvLyBBbGlhcyBmb3IgcGF0aC5cbiAgICB0bzogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBoYW5kbGVyOiBQcm9wVHlwZXMuZmFsc3lcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWRpcmVjdDtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgRmFrZU5vZGUgPSByZXF1aXJlKCcuLi9taXhpbnMvRmFrZU5vZGUnKTtcblxuLyoqXG4gKiA8Um91dGU+IGNvbXBvbmVudHMgc3BlY2lmeSBjb21wb25lbnRzIHRoYXQgYXJlIHJlbmRlcmVkIHRvIHRoZSBwYWdlIHdoZW4gdGhlXG4gKiBVUkwgbWF0Y2hlcyBhIGdpdmVuIHBhdHRlcm4uXG4gKlxuICogUm91dGVzIGFyZSBhcnJhbmdlZCBpbiBhIG5lc3RlZCB0cmVlIHN0cnVjdHVyZS4gV2hlbiBhIG5ldyBVUkwgaXMgcmVxdWVzdGVkLFxuICogdGhlIHRyZWUgaXMgc2VhcmNoZWQgZGVwdGgtZmlyc3QgdG8gZmluZCBhIHJvdXRlIHdob3NlIHBhdGggbWF0Y2hlcyB0aGUgVVJMLlxuICogV2hlbiBvbmUgaXMgZm91bmQsIGFsbCByb3V0ZXMgaW4gdGhlIHRyZWUgdGhhdCBsZWFkIHRvIGl0IGFyZSBjb25zaWRlcmVkXG4gKiBcImFjdGl2ZVwiIGFuZCB0aGVpciBjb21wb25lbnRzIGFyZSByZW5kZXJlZCBpbnRvIHRoZSBET00sIG5lc3RlZCBpbiB0aGUgc2FtZVxuICogb3JkZXIgYXMgdGhleSBhcmUgaW4gdGhlIHRyZWUuXG4gKlxuICogVGhlIHByZWZlcnJlZCB3YXkgdG8gY29uZmlndXJlIGEgcm91dGVyIGlzIHVzaW5nIEpTWC4gVGhlIFhNTC1saWtlIHN5bnRheCBpc1xuICogYSBncmVhdCB3YXkgdG8gdmlzdWFsaXplIGhvdyByb3V0ZXMgYXJlIGxhaWQgb3V0IGluIGFuIGFwcGxpY2F0aW9uLlxuICpcbiAqICAgdmFyIHJvdXRlcyA9IFtcbiAqICAgICA8Um91dGUgaGFuZGxlcj17QXBwfT5cbiAqICAgICAgIDxSb3V0ZSBuYW1lPVwibG9naW5cIiBoYW5kbGVyPXtMb2dpbn0vPlxuICogICAgICAgPFJvdXRlIG5hbWU9XCJsb2dvdXRcIiBoYW5kbGVyPXtMb2dvdXR9Lz5cbiAqICAgICAgIDxSb3V0ZSBuYW1lPVwiYWJvdXRcIiBoYW5kbGVyPXtBYm91dH0vPlxuICogICAgIDwvUm91dGU+XG4gKiAgIF07XG4gKiAgIFxuICogICBSb3V0ZXIucnVuKHJvdXRlcywgZnVuY3Rpb24gKEhhbmRsZXIpIHtcbiAqICAgICBSZWFjdC5yZW5kZXIoPEhhbmRsZXIvPiwgZG9jdW1lbnQuYm9keSk7XG4gKiAgIH0pO1xuICpcbiAqIEhhbmRsZXJzIGZvciBSb3V0ZSBjb21wb25lbnRzIHRoYXQgY29udGFpbiBjaGlsZHJlbiBjYW4gcmVuZGVyIHRoZWlyIGFjdGl2ZVxuICogY2hpbGQgcm91dGUgdXNpbmcgYSA8Um91dGVIYW5kbGVyPiBlbGVtZW50LlxuICpcbiAqICAgdmFyIEFwcCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAqICAgICAgIHJldHVybiAoXG4gKiAgICAgICAgIDxkaXYgY2xhc3M9XCJhcHBsaWNhdGlvblwiPlxuICogICAgICAgICAgIDxSb3V0ZUhhbmRsZXIvPlxuICogICAgICAgICA8L2Rpdj5cbiAqICAgICAgICk7XG4gKiAgICAgfVxuICogICB9KTtcbiAqL1xudmFyIFJvdXRlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuXG4gIGRpc3BsYXlOYW1lOiAnUm91dGUnLFxuXG4gIG1peGluczogWyBGYWtlTm9kZSBdLFxuXG4gIHByb3BUeXBlczoge1xuICAgIG5hbWU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsXG4gICAgcGF0aDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZyxcbiAgICBoYW5kbGVyOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIGlnbm9yZVNjcm9sbEJlaGF2aW9yOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbFxuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvdXRlO1xuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSb3V0ZUhhbmRsZXJNaXhpbiA9IHJlcXVpcmUoJy4uL21peGlucy9Sb3V0ZUhhbmRsZXInKTtcblxuLyoqXG4gKiBBIDxSb3V0ZUhhbmRsZXI+IGNvbXBvbmVudCByZW5kZXJzIHRoZSBhY3RpdmUgY2hpbGQgcm91dGUgaGFuZGxlclxuICogd2hlbiByb3V0ZXMgYXJlIG5lc3RlZC5cbiAqL1xudmFyIFJvdXRlSGFuZGxlciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcblxuICBkaXNwbGF5TmFtZTogJ1JvdXRlSGFuZGxlcicsXG5cbiAgbWl4aW5zOiBbUm91dGVIYW5kbGVyTWl4aW5dLFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZWY6ICdfX3JvdXRlSGFuZGxlcl9fJ1xuICAgIH07XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Um91dGVIYW5kbGVyKCk7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUm91dGVIYW5kbGVyO1xuIiwiZXhwb3J0cy5EZWZhdWx0Um91dGUgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvRGVmYXVsdFJvdXRlJyk7XG5leHBvcnRzLkxpbmsgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvTGluaycpO1xuZXhwb3J0cy5Ob3RGb3VuZFJvdXRlID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL05vdEZvdW5kUm91dGUnKTtcbmV4cG9ydHMuUmVkaXJlY3QgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvUmVkaXJlY3QnKTtcbmV4cG9ydHMuUm91dGUgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvUm91dGUnKTtcbmV4cG9ydHMuUm91dGVIYW5kbGVyID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL1JvdXRlSGFuZGxlcicpO1xuXG5leHBvcnRzLkhhc2hMb2NhdGlvbiA9IHJlcXVpcmUoJy4vbG9jYXRpb25zL0hhc2hMb2NhdGlvbicpO1xuZXhwb3J0cy5IaXN0b3J5TG9jYXRpb24gPSByZXF1aXJlKCcuL2xvY2F0aW9ucy9IaXN0b3J5TG9jYXRpb24nKTtcbmV4cG9ydHMuUmVmcmVzaExvY2F0aW9uID0gcmVxdWlyZSgnLi9sb2NhdGlvbnMvUmVmcmVzaExvY2F0aW9uJyk7XG5cbmV4cG9ydHMuSW1pdGF0ZUJyb3dzZXJCZWhhdmlvciA9IHJlcXVpcmUoJy4vYmVoYXZpb3JzL0ltaXRhdGVCcm93c2VyQmVoYXZpb3InKTtcbmV4cG9ydHMuU2Nyb2xsVG9Ub3BCZWhhdmlvciA9IHJlcXVpcmUoJy4vYmVoYXZpb3JzL1Njcm9sbFRvVG9wQmVoYXZpb3InKTtcblxuZXhwb3J0cy5OYXZpZ2F0aW9uID0gcmVxdWlyZSgnLi9taXhpbnMvTmF2aWdhdGlvbicpO1xuZXhwb3J0cy5TdGF0ZSA9IHJlcXVpcmUoJy4vbWl4aW5zL1N0YXRlJyk7XG5cbmV4cG9ydHMuY3JlYXRlID0gcmVxdWlyZSgnLi91dGlscy9jcmVhdGVSb3V0ZXInKTtcbmV4cG9ydHMucnVuID0gcmVxdWlyZSgnLi91dGlscy9ydW5Sb3V0ZXInKTtcblxuZXhwb3J0cy5IaXN0b3J5ID0gcmVxdWlyZSgnLi91dGlscy9IaXN0b3J5Jyk7XG4iLCJ2YXIgTG9jYXRpb25BY3Rpb25zID0gcmVxdWlyZSgnLi4vYWN0aW9ucy9Mb2NhdGlvbkFjdGlvbnMnKTtcbnZhciBIaXN0b3J5ID0gcmVxdWlyZSgnLi4vdXRpbHMvSGlzdG9yeScpO1xudmFyIFBhdGggPSByZXF1aXJlKCcuLi91dGlscy9QYXRoJyk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBVUkwgcGF0aCBmcm9tIHRoZSBgaGFzaGAgcG9ydGlvbiBvZiB0aGUgVVJMLCBpbmNsdWRpbmdcbiAqIHF1ZXJ5IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZ2V0SGFzaFBhdGgoKSB7XG4gIHJldHVybiBQYXRoLmRlY29kZShcbiAgICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gICAgLy8gY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnMgLSBGaXJlZm94IHdpbGwgcHJlLWRlY29kZSBpdCFcbiAgICB3aW5kb3cubG9jYXRpb24uaHJlZi5zcGxpdCgnIycpWzFdIHx8ICcnXG4gICk7XG59XG5cbnZhciBfYWN0aW9uVHlwZTtcblxuZnVuY3Rpb24gZW5zdXJlU2xhc2goKSB7XG4gIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcblxuICBpZiAocGF0aC5jaGFyQXQoMCkgPT09ICcvJylcbiAgICByZXR1cm4gdHJ1ZTtcblxuICBIYXNoTG9jYXRpb24ucmVwbGFjZSgnLycgKyBwYXRoKTtcblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBfY2hhbmdlTGlzdGVuZXJzID0gW107XG5cbmZ1bmN0aW9uIG5vdGlmeUNoYW5nZSh0eXBlKSB7XG4gIGlmICh0eXBlID09PSBMb2NhdGlvbkFjdGlvbnMuUFVTSClcbiAgICBIaXN0b3J5Lmxlbmd0aCArPSAxO1xuXG4gIHZhciBjaGFuZ2UgPSB7XG4gICAgcGF0aDogZ2V0SGFzaFBhdGgoKSxcbiAgICB0eXBlOiB0eXBlXG4gIH07XG5cbiAgX2NoYW5nZUxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgIGxpc3RlbmVyKGNoYW5nZSk7XG4gIH0pO1xufVxuXG52YXIgX2lzTGlzdGVuaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIG9uSGFzaENoYW5nZSgpIHtcbiAgaWYgKGVuc3VyZVNsYXNoKCkpIHtcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFuIF9hY3Rpb25UeXBlIHRoZW4gYWxsIHdlIGtub3cgaXMgdGhlIGhhc2hcbiAgICAvLyBjaGFuZ2VkLiBJdCB3YXMgcHJvYmFibHkgY2F1c2VkIGJ5IHRoZSB1c2VyIGNsaWNraW5nIHRoZSBCYWNrXG4gICAgLy8gYnV0dG9uLCBidXQgbWF5IGhhdmUgYWxzbyBiZWVuIHRoZSBGb3J3YXJkIGJ1dHRvbiBvciBtYW51YWxcbiAgICAvLyBtYW5pcHVsYXRpb24uIFNvIGp1c3QgZ3Vlc3MgJ3BvcCcuXG4gICAgbm90aWZ5Q2hhbmdlKF9hY3Rpb25UeXBlIHx8IExvY2F0aW9uQWN0aW9ucy5QT1ApO1xuICAgIF9hY3Rpb25UeXBlID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEEgTG9jYXRpb24gdGhhdCB1c2VzIGB3aW5kb3cubG9jYXRpb24uaGFzaGAuXG4gKi9cbnZhciBIYXNoTG9jYXRpb24gPSB7XG5cbiAgYWRkQ2hhbmdlTGlzdGVuZXI6IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgIF9jaGFuZ2VMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICAvLyBEbyB0aGlzIEJFRk9SRSBsaXN0ZW5pbmcgZm9yIGhhc2hjaGFuZ2UuXG4gICAgZW5zdXJlU2xhc2goKTtcblxuICAgIGlmIChfaXNMaXN0ZW5pbmcpXG4gICAgICByZXR1cm47XG5cbiAgICBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgb25IYXNoQ2hhbmdlLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5hdHRhY2hFdmVudCgnb25oYXNoY2hhbmdlJywgb25IYXNoQ2hhbmdlKTtcbiAgICB9XG5cbiAgICBfaXNMaXN0ZW5pbmcgPSB0cnVlO1xuICB9LFxuXG4gIHJlbW92ZUNoYW5nZUxpc3RlbmVyOiBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gX2NoYW5nZUxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyBpICsrKSB7XG4gICAgICBpZiAoX2NoYW5nZUxpc3RlbmVyc1tpXSA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgX2NoYW5nZUxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCBvbkhhc2hDaGFuZ2UsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50KCdvbmhhc2hjaGFuZ2UnLCBvbkhhc2hDaGFuZ2UpO1xuICAgIH1cblxuICAgIGlmIChfY2hhbmdlTGlzdGVuZXJzLmxlbmd0aCA9PT0gMClcbiAgICAgIF9pc0xpc3RlbmluZyA9IGZhbHNlO1xuICB9LFxuXG5cblxuICBwdXNoOiBmdW5jdGlvbiAocGF0aCkge1xuICAgIF9hY3Rpb25UeXBlID0gTG9jYXRpb25BY3Rpb25zLlBVU0g7XG4gICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBQYXRoLmVuY29kZShwYXRoKTtcbiAgfSxcblxuICByZXBsYWNlOiBmdW5jdGlvbiAocGF0aCkge1xuICAgIF9hY3Rpb25UeXBlID0gTG9jYXRpb25BY3Rpb25zLlJFUExBQ0U7XG4gICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgJyMnICsgUGF0aC5lbmNvZGUocGF0aCkpO1xuICB9LFxuXG4gIHBvcDogZnVuY3Rpb24gKCkge1xuICAgIF9hY3Rpb25UeXBlID0gTG9jYXRpb25BY3Rpb25zLlBPUDtcbiAgICBIaXN0b3J5LmJhY2soKTtcbiAgfSxcblxuICBnZXRDdXJyZW50UGF0aDogZ2V0SGFzaFBhdGgsXG5cbiAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJzxIYXNoTG9jYXRpb24+JztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2hMb2NhdGlvbjtcbiIsInZhciBMb2NhdGlvbkFjdGlvbnMgPSByZXF1aXJlKCcuLi9hY3Rpb25zL0xvY2F0aW9uQWN0aW9ucycpO1xudmFyIEhpc3RvcnkgPSByZXF1aXJlKCcuLi91dGlscy9IaXN0b3J5Jyk7XG52YXIgUGF0aCA9IHJlcXVpcmUoJy4uL3V0aWxzL1BhdGgnKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IFVSTCBwYXRoIGZyb20gYHdpbmRvdy5sb2NhdGlvbmAsIGluY2x1ZGluZyBxdWVyeSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvd1BhdGgoKSB7XG4gIHJldHVybiBQYXRoLmRlY29kZShcbiAgICB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoXG4gICk7XG59XG5cbnZhciBfY2hhbmdlTGlzdGVuZXJzID0gW107XG5cbmZ1bmN0aW9uIG5vdGlmeUNoYW5nZSh0eXBlKSB7XG4gIHZhciBjaGFuZ2UgPSB7XG4gICAgcGF0aDogZ2V0V2luZG93UGF0aCgpLFxuICAgIHR5cGU6IHR5cGVcbiAgfTtcblxuICBfY2hhbmdlTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgbGlzdGVuZXIoY2hhbmdlKTtcbiAgfSk7XG59XG5cbnZhciBfaXNMaXN0ZW5pbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gb25Qb3BTdGF0ZSgpIHtcbiAgbm90aWZ5Q2hhbmdlKExvY2F0aW9uQWN0aW9ucy5QT1ApO1xufVxuXG4vKipcbiAqIEEgTG9jYXRpb24gdGhhdCB1c2VzIEhUTUw1IGhpc3RvcnkuXG4gKi9cbnZhciBIaXN0b3J5TG9jYXRpb24gPSB7XG5cbiAgYWRkQ2hhbmdlTGlzdGVuZXI6IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgIF9jaGFuZ2VMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICBpZiAoX2lzTGlzdGVuaW5nKVxuICAgICAgcmV0dXJuO1xuXG4gICAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBvblBvcFN0YXRlLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5hdHRhY2hFdmVudCgncG9wc3RhdGUnLCBvblBvcFN0YXRlKTtcbiAgICB9XG5cbiAgICBfaXNMaXN0ZW5pbmcgPSB0cnVlO1xuICB9LFxuXG4gIHJlbW92ZUNoYW5nZUxpc3RlbmVyOiBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gX2NoYW5nZUxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyBpICsrKSB7XG4gICAgICBpZiAoX2NoYW5nZUxpc3RlbmVyc1tpXSA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgX2NoYW5nZUxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgb25Qb3BTdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudCgncG9wc3RhdGUnLCBvblBvcFN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoX2NoYW5nZUxpc3RlbmVycy5sZW5ndGggPT09IDApXG4gICAgICBfaXNMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgfSxcblxuXG5cbiAgcHVzaDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoeyBwYXRoOiBwYXRoIH0sICcnLCBQYXRoLmVuY29kZShwYXRoKSk7XG4gICAgSGlzdG9yeS5sZW5ndGggKz0gMTtcbiAgICBub3RpZnlDaGFuZ2UoTG9jYXRpb25BY3Rpb25zLlBVU0gpO1xuICB9LFxuXG4gIHJlcGxhY2U6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHsgcGF0aDogcGF0aCB9LCAnJywgUGF0aC5lbmNvZGUocGF0aCkpO1xuICAgIG5vdGlmeUNoYW5nZShMb2NhdGlvbkFjdGlvbnMuUkVQTEFDRSk7XG4gIH0sXG5cbiAgcG9wOiBIaXN0b3J5LmJhY2ssXG5cbiAgZ2V0Q3VycmVudFBhdGg6IGdldFdpbmRvd1BhdGgsXG5cbiAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJzxIaXN0b3J5TG9jYXRpb24+JztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhpc3RvcnlMb2NhdGlvbjtcbiIsInZhciBIaXN0b3J5TG9jYXRpb24gPSByZXF1aXJlKCcuL0hpc3RvcnlMb2NhdGlvbicpO1xudmFyIEhpc3RvcnkgPSByZXF1aXJlKCcuLi91dGlscy9IaXN0b3J5Jyk7XG52YXIgUGF0aCA9IHJlcXVpcmUoJy4uL3V0aWxzL1BhdGgnKTtcblxuLyoqXG4gKiBBIExvY2F0aW9uIHRoYXQgdXNlcyBmdWxsIHBhZ2UgcmVmcmVzaGVzLiBUaGlzIGlzIHVzZWQgYXNcbiAqIHRoZSBmYWxsYmFjayBmb3IgSGlzdG9yeUxvY2F0aW9uIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90XG4gKiBzdXBwb3J0IHRoZSBIVE1MNSBoaXN0b3J5IEFQSS5cbiAqL1xudmFyIFJlZnJlc2hMb2NhdGlvbiA9IHtcblxuICBwdXNoOiBmdW5jdGlvbiAocGF0aCkge1xuICAgIHdpbmRvdy5sb2NhdGlvbiA9IFBhdGguZW5jb2RlKHBhdGgpO1xuICB9LFxuXG4gIHJlcGxhY2U6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoUGF0aC5lbmNvZGUocGF0aCkpO1xuICB9LFxuXG4gIHBvcDogSGlzdG9yeS5iYWNrLFxuXG4gIGdldEN1cnJlbnRQYXRoOiBIaXN0b3J5TG9jYXRpb24uZ2V0Q3VycmVudFBhdGgsXG5cbiAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJzxSZWZyZXNoTG9jYXRpb24+JztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlZnJlc2hMb2NhdGlvbjtcbiIsInZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdyZWFjdC9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBGYWtlTm9kZSA9IHtcblxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBmYWxzZSxcbiAgICAgICclcyBlbGVtZW50cyBzaG91bGQgbm90IGJlIHJlbmRlcmVkJyxcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuZGlzcGxheU5hbWVcbiAgICApO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmFrZU5vZGU7XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vKipcbiAqIEEgbWl4aW4gZm9yIGNvbXBvbmVudHMgdGhhdCBtb2RpZnkgdGhlIFVSTC5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICBtaXhpbnM6IFsgUm91dGVyLk5hdmlnYXRpb24gXSxcbiAqICAgICBoYW5kbGVDbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gKiAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICogICAgICAgdGhpcy50cmFuc2l0aW9uVG8oJ2FSb3V0ZScsIHsgdGhlOiAncGFyYW1zJyB9LCB7IHRoZTogJ3F1ZXJ5JyB9KTtcbiAqICAgICB9LFxuICogICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICogICAgICAgcmV0dXJuIChcbiAqICAgICAgICAgPGEgb25DbGljaz17dGhpcy5oYW5kbGVDbGlja30+Q2xpY2sgbWUhPC9hPlxuICogICAgICAgKTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICovXG52YXIgTmF2aWdhdGlvbiA9IHtcblxuICBjb250ZXh0VHlwZXM6IHtcbiAgICBtYWtlUGF0aDogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBtYWtlSHJlZjogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICB0cmFuc2l0aW9uVG86IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgcmVwbGFjZVdpdGg6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgZ29CYWNrOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYWJzb2x1dGUgVVJMIHBhdGggY3JlYXRlZCBmcm9tIHRoZSBnaXZlbiByb3V0ZVxuICAgKiBuYW1lLCBVUkwgcGFyYW1ldGVycywgYW5kIHF1ZXJ5IHZhbHVlcy5cbiAgICovXG4gIG1ha2VQYXRoOiBmdW5jdGlvbiAodG8sIHBhcmFtcywgcXVlcnkpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0Lm1ha2VQYXRoKHRvLCBwYXJhbXMsIHF1ZXJ5KTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyB0aGF0IG1heSBzYWZlbHkgYmUgdXNlZCBhcyB0aGUgaHJlZiBvZiBhXG4gICAqIGxpbmsgdG8gdGhlIHJvdXRlIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICAqL1xuICBtYWtlSHJlZjogZnVuY3Rpb24gKHRvLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5tYWtlSHJlZih0bywgcGFyYW1zLCBxdWVyeSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYW5zaXRpb25zIHRvIHRoZSBVUkwgc3BlY2lmaWVkIGluIHRoZSBhcmd1bWVudHMgYnkgcHVzaGluZ1xuICAgKiBhIG5ldyBVUkwgb250byB0aGUgaGlzdG9yeSBzdGFjay5cbiAgICovXG4gIHRyYW5zaXRpb25UbzogZnVuY3Rpb24gKHRvLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gICAgdGhpcy5jb250ZXh0LnRyYW5zaXRpb25Ubyh0bywgcGFyYW1zLCBxdWVyeSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYW5zaXRpb25zIHRvIHRoZSBVUkwgc3BlY2lmaWVkIGluIHRoZSBhcmd1bWVudHMgYnkgcmVwbGFjaW5nXG4gICAqIHRoZSBjdXJyZW50IFVSTCBpbiB0aGUgaGlzdG9yeSBzdGFjay5cbiAgICovXG4gIHJlcGxhY2VXaXRoOiBmdW5jdGlvbiAodG8sIHBhcmFtcywgcXVlcnkpIHtcbiAgICB0aGlzLmNvbnRleHQucmVwbGFjZVdpdGgodG8sIHBhcmFtcywgcXVlcnkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFuc2l0aW9ucyB0byB0aGUgcHJldmlvdXMgVVJMLlxuICAgKi9cbiAgZ29CYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jb250ZXh0LmdvQmFjaygpO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTmF2aWdhdGlvbjtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8qKlxuICogUHJvdmlkZXMgdGhlIHJvdXRlciB3aXRoIGNvbnRleHQgZm9yIFJvdXRlci5OYXZpZ2F0aW9uLlxuICovXG52YXIgTmF2aWdhdGlvbkNvbnRleHQgPSB7XG5cbiAgY2hpbGRDb250ZXh0VHlwZXM6IHtcbiAgICBtYWtlUGF0aDogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBtYWtlSHJlZjogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICB0cmFuc2l0aW9uVG86IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgcmVwbGFjZVdpdGg6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgZ29CYWNrOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgZ2V0Q2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1ha2VQYXRoOiB0aGlzLmNvbnN0cnVjdG9yLm1ha2VQYXRoLFxuICAgICAgbWFrZUhyZWY6IHRoaXMuY29uc3RydWN0b3IubWFrZUhyZWYsXG4gICAgICB0cmFuc2l0aW9uVG86IHRoaXMuY29uc3RydWN0b3IudHJhbnNpdGlvblRvLFxuICAgICAgcmVwbGFjZVdpdGg6IHRoaXMuY29uc3RydWN0b3IucmVwbGFjZVdpdGgsXG4gICAgICBnb0JhY2s6IHRoaXMuY29uc3RydWN0b3IuZ29CYWNrXG4gICAgfTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5hdmlnYXRpb25Db250ZXh0O1xuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbnRleHRUeXBlczoge1xuICAgIGdldFJvdXRlQXREZXB0aDogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBnZXRSb3V0ZUNvbXBvbmVudHM6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgcm91dGVIYW5kbGVyczogUmVhY3QuUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWRcbiAgfSxcblxuICBjaGlsZENvbnRleHRUeXBlczoge1xuICAgIHJvdXRlSGFuZGxlcnM6IFJlYWN0LlByb3BUeXBlcy5hcnJheS5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgZ2V0Q2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdXRlSGFuZGxlcnM6IHRoaXMuY29udGV4dC5yb3V0ZUhhbmRsZXJzLmNvbmNhdChbIHRoaXMgXSlcbiAgICB9O1xuICB9LFxuXG4gIGdldFJvdXRlRGVwdGg6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LnJvdXRlSGFuZGxlcnMubGVuZ3RoIC0gMTtcbiAgfSxcblxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3VwZGF0ZVJvdXRlQ29tcG9uZW50KCk7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdXBkYXRlUm91dGVDb21wb25lbnQoKTtcbiAgfSxcblxuICBfdXBkYXRlUm91dGVDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGVwdGggPSB0aGlzLmdldFJvdXRlRGVwdGgoKTtcbiAgICB2YXIgY29tcG9uZW50cyA9IHRoaXMuY29udGV4dC5nZXRSb3V0ZUNvbXBvbmVudHMoKTtcbiAgICBjb21wb25lbnRzW2RlcHRoXSA9IHRoaXMucmVmc1t0aGlzLnByb3BzLnJlZiB8fCAnX19yb3V0ZUhhbmRsZXJfXyddO1xuICB9LFxuXG4gIGdldFJvdXRlSGFuZGxlcjogZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIHJvdXRlID0gdGhpcy5jb250ZXh0LmdldFJvdXRlQXREZXB0aCh0aGlzLmdldFJvdXRlRGVwdGgoKSk7XG4gICAgcmV0dXJuIHJvdXRlID8gUmVhY3QuY3JlYXRlRWxlbWVudChyb3V0ZS5oYW5kbGVyLCBwcm9wcyB8fCB0aGlzLnByb3BzKSA6IG51bGw7XG4gIH1cbn07IiwidmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9pbnZhcmlhbnQnKTtcbnZhciBjYW5Vc2VET00gPSByZXF1aXJlKCdyZWFjdC9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKS5jYW5Vc2VET007XG52YXIgZ2V0V2luZG93U2Nyb2xsUG9zaXRpb24gPSByZXF1aXJlKCcuLi91dGlscy9nZXRXaW5kb3dTY3JvbGxQb3NpdGlvbicpO1xuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVTY3JvbGwoc3RhdGUsIHByZXZTdGF0ZSkge1xuICBpZiAoIXByZXZTdGF0ZSlcbiAgICByZXR1cm4gdHJ1ZTtcblxuICAvLyBEb24ndCB1cGRhdGUgc2Nyb2xsIHBvc2l0aW9uIHdoZW4gb25seSB0aGUgcXVlcnkgaGFzIGNoYW5nZWQuXG4gIGlmIChzdGF0ZS5wYXRobmFtZSA9PT0gcHJldlN0YXRlLnBhdGhuYW1lKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB2YXIgcm91dGVzID0gc3RhdGUucm91dGVzO1xuICB2YXIgcHJldlJvdXRlcyA9IHByZXZTdGF0ZS5yb3V0ZXM7XG5cbiAgdmFyIHNoYXJlZEFuY2VzdG9yUm91dGVzID0gcm91dGVzLmZpbHRlcihmdW5jdGlvbiAocm91dGUpIHtcbiAgICByZXR1cm4gcHJldlJvdXRlcy5pbmRleE9mKHJvdXRlKSAhPT0gLTE7XG4gIH0pO1xuXG4gIHJldHVybiAhc2hhcmVkQW5jZXN0b3JSb3V0ZXMuc29tZShmdW5jdGlvbiAocm91dGUpIHtcbiAgICByZXR1cm4gcm91dGUuaWdub3JlU2Nyb2xsQmVoYXZpb3I7XG4gIH0pO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIHRoZSByb3V0ZXIgd2l0aCB0aGUgYWJpbGl0eSB0byBtYW5hZ2Ugd2luZG93IHNjcm9sbCBwb3NpdGlvblxuICogYWNjb3JkaW5nIHRvIGl0cyBzY3JvbGwgYmVoYXZpb3IuXG4gKi9cbnZhciBTY3JvbGxpbmcgPSB7XG5cbiAgc3RhdGljczoge1xuICAgIC8qKlxuICAgICAqIFJlY29yZHMgY3VyZW50IHNjcm9sbCBwb3NpdGlvbiBhcyB0aGUgbGFzdCBrbm93biBwb3NpdGlvbiBmb3IgdGhlIGdpdmVuIFVSTCBwYXRoLlxuICAgICAqL1xuICAgIHJlY29yZFNjcm9sbFBvc2l0aW9uOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgaWYgKCF0aGlzLnNjcm9sbEhpc3RvcnkpXG4gICAgICAgIHRoaXMuc2Nyb2xsSGlzdG9yeSA9IHt9O1xuXG4gICAgICB0aGlzLnNjcm9sbEhpc3RvcnlbcGF0aF0gPSBnZXRXaW5kb3dTY3JvbGxQb3NpdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsYXN0IGtub3duIHNjcm9sbCBwb3NpdGlvbiBmb3IgdGhlIGdpdmVuIFVSTCBwYXRoLlxuICAgICAqL1xuICAgIGdldFNjcm9sbFBvc2l0aW9uOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgaWYgKCF0aGlzLnNjcm9sbEhpc3RvcnkpXG4gICAgICAgIHRoaXMuc2Nyb2xsSGlzdG9yeSA9IHt9O1xuXG4gICAgICByZXR1cm4gdGhpcy5zY3JvbGxIaXN0b3J5W3BhdGhdIHx8IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24gKCkge1xuICAgIGludmFyaWFudChcbiAgICAgIHRoaXMuZ2V0U2Nyb2xsQmVoYXZpb3IoKSA9PSBudWxsIHx8IGNhblVzZURPTSxcbiAgICAgICdDYW5ub3QgdXNlIHNjcm9sbCBiZWhhdmlvciB3aXRob3V0IGEgRE9NJ1xuICAgICk7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl91cGRhdGVTY3JvbGwoKTtcbiAgfSxcblxuICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uIChwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgIHRoaXMuX3VwZGF0ZVNjcm9sbChwcmV2U3RhdGUpO1xuICB9LFxuXG4gIF91cGRhdGVTY3JvbGw6IGZ1bmN0aW9uIChwcmV2U3RhdGUpIHtcbiAgICBpZiAoIXNob3VsZFVwZGF0ZVNjcm9sbCh0aGlzLnN0YXRlLCBwcmV2U3RhdGUpKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHNjcm9sbEJlaGF2aW9yID0gdGhpcy5nZXRTY3JvbGxCZWhhdmlvcigpO1xuXG4gICAgaWYgKHNjcm9sbEJlaGF2aW9yKVxuICAgICAgc2Nyb2xsQmVoYXZpb3IudXBkYXRlU2Nyb2xsUG9zaXRpb24oXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuZ2V0U2Nyb2xsUG9zaXRpb24odGhpcy5zdGF0ZS5wYXRoKSxcbiAgICAgICAgdGhpcy5zdGF0ZS5hY3Rpb25cbiAgICAgICk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY3JvbGxpbmc7XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vKipcbiAqIEEgbWl4aW4gZm9yIGNvbXBvbmVudHMgdGhhdCBuZWVkIHRvIGtub3cgdGhlIHBhdGgsIHJvdXRlcywgVVJMXG4gKiBwYXJhbXMgYW5kIHF1ZXJ5IHRoYXQgYXJlIGN1cnJlbnRseSBhY3RpdmUuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgIHZhciBBYm91dExpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgbWl4aW5zOiBbIFJvdXRlci5TdGF0ZSBdLFxuICogICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICogICAgICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMucHJvcHMuY2xhc3NOYW1lO1xuICogICBcbiAqICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKCdhYm91dCcpKVxuICogICAgICAgICBjbGFzc05hbWUgKz0gJyBpcy1hY3RpdmUnO1xuICogICBcbiAqICAgICAgIHJldHVybiBSZWFjdC5ET00uYSh7IGNsYXNzTmFtZTogY2xhc3NOYW1lIH0sIHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICogICAgIH1cbiAqICAgfSk7XG4gKi9cbnZhciBTdGF0ZSA9IHtcblxuICBjb250ZXh0VHlwZXM6IHtcbiAgICBnZXRDdXJyZW50UGF0aDogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBnZXRDdXJyZW50Um91dGVzOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIGdldEN1cnJlbnRQYXRobmFtZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBnZXRDdXJyZW50UGFyYW1zOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIGdldEN1cnJlbnRRdWVyeTogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBpc0FjdGl2ZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IFVSTCBwYXRoLlxuICAgKi9cbiAgZ2V0UGF0aDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuZ2V0Q3VycmVudFBhdGgoKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcm91dGVzIHRoYXQgYXJlIGN1cnJlbnRseSBhY3RpdmUuXG4gICAqL1xuICBnZXRSb3V0ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LmdldEN1cnJlbnRSb3V0ZXMoKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBVUkwgcGF0aCB3aXRob3V0IHRoZSBxdWVyeSBzdHJpbmcuXG4gICAqL1xuICBnZXRQYXRobmFtZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuZ2V0Q3VycmVudFBhdGhuYW1lKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IG9mIHRoZSBVUkwgcGFyYW1zIHRoYXQgYXJlIGN1cnJlbnRseSBhY3RpdmUuXG4gICAqL1xuICBnZXRQYXJhbXM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LmdldEN1cnJlbnRQYXJhbXMoKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3Qgb2YgdGhlIHF1ZXJ5IHBhcmFtcyB0aGF0IGFyZSBjdXJyZW50bHkgYWN0aXZlLlxuICAgKi9cbiAgZ2V0UXVlcnk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LmdldEN1cnJlbnRRdWVyeSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBtZXRob2QgdG8gZGV0ZXJtaW5lIGlmIGEgZ2l2ZW4gcm91dGUsIHBhcmFtcywgYW5kIHF1ZXJ5XG4gICAqIGFyZSBhY3RpdmUuXG4gICAqL1xuICBpc0FjdGl2ZTogZnVuY3Rpb24gKHRvLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5pc0FjdGl2ZSh0bywgcGFyYW1zLCBxdWVyeSk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZTtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgncmVhY3QvbGliL09iamVjdC5hc3NpZ24nKTtcbnZhciBQYXRoID0gcmVxdWlyZSgnLi4vdXRpbHMvUGF0aCcpO1xuXG5mdW5jdGlvbiByb3V0ZUlzQWN0aXZlKGFjdGl2ZVJvdXRlcywgcm91dGVOYW1lKSB7XG4gIHJldHVybiBhY3RpdmVSb3V0ZXMuc29tZShmdW5jdGlvbiAocm91dGUpIHtcbiAgICByZXR1cm4gcm91dGUubmFtZSA9PT0gcm91dGVOYW1lO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcGFyYW1zQXJlQWN0aXZlKGFjdGl2ZVBhcmFtcywgcGFyYW1zKSB7XG4gIGZvciAodmFyIHByb3BlcnR5IGluIHBhcmFtcylcbiAgICBpZiAoU3RyaW5nKGFjdGl2ZVBhcmFtc1twcm9wZXJ0eV0pICE9PSBTdHJpbmcocGFyYW1zW3Byb3BlcnR5XSkpXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHF1ZXJ5SXNBY3RpdmUoYWN0aXZlUXVlcnksIHF1ZXJ5KSB7XG4gIGZvciAodmFyIHByb3BlcnR5IGluIHF1ZXJ5KVxuICAgIGlmIChTdHJpbmcoYWN0aXZlUXVlcnlbcHJvcGVydHldKSAhPT0gU3RyaW5nKHF1ZXJ5W3Byb3BlcnR5XSkpXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgdGhlIHJvdXRlciB3aXRoIGNvbnRleHQgZm9yIFJvdXRlci5TdGF0ZS5cbiAqL1xudmFyIFN0YXRlQ29udGV4dCA9IHtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBVUkwgcGF0aCArIHF1ZXJ5IHN0cmluZy5cbiAgICovXG4gIGdldEN1cnJlbnRQYXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUucGF0aDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHJlYWQtb25seSBhcnJheSBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSByb3V0ZXMuXG4gICAqL1xuICBnZXRDdXJyZW50Um91dGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUucm91dGVzLnNsaWNlKDApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IFVSTCBwYXRoIHdpdGhvdXQgdGhlIHF1ZXJ5IHN0cmluZy5cbiAgICovXG4gIGdldEN1cnJlbnRQYXRobmFtZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnBhdGhuYW1lO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcmVhZC1vbmx5IG9iamVjdCBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBVUkwgcGFyYW1ldGVycy5cbiAgICovXG4gIGdldEN1cnJlbnRQYXJhbXM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXNzaWduKHt9LCB0aGlzLnN0YXRlLnBhcmFtcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSByZWFkLW9ubHkgb2JqZWN0IG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIHF1ZXJ5IHBhcmFtZXRlcnMuXG4gICAqL1xuICBnZXRDdXJyZW50UXVlcnk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXNzaWduKHt9LCB0aGlzLnN0YXRlLnF1ZXJ5KTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiByb3V0ZSwgcGFyYW1zLCBhbmQgcXVlcnkgYXJlIGFjdGl2ZS5cbiAgICovXG4gIGlzQWN0aXZlOiBmdW5jdGlvbiAodG8sIHBhcmFtcywgcXVlcnkpIHtcbiAgICBpZiAoUGF0aC5pc0Fic29sdXRlKHRvKSlcbiAgICAgIHJldHVybiB0byA9PT0gdGhpcy5zdGF0ZS5wYXRoO1xuXG4gICAgcmV0dXJuIHJvdXRlSXNBY3RpdmUodGhpcy5zdGF0ZS5yb3V0ZXMsIHRvKSAmJlxuICAgICAgcGFyYW1zQXJlQWN0aXZlKHRoaXMuc3RhdGUucGFyYW1zLCBwYXJhbXMpICYmXG4gICAgICAocXVlcnkgPT0gbnVsbCB8fCBxdWVyeUlzQWN0aXZlKHRoaXMuc3RhdGUucXVlcnksIHF1ZXJ5KSk7XG4gIH0sXG5cbiAgY2hpbGRDb250ZXh0VHlwZXM6IHtcbiAgICBnZXRDdXJyZW50UGF0aDogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBnZXRDdXJyZW50Um91dGVzOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIGdldEN1cnJlbnRQYXRobmFtZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBnZXRDdXJyZW50UGFyYW1zOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIGdldEN1cnJlbnRRdWVyeTogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBpc0FjdGl2ZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICB9LFxuXG4gIGdldENoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBnZXRDdXJyZW50UGF0aDogdGhpcy5nZXRDdXJyZW50UGF0aCxcbiAgICAgIGdldEN1cnJlbnRSb3V0ZXM6IHRoaXMuZ2V0Q3VycmVudFJvdXRlcyxcbiAgICAgIGdldEN1cnJlbnRQYXRobmFtZTogdGhpcy5nZXRDdXJyZW50UGF0aG5hbWUsXG4gICAgICBnZXRDdXJyZW50UGFyYW1zOiB0aGlzLmdldEN1cnJlbnRQYXJhbXMsXG4gICAgICBnZXRDdXJyZW50UXVlcnk6IHRoaXMuZ2V0Q3VycmVudFF1ZXJ5LFxuICAgICAgaXNBY3RpdmU6IHRoaXMuaXNBY3RpdmVcbiAgICB9O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVDb250ZXh0O1xuIiwiLyoqXG4gKiBSZXByZXNlbnRzIGEgY2FuY2VsbGF0aW9uIGNhdXNlZCBieSBuYXZpZ2F0aW5nIGF3YXlcbiAqIGJlZm9yZSB0aGUgcHJldmlvdXMgdHJhbnNpdGlvbiBoYXMgZnVsbHkgcmVzb2x2ZWQuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbGxhdGlvbigpIHsgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbGxhdGlvbjtcbiIsInZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdyZWFjdC9saWIvaW52YXJpYW50Jyk7XG52YXIgY2FuVXNlRE9NID0gcmVxdWlyZSgncmVhY3QvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50JykuY2FuVXNlRE9NO1xuXG52YXIgSGlzdG9yeSA9IHtcblxuICAvKipcbiAgICogU2VuZHMgdGhlIGJyb3dzZXIgYmFjayBvbmUgZW50cnkgaW4gdGhlIGhpc3RvcnkuXG4gICAqL1xuICBiYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgY2FuVXNlRE9NLFxuICAgICAgJ0Nhbm5vdCB1c2UgSGlzdG9yeS5iYWNrIHdpdGhvdXQgYSBET00nXG4gICAgKTtcblxuICAgIC8vIERvIHRoaXMgZmlyc3Qgc28gdGhhdCBIaXN0b3J5Lmxlbmd0aCB3aWxsXG4gICAgLy8gYmUgYWNjdXJhdGUgaW4gbG9jYXRpb24gY2hhbmdlIGxpc3RlbmVycy5cbiAgICBIaXN0b3J5Lmxlbmd0aCAtPSAxO1xuXG4gICAgd2luZG93Lmhpc3RvcnkuYmFjaygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgaGlzdG9yeS5cbiAgICovXG4gIGxlbmd0aDogMVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhpc3Rvcnk7XG4iLCJ2YXIgaW52YXJpYW50ID0gcmVxdWlyZSgncmVhY3QvbGliL2ludmFyaWFudCcpO1xudmFyIG1lcmdlID0gcmVxdWlyZSgncXMvbGliL3V0aWxzJykubWVyZ2U7XG52YXIgcXMgPSByZXF1aXJlKCdxcycpO1xuXG52YXIgcGFyYW1Db21waWxlTWF0Y2hlciA9IC86KFthLXpBLVpfJF1bYS16QS1aMC05XyRdKil8WyouKClcXFtcXF1cXFxcK3x7fV4kXS9nO1xudmFyIHBhcmFtSW5qZWN0TWF0Y2hlciA9IC86KFthLXpBLVpfJF1bYS16QS1aMC05XyQ/XSpbP10/KXxbKl0vZztcbnZhciBwYXJhbUluamVjdFRyYWlsaW5nU2xhc2hNYXRjaGVyID0gL1xcL1xcL1xcP3xcXC9cXD8vZztcbnZhciBxdWVyeU1hdGNoZXIgPSAvXFw/KC4rKS87XG5cbnZhciBfY29tcGlsZWRQYXR0ZXJucyA9IHt9O1xuXG5mdW5jdGlvbiBjb21waWxlUGF0dGVybihwYXR0ZXJuKSB7XG4gIGlmICghKHBhdHRlcm4gaW4gX2NvbXBpbGVkUGF0dGVybnMpKSB7XG4gICAgdmFyIHBhcmFtTmFtZXMgPSBbXTtcbiAgICB2YXIgc291cmNlID0gcGF0dGVybi5yZXBsYWNlKHBhcmFtQ29tcGlsZU1hdGNoZXIsIGZ1bmN0aW9uIChtYXRjaCwgcGFyYW1OYW1lKSB7XG4gICAgICBpZiAocGFyYW1OYW1lKSB7XG4gICAgICAgIHBhcmFtTmFtZXMucHVzaChwYXJhbU5hbWUpO1xuICAgICAgICByZXR1cm4gJyhbXi8/I10rKSc7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoID09PSAnKicpIHtcbiAgICAgICAgcGFyYW1OYW1lcy5wdXNoKCdzcGxhdCcpO1xuICAgICAgICByZXR1cm4gJyguKj8pJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnXFxcXCcgKyBtYXRjaDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF9jb21waWxlZFBhdHRlcm5zW3BhdHRlcm5dID0ge1xuICAgICAgbWF0Y2hlcjogbmV3IFJlZ0V4cCgnXicgKyBzb3VyY2UgKyAnJCcsICdpJyksXG4gICAgICBwYXJhbU5hbWVzOiBwYXJhbU5hbWVzXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfY29tcGlsZWRQYXR0ZXJuc1twYXR0ZXJuXTtcbn1cblxudmFyIFBhdGggPSB7XG5cbiAgLyoqXG4gICAqIFNhZmVseSBkZWNvZGVzIHNwZWNpYWwgY2hhcmFjdGVycyBpbiB0aGUgZ2l2ZW4gVVJMIHBhdGguXG4gICAqL1xuICBkZWNvZGU6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSShwYXRoLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgfSxcblxuICAvKipcbiAgICogU2FmZWx5IGVuY29kZXMgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIHRoZSBnaXZlbiBVUkwgcGF0aC5cbiAgICovXG4gIGVuY29kZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJKHBhdGgpLnJlcGxhY2UoLyUyMC9nLCAnKycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBuYW1lcyBvZiBhbGwgcGFyYW1ldGVycyBpbiB0aGUgZ2l2ZW4gcGF0dGVybi5cbiAgICovXG4gIGV4dHJhY3RQYXJhbU5hbWVzOiBmdW5jdGlvbiAocGF0dGVybikge1xuICAgIHJldHVybiBjb21waWxlUGF0dGVybihwYXR0ZXJuKS5wYXJhbU5hbWVzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyB0aGUgcG9ydGlvbnMgb2YgdGhlIGdpdmVuIFVSTCBwYXRoIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIHBhdHRlcm5cbiAgICogYW5kIHJldHVybnMgYW4gb2JqZWN0IG9mIHBhcmFtIG5hbWUgPT4gdmFsdWUgcGFpcnMuIFJldHVybnMgbnVsbCBpZiB0aGVcbiAgICogcGF0dGVybiBkb2VzIG5vdCBtYXRjaCB0aGUgZ2l2ZW4gcGF0aC5cbiAgICovXG4gIGV4dHJhY3RQYXJhbXM6IGZ1bmN0aW9uIChwYXR0ZXJuLCBwYXRoKSB7XG4gICAgdmFyIG9iamVjdCA9IGNvbXBpbGVQYXR0ZXJuKHBhdHRlcm4pO1xuICAgIHZhciBtYXRjaCA9IHBhdGgubWF0Y2gob2JqZWN0Lm1hdGNoZXIpO1xuXG4gICAgaWYgKCFtYXRjaClcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgdmFyIHBhcmFtcyA9IHt9O1xuXG4gICAgb2JqZWN0LnBhcmFtTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW1OYW1lLCBpbmRleCkge1xuICAgICAgcGFyYW1zW3BhcmFtTmFtZV0gPSBtYXRjaFtpbmRleCArIDFdO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZlcnNpb24gb2YgdGhlIGdpdmVuIHJvdXRlIHBhdGggd2l0aCBwYXJhbXMgaW50ZXJwb2xhdGVkLiBUaHJvd3NcbiAgICogaWYgdGhlcmUgaXMgYSBkeW5hbWljIHNlZ21lbnQgb2YgdGhlIHJvdXRlIHBhdGggZm9yIHdoaWNoIHRoZXJlIGlzIG5vIHBhcmFtLlxuICAgKi9cbiAgaW5qZWN0UGFyYW1zOiBmdW5jdGlvbiAocGF0dGVybiwgcGFyYW1zKSB7XG4gICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgdmFyIHNwbGF0SW5kZXggPSAwO1xuXG4gICAgcmV0dXJuIHBhdHRlcm4ucmVwbGFjZShwYXJhbUluamVjdE1hdGNoZXIsIGZ1bmN0aW9uIChtYXRjaCwgcGFyYW1OYW1lKSB7XG4gICAgICBwYXJhbU5hbWUgPSBwYXJhbU5hbWUgfHwgJ3NwbGF0JztcblxuICAgICAgLy8gSWYgcGFyYW0gaXMgb3B0aW9uYWwgZG9uJ3QgY2hlY2sgZm9yIGV4aXN0ZW5jZVxuICAgICAgaWYgKHBhcmFtTmFtZS5zbGljZSgtMSkgIT09ICc/Jykge1xuICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgcGFyYW1zW3BhcmFtTmFtZV0gIT0gbnVsbCxcbiAgICAgICAgICAnTWlzc2luZyBcIicgKyBwYXJhbU5hbWUgKyAnXCIgcGFyYW1ldGVyIGZvciBwYXRoIFwiJyArIHBhdHRlcm4gKyAnXCInXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbU5hbWUgPSBwYXJhbU5hbWUuc2xpY2UoMCwgLTEpO1xuXG4gICAgICAgIGlmIChwYXJhbXNbcGFyYW1OYW1lXSA9PSBudWxsKVxuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgdmFyIHNlZ21lbnQ7XG4gICAgICBpZiAocGFyYW1OYW1lID09PSAnc3BsYXQnICYmIEFycmF5LmlzQXJyYXkocGFyYW1zW3BhcmFtTmFtZV0pKSB7XG4gICAgICAgIHNlZ21lbnQgPSBwYXJhbXNbcGFyYW1OYW1lXVtzcGxhdEluZGV4KytdO1xuXG4gICAgICAgIGludmFyaWFudChcbiAgICAgICAgICBzZWdtZW50ICE9IG51bGwsXG4gICAgICAgICAgJ01pc3Npbmcgc3BsYXQgIyAnICsgc3BsYXRJbmRleCArICcgZm9yIHBhdGggXCInICsgcGF0dGVybiArICdcIidcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZ21lbnQgPSBwYXJhbXNbcGFyYW1OYW1lXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlZ21lbnQ7XG4gICAgfSkucmVwbGFjZShwYXJhbUluamVjdFRyYWlsaW5nU2xhc2hNYXRjaGVyLCAnLycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGlzIHRoZSByZXN1bHQgb2YgcGFyc2luZyBhbnkgcXVlcnkgc3RyaW5nIGNvbnRhaW5lZFxuICAgKiBpbiB0aGUgZ2l2ZW4gcGF0aCwgbnVsbCBpZiB0aGUgcGF0aCBjb250YWlucyBubyBxdWVyeSBzdHJpbmcuXG4gICAqL1xuICBleHRyYWN0UXVlcnk6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgdmFyIG1hdGNoID0gcGF0aC5tYXRjaChxdWVyeU1hdGNoZXIpO1xuICAgIHJldHVybiBtYXRjaCAmJiBxcy5wYXJzZShtYXRjaFsxXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBwYXRoIHdpdGhvdXQgdGhlIHF1ZXJ5IHN0cmluZy5cbiAgICovXG4gIHdpdGhvdXRRdWVyeTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKHF1ZXJ5TWF0Y2hlciwgJycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gcGF0aCB3aXRoIHRoZSBwYXJhbWV0ZXJzIGluIHRoZSBnaXZlblxuICAgKiBxdWVyeSBtZXJnZWQgaW50byB0aGUgcXVlcnkgc3RyaW5nLlxuICAgKi9cbiAgd2l0aFF1ZXJ5OiBmdW5jdGlvbiAocGF0aCwgcXVlcnkpIHtcbiAgICB2YXIgZXhpc3RpbmdRdWVyeSA9IFBhdGguZXh0cmFjdFF1ZXJ5KHBhdGgpO1xuXG4gICAgaWYgKGV4aXN0aW5nUXVlcnkpXG4gICAgICBxdWVyeSA9IHF1ZXJ5ID8gbWVyZ2UoZXhpc3RpbmdRdWVyeSwgcXVlcnkpIDogZXhpc3RpbmdRdWVyeTtcblxuICAgIHZhciBxdWVyeVN0cmluZyA9IHF1ZXJ5ICYmIHFzLnN0cmluZ2lmeShxdWVyeSk7XG5cbiAgICBpZiAocXVlcnlTdHJpbmcpXG4gICAgICByZXR1cm4gUGF0aC53aXRob3V0UXVlcnkocGF0aCkgKyAnPycgKyBxdWVyeVN0cmluZztcblxuICAgIHJldHVybiBwYXRoO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHBhdGggaXMgYWJzb2x1dGUuXG4gICAqL1xuICBpc0Fic29sdXRlOiBmdW5jdGlvbiAocGF0aCkge1xuICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbm9ybWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBwYXRoLlxuICAgKi9cbiAgbm9ybWFsaXplOiBmdW5jdGlvbiAocGF0aCwgcGFyZW50Um91dGUpIHtcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9eXFwvKi8sICcvJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEpvaW5zIHR3byBVUkwgcGF0aHMgdG9nZXRoZXIuXG4gICAqL1xuICBqb2luOiBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLnJlcGxhY2UoL1xcLyokLywgJy8nKSArIGI7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXRoO1xuIiwidmFyIFByb21pc2UgPSByZXF1aXJlKCd3aGVuL2xpYi9Qcm9taXNlJyk7XG5cbi8vIFRPRE86IFVzZSBwcm9jZXNzLmVudi5OT0RFX0VOViBjaGVjayArIGVudmlmeSB0byBlbmFibGVcbi8vIHdoZW4ncyBwcm9taXNlIG1vbml0b3IgaGVyZSB3aGVuIGluIGRldi5cblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuIiwidmFyIFByb3BUeXBlcyA9IHtcblxuICAvKipcbiAgICogUmVxdWlyZXMgdGhhdCB0aGUgdmFsdWUgb2YgYSBwcm9wIGJlIGZhbHN5LlxuICAgKi9cbiAgZmFsc3k6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdKVxuICAgICAgcmV0dXJuIG5ldyBFcnJvcignPCcgKyBjb21wb25lbnROYW1lICsgJz4gbWF5IG5vdCBoYXZlIGEgXCInICsgcHJvcE5hbWUgKyAnXCIgcHJvcCcpO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvcFR5cGVzO1xuIiwiLyoqXG4gKiBFbmNhcHN1bGF0ZXMgYSByZWRpcmVjdCB0byB0aGUgZ2l2ZW4gcm91dGUuXG4gKi9cbmZ1bmN0aW9uIFJlZGlyZWN0KHRvLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gIHRoaXMudG8gPSB0bztcbiAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gIHRoaXMucXVlcnkgPSBxdWVyeTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWRpcmVjdDtcbiIsInZhciBhc3NpZ24gPSByZXF1aXJlKCdyZWFjdC9saWIvT2JqZWN0LmFzc2lnbicpO1xudmFyIHJldmVyc2VkQXJyYXkgPSByZXF1aXJlKCcuL3JldmVyc2VkQXJyYXknKTtcbnZhciBSZWRpcmVjdCA9IHJlcXVpcmUoJy4vUmVkaXJlY3QnKTtcbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi9Qcm9taXNlJyk7XG5cbi8qKlxuICogUnVucyBhbGwgaG9vayBmdW5jdGlvbnMgc2VyaWFsbHkgYW5kIGNhbGxzIGNhbGxiYWNrKGVycm9yKSB3aGVuIGZpbmlzaGVkLlxuICogQSBob29rIG1heSByZXR1cm4gYSBwcm9taXNlIGlmIGl0IG5lZWRzIHRvIGV4ZWN1dGUgYXN5bmNocm9ub3VzbHkuXG4gKi9cbmZ1bmN0aW9uIHJ1bkhvb2tzKGhvb2tzLCBjYWxsYmFjaykge1xuICB2YXIgcHJvbWlzZTtcbiAgdHJ5IHtcbiAgICBwcm9taXNlID0gaG9va3MucmVkdWNlKGZ1bmN0aW9uIChwcm9taXNlLCBob29rKSB7XG4gICAgICAvLyBUaGUgZmlyc3QgaG9vayB0byB1c2UgdHJhbnNpdGlvbi53YWl0IG1ha2VzIHRoZSByZXN0XG4gICAgICAvLyBvZiB0aGUgdHJhbnNpdGlvbiBhc3luYyBmcm9tIHRoYXQgcG9pbnQgZm9yd2FyZC5cbiAgICAgIHJldHVybiBwcm9taXNlID8gcHJvbWlzZS50aGVuKGhvb2spIDogaG9vaygpO1xuICAgIH0sIG51bGwpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBjYWxsYmFjayhlcnJvcik7IC8vIFN5bmMgZXJyb3IuXG4gIH1cblxuICBpZiAocHJvbWlzZSkge1xuICAgIC8vIFVzZSBzZXRUaW1lb3V0IHRvIGJyZWFrIHRoZSBwcm9taXNlIGNoYWluLlxuICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrKTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG5cbi8qKlxuICogQ2FsbHMgdGhlIHdpbGxUcmFuc2l0aW9uRnJvbSBob29rIG9mIGFsbCBoYW5kbGVycyBpbiB0aGUgZ2l2ZW4gbWF0Y2hlc1xuICogc2VyaWFsbHkgaW4gcmV2ZXJzZSB3aXRoIHRoZSB0cmFuc2l0aW9uIG9iamVjdCBhbmQgdGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2ZcbiAqIHRoZSByb3V0ZSdzIGhhbmRsZXIsIHNvIHRoYXQgdGhlIGRlZXBlc3QgbmVzdGVkIGhhbmRsZXJzIGFyZSBjYWxsZWQgZmlyc3QuXG4gKiBDYWxscyBjYWxsYmFjayhlcnJvcikgd2hlbiBmaW5pc2hlZC5cbiAqL1xuZnVuY3Rpb24gcnVuVHJhbnNpdGlvbkZyb21Ib29rcyh0cmFuc2l0aW9uLCByb3V0ZXMsIGNvbXBvbmVudHMsIGNhbGxiYWNrKSB7XG4gIGNvbXBvbmVudHMgPSByZXZlcnNlZEFycmF5KGNvbXBvbmVudHMpO1xuXG4gIHZhciBob29rcyA9IHJldmVyc2VkQXJyYXkocm91dGVzKS5tYXAoZnVuY3Rpb24gKHJvdXRlLCBpbmRleCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IHJvdXRlLmhhbmRsZXI7XG5cbiAgICAgIGlmICghdHJhbnNpdGlvbi5pc0Fib3J0ZWQgJiYgaGFuZGxlci53aWxsVHJhbnNpdGlvbkZyb20pXG4gICAgICAgIHJldHVybiBoYW5kbGVyLndpbGxUcmFuc2l0aW9uRnJvbSh0cmFuc2l0aW9uLCBjb21wb25lbnRzW2luZGV4XSk7XG5cbiAgICAgIHZhciBwcm9taXNlID0gdHJhbnNpdGlvbi5fcHJvbWlzZTtcbiAgICAgIHRyYW5zaXRpb24uX3Byb21pc2UgPSBudWxsO1xuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuICB9KTtcblxuICBydW5Ib29rcyhob29rcywgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIENhbGxzIHRoZSB3aWxsVHJhbnNpdGlvblRvIGhvb2sgb2YgYWxsIGhhbmRsZXJzIGluIHRoZSBnaXZlbiBtYXRjaGVzXG4gKiBzZXJpYWxseSB3aXRoIHRoZSB0cmFuc2l0aW9uIG9iamVjdCBhbmQgYW55IHBhcmFtcyB0aGF0IGFwcGx5IHRvIHRoYXRcbiAqIGhhbmRsZXIuIENhbGxzIGNhbGxiYWNrKGVycm9yKSB3aGVuIGZpbmlzaGVkLlxuICovXG5mdW5jdGlvbiBydW5UcmFuc2l0aW9uVG9Ib29rcyh0cmFuc2l0aW9uLCByb3V0ZXMsIHBhcmFtcywgcXVlcnksIGNhbGxiYWNrKSB7XG4gIHZhciBob29rcyA9IHJvdXRlcy5tYXAoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBoYW5kbGVyID0gcm91dGUuaGFuZGxlcjtcblxuICAgICAgaWYgKCF0cmFuc2l0aW9uLmlzQWJvcnRlZCAmJiBoYW5kbGVyLndpbGxUcmFuc2l0aW9uVG8pXG4gICAgICAgIGhhbmRsZXIud2lsbFRyYW5zaXRpb25Ubyh0cmFuc2l0aW9uLCBwYXJhbXMsIHF1ZXJ5KTtcblxuICAgICAgdmFyIHByb21pc2UgPSB0cmFuc2l0aW9uLl9wcm9taXNlO1xuICAgICAgdHJhbnNpdGlvbi5fcHJvbWlzZSA9IG51bGw7XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG4gIH0pO1xuXG4gIHJ1bkhvb2tzKGhvb2tzLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogRW5jYXBzdWxhdGVzIGEgdHJhbnNpdGlvbiB0byBhIGdpdmVuIHBhdGguXG4gKlxuICogVGhlIHdpbGxUcmFuc2l0aW9uVG8gYW5kIHdpbGxUcmFuc2l0aW9uRnJvbSBoYW5kbGVycyByZWNlaXZlXG4gKiBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGFzIHRoZWlyIGZpcnN0IGFyZ3VtZW50LlxuICovXG5mdW5jdGlvbiBUcmFuc2l0aW9uKHBhdGgsIHJldHJ5KSB7XG4gIHRoaXMucGF0aCA9IHBhdGg7XG4gIHRoaXMuYWJvcnRSZWFzb24gPSBudWxsO1xuICB0aGlzLmlzQWJvcnRlZCA9IGZhbHNlO1xuICB0aGlzLnJldHJ5ID0gcmV0cnkuYmluZCh0aGlzKTtcbiAgdGhpcy5fcHJvbWlzZSA9IG51bGw7XG59XG5cbmFzc2lnbihUcmFuc2l0aW9uLnByb3RvdHlwZSwge1xuXG4gIGFib3J0OiBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgaWYgKHRoaXMuaXNBYm9ydGVkKSB7XG4gICAgICAvLyBGaXJzdCBhYm9ydCB3aW5zLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYWJvcnRSZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5pc0Fib3J0ZWQgPSB0cnVlO1xuICB9LFxuXG4gIHJlZGlyZWN0OiBmdW5jdGlvbiAodG8sIHBhcmFtcywgcXVlcnkpIHtcbiAgICB0aGlzLmFib3J0KG5ldyBSZWRpcmVjdCh0bywgcGFyYW1zLCBxdWVyeSkpO1xuICB9LFxuXG4gIHdhaXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuX3Byb21pc2UgPSBQcm9taXNlLnJlc29sdmUodmFsdWUpO1xuICB9LFxuXG4gIGZyb206IGZ1bmN0aW9uIChyb3V0ZXMsIGNvbXBvbmVudHMsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHJ1blRyYW5zaXRpb25Gcm9tSG9va3ModGhpcywgcm91dGVzLCBjb21wb25lbnRzLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgdG86IGZ1bmN0aW9uIChyb3V0ZXMsIHBhcmFtcywgcXVlcnksIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHJ1blRyYW5zaXRpb25Ub0hvb2tzKHRoaXMsIHJvdXRlcywgcGFyYW1zLCBxdWVyeSwgY2FsbGJhY2spO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zaXRpb247XG4iLCIvKiBqc2hpbnQgLVcwNTggKi9cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ3JlYWN0L2xpYi93YXJuaW5nJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgncmVhY3QvbGliL2ludmFyaWFudCcpO1xudmFyIGNhblVzZURPTSA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpLmNhblVzZURPTTtcbnZhciBJbWl0YXRlQnJvd3NlckJlaGF2aW9yID0gcmVxdWlyZSgnLi4vYmVoYXZpb3JzL0ltaXRhdGVCcm93c2VyQmVoYXZpb3InKTtcbnZhciBSb3V0ZUhhbmRsZXIgPSByZXF1aXJlKCcuLi9jb21wb25lbnRzL1JvdXRlSGFuZGxlcicpO1xudmFyIExvY2F0aW9uQWN0aW9ucyA9IHJlcXVpcmUoJy4uL2FjdGlvbnMvTG9jYXRpb25BY3Rpb25zJyk7XG52YXIgSGFzaExvY2F0aW9uID0gcmVxdWlyZSgnLi4vbG9jYXRpb25zL0hhc2hMb2NhdGlvbicpO1xudmFyIEhpc3RvcnlMb2NhdGlvbiA9IHJlcXVpcmUoJy4uL2xvY2F0aW9ucy9IaXN0b3J5TG9jYXRpb24nKTtcbnZhciBSZWZyZXNoTG9jYXRpb24gPSByZXF1aXJlKCcuLi9sb2NhdGlvbnMvUmVmcmVzaExvY2F0aW9uJyk7XG52YXIgTmF2aWdhdGlvbkNvbnRleHQgPSByZXF1aXJlKCcuLi9taXhpbnMvTmF2aWdhdGlvbkNvbnRleHQnKTtcbnZhciBTdGF0ZUNvbnRleHQgPSByZXF1aXJlKCcuLi9taXhpbnMvU3RhdGVDb250ZXh0Jyk7XG52YXIgU2Nyb2xsaW5nID0gcmVxdWlyZSgnLi4vbWl4aW5zL1Njcm9sbGluZycpO1xudmFyIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiA9IHJlcXVpcmUoJy4vY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuJyk7XG52YXIgc3VwcG9ydHNIaXN0b3J5ID0gcmVxdWlyZSgnLi9zdXBwb3J0c0hpc3RvcnknKTtcbnZhciBUcmFuc2l0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2l0aW9uJyk7XG52YXIgUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9Qcm9wVHlwZXMnKTtcbnZhciBSZWRpcmVjdCA9IHJlcXVpcmUoJy4vUmVkaXJlY3QnKTtcbnZhciBIaXN0b3J5ID0gcmVxdWlyZSgnLi9IaXN0b3J5Jyk7XG52YXIgQ2FuY2VsbGF0aW9uID0gcmVxdWlyZSgnLi9DYW5jZWxsYXRpb24nKTtcbnZhciBQYXRoID0gcmVxdWlyZSgnLi9QYXRoJyk7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgbG9jYXRpb24gZm9yIG5ldyByb3V0ZXJzLlxuICovXG52YXIgREVGQVVMVF9MT0NBVElPTiA9IGNhblVzZURPTSA/IEhhc2hMb2NhdGlvbiA6ICcvJztcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBzY3JvbGwgYmVoYXZpb3IgZm9yIG5ldyByb3V0ZXJzLlxuICovXG52YXIgREVGQVVMVF9TQ1JPTExfQkVIQVZJT1IgPSBjYW5Vc2VET00gPyBJbWl0YXRlQnJvd3NlckJlaGF2aW9yIDogbnVsbDtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBlcnJvciBoYW5kbGVyIGZvciBuZXcgcm91dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdEVycm9ySGFuZGxlcihlcnJvcikge1xuICAvLyBUaHJvdyBzbyB3ZSBkb24ndCBzaWxlbnRseSBzd2FsbG93IGFzeW5jIGVycm9ycy5cbiAgdGhyb3cgZXJyb3I7IC8vIFRoaXMgZXJyb3IgcHJvYmFibHkgb3JpZ2luYXRlZCBpbiBhIHRyYW5zaXRpb24gaG9vay5cbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBhYm9ydGVkIHRyYW5zaXRpb24gaGFuZGxlciBmb3IgbmV3IHJvdXRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRBYm9ydEhhbmRsZXIoYWJvcnRSZWFzb24sIGxvY2F0aW9uKSB7XG4gIGlmICh0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnKVxuICAgIHRocm93IG5ldyBFcnJvcignVW5oYW5kbGVkIGFib3J0ZWQgdHJhbnNpdGlvbiEgUmVhc29uOiAnICsgYWJvcnRSZWFzb24pO1xuXG4gIGlmIChhYm9ydFJlYXNvbiBpbnN0YW5jZW9mIENhbmNlbGxhdGlvbikge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChhYm9ydFJlYXNvbiBpbnN0YW5jZW9mIFJlZGlyZWN0KSB7XG4gICAgbG9jYXRpb24ucmVwbGFjZSh0aGlzLm1ha2VQYXRoKGFib3J0UmVhc29uLnRvLCBhYm9ydFJlYXNvbi5wYXJhbXMsIGFib3J0UmVhc29uLnF1ZXJ5KSk7XG4gIH0gZWxzZSB7XG4gICAgbG9jYXRpb24ucG9wKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZE1hdGNoKHBhdGhuYW1lLCByb3V0ZXMsIGRlZmF1bHRSb3V0ZSwgbm90Rm91bmRSb3V0ZSkge1xuICB2YXIgbWF0Y2gsIHJvdXRlLCBwYXJhbXM7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJvdXRlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHJvdXRlID0gcm91dGVzW2ldO1xuXG4gICAgLy8gQ2hlY2sgdGhlIHN1YnRyZWUgZmlyc3QgdG8gZmluZCB0aGUgbW9zdCBkZWVwbHktbmVzdGVkIG1hdGNoLlxuICAgIG1hdGNoID0gZmluZE1hdGNoKHBhdGhuYW1lLCByb3V0ZS5jaGlsZFJvdXRlcywgcm91dGUuZGVmYXVsdFJvdXRlLCByb3V0ZS5ub3RGb3VuZFJvdXRlKTtcblxuICAgIGlmIChtYXRjaCAhPSBudWxsKSB7XG4gICAgICBtYXRjaC5yb3V0ZXMudW5zaGlmdChyb3V0ZSk7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuXG4gICAgLy8gTm8gcm91dGVzIGluIHRoZSBzdWJ0cmVlIG1hdGNoZWQsIHNvIGNoZWNrIHRoaXMgcm91dGUuXG4gICAgcGFyYW1zID0gUGF0aC5leHRyYWN0UGFyYW1zKHJvdXRlLnBhdGgsIHBhdGhuYW1lKTtcblxuICAgIGlmIChwYXJhbXMpXG4gICAgICByZXR1cm4gY3JlYXRlTWF0Y2gocm91dGUsIHBhcmFtcyk7XG4gIH1cblxuICAvLyBObyByb3V0ZXMgbWF0Y2hlZCwgc28gdHJ5IHRoZSBkZWZhdWx0IHJvdXRlIGlmIHRoZXJlIGlzIG9uZS5cbiAgaWYgKGRlZmF1bHRSb3V0ZSAmJiAocGFyYW1zID0gUGF0aC5leHRyYWN0UGFyYW1zKGRlZmF1bHRSb3V0ZS5wYXRoLCBwYXRobmFtZSkpKVxuICAgIHJldHVybiBjcmVhdGVNYXRjaChkZWZhdWx0Um91dGUsIHBhcmFtcyk7XG5cbiAgLy8gTGFzdCBhdHRlbXB0OiBkb2VzIHRoZSBcIm5vdCBmb3VuZFwiIHJvdXRlIG1hdGNoP1xuICBpZiAobm90Rm91bmRSb3V0ZSAmJiAocGFyYW1zID0gUGF0aC5leHRyYWN0UGFyYW1zKG5vdEZvdW5kUm91dGUucGF0aCwgcGF0aG5hbWUpKSlcbiAgICByZXR1cm4gY3JlYXRlTWF0Y2gobm90Rm91bmRSb3V0ZSwgcGFyYW1zKTtcblxuICByZXR1cm4gbWF0Y2g7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hdGNoKHJvdXRlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIHsgcm91dGVzOiBbIHJvdXRlIF0sIHBhcmFtczogcGFyYW1zIH07XG59XG5cbmZ1bmN0aW9uIGhhc1Byb3BlcnRpZXMob2JqZWN0LCBwcm9wZXJ0aWVzKSB7XG4gIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBwcm9wZXJ0aWVzKVxuICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkgJiYgb2JqZWN0W3Byb3BlcnR5TmFtZV0gIT09IHByb3BlcnRpZXNbcHJvcGVydHlOYW1lXSlcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaGFzTWF0Y2gocm91dGVzLCByb3V0ZSwgcHJldlBhcmFtcywgbmV4dFBhcmFtcywgcHJldlF1ZXJ5LCBuZXh0UXVlcnkpIHtcbiAgcmV0dXJuIHJvdXRlcy5zb21lKGZ1bmN0aW9uIChyKSB7XG4gICAgaWYgKHIgIT09IHJvdXRlKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIHBhcmFtTmFtZXMgPSByb3V0ZS5wYXJhbU5hbWVzO1xuICAgIHZhciBwYXJhbU5hbWU7XG5cbiAgICAvLyBFbnN1cmUgdGhhdCBhbGwgcGFyYW1zIHRoZSByb3V0ZSBjYXJlcyBhYm91dCBkaWQgbm90IGNoYW5nZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFyYW1OYW1lcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgcGFyYW1OYW1lID0gcGFyYW1OYW1lc1tpXTtcblxuICAgICAgaWYgKG5leHRQYXJhbXNbcGFyYW1OYW1lXSAhPT0gcHJldlBhcmFtc1twYXJhbU5hbWVdKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoZSBxdWVyeSBoYXNuJ3QgY2hhbmdlZC5cbiAgICByZXR1cm4gaGFzUHJvcGVydGllcyhwcmV2UXVlcnksIG5leHRRdWVyeSkgJiYgaGFzUHJvcGVydGllcyhuZXh0UXVlcnksIHByZXZRdWVyeSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBuZXcgcm91dGVyIHVzaW5nIHRoZSBnaXZlbiBvcHRpb25zLiBBIHJvdXRlclxuICogaXMgYSBSZWFjdENvbXBvbmVudCBjbGFzcyB0aGF0IGtub3dzIGhvdyB0byByZWFjdCB0byBjaGFuZ2VzIGluIHRoZVxuICogVVJMIGFuZCBrZWVwIHRoZSBjb250ZW50cyBvZiB0aGUgcGFnZSBpbiBzeW5jLlxuICpcbiAqIE9wdGlvbnMgbWF5IGJlIGFueSBvZiB0aGUgZm9sbG93aW5nOlxuICpcbiAqIC0gcm91dGVzICAgICAgICAgICAocmVxdWlyZWQpIFRoZSByb3V0ZSBjb25maWdcbiAqIC0gbG9jYXRpb24gICAgICAgICBUaGUgbG9jYXRpb24gdG8gdXNlLiBEZWZhdWx0cyB0byBIYXNoTG9jYXRpb24gd2hlblxuICogICAgICAgICAgICAgICAgICAgIHRoZSBET00gaXMgYXZhaWxhYmxlLCBcIi9cIiBvdGhlcndpc2VcbiAqIC0gc2Nyb2xsQmVoYXZpb3IgICBUaGUgc2Nyb2xsIGJlaGF2aW9yIHRvIHVzZS4gRGVmYXVsdHMgdG8gSW1pdGF0ZUJyb3dzZXJCZWhhdmlvclxuICogICAgICAgICAgICAgICAgICAgIHdoZW4gdGhlIERPTSBpcyBhdmFpbGFibGUsIG51bGwgb3RoZXJ3aXNlXG4gKiAtIG9uRXJyb3IgICAgICAgICAgQSBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gaGFuZGxlIGVycm9yc1xuICogLSBvbkFib3J0ICAgICAgICAgIEEgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGhhbmRsZSBhYm9ydGVkIHRyYW5zaXRpb25zXG4gKlxuICogV2hlbiByZW5kZXJpbmcgaW4gYSBzZXJ2ZXItc2lkZSBlbnZpcm9ubWVudCwgdGhlIGxvY2F0aW9uIHNob3VsZCBzaW1wbHlcbiAqIGJlIHRoZSBVUkwgcGF0aCB0aGF0IHdhcyB1c2VkIGluIHRoZSByZXF1ZXN0LCBpbmNsdWRpbmcgdGhlIHF1ZXJ5IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUm91dGVyKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0aW9ucyA9IHsgcm91dGVzOiBvcHRpb25zIH07IC8vIFJvdXRlci5jcmVhdGUoPFJvdXRlPilcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucyA9IHsgcm91dGVzOiBvcHRpb25zIH07IC8vIFJvdXRlci5jcmVhdGUoWyA8Um91dGU+LCA8Um91dGU+IF0pXG4gIH1cblxuICB2YXIgcm91dGVzID0gW107XG4gIHZhciBuYW1lZFJvdXRlcyA9IHt9O1xuICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICB2YXIgbG9jYXRpb24gPSBvcHRpb25zLmxvY2F0aW9uIHx8IERFRkFVTFRfTE9DQVRJT047XG4gIHZhciBzY3JvbGxCZWhhdmlvciA9IG9wdGlvbnMuc2Nyb2xsQmVoYXZpb3IgfHwgREVGQVVMVF9TQ1JPTExfQkVIQVZJT1I7XG4gIHZhciBvbkVycm9yID0gb3B0aW9ucy5vbkVycm9yIHx8IGRlZmF1bHRFcnJvckhhbmRsZXI7XG4gIHZhciBvbkFib3J0ID0gb3B0aW9ucy5vbkFib3J0IHx8IGRlZmF1bHRBYm9ydEhhbmRsZXI7XG4gIHZhciBzdGF0ZSA9IHt9O1xuICB2YXIgbmV4dFN0YXRlID0ge307XG4gIHZhciBwZW5kaW5nVHJhbnNpdGlvbiA9IG51bGw7XG5cbiAgZnVuY3Rpb24gdXBkYXRlU3RhdGUoKSB7XG4gICAgc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgbmV4dFN0YXRlID0ge307XG4gIH1cblxuICBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJykge1xuICAgIHdhcm5pbmcoXG4gICAgICAhY2FuVXNlRE9NIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcsXG4gICAgICAnWW91IHNob3VsZCBub3QgdXNlIGEgc3RhdGljIGxvY2F0aW9uIGluIGEgRE9NIGVudmlyb25tZW50IGJlY2F1c2UgJyArXG4gICAgICAndGhlIHJvdXRlciB3aWxsIG5vdCBiZSBrZXB0IGluIHN5bmMgd2l0aCB0aGUgY3VycmVudCBVUkwnXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBjYW5Vc2VET00sXG4gICAgICAnWW91IGNhbm5vdCB1c2UgJXMgd2l0aG91dCBhIERPTScsXG4gICAgICBsb2NhdGlvblxuICAgICk7XG4gIH1cblxuICAvLyBBdXRvbWF0aWNhbGx5IGZhbGwgYmFjayB0byBmdWxsIHBhZ2UgcmVmcmVzaGVzIGluXG4gIC8vIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0aGUgSFRNTCBoaXN0b3J5IEFQSS5cbiAgaWYgKGxvY2F0aW9uID09PSBIaXN0b3J5TG9jYXRpb24gJiYgIXN1cHBvcnRzSGlzdG9yeSgpKVxuICAgIGxvY2F0aW9uID0gUmVmcmVzaExvY2F0aW9uO1xuXG4gIHZhciByb3V0ZXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgICBkaXNwbGF5TmFtZTogJ1JvdXRlcicsXG5cbiAgICBtaXhpbnM6IFsgTmF2aWdhdGlvbkNvbnRleHQsIFN0YXRlQ29udGV4dCwgU2Nyb2xsaW5nIF0sXG5cbiAgICBzdGF0aWNzOiB7XG5cbiAgICAgIGRlZmF1bHRSb3V0ZTogbnVsbCxcbiAgICAgIG5vdEZvdW5kUm91dGU6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkcyByb3V0ZXMgdG8gdGhpcyByb3V0ZXIgZnJvbSB0aGUgZ2l2ZW4gY2hpbGRyZW4gb2JqZWN0IChzZWUgUmVhY3RDaGlsZHJlbikuXG4gICAgICAgKi9cbiAgICAgIGFkZFJvdXRlczogZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gICAgICAgIHJvdXRlcy5wdXNoLmFwcGx5KHJvdXRlcywgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGNoaWxkcmVuLCB0aGlzLCBuYW1lZFJvdXRlcykpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGFuIGFic29sdXRlIFVSTCBwYXRoIGNyZWF0ZWQgZnJvbSB0aGUgZ2l2ZW4gcm91dGVcbiAgICAgICAqIG5hbWUsIFVSTCBwYXJhbWV0ZXJzLCBhbmQgcXVlcnkuXG4gICAgICAgKi9cbiAgICAgIG1ha2VQYXRoOiBmdW5jdGlvbiAodG8sIHBhcmFtcywgcXVlcnkpIHtcbiAgICAgICAgdmFyIHBhdGg7XG4gICAgICAgIGlmIChQYXRoLmlzQWJzb2x1dGUodG8pKSB7XG4gICAgICAgICAgcGF0aCA9IFBhdGgubm9ybWFsaXplKHRvKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcm91dGUgPSBuYW1lZFJvdXRlc1t0b107XG5cbiAgICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgICdVbmFibGUgdG8gZmluZCA8Um91dGUgbmFtZT1cIiVzXCI+JyxcbiAgICAgICAgICAgIHRvXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHBhdGggPSByb3V0ZS5wYXRoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFBhdGgud2l0aFF1ZXJ5KFBhdGguaW5qZWN0UGFyYW1zKHBhdGgsIHBhcmFtcyksIHF1ZXJ5KTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBhIHN0cmluZyB0aGF0IG1heSBzYWZlbHkgYmUgdXNlZCBhcyB0aGUgaHJlZiBvZiBhIGxpbmtcbiAgICAgICAqIHRvIHRoZSByb3V0ZSB3aXRoIHRoZSBnaXZlbiBuYW1lLCBVUkwgcGFyYW1ldGVycywgYW5kIHF1ZXJ5LlxuICAgICAgICovXG4gICAgICBtYWtlSHJlZjogZnVuY3Rpb24gKHRvLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5tYWtlUGF0aCh0bywgcGFyYW1zLCBxdWVyeSk7XG4gICAgICAgIHJldHVybiAobG9jYXRpb24gPT09IEhhc2hMb2NhdGlvbikgPyAnIycgKyBwYXRoIDogcGF0aDtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNpdGlvbnMgdG8gdGhlIFVSTCBzcGVjaWZpZWQgaW4gdGhlIGFyZ3VtZW50cyBieSBwdXNoaW5nXG4gICAgICAgKiBhIG5ldyBVUkwgb250byB0aGUgaGlzdG9yeSBzdGFjay5cbiAgICAgICAqL1xuICAgICAgdHJhbnNpdGlvblRvOiBmdW5jdGlvbiAodG8sIHBhcmFtcywgcXVlcnkpIHtcbiAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgIHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3N0cmluZycsXG4gICAgICAgICAgJ1lvdSBjYW5ub3QgdXNlIHRyYW5zaXRpb25UbyB3aXRoIGEgc3RhdGljIGxvY2F0aW9uJ1xuICAgICAgICApO1xuXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5tYWtlUGF0aCh0bywgcGFyYW1zLCBxdWVyeSk7XG5cbiAgICAgICAgaWYgKHBlbmRpbmdUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgLy8gUmVwbGFjZSBzbyBwZW5kaW5nIGxvY2F0aW9uIGRvZXMgbm90IHN0YXkgaW4gaGlzdG9yeS5cbiAgICAgICAgICBsb2NhdGlvbi5yZXBsYWNlKHBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvY2F0aW9uLnB1c2gocGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNpdGlvbnMgdG8gdGhlIFVSTCBzcGVjaWZpZWQgaW4gdGhlIGFyZ3VtZW50cyBieSByZXBsYWNpbmdcbiAgICAgICAqIHRoZSBjdXJyZW50IFVSTCBpbiB0aGUgaGlzdG9yeSBzdGFjay5cbiAgICAgICAqL1xuICAgICAgcmVwbGFjZVdpdGg6IGZ1bmN0aW9uICh0bywgcGFyYW1zLCBxdWVyeSkge1xuICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgdHlwZW9mIGxvY2F0aW9uICE9PSAnc3RyaW5nJyxcbiAgICAgICAgICAnWW91IGNhbm5vdCB1c2UgcmVwbGFjZVdpdGggd2l0aCBhIHN0YXRpYyBsb2NhdGlvbidcbiAgICAgICAgKTtcblxuICAgICAgICBsb2NhdGlvbi5yZXBsYWNlKHRoaXMubWFrZVBhdGgodG8sIHBhcmFtcywgcXVlcnkpKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNpdGlvbnMgdG8gdGhlIHByZXZpb3VzIFVSTCBpZiBvbmUgaXMgYXZhaWxhYmxlLiBSZXR1cm5zIHRydWUgaWYgdGhlXG4gICAgICAgKiByb3V0ZXIgd2FzIGFibGUgdG8gZ28gYmFjaywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICpcbiAgICAgICAqIE5vdGU6IFRoZSByb3V0ZXIgb25seSB0cmFja3MgaGlzdG9yeSBlbnRyaWVzIGluIHlvdXIgYXBwbGljYXRpb24sIG5vdCB0aGVcbiAgICAgICAqIGN1cnJlbnQgYnJvd3NlciBzZXNzaW9uLCBzbyB5b3UgY2FuIHNhZmVseSBjYWxsIHRoaXMgZnVuY3Rpb24gd2l0aG91dCBndWFyZGluZ1xuICAgICAgICogYWdhaW5zdCBzZW5kaW5nIHRoZSB1c2VyIGJhY2sgdG8gc29tZSBvdGhlciBzaXRlLiBIb3dldmVyLCB3aGVuIHVzaW5nXG4gICAgICAgKiBSZWZyZXNoTG9jYXRpb24gKHdoaWNoIGlzIHRoZSBmYWxsYmFjayBmb3IgSGlzdG9yeUxvY2F0aW9uIGluIGJyb3dzZXJzIHRoYXRcbiAgICAgICAqIGRvbid0IHN1cHBvcnQgSFRNTDUgaGlzdG9yeSkgdGhpcyBtZXRob2Qgd2lsbCAqYWx3YXlzKiBzZW5kIHRoZSBjbGllbnQgYmFja1xuICAgICAgICogYmVjYXVzZSB3ZSBjYW5ub3QgcmVsaWFibHkgdHJhY2sgaGlzdG9yeSBsZW5ndGguXG4gICAgICAgKi9cbiAgICAgIGdvQmFjazogZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgdHlwZW9mIGxvY2F0aW9uICE9PSAnc3RyaW5nJyxcbiAgICAgICAgICAnWW91IGNhbm5vdCB1c2UgZ29CYWNrIHdpdGggYSBzdGF0aWMgbG9jYXRpb24nXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKEhpc3RvcnkubGVuZ3RoID4gMSB8fCBsb2NhdGlvbiA9PT0gUmVmcmVzaExvY2F0aW9uKSB7XG4gICAgICAgICAgbG9jYXRpb24ucG9wKCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnZ29CYWNrKCkgd2FzIGlnbm9yZWQgYmVjYXVzZSB0aGVyZSBpcyBubyByb3V0ZXIgaGlzdG9yeScpO1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUGVyZm9ybXMgYSBtYXRjaCBvZiB0aGUgZ2l2ZW4gcGF0aG5hbWUgYWdhaW5zdCB0aGlzIHJvdXRlciBhbmQgcmV0dXJucyBhbiBvYmplY3RcbiAgICAgICAqIHdpdGggdGhlIHsgcm91dGVzLCBwYXJhbXMgfSB0aGF0IG1hdGNoLiBSZXR1cm5zIG51bGwgaWYgbm8gbWF0Y2ggY2FuIGJlIG1hZGUuXG4gICAgICAgKi9cbiAgICAgIG1hdGNoOiBmdW5jdGlvbiAocGF0aG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRNYXRjaChwYXRobmFtZSwgcm91dGVzLCB0aGlzLmRlZmF1bHRSb3V0ZSwgdGhpcy5ub3RGb3VuZFJvdXRlKSB8fCBudWxsO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQZXJmb3JtcyBhIHRyYW5zaXRpb24gdG8gdGhlIGdpdmVuIHBhdGggYW5kIGNhbGxzIGNhbGxiYWNrKGVycm9yLCBhYm9ydFJlYXNvbilcbiAgICAgICAqIHdoZW4gdGhlIHRyYW5zaXRpb24gaXMgZmluaXNoZWQuIElmIGJvdGggYXJndW1lbnRzIGFyZSBudWxsIHRoZSByb3V0ZXIncyBzdGF0ZVxuICAgICAgICogd2FzIHVwZGF0ZWQuIE90aGVyd2lzZSB0aGUgdHJhbnNpdGlvbiBkaWQgbm90IGNvbXBsZXRlLlxuICAgICAgICpcbiAgICAgICAqIEluIGEgdHJhbnNpdGlvbiwgYSByb3V0ZXIgZmlyc3QgZGV0ZXJtaW5lcyB3aGljaCByb3V0ZXMgYXJlIGludm9sdmVkIGJ5IGJlZ2lubmluZ1xuICAgICAgICogd2l0aCB0aGUgY3VycmVudCByb3V0ZSwgdXAgdGhlIHJvdXRlIHRyZWUgdG8gdGhlIGZpcnN0IHBhcmVudCByb3V0ZSB0aGF0IGlzIHNoYXJlZFxuICAgICAgICogd2l0aCB0aGUgZGVzdGluYXRpb24gcm91dGUsIGFuZCBiYWNrIGRvd24gdGhlIHRyZWUgdG8gdGhlIGRlc3RpbmF0aW9uIHJvdXRlLiBUaGVcbiAgICAgICAqIHdpbGxUcmFuc2l0aW9uRnJvbSBob29rIGlzIGludm9rZWQgb24gYWxsIHJvdXRlIGhhbmRsZXJzIHdlJ3JlIHRyYW5zaXRpb25pbmcgYXdheVxuICAgICAgICogZnJvbSwgaW4gcmV2ZXJzZSBuZXN0aW5nIG9yZGVyLiBMaWtld2lzZSwgdGhlIHdpbGxUcmFuc2l0aW9uVG8gaG9vayBpcyBpbnZva2VkIG9uXG4gICAgICAgKiBhbGwgcm91dGUgaGFuZGxlcnMgd2UncmUgdHJhbnNpdGlvbmluZyB0by5cbiAgICAgICAqXG4gICAgICAgKiBCb3RoIHdpbGxUcmFuc2l0aW9uRnJvbSBhbmQgd2lsbFRyYW5zaXRpb25UbyBob29rcyBtYXkgZWl0aGVyIGFib3J0IG9yIHJlZGlyZWN0IHRoZVxuICAgICAgICogdHJhbnNpdGlvbi4gVG8gcmVzb2x2ZSBhc3luY2hyb25vdXNseSwgdGhleSBtYXkgdXNlIHRyYW5zaXRpb24ud2FpdChwcm9taXNlKS4gSWYgbm9cbiAgICAgICAqIGhvb2tzIHdhaXQsIHRoZSB0cmFuc2l0aW9uIGlzIGZ1bGx5IHN5bmNocm9ub3VzLlxuICAgICAgICovXG4gICAgICBkaXNwYXRjaDogZnVuY3Rpb24gKHBhdGgsIGFjdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHBlbmRpbmdUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgcGVuZGluZ1RyYW5zaXRpb24uYWJvcnQobmV3IENhbmNlbGxhdGlvbik7XG4gICAgICAgICAgcGVuZGluZ1RyYW5zaXRpb24gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZXZQYXRoID0gc3RhdGUucGF0aDtcbiAgICAgICAgaWYgKHByZXZQYXRoID09PSBwYXRoKVxuICAgICAgICAgIHJldHVybjsgLy8gTm90aGluZyB0byBkbyFcblxuICAgICAgICAvLyBSZWNvcmQgdGhlIHNjcm9sbCBwb3NpdGlvbiBhcyBlYXJseSBhcyBwb3NzaWJsZSB0b1xuICAgICAgICAvLyBnZXQgaXQgYmVmb3JlIGJyb3dzZXJzIHRyeSB1cGRhdGUgaXQgYXV0b21hdGljYWxseS5cbiAgICAgICAgaWYgKHByZXZQYXRoICYmIGFjdGlvbiAhPT0gTG9jYXRpb25BY3Rpb25zLlJFUExBQ0UpXG4gICAgICAgICAgdGhpcy5yZWNvcmRTY3JvbGxQb3NpdGlvbihwcmV2UGF0aCk7XG5cbiAgICAgICAgdmFyIHBhdGhuYW1lID0gUGF0aC53aXRob3V0UXVlcnkocGF0aCk7XG4gICAgICAgIHZhciBtYXRjaCA9IHRoaXMubWF0Y2gocGF0aG5hbWUpO1xuXG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgbWF0Y2ggIT0gbnVsbCxcbiAgICAgICAgICAnTm8gcm91dGUgbWF0Y2hlcyBwYXRoIFwiJXNcIi4gTWFrZSBzdXJlIHlvdSBoYXZlIDxSb3V0ZSBwYXRoPVwiJXNcIj4gc29tZXdoZXJlIGluIHlvdXIgcm91dGVzJyxcbiAgICAgICAgICBwYXRoLCBwYXRoXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKG1hdGNoID09IG51bGwpXG4gICAgICAgICAgbWF0Y2ggPSB7fTtcblxuICAgICAgICB2YXIgcHJldlJvdXRlcyA9IHN0YXRlLnJvdXRlcyB8fCBbXTtcbiAgICAgICAgdmFyIHByZXZQYXJhbXMgPSBzdGF0ZS5wYXJhbXMgfHwge307XG4gICAgICAgIHZhciBwcmV2UXVlcnkgPSBzdGF0ZS5xdWVyeSB8fCB7fTtcblxuICAgICAgICB2YXIgbmV4dFJvdXRlcyA9IG1hdGNoLnJvdXRlcyB8fCBbXTtcbiAgICAgICAgdmFyIG5leHRQYXJhbXMgPSBtYXRjaC5wYXJhbXMgfHwge307XG4gICAgICAgIHZhciBuZXh0UXVlcnkgPSBQYXRoLmV4dHJhY3RRdWVyeShwYXRoKSB8fCB7fTtcblxuICAgICAgICB2YXIgZnJvbVJvdXRlcywgdG9Sb3V0ZXM7XG4gICAgICAgIGlmIChwcmV2Um91dGVzLmxlbmd0aCkge1xuICAgICAgICAgIGZyb21Sb3V0ZXMgPSBwcmV2Um91dGVzLmZpbHRlcihmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgICAgIHJldHVybiAhaGFzTWF0Y2gobmV4dFJvdXRlcywgcm91dGUsIHByZXZQYXJhbXMsIG5leHRQYXJhbXMsIHByZXZRdWVyeSwgbmV4dFF1ZXJ5KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRvUm91dGVzID0gbmV4dFJvdXRlcy5maWx0ZXIoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gIWhhc01hdGNoKHByZXZSb3V0ZXMsIHJvdXRlLCBwcmV2UGFyYW1zLCBuZXh0UGFyYW1zLCBwcmV2UXVlcnksIG5leHRRdWVyeSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJvbVJvdXRlcyA9IFtdO1xuICAgICAgICAgIHRvUm91dGVzID0gbmV4dFJvdXRlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gbmV3IFRyYW5zaXRpb24ocGF0aCwgdGhpcy5yZXBsYWNlV2l0aC5iaW5kKHRoaXMsIHBhdGgpKTtcbiAgICAgICAgcGVuZGluZ1RyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuXG4gICAgICAgIHRyYW5zaXRpb24uZnJvbShmcm9tUm91dGVzLCBjb21wb25lbnRzLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAoZXJyb3IgfHwgdHJhbnNpdGlvbi5pc0Fib3J0ZWQpXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChyb3V0ZXIsIGVycm9yLCB0cmFuc2l0aW9uKTtcblxuICAgICAgICAgIHRyYW5zaXRpb24udG8odG9Sb3V0ZXMsIG5leHRQYXJhbXMsIG5leHRRdWVyeSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgfHwgdHJhbnNpdGlvbi5pc0Fib3J0ZWQpXG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHJvdXRlciwgZXJyb3IsIHRyYW5zaXRpb24pO1xuXG4gICAgICAgICAgICBuZXh0U3RhdGUucGF0aCA9IHBhdGg7XG4gICAgICAgICAgICBuZXh0U3RhdGUuYWN0aW9uID0gYWN0aW9uO1xuICAgICAgICAgICAgbmV4dFN0YXRlLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgICAgICBuZXh0U3RhdGUucm91dGVzID0gbmV4dFJvdXRlcztcbiAgICAgICAgICAgIG5leHRTdGF0ZS5wYXJhbXMgPSBuZXh0UGFyYW1zO1xuICAgICAgICAgICAgbmV4dFN0YXRlLnF1ZXJ5ID0gbmV4dFF1ZXJ5O1xuXG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHJvdXRlciwgbnVsbCwgdHJhbnNpdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBTdGFydHMgdGhpcyByb3V0ZXIgYW5kIGNhbGxzIGNhbGxiYWNrKHJvdXRlciwgc3RhdGUpIHdoZW4gdGhlIHJvdXRlIGNoYW5nZXMuXG4gICAgICAgKlxuICAgICAgICogSWYgdGhlIHJvdXRlcidzIGxvY2F0aW9uIGlzIHN0YXRpYyAoaS5lLiBhIFVSTCBwYXRoIGluIGEgc2VydmVyIGVudmlyb25tZW50KVxuICAgICAgICogdGhlIGNhbGxiYWNrIGlzIGNhbGxlZCBvbmx5IG9uY2UuIE90aGVyd2lzZSwgdGhlIGxvY2F0aW9uIHNob3VsZCBiZSBvbmUgb2YgdGhlXG4gICAgICAgKiBSb3V0ZXIuKkxvY2F0aW9uIG9iamVjdHMgKGUuZy4gUm91dGVyLkhhc2hMb2NhdGlvbiBvciBSb3V0ZXIuSGlzdG9yeUxvY2F0aW9uKS5cbiAgICAgICAqL1xuICAgICAgcnVuOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGRpc3BhdGNoSGFuZGxlciA9IGZ1bmN0aW9uIChlcnJvciwgdHJhbnNpdGlvbikge1xuICAgICAgICAgIHBlbmRpbmdUcmFuc2l0aW9uID0gbnVsbDtcblxuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgb25FcnJvci5jYWxsKHJvdXRlciwgZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHJhbnNpdGlvbi5pc0Fib3J0ZWQpIHtcbiAgICAgICAgICAgIG9uQWJvcnQuY2FsbChyb3V0ZXIsIHRyYW5zaXRpb24uYWJvcnRSZWFzb24sIGxvY2F0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChyb3V0ZXIsIHJvdXRlciwgbmV4dFN0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByb3V0ZXIuZGlzcGF0Y2gobG9jYXRpb24sIG51bGwsIGRpc3BhdGNoSGFuZGxlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTGlzdGVuIGZvciBjaGFuZ2VzIHRvIHRoZSBsb2NhdGlvbi5cbiAgICAgICAgICB2YXIgY2hhbmdlTGlzdGVuZXIgPSBmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICByb3V0ZXIuZGlzcGF0Y2goY2hhbmdlLnBhdGgsIGNoYW5nZS50eXBlLCBkaXNwYXRjaEhhbmRsZXIpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAobG9jYXRpb24uYWRkQ2hhbmdlTGlzdGVuZXIpXG4gICAgICAgICAgICBsb2NhdGlvbi5hZGRDaGFuZ2VMaXN0ZW5lcihjaGFuZ2VMaXN0ZW5lcik7XG5cbiAgICAgICAgICAvLyBCb290c3RyYXAgdXNpbmcgdGhlIGN1cnJlbnQgcGF0aC5cbiAgICAgICAgICByb3V0ZXIuZGlzcGF0Y2gobG9jYXRpb24uZ2V0Q3VycmVudFBhdGgoKSwgbnVsbCwgZGlzcGF0Y2hIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdGVhcmRvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICBsb2NhdGlvbi5yZW1vdmVDaGFuZ2VMaXN0ZW5lcih0aGlzLmNoYW5nZUxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICBwcm9wVHlwZXM6IHtcbiAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuZmFsc3lcbiAgICB9LFxuXG4gICAgZ2V0TG9jYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9LFxuXG4gICAgZ2V0U2Nyb2xsQmVoYXZpb3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzY3JvbGxCZWhhdmlvcjtcbiAgICB9LFxuXG4gICAgZ2V0Um91dGVBdERlcHRoOiBmdW5jdGlvbiAoZGVwdGgpIHtcbiAgICAgIHZhciByb3V0ZXMgPSB0aGlzLnN0YXRlLnJvdXRlcztcbiAgICAgIHJldHVybiByb3V0ZXMgJiYgcm91dGVzW2RlcHRoXTtcbiAgICB9LFxuXG4gICAgZ2V0Um91dGVDb21wb25lbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9LFxuXG4gICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB1cGRhdGVTdGF0ZSgpO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG5cbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB1cGRhdGVTdGF0ZSgpO1xuICAgICAgdGhpcy5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgfSxcblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHJvdXRlci50ZWFyZG93bigpO1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJvdXRlQXREZXB0aCgwKSA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVIYW5kbGVyLCB0aGlzLnByb3BzKSA6IG51bGw7XG4gICAgfSxcblxuICAgIGNoaWxkQ29udGV4dFR5cGVzOiB7XG4gICAgICBnZXRSb3V0ZUF0RGVwdGg6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgICBnZXRSb3V0ZUNvbXBvbmVudHM6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgICByb3V0ZUhhbmRsZXJzOiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZFxuICAgIH0sXG5cbiAgICBnZXRDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdldFJvdXRlQ29tcG9uZW50czogdGhpcy5nZXRSb3V0ZUNvbXBvbmVudHMsXG4gICAgICAgIGdldFJvdXRlQXREZXB0aDogdGhpcy5nZXRSb3V0ZUF0RGVwdGgsXG4gICAgICAgIHJvdXRlSGFuZGxlcnM6IFsgdGhpcyBdXG4gICAgICB9O1xuICAgIH1cblxuICB9KTtcblxuICBpZiAob3B0aW9ucy5yb3V0ZXMpXG4gICAgcm91dGVyLmFkZFJvdXRlcyhvcHRpb25zLnJvdXRlcyk7XG5cbiAgcmV0dXJuIHJvdXRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVSb3V0ZXI7XG4iLCIvKiBqc2hpbnQgLVcwODQgKi9cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ3JlYWN0L2xpYi93YXJuaW5nJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgncmVhY3QvbGliL2ludmFyaWFudCcpO1xudmFyIERlZmF1bHRSb3V0ZSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvRGVmYXVsdFJvdXRlJyk7XG52YXIgTm90Rm91bmRSb3V0ZSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvTm90Rm91bmRSb3V0ZScpO1xudmFyIFJlZGlyZWN0ID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9SZWRpcmVjdCcpO1xudmFyIFJvdXRlID0gcmVxdWlyZSgnLi4vY29tcG9uZW50cy9Sb3V0ZScpO1xudmFyIFBhdGggPSByZXF1aXJlKCcuL1BhdGgnKTtcblxudmFyIENPTkZJR19FTEVNRU5UX1RZUEVTID0gW1xuICBEZWZhdWx0Um91dGUudHlwZSxcbiAgTm90Rm91bmRSb3V0ZS50eXBlLFxuICBSZWRpcmVjdC50eXBlLFxuICBSb3V0ZS50eXBlXG5dO1xuXG5mdW5jdGlvbiBjcmVhdGVSZWRpcmVjdEhhbmRsZXIodG8sIF9wYXJhbXMsIF9xdWVyeSkge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgIHN0YXRpY3M6IHtcbiAgICAgIHdpbGxUcmFuc2l0aW9uVG86IGZ1bmN0aW9uICh0cmFuc2l0aW9uLCBwYXJhbXMsIHF1ZXJ5KSB7XG4gICAgICAgIHRyYW5zaXRpb24ucmVkaXJlY3QodG8sIF9wYXJhbXMgfHwgcGFyYW1zLCBfcXVlcnkgfHwgcXVlcnkpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKGNvbXBvbmVudE5hbWUsIHByb3BUeXBlcywgcHJvcHMpIHtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcFR5cGVzKSB7XG4gICAgaWYgKHByb3BUeXBlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIHZhciBlcnJvciA9IHByb3BUeXBlc1twcm9wTmFtZV0ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpXG4gICAgICAgIHdhcm5pbmcoZmFsc2UsIGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZShlbGVtZW50LCBwYXJlbnRSb3V0ZSwgbmFtZWRSb3V0ZXMpIHtcbiAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gIHZhciBwcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIHZhciBjb21wb25lbnROYW1lID0gKHR5cGUgJiYgdHlwZS5kaXNwbGF5TmFtZSkgfHwgJ1Vua25vd25Db21wb25lbnQnO1xuXG4gIGludmFyaWFudChcbiAgICBDT05GSUdfRUxFTUVOVF9UWVBFUy5pbmRleE9mKHR5cGUpICE9PSAtMSxcbiAgICAnVW5yZWNvZ25pemVkIHJvdXRlIGNvbmZpZ3VyYXRpb24gZWxlbWVudCBcIjwlcz5cIicsXG4gICAgY29tcG9uZW50TmFtZVxuICApO1xuXG4gIGlmICh0eXBlLnByb3BUeXBlcylcbiAgICBjaGVja1Byb3BUeXBlcyhjb21wb25lbnROYW1lLCB0eXBlLnByb3BUeXBlcywgcHJvcHMpO1xuXG4gIHZhciByb3V0ZSA9IHsgbmFtZTogcHJvcHMubmFtZSB9O1xuXG4gIGlmIChwcm9wcy5pZ25vcmVTY3JvbGxCZWhhdmlvcikge1xuICAgIHJvdXRlLmlnbm9yZVNjcm9sbEJlaGF2aW9yID0gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlID09PSBSZWRpcmVjdC50eXBlKSB7XG4gICAgcm91dGUuaGFuZGxlciA9IGNyZWF0ZVJlZGlyZWN0SGFuZGxlcihwcm9wcy50bywgcHJvcHMucGFyYW1zLCBwcm9wcy5xdWVyeSk7XG4gICAgcHJvcHMucGF0aCA9IHByb3BzLnBhdGggfHwgcHJvcHMuZnJvbSB8fCAnKic7XG4gIH0gZWxzZSB7XG4gICAgcm91dGUuaGFuZGxlciA9IHByb3BzLmhhbmRsZXI7XG4gIH1cblxuICB2YXIgcGFyZW50UGF0aCA9IChwYXJlbnRSb3V0ZSAmJiBwYXJlbnRSb3V0ZS5wYXRoKSB8fCAnLyc7XG5cbiAgaWYgKChwcm9wcy5wYXRoIHx8IHByb3BzLm5hbWUpICYmIHR5cGUgIT09IERlZmF1bHRSb3V0ZS50eXBlICYmIHR5cGUgIT09IE5vdEZvdW5kUm91dGUudHlwZSkge1xuICAgIHZhciBwYXRoID0gcHJvcHMucGF0aCB8fCBwcm9wcy5uYW1lO1xuXG4gICAgLy8gUmVsYXRpdmUgcGF0aHMgZXh0ZW5kIHRoZWlyIHBhcmVudC5cbiAgICBpZiAoIVBhdGguaXNBYnNvbHV0ZShwYXRoKSlcbiAgICAgIHBhdGggPSBQYXRoLmpvaW4ocGFyZW50UGF0aCwgcGF0aCk7XG5cbiAgICByb3V0ZS5wYXRoID0gUGF0aC5ub3JtYWxpemUocGF0aCk7XG4gIH0gZWxzZSB7XG4gICAgcm91dGUucGF0aCA9IHBhcmVudFBhdGg7XG5cbiAgICBpZiAodHlwZSA9PT0gTm90Rm91bmRSb3V0ZS50eXBlKVxuICAgICAgcm91dGUucGF0aCArPSAnKic7XG4gIH1cblxuICByb3V0ZS5wYXJhbU5hbWVzID0gUGF0aC5leHRyYWN0UGFyYW1OYW1lcyhyb3V0ZS5wYXRoKTtcblxuICAvLyBNYWtlIHN1cmUgdGhlIHJvdXRlJ3MgcGF0aCBoYXMgYWxsIHBhcmFtcyBpdHMgcGFyZW50IG5lZWRzLlxuICBpZiAocGFyZW50Um91dGUgJiYgQXJyYXkuaXNBcnJheShwYXJlbnRSb3V0ZS5wYXJhbU5hbWVzKSkge1xuICAgIHBhcmVudFJvdXRlLnBhcmFtTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW1OYW1lKSB7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIHJvdXRlLnBhcmFtTmFtZXMuaW5kZXhPZihwYXJhbU5hbWUpICE9PSAtMSxcbiAgICAgICAgJ1RoZSBuZXN0ZWQgcm91dGUgcGF0aCBcIiVzXCIgaXMgbWlzc2luZyB0aGUgXCIlc1wiIHBhcmFtZXRlciBvZiBpdHMgcGFyZW50IHBhdGggXCIlc1wiJyxcbiAgICAgICAgcm91dGUucGF0aCwgcGFyYW1OYW1lLCBwYXJlbnRSb3V0ZS5wYXRoXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHRoZSByb3V0ZSBjYW4gYmUgbG9va2VkIHVwIGJ5IDxMaW5rPnMuXG4gIGlmIChwcm9wcy5uYW1lKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgbmFtZWRSb3V0ZXNbcHJvcHMubmFtZV0gPT0gbnVsbCxcbiAgICAgICdZb3UgY2Fubm90IHVzZSB0aGUgbmFtZSBcIiVzXCIgZm9yIG1vcmUgdGhhbiBvbmUgcm91dGUnLFxuICAgICAgcHJvcHMubmFtZVxuICAgICk7XG5cbiAgICBuYW1lZFJvdXRlc1twcm9wcy5uYW1lXSA9IHJvdXRlO1xuICB9XG5cbiAgLy8gSGFuZGxlIDxOb3RGb3VuZFJvdXRlPi5cbiAgaWYgKHR5cGUgPT09IE5vdEZvdW5kUm91dGUudHlwZSkge1xuICAgIGludmFyaWFudChcbiAgICAgIHBhcmVudFJvdXRlLFxuICAgICAgJzxOb3RGb3VuZFJvdXRlPiBtdXN0IGhhdmUgYSBwYXJlbnQgPFJvdXRlPidcbiAgICApO1xuXG4gICAgaW52YXJpYW50KFxuICAgICAgcGFyZW50Um91dGUubm90Rm91bmRSb3V0ZSA9PSBudWxsLFxuICAgICAgJ1lvdSBtYXkgbm90IGhhdmUgbW9yZSB0aGFuIG9uZSA8Tm90Rm91bmRSb3V0ZT4gcGVyIDxSb3V0ZT4nXG4gICAgKTtcblxuICAgIHBhcmVudFJvdXRlLm5vdEZvdW5kUm91dGUgPSByb3V0ZTtcblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gSGFuZGxlIDxEZWZhdWx0Um91dGU+LlxuICBpZiAodHlwZSA9PT0gRGVmYXVsdFJvdXRlLnR5cGUpIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBwYXJlbnRSb3V0ZSxcbiAgICAgICc8RGVmYXVsdFJvdXRlPiBtdXN0IGhhdmUgYSBwYXJlbnQgPFJvdXRlPidcbiAgICApO1xuXG4gICAgaW52YXJpYW50KFxuICAgICAgcGFyZW50Um91dGUuZGVmYXVsdFJvdXRlID09IG51bGwsXG4gICAgICAnWW91IG1heSBub3QgaGF2ZSBtb3JlIHRoYW4gb25lIDxEZWZhdWx0Um91dGU+IHBlciA8Um91dGU+J1xuICAgICk7XG5cbiAgICBwYXJlbnRSb3V0ZS5kZWZhdWx0Um91dGUgPSByb3V0ZTtcblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcm91dGUuY2hpbGRSb3V0ZXMgPSBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4sIHJvdXRlLCBuYW1lZFJvdXRlcyk7XG5cbiAgcmV0dXJuIHJvdXRlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYW4gYXJyYXkgb2Ygcm91dGUgb2JqZWN0cyBmcm9tIHRoZSBnaXZlbiBSZWFjdENoaWxkcmVuLlxuICovXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oY2hpbGRyZW4sIHBhcmVudFJvdXRlLCBuYW1lZFJvdXRlcykge1xuICB2YXIgcm91dGVzID0gW107XG5cbiAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgLy8gRXhjbHVkZSA8RGVmYXVsdFJvdXRlPnMgYW5kIDxOb3RGb3VuZFJvdXRlPnMuXG4gICAgaWYgKGNoaWxkID0gY3JlYXRlUm91dGUoY2hpbGQsIHBhcmVudFJvdXRlLCBuYW1lZFJvdXRlcykpXG4gICAgICByb3V0ZXMucHVzaChjaGlsZCk7XG4gIH0pO1xuXG4gIHJldHVybiByb3V0ZXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuO1xuIiwidmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9pbnZhcmlhbnQnKTtcbnZhciBjYW5Vc2VET00gPSByZXF1aXJlKCdyZWFjdC9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKS5jYW5Vc2VET007XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIHdpbmRvdyBhcyB7IHgsIHkgfS5cbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsUG9zaXRpb24oKSB7XG4gIGludmFyaWFudChcbiAgICBjYW5Vc2VET00sXG4gICAgJ0Nhbm5vdCBnZXQgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gd2l0aG91dCBhIERPTSdcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIHg6IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICB5OiB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFdpbmRvd1Njcm9sbFBvc2l0aW9uO1xuIiwiZnVuY3Rpb24gcmV2ZXJzZWRBcnJheShhcnJheSkge1xuICByZXR1cm4gYXJyYXkuc2xpY2UoMCkucmV2ZXJzZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJldmVyc2VkQXJyYXk7XG4iLCJ2YXIgY3JlYXRlUm91dGVyID0gcmVxdWlyZSgnLi9jcmVhdGVSb3V0ZXInKTtcblxuLyoqXG4gKiBBIGhpZ2gtbGV2ZWwgY29udmVuaWVuY2UgbWV0aG9kIHRoYXQgY3JlYXRlcywgY29uZmlndXJlcywgYW5kXG4gKiBydW5zIGEgcm91dGVyIGluIG9uZSBzaG90LiBUaGUgbWV0aG9kIHNpZ25hdHVyZSBpczpcbiAqXG4gKiAgIFJvdXRlci5ydW4ocm91dGVzWywgbG9jYXRpb24gXSwgY2FsbGJhY2spO1xuICpcbiAqIFVzaW5nIGB3aW5kb3cubG9jYXRpb24uaGFzaGAgdG8gbWFuYWdlIHRoZSBVUkwsIHlvdSBjb3VsZCBkbzpcbiAqXG4gKiAgIFJvdXRlci5ydW4ocm91dGVzLCBmdW5jdGlvbiAoSGFuZGxlcikge1xuICogICAgIFJlYWN0LnJlbmRlcig8SGFuZGxlci8+LCBkb2N1bWVudC5ib2R5KTtcbiAqICAgfSk7XG4gKiBcbiAqIFVzaW5nIEhUTUw1IGhpc3RvcnkgYW5kIGEgY3VzdG9tIFwiY3Vyc29yXCIgcHJvcDpcbiAqIFxuICogICBSb3V0ZXIucnVuKHJvdXRlcywgUm91dGVyLkhpc3RvcnlMb2NhdGlvbiwgZnVuY3Rpb24gKEhhbmRsZXIpIHtcbiAqICAgICBSZWFjdC5yZW5kZXIoPEhhbmRsZXIgY3Vyc29yPXtjdXJzb3J9Lz4sIGRvY3VtZW50LmJvZHkpO1xuICogICB9KTtcbiAqXG4gKiBSZXR1cm5zIHRoZSBuZXdseSBjcmVhdGVkIHJvdXRlci5cbiAqXG4gKiBOb3RlOiBJZiB5b3UgbmVlZCB0byBzcGVjaWZ5IGZ1cnRoZXIgb3B0aW9ucyBmb3IgeW91ciByb3V0ZXIgc3VjaFxuICogYXMgZXJyb3IvYWJvcnQgaGFuZGxpbmcgb3IgY3VzdG9tIHNjcm9sbCBiZWhhdmlvciwgdXNlIFJvdXRlci5jcmVhdGVcbiAqIGluc3RlYWQuXG4gKlxuICogICB2YXIgcm91dGVyID0gUm91dGVyLmNyZWF0ZShvcHRpb25zKTtcbiAqICAgcm91dGVyLnJ1bihmdW5jdGlvbiAoSGFuZGxlcikge1xuICogICAgIC8vIC4uLlxuICogICB9KTtcbiAqL1xuZnVuY3Rpb24gcnVuUm91dGVyKHJvdXRlcywgbG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgbG9jYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGxvY2F0aW9uO1xuICAgIGxvY2F0aW9uID0gbnVsbDtcbiAgfVxuXG4gIHZhciByb3V0ZXIgPSBjcmVhdGVSb3V0ZXIoe1xuICAgIHJvdXRlczogcm91dGVzLFxuICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICB9KTtcblxuICByb3V0ZXIucnVuKGNhbGxiYWNrKTtcblxuICByZXR1cm4gcm91dGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJ1blJvdXRlcjtcbiIsImZ1bmN0aW9uIHN1cHBvcnRzSGlzdG9yeSgpIHtcbiAgLyohIHRha2VuIGZyb20gbW9kZXJuaXpyXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2hpc3RvcnkuanNcbiAgICogY2hhbmdlZCB0byBhdm9pZCBmYWxzZSBuZWdhdGl2ZXMgZm9yIFdpbmRvd3MgUGhvbmVzOiBodHRwczovL2dpdGh1Yi5jb20vcmFja3QvcmVhY3Qtcm91dGVyL2lzc3Vlcy81ODZcbiAgICovXG4gIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIGlmICgodWEuaW5kZXhPZignQW5kcm9pZCAyLicpICE9PSAtMSB8fFxuICAgICAgKHVhLmluZGV4T2YoJ0FuZHJvaWQgNC4wJykgIT09IC0xKSkgJiZcbiAgICAgIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiZcbiAgICAgIHVhLmluZGV4T2YoJ0Nocm9tZScpID09PSAtMSAmJlxuICAgICAgdWEuaW5kZXhPZignV2luZG93cyBQaG9uZScpID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKHdpbmRvdy5oaXN0b3J5ICYmICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0c0hpc3Rvcnk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliJyk7XG4iLCIvLyBMb2FkIG1vZHVsZXNcblxudmFyIFN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vc3RyaW5naWZ5Jyk7XG52YXIgUGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJyk7XG5cblxuLy8gRGVjbGFyZSBpbnRlcm5hbHNcblxudmFyIGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHN0cmluZ2lmeTogU3RyaW5naWZ5LFxuICAgIHBhcnNlOiBQYXJzZVxufTtcbiIsIi8vIExvYWQgbW9kdWxlc1xuXG52YXIgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cblxuLy8gRGVjbGFyZSBpbnRlcm5hbHNcblxudmFyIGludGVybmFscyA9IHtcbiAgICBkZWxpbWl0ZXI6ICcmJyxcbiAgICBkZXB0aDogNSxcbiAgICBhcnJheUxpbWl0OiAyMCxcbiAgICBwYXJhbWV0ZXJMaW1pdDogMTAwMFxufTtcblxuXG5pbnRlcm5hbHMucGFyc2VWYWx1ZXMgPSBmdW5jdGlvbiAoc3RyLCBvcHRpb25zKSB7XG5cbiAgICB2YXIgb2JqID0ge307XG4gICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KG9wdGlvbnMuZGVsaW1pdGVyLCBvcHRpb25zLnBhcmFtZXRlckxpbWl0ID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IG9wdGlvbnMucGFyYW1ldGVyTGltaXQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gcGFydHMubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICB2YXIgcG9zID0gcGFydC5pbmRleE9mKCddPScpID09PSAtMSA/IHBhcnQuaW5kZXhPZignPScpIDogcGFydC5pbmRleE9mKCddPScpICsgMTtcblxuICAgICAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgICAgICAgb2JqW1V0aWxzLmRlY29kZShwYXJ0KV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBVdGlscy5kZWNvZGUocGFydC5zbGljZSgwLCBwb3MpKTtcbiAgICAgICAgICAgIHZhciB2YWwgPSBVdGlscy5kZWNvZGUocGFydC5zbGljZShwb3MgKyAxKSk7XG5cbiAgICAgICAgICAgIGlmICghb2JqW2tleV0pIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ialtrZXldID0gW10uY29uY2F0KG9ialtrZXldKS5jb25jYXQodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG5cbmludGVybmFscy5wYXJzZU9iamVjdCA9IGZ1bmN0aW9uIChjaGFpbiwgdmFsLCBvcHRpb25zKSB7XG5cbiAgICBpZiAoIWNoYWluLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIHZhciByb290ID0gY2hhaW4uc2hpZnQoKTtcblxuICAgIHZhciBvYmogPSB7fTtcbiAgICBpZiAocm9vdCA9PT0gJ1tdJykge1xuICAgICAgICBvYmogPSBbXTtcbiAgICAgICAgb2JqID0gb2JqLmNvbmNhdChpbnRlcm5hbHMucGFyc2VPYmplY3QoY2hhaW4sIHZhbCwgb3B0aW9ucykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGNsZWFuUm9vdCA9IHJvb3RbMF0gPT09ICdbJyAmJiByb290W3Jvb3QubGVuZ3RoIC0gMV0gPT09ICddJyA/IHJvb3Quc2xpY2UoMSwgcm9vdC5sZW5ndGggLSAxKSA6IHJvb3Q7XG4gICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KGNsZWFuUm9vdCwgMTApO1xuICAgICAgICBpZiAoIWlzTmFOKGluZGV4KSAmJlxuICAgICAgICAgICAgcm9vdCAhPT0gY2xlYW5Sb290ICYmXG4gICAgICAgICAgICBpbmRleCA8PSBvcHRpb25zLmFycmF5TGltaXQpIHtcblxuICAgICAgICAgICAgb2JqID0gW107XG4gICAgICAgICAgICBvYmpbaW5kZXhdID0gaW50ZXJuYWxzLnBhcnNlT2JqZWN0KGNoYWluLCB2YWwsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqW2NsZWFuUm9vdF0gPSBpbnRlcm5hbHMucGFyc2VPYmplY3QoY2hhaW4sIHZhbCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxuXG5pbnRlcm5hbHMucGFyc2VLZXlzID0gZnVuY3Rpb24gKGtleSwgdmFsLCBvcHRpb25zKSB7XG5cbiAgICBpZiAoIWtleSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGhlIHJlZ2V4IGNodW5rc1xuXG4gICAgdmFyIHBhcmVudCA9IC9eKFteXFxbXFxdXSopLztcbiAgICB2YXIgY2hpbGQgPSAvKFxcW1teXFxbXFxdXSpcXF0pL2c7XG5cbiAgICAvLyBHZXQgdGhlIHBhcmVudFxuXG4gICAgdmFyIHNlZ21lbnQgPSBwYXJlbnQuZXhlYyhrZXkpO1xuXG4gICAgLy8gRG9uJ3QgYWxsb3cgdGhlbSB0byBvdmVyd3JpdGUgb2JqZWN0IHByb3RvdHlwZSBwcm9wZXJ0aWVzXG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShzZWdtZW50WzFdKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU3Rhc2ggdGhlIHBhcmVudCBpZiBpdCBleGlzdHNcblxuICAgIHZhciBrZXlzID0gW107XG4gICAgaWYgKHNlZ21lbnRbMV0pIHtcbiAgICAgICAga2V5cy5wdXNoKHNlZ21lbnRbMV0pO1xuICAgIH1cblxuICAgIC8vIExvb3AgdGhyb3VnaCBjaGlsZHJlbiBhcHBlbmRpbmcgdG8gdGhlIGFycmF5IHVudGlsIHdlIGhpdCBkZXB0aFxuXG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlICgoc2VnbWVudCA9IGNoaWxkLmV4ZWMoa2V5KSkgIT09IG51bGwgJiYgaSA8IG9wdGlvbnMuZGVwdGgpIHtcblxuICAgICAgICArK2k7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShzZWdtZW50WzFdLnJlcGxhY2UoL1xcW3xcXF0vZywgJycpKSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKHNlZ21lbnRbMV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUncyBhIHJlbWFpbmRlciwganVzdCBhZGQgd2hhdGV2ZXIgaXMgbGVmdFxuXG4gICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAga2V5cy5wdXNoKCdbJyArIGtleS5zbGljZShzZWdtZW50LmluZGV4KSArICddJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFscy5wYXJzZU9iamVjdChrZXlzLCB2YWwsIG9wdGlvbnMpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIsIG9wdGlvbnMpIHtcblxuICAgIGlmIChzdHIgPT09ICcnIHx8XG4gICAgICAgIHN0ciA9PT0gbnVsbCB8fFxuICAgICAgICB0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJykge1xuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmRlbGltaXRlciA9IHR5cGVvZiBvcHRpb25zLmRlbGltaXRlciA9PT0gJ3N0cmluZycgfHwgVXRpbHMuaXNSZWdFeHAob3B0aW9ucy5kZWxpbWl0ZXIpID8gb3B0aW9ucy5kZWxpbWl0ZXIgOiBpbnRlcm5hbHMuZGVsaW1pdGVyO1xuICAgIG9wdGlvbnMuZGVwdGggPSB0eXBlb2Ygb3B0aW9ucy5kZXB0aCA9PT0gJ251bWJlcicgPyBvcHRpb25zLmRlcHRoIDogaW50ZXJuYWxzLmRlcHRoO1xuICAgIG9wdGlvbnMuYXJyYXlMaW1pdCA9IHR5cGVvZiBvcHRpb25zLmFycmF5TGltaXQgPT09ICdudW1iZXInID8gb3B0aW9ucy5hcnJheUxpbWl0IDogaW50ZXJuYWxzLmFycmF5TGltaXQ7XG4gICAgb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCA9IHR5cGVvZiBvcHRpb25zLnBhcmFtZXRlckxpbWl0ID09PSAnbnVtYmVyJyA/IG9wdGlvbnMucGFyYW1ldGVyTGltaXQgOiBpbnRlcm5hbHMucGFyYW1ldGVyTGltaXQ7XG5cbiAgICB2YXIgdGVtcE9iaiA9IHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnID8gaW50ZXJuYWxzLnBhcnNlVmFsdWVzKHN0ciwgb3B0aW9ucykgOiBzdHI7XG4gICAgdmFyIG9iaiA9IHt9O1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBrZXlzIGFuZCBzZXR1cCB0aGUgbmV3IG9iamVjdFxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0ZW1wT2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBrZXlzLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciBuZXdPYmogPSBpbnRlcm5hbHMucGFyc2VLZXlzKGtleSwgdGVtcE9ialtrZXldLCBvcHRpb25zKTtcbiAgICAgICAgb2JqID0gVXRpbHMubWVyZ2Uob2JqLCBuZXdPYmopO1xuICAgIH1cblxuICAgIHJldHVybiBVdGlscy5jb21wYWN0KG9iaik7XG59O1xuIiwiLy8gTG9hZCBtb2R1bGVzXG5cbnZhciBVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuXG4vLyBEZWNsYXJlIGludGVybmFsc1xuXG52YXIgaW50ZXJuYWxzID0ge1xuICAgIGRlbGltaXRlcjogJyYnXG59O1xuXG5cbmludGVybmFscy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAob2JqLCBwcmVmaXgpIHtcblxuICAgIGlmIChVdGlscy5pc0J1ZmZlcihvYmopKSB7XG4gICAgICAgIG9iaiA9IG9iai50b1N0cmluZygpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIG9iaiA9IG9iai50b0lTT1N0cmluZygpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgb2JqID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnIHx8XG4gICAgICAgIHR5cGVvZiBvYmogPT09ICdudW1iZXInIHx8XG4gICAgICAgIHR5cGVvZiBvYmogPT09ICdib29sZWFuJykge1xuXG4gICAgICAgIHJldHVybiBbZW5jb2RlVVJJQ29tcG9uZW50KHByZWZpeCkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqKV07XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQoaW50ZXJuYWxzLnN0cmluZ2lmeShvYmpba2V5XSwgcHJlZml4ICsgJ1snICsga2V5ICsgJ10nKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIG9wdGlvbnMpIHtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBkZWxpbWl0ZXIgPSB0eXBlb2Ygb3B0aW9ucy5kZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gaW50ZXJuYWxzLmRlbGltaXRlciA6IG9wdGlvbnMuZGVsaW1pdGVyO1xuXG4gICAgdmFyIGtleXMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoaW50ZXJuYWxzLnN0cmluZ2lmeShvYmpba2V5XSwga2V5KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ga2V5cy5qb2luKGRlbGltaXRlcik7XG59O1xuIiwiLy8gTG9hZCBtb2R1bGVzXG5cblxuLy8gRGVjbGFyZSBpbnRlcm5hbHNcblxudmFyIGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuYXJyYXlUb09iamVjdCA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcblxuICAgIHZhciBvYmogPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBzb3VyY2UubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcblxuICAgICAgICAgICAgb2JqW2ldID0gc291cmNlW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cblxuZXhwb3J0cy5tZXJnZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHNvdXJjZS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldFtpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2ldID0gZXhwb3J0cy5tZXJnZSh0YXJnZXRbaV0sIHNvdXJjZVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSBzb3VyY2VbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2goc291cmNlKTtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBleHBvcnRzLmFycmF5VG9PYmplY3QodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICBmb3IgKHZhciBrID0gMCwga2wgPSBrZXlzLmxlbmd0aDsgayA8IGtsOyArK2spIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNba107XG4gICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuXG4gICAgICAgICAgICBpZiAoIXRhcmdldFtrZXldKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gZXhwb3J0cy5tZXJnZSh0YXJnZXRba2V5XSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKHN0cikge1xuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIucmVwbGFjZSgvXFwrL2csICcgJykpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuY29tcGFjdCA9IGZ1bmN0aW9uIChvYmosIHJlZnMpIHtcblxuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICBvYmogPT09IG51bGwpIHtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHJlZnMgPSByZWZzIHx8IFtdO1xuICAgIHZhciBsb29rdXAgPSByZWZzLmluZGV4T2Yob2JqKTtcbiAgICBpZiAobG9va3VwICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gcmVmc1tsb29rdXBdO1xuICAgIH1cblxuICAgIHJlZnMucHVzaChvYmopO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICB2YXIgY29tcGFjdGVkID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9ialtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb21wYWN0ZWQucHVzaChvYmpbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXBhY3RlZDtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0ga2V5cy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBvYmpba2V5XSA9IGV4cG9ydHMuY29tcGFjdChvYmpba2V5XSwgcmVmcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cblxuZXhwb3J0cy5pc1JlZ0V4cCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufTtcblxuXG5leHBvcnRzLmlzQnVmZmVyID0gZnVuY3Rpb24gKG9iaikge1xuXG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuIiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG4vKiogQGF1dGhvciBCcmlhbiBDYXZhbGllciAqL1xuLyoqIEBhdXRob3IgSm9obiBIYW5uICovXG5cbihmdW5jdGlvbihkZWZpbmUpIHsgJ3VzZSBzdHJpY3QnO1xuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cblx0dmFyIG1ha2VQcm9taXNlID0gcmVxdWlyZSgnLi9tYWtlUHJvbWlzZScpO1xuXHR2YXIgU2NoZWR1bGVyID0gcmVxdWlyZSgnLi9TY2hlZHVsZXInKTtcblx0dmFyIGFzeW5jID0gcmVxdWlyZSgnLi9hc3luYycpO1xuXG5cdHJldHVybiBtYWtlUHJvbWlzZSh7XG5cdFx0c2NoZWR1bGVyOiBuZXcgU2NoZWR1bGVyKGFzeW5jKVxuXHR9KTtcblxufSk7XG59KSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbiAoZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH0pO1xuIiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG4vKiogQGF1dGhvciBCcmlhbiBDYXZhbGllciAqL1xuLyoqIEBhdXRob3IgSm9obiBIYW5uICovXG5cbihmdW5jdGlvbihkZWZpbmUpIHsgJ3VzZSBzdHJpY3QnO1xuZGVmaW5lKGZ1bmN0aW9uKCkge1xuXHQvKipcblx0ICogQ2lyY3VsYXIgcXVldWVcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNhcGFjaXR5UG93MiBwb3dlciBvZiAyIHRvIHdoaWNoIHRoaXMgcXVldWUncyBjYXBhY2l0eVxuXHQgKiAgd2lsbCBiZSBzZXQgaW5pdGlhbGx5LiBlZyB3aGVuIGNhcGFjaXR5UG93MiA9PSAzLCBxdWV1ZSBjYXBhY2l0eVxuXHQgKiAgd2lsbCBiZSA4LlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFF1ZXVlKGNhcGFjaXR5UG93Mikge1xuXHRcdHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IHRoaXMubGVuZ3RoID0gMDtcblx0XHR0aGlzLmJ1ZmZlciA9IG5ldyBBcnJheSgxIDw8IGNhcGFjaXR5UG93Mik7XG5cdH1cblxuXHRRdWV1ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKHgpIHtcblx0XHRpZih0aGlzLmxlbmd0aCA9PT0gdGhpcy5idWZmZXIubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLl9lbnN1cmVDYXBhY2l0eSh0aGlzLmxlbmd0aCAqIDIpO1xuXHRcdH1cblxuXHRcdHRoaXMuYnVmZmVyW3RoaXMudGFpbF0gPSB4O1xuXHRcdHRoaXMudGFpbCA9ICh0aGlzLnRhaWwgKyAxKSAmICh0aGlzLmJ1ZmZlci5sZW5ndGggLSAxKTtcblx0XHQrK3RoaXMubGVuZ3RoO1xuXHRcdHJldHVybiB0aGlzLmxlbmd0aDtcblx0fTtcblxuXHRRdWV1ZS5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgeCA9IHRoaXMuYnVmZmVyW3RoaXMuaGVhZF07XG5cdFx0dGhpcy5idWZmZXJbdGhpcy5oZWFkXSA9IHZvaWQgMDtcblx0XHR0aGlzLmhlYWQgPSAodGhpcy5oZWFkICsgMSkgJiAodGhpcy5idWZmZXIubGVuZ3RoIC0gMSk7XG5cdFx0LS10aGlzLmxlbmd0aDtcblx0XHRyZXR1cm4geDtcblx0fTtcblxuXHRRdWV1ZS5wcm90b3R5cGUuX2Vuc3VyZUNhcGFjaXR5ID0gZnVuY3Rpb24oY2FwYWNpdHkpIHtcblx0XHR2YXIgaGVhZCA9IHRoaXMuaGVhZDtcblx0XHR2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG5cdFx0dmFyIG5ld0J1ZmZlciA9IG5ldyBBcnJheShjYXBhY2l0eSk7XG5cdFx0dmFyIGkgPSAwO1xuXHRcdHZhciBsZW47XG5cblx0XHRpZihoZWFkID09PSAwKSB7XG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aDtcblx0XHRcdGZvcig7IGk8bGVuOyArK2kpIHtcblx0XHRcdFx0bmV3QnVmZmVyW2ldID0gYnVmZmVyW2ldO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYXBhY2l0eSA9IGJ1ZmZlci5sZW5ndGg7XG5cdFx0XHRsZW4gPSB0aGlzLnRhaWw7XG5cdFx0XHRmb3IoOyBoZWFkPGNhcGFjaXR5OyArK2ksICsraGVhZCkge1xuXHRcdFx0XHRuZXdCdWZmZXJbaV0gPSBidWZmZXJbaGVhZF07XG5cdFx0XHR9XG5cblx0XHRcdGZvcihoZWFkPTA7IGhlYWQ8bGVuOyArK2ksICsraGVhZCkge1xuXHRcdFx0XHRuZXdCdWZmZXJbaV0gPSBidWZmZXJbaGVhZF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5idWZmZXIgPSBuZXdCdWZmZXI7XG5cdFx0dGhpcy5oZWFkID0gMDtcblx0XHR0aGlzLnRhaWwgPSB0aGlzLmxlbmd0aDtcblx0fTtcblxuXHRyZXR1cm4gUXVldWU7XG5cbn0pO1xufSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbihmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpOyB9KSk7XG4iLCIvKiogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKGMpIGNvcHlyaWdodCAyMDEwLTIwMTQgb3JpZ2luYWwgYXV0aG9yIG9yIGF1dGhvcnMgKi9cbi8qKiBAYXV0aG9yIEJyaWFuIENhdmFsaWVyICovXG4vKiogQGF1dGhvciBKb2huIEhhbm4gKi9cblxuKGZ1bmN0aW9uKGRlZmluZSkgeyAndXNlIHN0cmljdCc7XG5kZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSkge1xuXG5cdHZhciBRdWV1ZSA9IHJlcXVpcmUoJy4vUXVldWUnKTtcblxuXHQvLyBDcmVkaXQgdG8gVHdpc29sIChodHRwczovL2dpdGh1Yi5jb20vVHdpc29sKSBmb3Igc3VnZ2VzdGluZ1xuXHQvLyB0aGlzIHR5cGUgb2YgZXh0ZW5zaWJsZSBxdWV1ZSArIHRyYW1wb2xpbmUgYXBwcm9hY2ggZm9yIG5leHQtdGljayBjb25mbGF0aW9uLlxuXG5cdC8qKlxuXHQgKiBBc3luYyB0YXNrIHNjaGVkdWxlclxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBhc3luYyBmdW5jdGlvbiB0byBzY2hlZHVsZSBhIHNpbmdsZSBhc3luYyBmdW5jdGlvblxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFNjaGVkdWxlcihhc3luYykge1xuXHRcdHRoaXMuX2FzeW5jID0gYXN5bmM7XG5cdFx0dGhpcy5fcXVldWUgPSBuZXcgUXVldWUoMTUpO1xuXHRcdHRoaXMuX2FmdGVyUXVldWUgPSBuZXcgUXVldWUoNSk7XG5cdFx0dGhpcy5fcnVubmluZyA9IGZhbHNlO1xuXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHRoaXMuZHJhaW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdHNlbGYuX2RyYWluKCk7XG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbnF1ZXVlIGEgdGFza1xuXHQgKiBAcGFyYW0ge3sgcnVuOmZ1bmN0aW9uIH19IHRhc2tcblx0ICovXG5cdFNjaGVkdWxlci5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uKHRhc2spIHtcblx0XHR0aGlzLl9hZGQodGhpcy5fcXVldWUsIHRhc2spO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbnF1ZXVlIGEgdGFzayB0byBydW4gYWZ0ZXIgdGhlIG1haW4gdGFzayBxdWV1ZVxuXHQgKiBAcGFyYW0ge3sgcnVuOmZ1bmN0aW9uIH19IHRhc2tcblx0ICovXG5cdFNjaGVkdWxlci5wcm90b3R5cGUuYWZ0ZXJRdWV1ZSA9IGZ1bmN0aW9uKHRhc2spIHtcblx0XHR0aGlzLl9hZGQodGhpcy5fYWZ0ZXJRdWV1ZSwgdGFzayk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYWluIHRoZSBoYW5kbGVyIHF1ZXVlIGVudGlyZWx5LCBhbmQgdGhlbiB0aGUgYWZ0ZXIgcXVldWVcblx0ICovXG5cdFNjaGVkdWxlci5wcm90b3R5cGUuX2RyYWluID0gZnVuY3Rpb24oKSB7XG5cdFx0cnVuUXVldWUodGhpcy5fcXVldWUpO1xuXHRcdHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcblx0XHRydW5RdWV1ZSh0aGlzLl9hZnRlclF1ZXVlKTtcblx0fTtcblxuXHQvKipcblx0ICogQWRkIGEgdGFzayB0byB0aGUgcSwgYW5kIHNjaGVkdWxlIGRyYWluIGlmIG5vdCBhbHJlYWR5IHNjaGVkdWxlZFxuXHQgKiBAcGFyYW0ge1F1ZXVlfSBxdWV1ZVxuXHQgKiBAcGFyYW0ge3tydW46ZnVuY3Rpb259fSB0YXNrXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRTY2hlZHVsZXIucHJvdG90eXBlLl9hZGQgPSBmdW5jdGlvbihxdWV1ZSwgdGFzaykge1xuXHRcdHF1ZXVlLnB1c2godGFzayk7XG5cdFx0aWYoIXRoaXMuX3J1bm5pbmcpIHtcblx0XHRcdHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuXHRcdFx0dGhpcy5fYXN5bmModGhpcy5kcmFpbik7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSdW4gYWxsIHRoZSB0YXNrcyBpbiB0aGUgcVxuXHQgKiBAcGFyYW0gcXVldWVcblx0ICovXG5cdGZ1bmN0aW9uIHJ1blF1ZXVlKHF1ZXVlKSB7XG5cdFx0d2hpbGUocXVldWUubGVuZ3RoID4gMCkge1xuXHRcdFx0cXVldWUuc2hpZnQoKS5ydW4oKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gU2NoZWR1bGVyO1xuXG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSk7IH0pKTtcbiIsIi8qKiBAbGljZW5zZSBNSVQgTGljZW5zZSAoYykgY29weXJpZ2h0IDIwMTAtMjAxNCBvcmlnaW5hbCBhdXRob3Igb3IgYXV0aG9ycyAqL1xuLyoqIEBhdXRob3IgQnJpYW4gQ2F2YWxpZXIgKi9cbi8qKiBAYXV0aG9yIEpvaG4gSGFubiAqL1xuXG4oZnVuY3Rpb24oZGVmaW5lKSB7ICd1c2Ugc3RyaWN0JztcbmRlZmluZShmdW5jdGlvbihyZXF1aXJlKSB7XG5cblx0Ly8gU25pZmYgXCJiZXN0XCIgYXN5bmMgc2NoZWR1bGluZyBvcHRpb25cblx0Ly8gUHJlZmVyIHByb2Nlc3MubmV4dFRpY2sgb3IgTXV0YXRpb25PYnNlcnZlciwgdGhlbiBjaGVjayBmb3Jcblx0Ly8gdmVydHggYW5kIGZpbmFsbHkgZmFsbCBiYWNrIHRvIHNldFRpbWVvdXRcblxuXHQvKmpzaGludCBtYXhjb21wbGV4aXR5OjYqL1xuXHQvKmdsb2JhbCBwcm9jZXNzLGRvY3VtZW50LHNldFRpbWVvdXQsTXV0YXRpb25PYnNlcnZlcixXZWJLaXRNdXRhdGlvbk9ic2VydmVyKi9cblx0dmFyIG5leHRUaWNrLCBNdXRhdGlvbk9icztcblxuXHRpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MgIT09IG51bGwgJiZcblx0XHR0eXBlb2YgcHJvY2Vzcy5uZXh0VGljayA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdG5leHRUaWNrID0gZnVuY3Rpb24oZikge1xuXHRcdFx0cHJvY2Vzcy5uZXh0VGljayhmKTtcblx0XHR9O1xuXG5cdH0gZWxzZSBpZiAoTXV0YXRpb25PYnMgPVxuXHRcdCh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBNdXRhdGlvbk9ic2VydmVyKSB8fFxuXHRcdCh0eXBlb2YgV2ViS2l0TXV0YXRpb25PYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBXZWJLaXRNdXRhdGlvbk9ic2VydmVyKSkge1xuXHRcdG5leHRUaWNrID0gKGZ1bmN0aW9uIChkb2N1bWVudCwgTXV0YXRpb25PYnNlcnZlcikge1xuXHRcdFx0dmFyIHNjaGVkdWxlZDtcblx0XHRcdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0dmFyIG8gPSBuZXcgTXV0YXRpb25PYnNlcnZlcihydW4pO1xuXHRcdFx0by5vYnNlcnZlKGVsLCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG5cblx0XHRcdGZ1bmN0aW9uIHJ1bigpIHtcblx0XHRcdFx0dmFyIGYgPSBzY2hlZHVsZWQ7XG5cdFx0XHRcdHNjaGVkdWxlZCA9IHZvaWQgMDtcblx0XHRcdFx0ZigpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGYpIHtcblx0XHRcdFx0c2NoZWR1bGVkID0gZjtcblx0XHRcdFx0ZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsICd4Jyk7XG5cdFx0XHR9O1xuXHRcdH0oZG9jdW1lbnQsIE11dGF0aW9uT2JzKSk7XG5cblx0fSBlbHNlIHtcblx0XHRuZXh0VGljayA9IChmdW5jdGlvbihjanNSZXF1aXJlKSB7XG5cdFx0XHR2YXIgdmVydHg7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyB2ZXJ0LnggMS54IHx8IDIueFxuXHRcdFx0XHR2ZXJ0eCA9IGNqc1JlcXVpcmUoJ3ZlcnR4Jyk7XG5cdFx0XHR9IGNhdGNoIChpZ25vcmUpIHt9XG5cblx0XHRcdGlmICh2ZXJ0eCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIHZlcnR4LnJ1bk9uTG9vcCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdHJldHVybiB2ZXJ0eC5ydW5Pbkxvb3A7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR5cGVvZiB2ZXJ0eC5ydW5PbkNvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRyZXR1cm4gdmVydHgucnVuT25Db250ZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNhcHR1cmUgc2V0VGltZW91dCB0byBhdm9pZCBiZWluZyBjYXVnaHQgYnkgZmFrZSB0aW1lcnNcblx0XHRcdC8vIHVzZWQgaW4gdGltZSBiYXNlZCB0ZXN0c1xuXHRcdFx0dmFyIGNhcHR1cmVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKHQpIHtcblx0XHRcdFx0Y2FwdHVyZWRTZXRUaW1lb3V0KHQsIDApO1xuXHRcdFx0fTtcblx0XHR9KHJlcXVpcmUpKTtcblx0fVxuXG5cdHJldHVybiBuZXh0VGljaztcbn0pO1xufSh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUgOiBmdW5jdGlvbihmYWN0b3J5KSB7IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKTsgfSkpO1xuIiwiLyoqIEBsaWNlbnNlIE1JVCBMaWNlbnNlIChjKSBjb3B5cmlnaHQgMjAxMC0yMDE0IG9yaWdpbmFsIGF1dGhvciBvciBhdXRob3JzICovXG4vKiogQGF1dGhvciBCcmlhbiBDYXZhbGllciAqL1xuLyoqIEBhdXRob3IgSm9obiBIYW5uICovXG5cbihmdW5jdGlvbihkZWZpbmUpIHsgJ3VzZSBzdHJpY3QnO1xuZGVmaW5lKGZ1bmN0aW9uKCkge1xuXG5cdHJldHVybiBmdW5jdGlvbiBtYWtlUHJvbWlzZShlbnZpcm9ubWVudCkge1xuXG5cdFx0dmFyIHRhc2tzID0gZW52aXJvbm1lbnQuc2NoZWR1bGVyO1xuXG5cdFx0dmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHxcblx0XHRcdGZ1bmN0aW9uKHByb3RvKSB7XG5cdFx0XHRcdGZ1bmN0aW9uIENoaWxkKCkge31cblx0XHRcdFx0Q2hpbGQucHJvdG90eXBlID0gcHJvdG87XG5cdFx0XHRcdHJldHVybiBuZXcgQ2hpbGQoKTtcblx0XHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGUgYSBwcm9taXNlIHdob3NlIGZhdGUgaXMgZGV0ZXJtaW5lZCBieSByZXNvbHZlclxuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlXG5cdFx0ICogQG5hbWUgUHJvbWlzZVxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIsIGhhbmRsZXIpIHtcblx0XHRcdHRoaXMuX2hhbmRsZXIgPSByZXNvbHZlciA9PT0gSGFuZGxlciA/IGhhbmRsZXIgOiBpbml0KHJlc29sdmVyKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBSdW4gdGhlIHN1cHBsaWVkIHJlc29sdmVyXG5cdFx0ICogQHBhcmFtIHJlc29sdmVyXG5cdFx0ICogQHJldHVybnMge1BlbmRpbmd9XG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gaW5pdChyZXNvbHZlcikge1xuXHRcdFx0dmFyIGhhbmRsZXIgPSBuZXcgUGVuZGluZygpO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXNvbHZlcihwcm9taXNlUmVzb2x2ZSwgcHJvbWlzZVJlamVjdCwgcHJvbWlzZU5vdGlmeSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHByb21pc2VSZWplY3QoZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBoYW5kbGVyO1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRyYW5zaXRpb24gZnJvbSBwcmUtcmVzb2x1dGlvbiBzdGF0ZSB0byBwb3N0LXJlc29sdXRpb24gc3RhdGUsIG5vdGlmeWluZ1xuXHRcdFx0ICogYWxsIGxpc3RlbmVycyBvZiB0aGUgdWx0aW1hdGUgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uXG5cdFx0XHQgKiBAcGFyYW0geyp9IHggcmVzb2x1dGlvbiB2YWx1ZVxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBwcm9taXNlUmVzb2x2ZSAoeCkge1xuXHRcdFx0XHRoYW5kbGVyLnJlc29sdmUoeCk7XG5cdFx0XHR9XG5cdFx0XHQvKipcblx0XHRcdCAqIFJlamVjdCB0aGlzIHByb21pc2Ugd2l0aCByZWFzb24sIHdoaWNoIHdpbGwgYmUgdXNlZCB2ZXJiYXRpbVxuXHRcdFx0ICogQHBhcmFtIHtFcnJvcnwqfSByZWFzb24gcmVqZWN0aW9uIHJlYXNvbiwgc3Ryb25nbHkgc3VnZ2VzdGVkXG5cdFx0XHQgKiAgIHRvIGJlIGFuIEVycm9yIHR5cGVcblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gcHJvbWlzZVJlamVjdCAocmVhc29uKSB7XG5cdFx0XHRcdGhhbmRsZXIucmVqZWN0KHJlYXNvbik7XG5cdFx0XHR9XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogSXNzdWUgYSBwcm9ncmVzcyBldmVudCwgbm90aWZ5aW5nIGFsbCBwcm9ncmVzcyBsaXN0ZW5lcnNcblx0XHRcdCAqIEBwYXJhbSB7Kn0geCBwcm9ncmVzcyBldmVudCBwYXlsb2FkIHRvIHBhc3MgdG8gYWxsIGxpc3RlbmVyc1xuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBwcm9taXNlTm90aWZ5ICh4KSB7XG5cdFx0XHRcdGhhbmRsZXIubm90aWZ5KHgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENyZWF0aW9uXG5cblx0XHRQcm9taXNlLnJlc29sdmUgPSByZXNvbHZlO1xuXHRcdFByb21pc2UucmVqZWN0ID0gcmVqZWN0O1xuXHRcdFByb21pc2UubmV2ZXIgPSBuZXZlcjtcblxuXHRcdFByb21pc2UuX2RlZmVyID0gZGVmZXI7XG5cdFx0UHJvbWlzZS5faGFuZGxlciA9IGdldEhhbmRsZXI7XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGEgdHJ1c3RlZCBwcm9taXNlLiBJZiB4IGlzIGFscmVhZHkgYSB0cnVzdGVkIHByb21pc2UsIGl0IGlzXG5cdFx0ICogcmV0dXJuZWQsIG90aGVyd2lzZSByZXR1cm5zIGEgbmV3IHRydXN0ZWQgUHJvbWlzZSB3aGljaCBmb2xsb3dzIHguXG5cdFx0ICogQHBhcmFtICB7Kn0geFxuXHRcdCAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Vcblx0XHQgKi9cblx0XHRmdW5jdGlvbiByZXNvbHZlKHgpIHtcblx0XHRcdHJldHVybiBpc1Byb21pc2UoeCkgPyB4XG5cdFx0XHRcdDogbmV3IFByb21pc2UoSGFuZGxlciwgbmV3IEFzeW5jKGdldEhhbmRsZXIoeCkpKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm4gYSByZWplY3QgcHJvbWlzZSB3aXRoIHggYXMgaXRzIHJlYXNvbiAoeCBpcyB1c2VkIHZlcmJhdGltKVxuXHRcdCAqIEBwYXJhbSB7Kn0geFxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSByZWplY3RlZCBwcm9taXNlXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gcmVqZWN0KHgpIHtcblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShIYW5kbGVyLCBuZXcgQXN5bmMobmV3IFJlamVjdGVkKHgpKSk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGEgcHJvbWlzZSB0aGF0IHJlbWFpbnMgcGVuZGluZyBmb3JldmVyXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9IGZvcmV2ZXItcGVuZGluZyBwcm9taXNlLlxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIG5ldmVyKCkge1xuXHRcdFx0cmV0dXJuIGZvcmV2ZXJQZW5kaW5nUHJvbWlzZTsgLy8gU2hvdWxkIGJlIGZyb3plblxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgYW4gaW50ZXJuYWwge3Byb21pc2UsIHJlc29sdmVyfSBwYWlyXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX1cblx0XHQgKi9cblx0XHRmdW5jdGlvbiBkZWZlcigpIHtcblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShIYW5kbGVyLCBuZXcgUGVuZGluZygpKTtcblx0XHR9XG5cblx0XHQvLyBUcmFuc2Zvcm1hdGlvbiBhbmQgZmxvdyBjb250cm9sXG5cblx0XHQvKipcblx0XHQgKiBUcmFuc2Zvcm0gdGhpcyBwcm9taXNlJ3MgZnVsZmlsbG1lbnQgdmFsdWUsIHJldHVybmluZyBhIG5ldyBQcm9taXNlXG5cdFx0ICogZm9yIHRoZSB0cmFuc2Zvcm1lZCByZXN1bHQuICBJZiB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLCBvblJlamVjdGVkXG5cdFx0ICogaXMgY2FsbGVkIHdpdGggdGhlIHJlYXNvbi4gIG9uUHJvZ3Jlc3MgKm1heSogYmUgY2FsbGVkIHdpdGggdXBkYXRlcyB0b3dhcmRcblx0XHQgKiB0aGlzIHByb21pc2UncyBmdWxmaWxsbWVudC5cblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9uPX0gb25GdWxmaWxsZWQgZnVsZmlsbG1lbnQgaGFuZGxlclxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb249fSBvblJlamVjdGVkIHJlamVjdGlvbiBoYW5kbGVyXG5cdFx0ICogQGRlcHJlY2F0ZWQgQHBhcmFtIHtmdW5jdGlvbj19IG9uUHJvZ3Jlc3MgcHJvZ3Jlc3MgaGFuZGxlclxuXHRcdCAqIEByZXR1cm4ge1Byb21pc2V9IG5ldyBwcm9taXNlXG5cdFx0ICovXG5cdFx0UHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5faGFuZGxlcjtcblx0XHRcdHZhciBzdGF0ZSA9IHBhcmVudC5qb2luKCkuc3RhdGUoKTtcblxuXHRcdFx0aWYgKCh0eXBlb2Ygb25GdWxmaWxsZWQgIT09ICdmdW5jdGlvbicgJiYgc3RhdGUgPiAwKSB8fFxuXHRcdFx0XHQodHlwZW9mIG9uUmVqZWN0ZWQgIT09ICdmdW5jdGlvbicgJiYgc3RhdGUgPCAwKSkge1xuXHRcdFx0XHQvLyBTaG9ydCBjaXJjdWl0OiB2YWx1ZSB3aWxsIG5vdCBjaGFuZ2UsIHNpbXBseSBzaGFyZSBoYW5kbGVyXG5cdFx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcihIYW5kbGVyLCBwYXJlbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcCA9IHRoaXMuX2JlZ2V0KCk7XG5cdFx0XHR2YXIgY2hpbGQgPSBwLl9oYW5kbGVyO1xuXG5cdFx0XHRwYXJlbnQuY2hhaW4oY2hpbGQsIHBhcmVudC5yZWNlaXZlciwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsXG5cdFx0XHRcdFx0YXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB2b2lkIDApO1xuXG5cdFx0XHRyZXR1cm4gcDtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogSWYgdGhpcyBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQgZHVlIHRvIGFuIGVycm9yLCBjYWxsIG9uUmVqZWN0ZWQgdG9cblx0XHQgKiBoYW5kbGUgdGhlIGVycm9yLiBTaG9ydGN1dCBmb3IgLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKVxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb24/fSBvblJlamVjdGVkXG5cdFx0ICogQHJldHVybiB7UHJvbWlzZX1cblx0XHQgKi9cblx0XHRQcm9taXNlLnByb3RvdHlwZVsnY2F0Y2gnXSA9IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpIHtcblx0XHRcdHJldHVybiB0aGlzLnRoZW4odm9pZCAwLCBvblJlamVjdGVkKTtcblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlcyBhIG5ldywgcGVuZGluZyBwcm9taXNlIG9mIHRoZSBzYW1lIHR5cGUgYXMgdGhpcyBwcm9taXNlXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAcmV0dXJucyB7UHJvbWlzZX1cblx0XHQgKi9cblx0XHRQcm9taXNlLnByb3RvdHlwZS5fYmVnZXQgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLl9oYW5kbGVyO1xuXHRcdFx0dmFyIGNoaWxkID0gbmV3IFBlbmRpbmcocGFyZW50LnJlY2VpdmVyLCBwYXJlbnQuam9pbigpLmNvbnRleHQpO1xuXHRcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKEhhbmRsZXIsIGNoaWxkKTtcblx0XHR9O1xuXG5cdFx0Ly8gQXJyYXkgY29tYmluYXRvcnNcblxuXHRcdFByb21pc2UuYWxsID0gYWxsO1xuXHRcdFByb21pc2UucmFjZSA9IHJhY2U7XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCBmdWxmaWxsIHdoZW4gYWxsIHByb21pc2VzIGluIHRoZVxuXHRcdCAqIGlucHV0IGFycmF5IGhhdmUgZnVsZmlsbGVkLCBvciB3aWxsIHJlamVjdCB3aGVuIG9uZSBvZiB0aGVcblx0XHQgKiBwcm9taXNlcyByZWplY3RzLlxuXHRcdCAqIEBwYXJhbSB7YXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzXG5cdFx0ICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2UgZm9yIGFycmF5IG9mIGZ1bGZpbGxtZW50IHZhbHVlc1xuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuXHRcdFx0Lypqc2hpbnQgbWF4Y29tcGxleGl0eTo4Ki9cblx0XHRcdHZhciByZXNvbHZlciA9IG5ldyBQZW5kaW5nKCk7XG5cdFx0XHR2YXIgcGVuZGluZyA9IHByb21pc2VzLmxlbmd0aCA+Pj4gMDtcblx0XHRcdHZhciByZXN1bHRzID0gbmV3IEFycmF5KHBlbmRpbmcpO1xuXG5cdFx0XHR2YXIgaSwgaCwgeCwgcztcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBwcm9taXNlcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR4ID0gcHJvbWlzZXNbaV07XG5cblx0XHRcdFx0aWYgKHggPT09IHZvaWQgMCAmJiAhKGkgaW4gcHJvbWlzZXMpKSB7XG5cdFx0XHRcdFx0LS1wZW5kaW5nO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG1heWJlVGhlbmFibGUoeCkpIHtcblx0XHRcdFx0XHRoID0gZ2V0SGFuZGxlck1heWJlVGhlbmFibGUoeCk7XG5cblx0XHRcdFx0XHRzID0gaC5zdGF0ZSgpO1xuXHRcdFx0XHRcdGlmIChzID09PSAwKSB7XG5cdFx0XHRcdFx0XHRoLmZvbGQoc2V0dGxlQXQsIGksIHJlc3VsdHMsIHJlc29sdmVyKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHMgPiAwKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzW2ldID0gaC52YWx1ZTtcblx0XHRcdFx0XHRcdC0tcGVuZGluZztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dW5yZXBvcnRSZW1haW5pbmcocHJvbWlzZXMsIGkrMSwgaCk7XG5cdFx0XHRcdFx0XHRyZXNvbHZlci5iZWNvbWUoaCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXN1bHRzW2ldID0geDtcblx0XHRcdFx0XHQtLXBlbmRpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYocGVuZGluZyA9PT0gMCkge1xuXHRcdFx0XHRyZXNvbHZlci5iZWNvbWUobmV3IEZ1bGZpbGxlZChyZXN1bHRzKSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShIYW5kbGVyLCByZXNvbHZlcik7XG5cblx0XHRcdGZ1bmN0aW9uIHNldHRsZUF0KGksIHgsIHJlc29sdmVyKSB7XG5cdFx0XHRcdC8qanNoaW50IHZhbGlkdGhpczp0cnVlKi9cblx0XHRcdFx0dGhpc1tpXSA9IHg7XG5cdFx0XHRcdGlmKC0tcGVuZGluZyA9PT0gMCkge1xuXHRcdFx0XHRcdHJlc29sdmVyLmJlY29tZShuZXcgRnVsZmlsbGVkKHRoaXMpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVucmVwb3J0UmVtYWluaW5nKHByb21pc2VzLCBzdGFydCwgcmVqZWN0ZWRIYW5kbGVyKSB7XG5cdFx0XHR2YXIgaSwgaCwgeDtcblx0XHRcdGZvcihpPXN0YXJ0OyBpPHByb21pc2VzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHggPSBwcm9taXNlc1tpXTtcblx0XHRcdFx0aWYobWF5YmVUaGVuYWJsZSh4KSkge1xuXHRcdFx0XHRcdGggPSBnZXRIYW5kbGVyTWF5YmVUaGVuYWJsZSh4KTtcblxuXHRcdFx0XHRcdGlmKGggIT09IHJlamVjdGVkSGFuZGxlcikge1xuXHRcdFx0XHRcdFx0aC52aXNpdChoLCB2b2lkIDAsIGguX3VucmVwb3J0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBGdWxmaWxsLXJlamVjdCBjb21wZXRpdGl2ZSByYWNlLiBSZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCBzZXR0bGVcblx0XHQgKiB0byB0aGUgc2FtZSBzdGF0ZSBhcyB0aGUgZWFybGllc3QgaW5wdXQgcHJvbWlzZSB0byBzZXR0bGUuXG5cdFx0ICpcblx0XHQgKiBXQVJOSU5HOiBUaGUgRVM2IFByb21pc2Ugc3BlYyByZXF1aXJlcyB0aGF0IHJhY2UoKWluZyBhbiBlbXB0eSBhcnJheVxuXHRcdCAqIG11c3QgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IGlzIHBlbmRpbmcgZm9yZXZlci4gIFRoaXMgaW1wbGVtZW50YXRpb25cblx0XHQgKiByZXR1cm5zIGEgc2luZ2xldG9uIGZvcmV2ZXItcGVuZGluZyBwcm9taXNlLCB0aGUgc2FtZSBzaW5nbGV0b24gdGhhdCBpc1xuXHRcdCAqIHJldHVybmVkIGJ5IFByb21pc2UubmV2ZXIoKSwgdGh1cyBjYW4gYmUgY2hlY2tlZCB3aXRoID09PVxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHthcnJheX0gcHJvbWlzZXMgYXJyYXkgb2YgcHJvbWlzZXMgdG8gcmFjZVxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlfSBpZiBpbnB1dCBpcyBub24tZW1wdHksIGEgcHJvbWlzZSB0aGF0IHdpbGwgc2V0dGxlXG5cdFx0ICogdG8gdGhlIHNhbWUgb3V0Y29tZSBhcyB0aGUgZWFybGllc3QgaW5wdXQgcHJvbWlzZSB0byBzZXR0bGUuIGlmIGVtcHR5XG5cdFx0ICogaXMgZW1wdHksIHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBuZXZlciBzZXR0bGUuXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gcmFjZShwcm9taXNlcykge1xuXHRcdFx0Ly8gU2lnaCwgcmFjZShbXSkgaXMgdW50ZXN0YWJsZSB1bmxlc3Mgd2UgcmV0dXJuICpzb21ldGhpbmcqXG5cdFx0XHQvLyB0aGF0IGlzIHJlY29nbml6YWJsZSB3aXRob3V0IGNhbGxpbmcgLnRoZW4oKSBvbiBpdC5cblx0XHRcdGlmKE9iamVjdChwcm9taXNlcykgPT09IHByb21pc2VzICYmIHByb21pc2VzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gbmV2ZXIoKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGggPSBuZXcgUGVuZGluZygpO1xuXHRcdFx0dmFyIGksIHg7XG5cdFx0XHRmb3IoaT0wOyBpPHByb21pc2VzLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHggPSBwcm9taXNlc1tpXTtcblx0XHRcdFx0aWYgKHggIT09IHZvaWQgMCAmJiBpIGluIHByb21pc2VzKSB7XG5cdFx0XHRcdFx0Z2V0SGFuZGxlcih4KS52aXNpdChoLCBoLnJlc29sdmUsIGgucmVqZWN0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKEhhbmRsZXIsIGgpO1xuXHRcdH1cblxuXHRcdC8vIFByb21pc2UgaW50ZXJuYWxzXG5cdFx0Ly8gQmVsb3cgdGhpcywgZXZlcnl0aGluZyBpcyBAcHJpdmF0ZVxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IGFuIGFwcHJvcHJpYXRlIGhhbmRsZXIgZm9yIHgsIHdpdGhvdXQgY2hlY2tpbmcgZm9yIGN5Y2xlc1xuXHRcdCAqIEBwYXJhbSB7Kn0geFxuXHRcdCAqIEByZXR1cm5zIHtvYmplY3R9IGhhbmRsZXJcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBnZXRIYW5kbGVyKHgpIHtcblx0XHRcdGlmKGlzUHJvbWlzZSh4KSkge1xuXHRcdFx0XHRyZXR1cm4geC5faGFuZGxlci5qb2luKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF5YmVUaGVuYWJsZSh4KSA/IGdldEhhbmRsZXJVbnRydXN0ZWQoeCkgOiBuZXcgRnVsZmlsbGVkKHgpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEdldCBhIGhhbmRsZXIgZm9yIHRoZW5hYmxlIHguXG5cdFx0ICogTk9URTogWW91IG11c3Qgb25seSBjYWxsIHRoaXMgaWYgbWF5YmVUaGVuYWJsZSh4KSA9PSB0cnVlXG5cdFx0ICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb258UHJvbWlzZX0geFxuXHRcdCAqIEByZXR1cm5zIHtvYmplY3R9IGhhbmRsZXJcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBnZXRIYW5kbGVyTWF5YmVUaGVuYWJsZSh4KSB7XG5cdFx0XHRyZXR1cm4gaXNQcm9taXNlKHgpID8geC5faGFuZGxlci5qb2luKCkgOiBnZXRIYW5kbGVyVW50cnVzdGVkKHgpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEdldCBhIGhhbmRsZXIgZm9yIHBvdGVudGlhbGx5IHVudHJ1c3RlZCB0aGVuYWJsZSB4XG5cdFx0ICogQHBhcmFtIHsqfSB4XG5cdFx0ICogQHJldHVybnMge29iamVjdH0gaGFuZGxlclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIGdldEhhbmRsZXJVbnRydXN0ZWQoeCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIHVudHJ1c3RlZFRoZW4gPSB4LnRoZW47XG5cdFx0XHRcdHJldHVybiB0eXBlb2YgdW50cnVzdGVkVGhlbiA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0XHRcdD8gbmV3IFRoZW5hYmxlKHVudHJ1c3RlZFRoZW4sIHgpXG5cdFx0XHRcdFx0OiBuZXcgRnVsZmlsbGVkKHgpO1xuXHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgUmVqZWN0ZWQoZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlciBmb3IgYSBwcm9taXNlIHRoYXQgaXMgcGVuZGluZyBmb3JldmVyXG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gSGFuZGxlcigpIHt9XG5cblx0XHRIYW5kbGVyLnByb3RvdHlwZS53aGVuXG5cdFx0XHQ9IEhhbmRsZXIucHJvdG90eXBlLmJlY29tZVxuXHRcdFx0PSBIYW5kbGVyLnByb3RvdHlwZS5ub3RpZnlcblx0XHRcdD0gSGFuZGxlci5wcm90b3R5cGUuZmFpbFxuXHRcdFx0PSBIYW5kbGVyLnByb3RvdHlwZS5fdW5yZXBvcnRcblx0XHRcdD0gSGFuZGxlci5wcm90b3R5cGUuX3JlcG9ydFxuXHRcdFx0PSBub29wO1xuXG5cdFx0SGFuZGxlci5wcm90b3R5cGUuX3N0YXRlID0gMDtcblxuXHRcdEhhbmRsZXIucHJvdG90eXBlLnN0YXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc3RhdGU7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFJlY3Vyc2l2ZWx5IGNvbGxhcHNlIGhhbmRsZXIgY2hhaW4gdG8gZmluZCB0aGUgaGFuZGxlclxuXHRcdCAqIG5lYXJlc3QgdG8gdGhlIGZ1bGx5IHJlc29sdmVkIHZhbHVlLlxuXHRcdCAqIEByZXR1cm5zIHtvYmplY3R9IGhhbmRsZXIgbmVhcmVzdCB0aGUgZnVsbHkgcmVzb2x2ZWQgdmFsdWVcblx0XHQgKi9cblx0XHRIYW5kbGVyLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaCA9IHRoaXM7XG5cdFx0XHR3aGlsZShoLmhhbmRsZXIgIT09IHZvaWQgMCkge1xuXHRcdFx0XHRoID0gaC5oYW5kbGVyO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGg7XG5cdFx0fTtcblxuXHRcdEhhbmRsZXIucHJvdG90eXBlLmNoYWluID0gZnVuY3Rpb24odG8sIHJlY2VpdmVyLCBmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcykge1xuXHRcdFx0dGhpcy53aGVuKHtcblx0XHRcdFx0cmVzb2x2ZXI6IHRvLFxuXHRcdFx0XHRyZWNlaXZlcjogcmVjZWl2ZXIsXG5cdFx0XHRcdGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuXHRcdFx0XHRyZWplY3RlZDogcmVqZWN0ZWQsXG5cdFx0XHRcdHByb2dyZXNzOiBwcm9ncmVzc1xuXHRcdFx0fSk7XG5cdFx0fTtcblxuXHRcdEhhbmRsZXIucHJvdG90eXBlLnZpc2l0ID0gZnVuY3Rpb24ocmVjZWl2ZXIsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKSB7XG5cdFx0XHR0aGlzLmNoYWluKGZhaWxJZlJlamVjdGVkLCByZWNlaXZlciwgZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpO1xuXHRcdH07XG5cblx0XHRIYW5kbGVyLnByb3RvdHlwZS5mb2xkID0gZnVuY3Rpb24oZiwgeiwgYywgdG8pIHtcblx0XHRcdHRoaXMudmlzaXQodG8sIGZ1bmN0aW9uKHgpIHtcblx0XHRcdFx0Zi5jYWxsKGMsIHosIHgsIHRoaXMpO1xuXHRcdFx0fSwgdG8ucmVqZWN0LCB0by5ub3RpZnkpO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGVyIHRoYXQgaW52b2tlcyBmYWlsKCkgb24gYW55IGhhbmRsZXIgaXQgYmVjb21lc1xuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIEZhaWxJZlJlamVjdGVkKCkge31cblxuXHRcdGluaGVyaXQoSGFuZGxlciwgRmFpbElmUmVqZWN0ZWQpO1xuXG5cdFx0RmFpbElmUmVqZWN0ZWQucHJvdG90eXBlLmJlY29tZSA9IGZ1bmN0aW9uKGgpIHtcblx0XHRcdGguZmFpbCgpO1xuXHRcdH07XG5cblx0XHR2YXIgZmFpbElmUmVqZWN0ZWQgPSBuZXcgRmFpbElmUmVqZWN0ZWQoKTtcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXIgdGhhdCBtYW5hZ2VzIGEgcXVldWUgb2YgY29uc3VtZXJzIHdhaXRpbmcgb24gYSBwZW5kaW5nIHByb21pc2Vcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBQZW5kaW5nKHJlY2VpdmVyLCBpbmhlcml0ZWRDb250ZXh0KSB7XG5cdFx0XHRQcm9taXNlLmNyZWF0ZUNvbnRleHQodGhpcywgaW5oZXJpdGVkQ29udGV4dCk7XG5cblx0XHRcdHRoaXMuY29uc3VtZXJzID0gdm9pZCAwO1xuXHRcdFx0dGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuXHRcdFx0dGhpcy5oYW5kbGVyID0gdm9pZCAwO1xuXHRcdFx0dGhpcy5yZXNvbHZlZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGluaGVyaXQoSGFuZGxlciwgUGVuZGluZyk7XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS5fc3RhdGUgPSAwO1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdHRoaXMuYmVjb21lKGdldEhhbmRsZXIoeCkpO1xuXHRcdH07XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbih4KSB7XG5cdFx0XHRpZih0aGlzLnJlc29sdmVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5iZWNvbWUobmV3IFJlamVjdGVkKHgpKTtcblx0XHR9O1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCF0aGlzLnJlc29sdmVkKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaCA9IHRoaXM7XG5cblx0XHRcdHdoaWxlIChoLmhhbmRsZXIgIT09IHZvaWQgMCkge1xuXHRcdFx0XHRoID0gaC5oYW5kbGVyO1xuXHRcdFx0XHRpZiAoaCA9PT0gdGhpcykge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmhhbmRsZXIgPSBjeWNsZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBoO1xuXHRcdH07XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBxID0gdGhpcy5jb25zdW1lcnM7XG5cdFx0XHR2YXIgaGFuZGxlciA9IHRoaXMuam9pbigpO1xuXHRcdFx0dGhpcy5jb25zdW1lcnMgPSB2b2lkIDA7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcS5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRoYW5kbGVyLndoZW4ocVtpXSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdFBlbmRpbmcucHJvdG90eXBlLmJlY29tZSA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcblx0XHRcdGlmKHRoaXMucmVzb2x2ZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnJlc29sdmVkID0gdHJ1ZTtcblx0XHRcdHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG5cdFx0XHRpZih0aGlzLmNvbnN1bWVycyAhPT0gdm9pZCAwKSB7XG5cdFx0XHRcdHRhc2tzLmVucXVldWUodGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKHRoaXMuY29udGV4dCAhPT0gdm9pZCAwKSB7XG5cdFx0XHRcdGhhbmRsZXIuX3JlcG9ydCh0aGlzLmNvbnRleHQpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS53aGVuID0gZnVuY3Rpb24oY29udGludWF0aW9uKSB7XG5cdFx0XHRpZih0aGlzLnJlc29sdmVkKSB7XG5cdFx0XHRcdHRhc2tzLmVucXVldWUobmV3IENvbnRpbnVhdGlvblRhc2soY29udGludWF0aW9uLCB0aGlzLmhhbmRsZXIpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmKHRoaXMuY29uc3VtZXJzID09PSB2b2lkIDApIHtcblx0XHRcdFx0XHR0aGlzLmNvbnN1bWVycyA9IFtjb250aW51YXRpb25dO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuY29uc3VtZXJzLnB1c2goY29udGludWF0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbih4KSB7XG5cdFx0XHRpZighdGhpcy5yZXNvbHZlZCkge1xuXHRcdFx0XHR0YXNrcy5lbnF1ZXVlKG5ldyBQcm9ncmVzc1Rhc2soeCwgdGhpcykpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRQZW5kaW5nLnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdFx0dmFyIGMgPSB0eXBlb2YgY29udGV4dCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmNvbnRleHQgOiBjb250ZXh0O1xuXHRcdFx0dGhpcy5yZXNvbHZlZCAmJiB0aGlzLmhhbmRsZXIuam9pbigpLmZhaWwoYyk7XG5cdFx0fTtcblxuXHRcdFBlbmRpbmcucHJvdG90eXBlLl9yZXBvcnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cdFx0XHR0aGlzLnJlc29sdmVkICYmIHRoaXMuaGFuZGxlci5qb2luKCkuX3JlcG9ydChjb250ZXh0KTtcblx0XHR9O1xuXG5cdFx0UGVuZGluZy5wcm90b3R5cGUuX3VucmVwb3J0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnJlc29sdmVkICYmIHRoaXMuaGFuZGxlci5qb2luKCkuX3VucmVwb3J0KCk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIFdyYXAgYW5vdGhlciBoYW5kbGVyIGFuZCBmb3JjZSBpdCBpbnRvIGEgZnV0dXJlIHN0YWNrXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGhhbmRsZXJcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBBc3luYyhoYW5kbGVyKSB7XG5cdFx0XHR0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuXHRcdH1cblxuXHRcdGluaGVyaXQoSGFuZGxlciwgQXN5bmMpO1xuXG5cdFx0QXN5bmMucHJvdG90eXBlLndoZW4gPSBmdW5jdGlvbihjb250aW51YXRpb24pIHtcblx0XHRcdHRhc2tzLmVucXVldWUobmV3IENvbnRpbnVhdGlvblRhc2soY29udGludWF0aW9uLCB0aGlzKSk7XG5cdFx0fTtcblxuXHRcdEFzeW5jLnByb3RvdHlwZS5fcmVwb3J0ID0gZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdFx0dGhpcy5qb2luKCkuX3JlcG9ydChjb250ZXh0KTtcblx0XHR9O1xuXG5cdFx0QXN5bmMucHJvdG90eXBlLl91bnJlcG9ydCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5qb2luKCkuX3VucmVwb3J0KCk7XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXIgdGhhdCB3cmFwcyBhbiB1bnRydXN0ZWQgdGhlbmFibGUgYW5kIGFzc2ltaWxhdGVzIGl0IGluIGEgZnV0dXJlIHN0YWNrXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gdGhlblxuXHRcdCAqIEBwYXJhbSB7e3RoZW46IGZ1bmN0aW9ufX0gdGhlbmFibGVcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBUaGVuYWJsZSh0aGVuLCB0aGVuYWJsZSkge1xuXHRcdFx0UGVuZGluZy5jYWxsKHRoaXMpO1xuXHRcdFx0dGFza3MuZW5xdWV1ZShuZXcgQXNzaW1pbGF0ZVRhc2sodGhlbiwgdGhlbmFibGUsIHRoaXMpKTtcblx0XHR9XG5cblx0XHRpbmhlcml0KFBlbmRpbmcsIFRoZW5hYmxlKTtcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXIgZm9yIGEgZnVsZmlsbGVkIHByb21pc2Vcblx0XHQgKiBAcGFyYW0geyp9IHggZnVsZmlsbG1lbnQgdmFsdWVcblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBGdWxmaWxsZWQoeCkge1xuXHRcdFx0UHJvbWlzZS5jcmVhdGVDb250ZXh0KHRoaXMpO1xuXHRcdFx0dGhpcy52YWx1ZSA9IHg7XG5cdFx0fVxuXG5cdFx0aW5oZXJpdChIYW5kbGVyLCBGdWxmaWxsZWQpO1xuXG5cdFx0RnVsZmlsbGVkLnByb3RvdHlwZS5fc3RhdGUgPSAxO1xuXG5cdFx0RnVsZmlsbGVkLnByb3RvdHlwZS5mb2xkID0gZnVuY3Rpb24oZiwgeiwgYywgdG8pIHtcblx0XHRcdHJ1bkNvbnRpbnVhdGlvbjMoZiwgeiwgdGhpcywgYywgdG8pO1xuXHRcdH07XG5cblx0XHRGdWxmaWxsZWQucHJvdG90eXBlLndoZW4gPSBmdW5jdGlvbihjb250KSB7XG5cdFx0XHRydW5Db250aW51YXRpb24xKGNvbnQuZnVsZmlsbGVkLCB0aGlzLCBjb250LnJlY2VpdmVyLCBjb250LnJlc29sdmVyKTtcblx0XHR9O1xuXG5cdFx0dmFyIGVycm9ySWQgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogSGFuZGxlciBmb3IgYSByZWplY3RlZCBwcm9taXNlXG5cdFx0ICogQHBhcmFtIHsqfSB4IHJlamVjdGlvbiByZWFzb25cblx0XHQgKiBAY29uc3RydWN0b3Jcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBSZWplY3RlZCh4KSB7XG5cdFx0XHRQcm9taXNlLmNyZWF0ZUNvbnRleHQodGhpcyk7XG5cblx0XHRcdHRoaXMuaWQgPSArK2Vycm9ySWQ7XG5cdFx0XHR0aGlzLnZhbHVlID0geDtcblx0XHRcdHRoaXMuaGFuZGxlZCA9IGZhbHNlO1xuXHRcdFx0dGhpcy5yZXBvcnRlZCA9IGZhbHNlO1xuXG5cdFx0XHR0aGlzLl9yZXBvcnQoKTtcblx0XHR9XG5cblx0XHRpbmhlcml0KEhhbmRsZXIsIFJlamVjdGVkKTtcblxuXHRcdFJlamVjdGVkLnByb3RvdHlwZS5fc3RhdGUgPSAtMTtcblxuXHRcdFJlamVjdGVkLnByb3RvdHlwZS5mb2xkID0gZnVuY3Rpb24oZiwgeiwgYywgdG8pIHtcblx0XHRcdHRvLmJlY29tZSh0aGlzKTtcblx0XHR9O1xuXG5cdFx0UmVqZWN0ZWQucHJvdG90eXBlLndoZW4gPSBmdW5jdGlvbihjb250KSB7XG5cdFx0XHRpZih0eXBlb2YgY29udC5yZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHR0aGlzLl91bnJlcG9ydCgpO1xuXHRcdFx0fVxuXHRcdFx0cnVuQ29udGludWF0aW9uMShjb250LnJlamVjdGVkLCB0aGlzLCBjb250LnJlY2VpdmVyLCBjb250LnJlc29sdmVyKTtcblx0XHR9O1xuXG5cdFx0UmVqZWN0ZWQucHJvdG90eXBlLl9yZXBvcnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cdFx0XHR0YXNrcy5hZnRlclF1ZXVlKG5ldyBSZXBvcnRUYXNrKHRoaXMsIGNvbnRleHQpKTtcblx0XHR9O1xuXG5cdFx0UmVqZWN0ZWQucHJvdG90eXBlLl91bnJlcG9ydCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5oYW5kbGVkID0gdHJ1ZTtcblx0XHRcdHRhc2tzLmFmdGVyUXVldWUobmV3IFVucmVwb3J0VGFzayh0aGlzKSk7XG5cdFx0fTtcblxuXHRcdFJlamVjdGVkLnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdFx0UHJvbWlzZS5vbkZhdGFsUmVqZWN0aW9uKHRoaXMsIGNvbnRleHQgPT09IHZvaWQgMCA/IHRoaXMuY29udGV4dCA6IGNvbnRleHQpO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBSZXBvcnRUYXNrKHJlamVjdGlvbiwgY29udGV4dCkge1xuXHRcdFx0dGhpcy5yZWplY3Rpb24gPSByZWplY3Rpb247XG5cdFx0XHR0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuXHRcdH1cblxuXHRcdFJlcG9ydFRhc2sucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYoIXRoaXMucmVqZWN0aW9uLmhhbmRsZWQpIHtcblx0XHRcdFx0dGhpcy5yZWplY3Rpb24ucmVwb3J0ZWQgPSB0cnVlO1xuXHRcdFx0XHRQcm9taXNlLm9uUG90ZW50aWFsbHlVbmhhbmRsZWRSZWplY3Rpb24odGhpcy5yZWplY3Rpb24sIHRoaXMuY29udGV4dCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIFVucmVwb3J0VGFzayhyZWplY3Rpb24pIHtcblx0XHRcdHRoaXMucmVqZWN0aW9uID0gcmVqZWN0aW9uO1xuXHRcdH1cblxuXHRcdFVucmVwb3J0VGFzay5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZih0aGlzLnJlamVjdGlvbi5yZXBvcnRlZCkge1xuXHRcdFx0XHRQcm9taXNlLm9uUG90ZW50aWFsbHlVbmhhbmRsZWRSZWplY3Rpb25IYW5kbGVkKHRoaXMucmVqZWN0aW9uKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gVW5oYW5kbGVkIHJlamVjdGlvbiBob29rc1xuXHRcdC8vIEJ5IGRlZmF1bHQsIGV2ZXJ5dGhpbmcgaXMgYSBub29wXG5cblx0XHQvLyBUT0RPOiBCZXR0ZXIgbmFtZXM6IFwiYW5ub3RhdGVcIj9cblx0XHRQcm9taXNlLmNyZWF0ZUNvbnRleHRcblx0XHRcdD0gUHJvbWlzZS5lbnRlckNvbnRleHRcblx0XHRcdD0gUHJvbWlzZS5leGl0Q29udGV4dFxuXHRcdFx0PSBQcm9taXNlLm9uUG90ZW50aWFsbHlVbmhhbmRsZWRSZWplY3Rpb25cblx0XHRcdD0gUHJvbWlzZS5vblBvdGVudGlhbGx5VW5oYW5kbGVkUmVqZWN0aW9uSGFuZGxlZFxuXHRcdFx0PSBQcm9taXNlLm9uRmF0YWxSZWplY3Rpb25cblx0XHRcdD0gbm9vcDtcblxuXHRcdC8vIEVycm9ycyBhbmQgc2luZ2xldG9uc1xuXG5cdFx0dmFyIGZvcmV2ZXJQZW5kaW5nSGFuZGxlciA9IG5ldyBIYW5kbGVyKCk7XG5cdFx0dmFyIGZvcmV2ZXJQZW5kaW5nUHJvbWlzZSA9IG5ldyBQcm9taXNlKEhhbmRsZXIsIGZvcmV2ZXJQZW5kaW5nSGFuZGxlcik7XG5cblx0XHRmdW5jdGlvbiBjeWNsZSgpIHtcblx0XHRcdHJldHVybiBuZXcgUmVqZWN0ZWQobmV3IFR5cGVFcnJvcignUHJvbWlzZSBjeWNsZScpKTtcblx0XHR9XG5cblx0XHQvLyBUYXNrIHJ1bm5lcnNcblxuXHRcdC8qKlxuXHRcdCAqIFJ1biBhIHNpbmdsZSBjb25zdW1lclxuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIENvbnRpbnVhdGlvblRhc2soY29udGludWF0aW9uLCBoYW5kbGVyKSB7XG5cdFx0XHR0aGlzLmNvbnRpbnVhdGlvbiA9IGNvbnRpbnVhdGlvbjtcblx0XHRcdHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG5cdFx0fVxuXG5cdFx0Q29udGludWF0aW9uVGFzay5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmhhbmRsZXIuam9pbigpLndoZW4odGhpcy5jb250aW51YXRpb24pO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBSdW4gYSBxdWV1ZSBvZiBwcm9ncmVzcyBoYW5kbGVyc1xuXHRcdCAqIEBjb25zdHJ1Y3RvclxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIFByb2dyZXNzVGFzayh2YWx1ZSwgaGFuZGxlcikge1xuXHRcdFx0dGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcblx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHR9XG5cblx0XHRQcm9ncmVzc1Rhc2sucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHEgPSB0aGlzLmhhbmRsZXIuY29uc3VtZXJzO1xuXHRcdFx0aWYocSA9PT0gdm9pZCAwKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgYywgaSA9IDA7IGkgPCBxLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdGMgPSBxW2ldO1xuXHRcdFx0XHRydW5Ob3RpZnkoYy5wcm9ncmVzcywgdGhpcy52YWx1ZSwgdGhpcy5oYW5kbGVyLCBjLnJlY2VpdmVyLCBjLnJlc29sdmVyKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyoqXG5cdFx0ICogQXNzaW1pbGF0ZSBhIHRoZW5hYmxlLCBzZW5kaW5nIGl0J3MgdmFsdWUgdG8gcmVzb2x2ZXJcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0aGVuXG5cdFx0ICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHRoZW5hYmxlXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IHJlc29sdmVyXG5cdFx0ICogQGNvbnN0cnVjdG9yXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gQXNzaW1pbGF0ZVRhc2sodGhlbiwgdGhlbmFibGUsIHJlc29sdmVyKSB7XG5cdFx0XHR0aGlzLl90aGVuID0gdGhlbjtcblx0XHRcdHRoaXMudGhlbmFibGUgPSB0aGVuYWJsZTtcblx0XHRcdHRoaXMucmVzb2x2ZXIgPSByZXNvbHZlcjtcblx0XHR9XG5cblx0XHRBc3NpbWlsYXRlVGFzay5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaCA9IHRoaXMucmVzb2x2ZXI7XG5cdFx0XHR0cnlBc3NpbWlsYXRlKHRoaXMuX3RoZW4sIHRoaXMudGhlbmFibGUsIF9yZXNvbHZlLCBfcmVqZWN0LCBfbm90aWZ5KTtcblxuXHRcdFx0ZnVuY3Rpb24gX3Jlc29sdmUoeCkgeyBoLnJlc29sdmUoeCk7IH1cblx0XHRcdGZ1bmN0aW9uIF9yZWplY3QoeCkgIHsgaC5yZWplY3QoeCk7IH1cblx0XHRcdGZ1bmN0aW9uIF9ub3RpZnkoeCkgIHsgaC5ub3RpZnkoeCk7IH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdHJ5QXNzaW1pbGF0ZSh0aGVuLCB0aGVuYWJsZSwgcmVzb2x2ZSwgcmVqZWN0LCBub3RpZnkpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRoZW4uY2FsbCh0aGVuYWJsZSwgcmVzb2x2ZSwgcmVqZWN0LCBub3RpZnkpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZWplY3QoZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXIgaGVscGVyc1xuXG5cdFx0LyoqXG5cdFx0ICogQHBhcmFtIHsqfSB4XG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWZmIHggaXMgYSB0cnVzdGVkIFByb21pc2Vcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBpc1Byb21pc2UoeCkge1xuXHRcdFx0cmV0dXJuIHggaW5zdGFuY2VvZiBQcm9taXNlO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFRlc3QganVzdCBlbm91Z2ggdG8gcnVsZSBvdXQgcHJpbWl0aXZlcywgaW4gb3JkZXIgdG8gdGFrZSBmYXN0ZXJcblx0XHQgKiBwYXRocyBpbiBzb21lIGNvZGVcblx0XHQgKiBAcGFyYW0geyp9IHhcblx0XHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UgaWZmIHggaXMgZ3VhcmFudGVlZCAqbm90KiB0byBiZSBhIHRoZW5hYmxlXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gbWF5YmVUaGVuYWJsZSh4KSB7XG5cdFx0XHRyZXR1cm4gKHR5cGVvZiB4ID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJykgJiYgeCAhPT0gbnVsbDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBydW5Db250aW51YXRpb24xKGYsIGgsIHJlY2VpdmVyLCBuZXh0KSB7XG5cdFx0XHRpZih0eXBlb2YgZiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRyZXR1cm4gbmV4dC5iZWNvbWUoaCk7XG5cdFx0XHR9XG5cblx0XHRcdFByb21pc2UuZW50ZXJDb250ZXh0KGgpO1xuXHRcdFx0dHJ5Q2F0Y2hSZWplY3QoZiwgaC52YWx1ZSwgcmVjZWl2ZXIsIG5leHQpO1xuXHRcdFx0UHJvbWlzZS5leGl0Q29udGV4dCgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJ1bkNvbnRpbnVhdGlvbjMoZiwgeCwgaCwgcmVjZWl2ZXIsIG5leHQpIHtcblx0XHRcdGlmKHR5cGVvZiBmICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHJldHVybiBuZXh0LmJlY29tZShoKTtcblx0XHRcdH1cblxuXHRcdFx0UHJvbWlzZS5lbnRlckNvbnRleHQoaCk7XG5cdFx0XHR0cnlDYXRjaFJlamVjdDMoZiwgeCwgaC52YWx1ZSwgcmVjZWl2ZXIsIG5leHQpO1xuXHRcdFx0UHJvbWlzZS5leGl0Q29udGV4dCgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJ1bk5vdGlmeShmLCB4LCBoLCByZWNlaXZlciwgbmV4dCkge1xuXHRcdFx0aWYodHlwZW9mIGYgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cmV0dXJuIG5leHQubm90aWZ5KHgpO1xuXHRcdFx0fVxuXG5cdFx0XHRQcm9taXNlLmVudGVyQ29udGV4dChoKTtcblx0XHRcdHRyeUNhdGNoUmV0dXJuKGYsIHgsIHJlY2VpdmVyLCBuZXh0KTtcblx0XHRcdFByb21pc2UuZXhpdENvbnRleHQoKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm4gZi5jYWxsKHRoaXNBcmcsIHgpLCBvciBpZiBpdCB0aHJvd3MgcmV0dXJuIGEgcmVqZWN0ZWQgcHJvbWlzZSBmb3Jcblx0XHQgKiB0aGUgdGhyb3duIGV4Y2VwdGlvblxuXHRcdCAqL1xuXHRcdGZ1bmN0aW9uIHRyeUNhdGNoUmVqZWN0KGYsIHgsIHRoaXNBcmcsIG5leHQpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdG5leHQuYmVjb21lKGdldEhhbmRsZXIoZi5jYWxsKHRoaXNBcmcsIHgpKSk7XG5cdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0bmV4dC5iZWNvbWUobmV3IFJlamVjdGVkKGUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBTYW1lIGFzIGFib3ZlLCBidXQgaW5jbHVkZXMgdGhlIGV4dHJhIGFyZ3VtZW50IHBhcmFtZXRlci5cblx0XHQgKi9cblx0XHRmdW5jdGlvbiB0cnlDYXRjaFJlamVjdDMoZiwgeCwgeSwgdGhpc0FyZywgbmV4dCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Zi5jYWxsKHRoaXNBcmcsIHgsIHksIG5leHQpO1xuXHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdG5leHQuYmVjb21lKG5ldyBSZWplY3RlZChlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJuIGYuY2FsbCh0aGlzQXJnLCB4KSwgb3IgaWYgaXQgdGhyb3dzLCAqcmV0dXJuKiB0aGUgZXhjZXB0aW9uXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gdHJ5Q2F0Y2hSZXR1cm4oZiwgeCwgdGhpc0FyZywgbmV4dCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0bmV4dC5ub3RpZnkoZi5jYWxsKHRoaXNBcmcsIHgpKTtcblx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRuZXh0Lm5vdGlmeShlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpbmhlcml0KFBhcmVudCwgQ2hpbGQpIHtcblx0XHRcdENoaWxkLnByb3RvdHlwZSA9IG9iamVjdENyZWF0ZShQYXJlbnQucHJvdG90eXBlKTtcblx0XHRcdENoaWxkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENoaWxkO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5cdFx0cmV0dXJuIFByb21pc2U7XG5cdH07XG59KTtcbn0odHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lIDogZnVuY3Rpb24oZmFjdG9yeSkgeyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTsgfSkpO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENTU0NvcmVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBUaGUgQ1NTQ29yZSBtb2R1bGUgc3BlY2lmaWVzIHRoZSBBUEkgKGFuZCBpbXBsZW1lbnRzIG1vc3Qgb2YgdGhlIG1ldGhvZHMpXG4gKiB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZW4gZGVhbGluZyB3aXRoIHRoZSBkaXNwbGF5IG9mIGVsZW1lbnRzICh2aWEgdGhlaXJcbiAqIENTUyBjbGFzc2VzIGFuZCB2aXNpYmlsaXR5IG9uIHNjcmVlbi4gSXQgaXMgYW4gQVBJIGZvY3VzZWQgb24gbXV0YXRpbmcgdGhlXG4gKiBkaXNwbGF5IGFuZCBub3QgcmVhZGluZyBpdCBhcyBubyBsb2dpY2FsIHN0YXRlIHNob3VsZCBiZSBlbmNvZGVkIGluIHRoZVxuICogZGlzcGxheSBvZiBlbGVtZW50cy5cbiAqL1xuXG52YXIgQ1NTQ29yZSA9IHtcblxuICAvKipcbiAgICogQWRkcyB0aGUgY2xhc3MgcGFzc2VkIGluIHRvIHRoZSBlbGVtZW50IGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBoYXZlIGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIHRoZSBDU1MgY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IHRoZSBlbGVtZW50IHBhc3NlZCBpblxuICAgKi9cbiAgYWRkQ2xhc3M6IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAhL1xccy8udGVzdChjbGFzc05hbWUpLFxuICAgICAgJ0NTU0NvcmUuYWRkQ2xhc3MgdGFrZXMgb25seSBhIHNpbmdsZSBjbGFzcyBuYW1lLiBcIiVzXCIgY29udGFpbnMgJyArXG4gICAgICAnbXVsdGlwbGUgY2xhc3Nlcy4nLCBjbGFzc05hbWVcbiAgICApIDogaW52YXJpYW50KCEvXFxzLy50ZXN0KGNsYXNzTmFtZSkpKTtcblxuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoIUNTU0NvcmUuaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnICsgY2xhc3NOYW1lO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgY2xhc3MgcGFzc2VkIGluIGZyb20gdGhlIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIHNldCB0aGUgY2xhc3Mgb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSB0aGUgQ1NTIGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fSB0aGUgZWxlbWVudCBwYXNzZWQgaW5cbiAgICovXG4gIHJlbW92ZUNsYXNzOiBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgIS9cXHMvLnRlc3QoY2xhc3NOYW1lKSxcbiAgICAgICdDU1NDb3JlLnJlbW92ZUNsYXNzIHRha2VzIG9ubHkgYSBzaW5nbGUgY2xhc3MgbmFtZS4gXCIlc1wiIGNvbnRhaW5zICcgK1xuICAgICAgJ211bHRpcGxlIGNsYXNzZXMuJywgY2xhc3NOYW1lXG4gICAgKSA6IGludmFyaWFudCghL1xccy8udGVzdChjbGFzc05hbWUpKSk7XG5cbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKENTU0NvcmUuaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lXG4gICAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIGNsYXNzTmFtZSArICcoPzpcXFxcc3wkKScsICdnJyksICckMScpXG4gICAgICAgICAgLnJlcGxhY2UoL1xccysvZywgJyAnKSAvLyBtdWx0aXBsZSBzcGFjZXMgdG8gb25lXG4gICAgICAgICAgLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKTsgLy8gdHJpbSB0aGUgZW5kc1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSxcblxuICAvKipcbiAgICogSGVscGVyIHRvIGFkZCBvciByZW1vdmUgYSBjbGFzcyBmcm9tIGFuIGVsZW1lbnQgYmFzZWQgb24gYSBjb25kaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgdGhlIENTUyBjbGFzc05hbWVcbiAgICogQHBhcmFtIHsqfSBib29sIGNvbmRpdGlvbiB0byB3aGV0aGVyIHRvIGFkZCBvciByZW1vdmUgdGhlIGNsYXNzXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IHRoZSBlbGVtZW50IHBhc3NlZCBpblxuICAgKi9cbiAgY29uZGl0aW9uQ2xhc3M6IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzTmFtZSwgYm9vbCkge1xuICAgIHJldHVybiAoYm9vbCA/IENTU0NvcmUuYWRkQ2xhc3MgOiBDU1NDb3JlLnJlbW92ZUNsYXNzKShlbGVtZW50LCBjbGFzc05hbWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUZXN0cyB3aGV0aGVyIHRoZSBlbGVtZW50IGhhcyB0aGUgY2xhc3Mgc3BlY2lmaWVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTU5vZGV8RE9NV2luZG93fSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIHNldCB0aGUgY2xhc3Mgb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSB0aGUgQ1NTIGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBlbGVtZW50IGhhcyB0aGUgY2xhc3MsIGZhbHNlIGlmIG5vdFxuICAgKi9cbiAgaGFzQ2xhc3M6IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAhL1xccy8udGVzdChjbGFzc05hbWUpLFxuICAgICAgJ0NTUy5oYXNDbGFzcyB0YWtlcyBvbmx5IGEgc2luZ2xlIGNsYXNzIG5hbWUuJ1xuICAgICkgOiBpbnZhcmlhbnQoIS9cXHMvLnRlc3QoY2xhc3NOYW1lKSkpO1xuICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgcmV0dXJuICEhY2xhc3NOYW1lICYmIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiAoJyAnICsgZWxlbWVudC5jbGFzc05hbWUgKyAnICcpLmluZGV4T2YoJyAnICsgY2xhc3NOYW1lICsgJyAnKSA+IC0xO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NTQ29yZTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFeGVjdXRpb25FbnZpcm9ubWVudFxuICovXG5cbi8qanNsaW50IGV2aWw6IHRydWUgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjYW5Vc2VET00gPSAhIShcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgd2luZG93LmRvY3VtZW50ICYmXG4gIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50XG4pO1xuXG4vKipcbiAqIFNpbXBsZSwgbGlnaHR3ZWlnaHQgbW9kdWxlIGFzc2lzdGluZyB3aXRoIHRoZSBkZXRlY3Rpb24gYW5kIGNvbnRleHQgb2ZcbiAqIFdvcmtlci4gSGVscHMgYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzIGFuZCBhbGxvd3MgY29kZSB0byByZWFzb24gYWJvdXRcbiAqIHdoZXRoZXIgb3Igbm90IHRoZXkgYXJlIGluIGEgV29ya2VyLCBldmVuIGlmIHRoZXkgbmV2ZXIgaW5jbHVkZSB0aGUgbWFpblxuICogYFJlYWN0V29ya2VyYCBkZXBlbmRlbmN5LlxuICovXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSB7XG5cbiAgY2FuVXNlRE9NOiBjYW5Vc2VET00sXG5cbiAgY2FuVXNlV29ya2VyczogdHlwZW9mIFdvcmtlciAhPT0gJ3VuZGVmaW5lZCcsXG5cbiAgY2FuVXNlRXZlbnRMaXN0ZW5lcnM6XG4gICAgY2FuVXNlRE9NICYmICEhKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIHx8IHdpbmRvdy5hdHRhY2hFdmVudCksXG5cbiAgY2FuVXNlVmlld3BvcnQ6IGNhblVzZURPTSAmJiAhIXdpbmRvdy5zY3JlZW4sXG5cbiAgaXNJbldvcmtlcjogIWNhblVzZURPTSAvLyBGb3Igbm93LCB0aGlzIGlzIHRydWUgLSBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgT2JqZWN0LmFzc2lnblxuICovXG5cbi8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1vYmplY3QuYXNzaWduXG5cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZXMpIHtcbiAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiB0YXJnZXQgY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gIH1cblxuICB2YXIgdG8gPSBPYmplY3QodGFyZ2V0KTtcbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmb3IgKHZhciBuZXh0SW5kZXggPSAxOyBuZXh0SW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBuZXh0SW5kZXgrKykge1xuICAgIHZhciBuZXh0U291cmNlID0gYXJndW1lbnRzW25leHRJbmRleF07XG4gICAgaWYgKG5leHRTb3VyY2UgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGZyb20gPSBPYmplY3QobmV4dFNvdXJjZSk7XG5cbiAgICAvLyBXZSBkb24ndCBjdXJyZW50bHkgc3VwcG9ydCBhY2Nlc3NvcnMgbm9yIHByb3hpZXMuIFRoZXJlZm9yZSB0aGlzXG4gICAgLy8gY29weSBjYW5ub3QgdGhyb3cuIElmIHdlIGV2ZXIgc3VwcG9ydGVkIHRoaXMgdGhlbiB3ZSBtdXN0IGhhbmRsZVxuICAgIC8vIGV4Y2VwdGlvbnMgYW5kIHNpZGUtZWZmZWN0cy4gV2UgZG9uJ3Qgc3VwcG9ydCBzeW1ib2xzIHNvIHRoZXkgd29uJ3RcbiAgICAvLyBiZSB0cmFuc2ZlcnJlZC5cblxuICAgIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG4gICAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRvO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ247XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RUcmFuc2l0aW9uRXZlbnRzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xuXG4vKipcbiAqIEVWRU5UX05BTUVfTUFQIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGV2ZW50IGZpcmVkIHdoZW4gYVxuICogdHJhbnNpdGlvbi9hbmltYXRpb24gZW5kcywgYmFzZWQgb24gdGhlIHN0eWxlIHByb3BlcnR5IHVzZWQgdG9cbiAqIGRlZmluZSB0aGF0IGV2ZW50LlxuICovXG52YXIgRVZFTlRfTkFNRV9NQVAgPSB7XG4gIHRyYW5zaXRpb25lbmQ6IHtcbiAgICAndHJhbnNpdGlvbic6ICd0cmFuc2l0aW9uZW5kJyxcbiAgICAnV2Via2l0VHJhbnNpdGlvbic6ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAnTW96VHJhbnNpdGlvbic6ICdtb3pUcmFuc2l0aW9uRW5kJyxcbiAgICAnT1RyYW5zaXRpb24nOiAnb1RyYW5zaXRpb25FbmQnLFxuICAgICdtc1RyYW5zaXRpb24nOiAnTVNUcmFuc2l0aW9uRW5kJ1xuICB9LFxuXG4gIGFuaW1hdGlvbmVuZDoge1xuICAgICdhbmltYXRpb24nOiAnYW5pbWF0aW9uZW5kJyxcbiAgICAnV2Via2l0QW5pbWF0aW9uJzogJ3dlYmtpdEFuaW1hdGlvbkVuZCcsXG4gICAgJ01vekFuaW1hdGlvbic6ICdtb3pBbmltYXRpb25FbmQnLFxuICAgICdPQW5pbWF0aW9uJzogJ29BbmltYXRpb25FbmQnLFxuICAgICdtc0FuaW1hdGlvbic6ICdNU0FuaW1hdGlvbkVuZCdcbiAgfVxufTtcblxudmFyIGVuZEV2ZW50cyA9IFtdO1xuXG5mdW5jdGlvbiBkZXRlY3RFdmVudHMoKSB7XG4gIHZhciB0ZXN0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmFyIHN0eWxlID0gdGVzdEVsLnN0eWxlO1xuXG4gIC8vIE9uIHNvbWUgcGxhdGZvcm1zLCBpbiBwYXJ0aWN1bGFyIHNvbWUgcmVsZWFzZXMgb2YgQW5kcm9pZCA0LngsXG4gIC8vIHRoZSB1bi1wcmVmaXhlZCBcImFuaW1hdGlvblwiIGFuZCBcInRyYW5zaXRpb25cIiBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIG9uIHRoZVxuICAvLyBzdHlsZSBvYmplY3QgYnV0IHRoZSBldmVudHMgdGhhdCBmaXJlIHdpbGwgc3RpbGwgYmUgcHJlZml4ZWQsIHNvIHdlIG5lZWRcbiAgLy8gdG8gY2hlY2sgaWYgdGhlIHVuLXByZWZpeGVkIGV2ZW50cyBhcmUgdXNlYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbVxuICAvLyBmcm9tIHRoZSBtYXBcbiAgaWYgKCEoJ0FuaW1hdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIEVWRU5UX05BTUVfTUFQLmFuaW1hdGlvbmVuZC5hbmltYXRpb247XG4gIH1cblxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIEVWRU5UX05BTUVfTUFQLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxuXG4gIGZvciAodmFyIGJhc2VFdmVudE5hbWUgaW4gRVZFTlRfTkFNRV9NQVApIHtcbiAgICB2YXIgYmFzZUV2ZW50cyA9IEVWRU5UX05BTUVfTUFQW2Jhc2VFdmVudE5hbWVdO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBiYXNlRXZlbnRzKSB7XG4gICAgICBpZiAoc3R5bGVOYW1lIGluIHN0eWxlKSB7XG4gICAgICAgIGVuZEV2ZW50cy5wdXNoKGJhc2VFdmVudHNbc3R5bGVOYW1lXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIGRldGVjdEV2ZW50cygpO1xufVxuXG4vLyBXZSB1c2UgdGhlIHJhdyB7YWRkfHJlbW92ZX1FdmVudExpc3RlbmVyKCkgY2FsbCBiZWNhdXNlIEV2ZW50TGlzdGVuZXJcbi8vIGRvZXMgbm90IGtub3cgaG93IHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lcnMgYW5kIHdlIHJlYWxseSBzaG91bGRcbi8vIGNsZWFuIHVwLiBBbHNvLCB0aGVzZSBldmVudHMgYXJlIG5vdCB0cmlnZ2VyZWQgaW4gb2xkZXIgYnJvd3NlcnNcbi8vIHNvIHdlIHNob3VsZCBiZSBBLU9LIGhlcmUuXG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnROYW1lLCBldmVudExpc3RlbmVyKSB7XG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIpIHtcbiAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnRMaXN0ZW5lciwgZmFsc2UpO1xufVxuXG52YXIgUmVhY3RUcmFuc2l0aW9uRXZlbnRzID0ge1xuICBhZGRFbmRFdmVudExpc3RlbmVyOiBmdW5jdGlvbihub2RlLCBldmVudExpc3RlbmVyKSB7XG4gICAgaWYgKGVuZEV2ZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIElmIENTUyB0cmFuc2l0aW9ucyBhcmUgbm90IHN1cHBvcnRlZCwgdHJpZ2dlciBhbiBcImVuZCBhbmltYXRpb25cIlxuICAgICAgLy8gZXZlbnQgaW1tZWRpYXRlbHkuXG4gICAgICB3aW5kb3cuc2V0VGltZW91dChldmVudExpc3RlbmVyLCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZW5kRXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZW5kRXZlbnQpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZW5kRXZlbnQsIGV2ZW50TGlzdGVuZXIpO1xuICAgIH0pO1xuICB9LFxuXG4gIHJlbW92ZUVuZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKG5vZGUsIGV2ZW50TGlzdGVuZXIpIHtcbiAgICBpZiAoZW5kRXZlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbmRFdmVudHMuZm9yRWFjaChmdW5jdGlvbihlbmRFdmVudCkge1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBlbmRFdmVudCwgZXZlbnRMaXN0ZW5lcik7XG4gICAgfSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RUcmFuc2l0aW9uRXZlbnRzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGN4XG4gKi9cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gbWFyayBzdHJpbmcgbGl0ZXJhbHMgcmVwcmVzZW50aW5nIENTUyBjbGFzcyBuYW1lc1xuICogc28gdGhhdCB0aGV5IGNhbiBiZSB0cmFuc2Zvcm1lZCBzdGF0aWNhbGx5LiBUaGlzIGFsbG93cyBmb3IgbW9kdWxhcml6YXRpb25cbiAqIGFuZCBtaW5pZmljYXRpb24gb2YgQ1NTIGNsYXNzIG5hbWVzLlxuICpcbiAqIEluIHN0YXRpY191cHN0cmVhbSwgdGhpcyBmdW5jdGlvbiBpcyBhY3R1YWxseSBpbXBsZW1lbnRlZCwgYnV0IGl0IHNob3VsZFxuICogZXZlbnR1YWxseSBiZSByZXBsYWNlZCB3aXRoIHNvbWV0aGluZyBtb3JlIGRlc2NyaXB0aXZlLCBhbmQgdGhlIHRyYW5zZm9ybVxuICogdGhhdCBpcyB1c2VkIGluIHRoZSBtYWluIHN0YWNrIHNob3VsZCBiZSBwb3J0ZWQgZm9yIHVzZSBlbHNld2hlcmUuXG4gKlxuICogQHBhcmFtIHN0cmluZ3xvYmplY3QgY2xhc3NOYW1lIHRvIG1vZHVsYXJpemUsIG9yIGFuIG9iamVjdCBvZiBrZXkvdmFsdWVzLlxuICogICAgICAgICAgICAgICAgICAgICAgSW4gdGhlIG9iamVjdCBjYXNlLCB0aGUgdmFsdWVzIGFyZSBjb25kaXRpb25zIHRoYXRcbiAqICAgICAgICAgICAgICAgICAgICAgIGRldGVybWluZSBpZiB0aGUgY2xhc3NOYW1lIGtleXMgc2hvdWxkIGJlIGluY2x1ZGVkLlxuICogQHBhcmFtIFtzdHJpbmcgLi4uXSAgVmFyaWFibGUgbGlzdCBvZiBjbGFzc05hbWVzIGluIHRoZSBzdHJpbmcgY2FzZS5cbiAqIEByZXR1cm4gc3RyaW5nICAgICAgIFJlbmRlcmFibGUgc3BhY2Utc2VwYXJhdGVkIENTUyBjbGFzc05hbWUuXG4gKi9cbmZ1bmN0aW9uIGN4KGNsYXNzTmFtZXMpIHtcbiAgaWYgKHR5cGVvZiBjbGFzc05hbWVzID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGNsYXNzTmFtZXMpLmZpbHRlcihmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICAgIHJldHVybiBjbGFzc05hbWVzW2NsYXNzTmFtZV07XG4gICAgfSkuam9pbignICcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuam9pbi5jYWxsKGFyZ3VtZW50cywgJyAnKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGN4O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGVtcHR5RnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge31cblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uKGFyZykgeyByZXR1cm4gYXJnOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaW52YXJpYW50XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgK1xuICAgICAgICAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ0ludmFyaWFudCBWaW9sYXRpb246ICcgK1xuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSB3YXJuaW5nXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZShcIi4vZW1wdHlGdW5jdGlvblwiKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCApIHtmb3IgKHZhciBhcmdzPVtdLCRfXzA9MiwkX18xPWFyZ3VtZW50cy5sZW5ndGg7JF9fMDwkX18xOyRfXzArKykgYXJncy5wdXNoKGFyZ3VtZW50c1skX18wXSk7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICtcbiAgICAgICAgJ21lc3NhZ2UgYXJndW1lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgY29uc29sZS53YXJuKCdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgIHtyZXR1cm4gYXJnc1thcmdJbmRleCsrXTt9KSk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcImltbXV0YWJsZVwiLFxuICBcInZlcnNpb25cIjogXCI0LjAuMC1yYy4xMlwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiSW1tdXRhYmxlIERhdGEgQ29sbGVjdGlvbnNcIixcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL2ltbXV0YWJsZS1qcy5jb21cIixcbiAgXCJhdXRob3JcIjoge1xuICAgIFwibmFtZVwiOiBcIkxlZSBCeXJvblwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2xlZWJ5cm9uXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdDovL2dpdGh1Yi5jb20vaW1tdXRhYmxlLWpzL2ltbXV0YWJsZS1qcy5naXRcIlxuICB9LFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2ltbXV0YWJsZS1qcy9pbW11dGFibGUtanMvaXNzdWVzXCJcbiAgfSxcbiAgXCJtYWluXCI6IFwiZGlzdC9pbW11dGFibGUuanNcIixcbiAgXCJtb2R1bGVcIjogXCJkaXN0L2ltbXV0YWJsZS5lcy5qc1wiLFxuICBcInR5cGluZ3NcIjogXCJkaXN0L2ltbXV0YWJsZS1ub25hbWJpZW50LmQudHNcIixcbiAgXCJ0eXBlc2NyaXB0XCI6IHtcbiAgICBcImRlZmluaXRpb25cIjogXCJkaXN0L2ltbXV0YWJsZS5kLnRzXCJcbiAgfSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImJ1aWxkXCI6IFwicnVuLXMgYnVpbGQ6KlwiLFxuICAgIFwiYnVpbGQ6ZGlzdFwiOiBcInJ1bi1zIGNsZWFuOmRpc3QgYnVuZGxlOmRpc3QgYnVuZGxlOmVzIGNvcHk6ZGlzdCBzdGF0czpkaXN0IHByZXBhcmU6ZGlzdFwiLFxuICAgIFwiYnVpbGQ6cGFnZXNcIjogXCJndWxwIC0tZ3VscGZpbGUgLi9yZXNvdXJjZXMvZ3VscGZpbGUuanMgZGVmYXVsdFwiLFxuICAgIFwic3RhdHM6ZGlzdFwiOiBcIm5vZGUgLi9yZXNvdXJjZXMvZGlzdC1zdGF0cy5qc1wiLFxuICAgIFwiY2xlYW46ZGlzdFwiOiBcInJpbXJhZiBkaXN0XCIsXG4gICAgXCJidW5kbGU6ZGlzdFwiOiBcInJvbGx1cCAtYyAuL3Jlc291cmNlcy9yb2xsdXAtY29uZmlnLmpzXCIsXG4gICAgXCJidW5kbGU6ZXNcIjogXCJyb2xsdXAgLWMgLi9yZXNvdXJjZXMvcm9sbHVwLWNvbmZpZy1lcy5qc1wiLFxuICAgIFwiY29weTpkaXN0XCI6IFwibm9kZSAuL3Jlc291cmNlcy9jb3B5LWRpc3QtdHlwZWRlZnMuanNcIixcbiAgICBcInByZXBhcmU6ZGlzdFwiOiBcIi4vcmVzb3VyY2VzL3ByZXBhcmUtZGlzdC5zaFwiLFxuICAgIFwiZm9ybWF0XCI6IFwibnBtIHJ1biBsaW50OmZvcm1hdCAtLSAtLXdyaXRlXCIsXG4gICAgXCJsaW50XCI6IFwicnVuLXMgbGludDoqXCIsXG4gICAgXCJsaW50OnRzXCI6IFwidHNsaW50IFxcXCJfX3Rlc3RzX18vKiovKi50c1xcXCJcIixcbiAgICBcImxpbnQ6anNcIjogXCJlc2xpbnQgXFxcIntfX3Rlc3RzX18sc3JjLHBhZ2VzL3NyYyxwYWdlcy9saWJ9LyoqLyouanNcXFwiXCIsXG4gICAgXCJsaW50OmZvcm1hdFwiOiBcInByZXR0aWVyIC0tY2hlY2sgXFxcIntfX3Rlc3RzX18sc3JjLHBhZ2VzL3NyYyxwYWdlcy9saWIscGVyZixyZXNvdXJjZXN9LyoqLyp7XFxcXC5qcyxcXFxcLnRzfVxcXCJcIixcbiAgICBcInRlc3Rvbmx5XCI6IFwiLi9yZXNvdXJjZXMvamVzdFwiLFxuICAgIFwidGVzdFwiOiBcInJ1bi1zIGZvcm1hdCBidWlsZCBsaW50IHRlc3Rvbmx5IHRlc3Q6dHlwZXNcIixcbiAgICBcInRlc3Q6dHJhdmlzXCI6IFwibnBtIHJ1biB0ZXN0ICYmIG5wbSBydW4gY2hlY2s6Z2l0LWNsZWFuXCIsXG4gICAgXCJjaGVjazpnaXQtY2xlYW5cIjogXCIuL3Jlc291cmNlcy9jaGVjay1jaGFuZ2VzXCIsXG4gICAgXCJ0ZXN0OnR5cGVzXCI6IFwicnVuLXMgdGVzdDp0eXBlczoqXCIsXG4gICAgXCJ0ZXN0OnR5cGVzOnRzXCI6IFwidHNjIC4vdHlwZS1kZWZpbml0aW9ucy9JbW11dGFibGUuZC50cyAtLWxpYiBlczIwMTUgJiYgZHRzbGludCB0eXBlLWRlZmluaXRpb25zL3RzLXRlc3RzXCIsXG4gICAgXCJ0ZXN0OnR5cGVzOmZsb3dcIjogXCJmbG93IGNoZWNrIHR5cGUtZGVmaW5pdGlvbnMvdGVzdHMgLS1pbmNsdWRlLXdhcm5pbmdzXCIsXG4gICAgXCJwZXJmXCI6IFwibm9kZSAuL3Jlc291cmNlcy9iZW5jaC5qc1wiLFxuICAgIFwic3RhcnRcIjogXCJndWxwIC0tZ3VscGZpbGUgLi9yZXNvdXJjZXMvZ3VscGZpbGUuanMgZGV2XCJcbiAgfSxcbiAgXCJwcmV0dGllclwiOiB7XG4gICAgXCJzaW5nbGVRdW90ZVwiOiB0cnVlLFxuICAgIFwidHJhaWxpbmdDb21tYVwiOiBcImVzNVwiLFxuICAgIFwic2VtaVwiOiB0cnVlLFxuICAgIFwiYXJyb3dQYXJlbnNcIjogXCJhdm9pZFwiXG4gIH0sXG4gIFwiamVzdFwiOiB7XG4gICAgXCJtb2R1bGVGaWxlRXh0ZW5zaW9uc1wiOiBbXG4gICAgICBcImpzXCIsXG4gICAgICBcInRzXCJcbiAgICBdLFxuICAgIFwidHJhbnNmb3JtXCI6IHtcbiAgICAgIFwiXi4rXFxcXC50cyRcIjogXCI8cm9vdERpcj4vcmVzb3VyY2VzL2plc3RQcmVwcm9jZXNzb3IuanNcIlxuICAgIH0sXG4gICAgXCJ0ZXN0UmVnZXhcIjogXCIvX190ZXN0c19fLy4qXFxcXC4odHN8anMpJFwiLFxuICAgIFwidW5tb2NrZWRNb2R1bGVQYXRoUGF0dGVybnNcIjogW1xuICAgICAgXCIuL25vZGVfbW9kdWxlcy9yZWFjdFwiXG4gICAgXVxuICB9LFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJiZW5jaG1hcmtcIjogXCIyLjEuNFwiLFxuICAgIFwiYnJvd3Nlci1zeW5jXCI6IFwiXjIuMjYuMTJcIixcbiAgICBcImJyb3dzZXJpZnlcIjogXCIxNi41LjJcIixcbiAgICBcImNvbG9yc1wiOiBcIjEuNC4wXCIsXG4gICAgXCJkZWxcIjogXCI2LjAuMFwiLFxuICAgIFwiZHRzbGludFwiOiBcIjQuMS4wXCIsXG4gICAgXCJlc2xpbnRcIjogXCI3LjExLjBcIixcbiAgICBcImVzbGludC1jb25maWctYWlyYm5iXCI6IFwiMTguMi4wXCIsXG4gICAgXCJlc2xpbnQtY29uZmlnLXByZXR0aWVyXCI6IFwiNi4xMi4wXCIsXG4gICAgXCJlc2xpbnQtcGx1Z2luLWltcG9ydFwiOiBcIjIuMjIuMVwiLFxuICAgIFwiZXNsaW50LXBsdWdpbi1qc3gtYTExeVwiOiBcIjYuMy4xXCIsXG4gICAgXCJlc2xpbnQtcGx1Z2luLXByZXR0aWVyXCI6IFwiMy4xLjRcIixcbiAgICBcImVzbGludC1wbHVnaW4tcmVhY3RcIjogXCI3LjIxLjRcIixcbiAgICBcImZsb3ctYmluXCI6IFwiMC44NS4wXCIsXG4gICAgXCJndWxwXCI6IFwiNC4wLjJcIixcbiAgICBcImd1bHAtY29uY2F0XCI6IFwiMi42LjFcIixcbiAgICBcImd1bHAtZmlsdGVyXCI6IFwiNi4wLjBcIixcbiAgICBcImd1bHAtaGVhZGVyXCI6IFwiMi4wLjlcIixcbiAgICBcImd1bHAtbGVzc1wiOiBcIjQuMC4xXCIsXG4gICAgXCJndWxwLXNpemVcIjogXCIzLjAuMFwiLFxuICAgIFwiZ3VscC1zb3VyY2VtYXBzXCI6IFwiMi42LjVcIixcbiAgICBcImd1bHAtdWdsaWZ5XCI6IFwiMy4wLjJcIixcbiAgICBcImd1bHAtdXRpbFwiOiBcIjMuMC44XCIsXG4gICAgXCJqYXNtaW5lLWNoZWNrXCI6IFwiMC4xLjVcIixcbiAgICBcImplc3RcIjogXCIyNi41LjJcIixcbiAgICBcIm1hcmtlZFwiOiBcIjEuMi4wXCIsXG4gICAgXCJtaWNyb3RpbWVcIjogXCIzLjAuMFwiLFxuICAgIFwibWtkaXJwXCI6IFwiMS4wLjRcIixcbiAgICBcIm5wbS1ydW4tYWxsXCI6IFwiNC4xLjVcIixcbiAgICBcInByZXR0aWVyXCI6IFwiXjIuMy4xXCIsXG4gICAgXCJyZWFjdFwiOiBcIl4wLjEyLjJcIixcbiAgICBcInJlYWN0LXJvdXRlclwiOiBcIl4wLjExLjZcIixcbiAgICBcInJlYWN0LXRvb2xzXCI6IFwiMC4xMy4zXCIsXG4gICAgXCJyaW1yYWZcIjogXCIzLjAuMlwiLFxuICAgIFwicm9sbHVwXCI6IFwiMi4yOS4wXCIsXG4gICAgXCJyb2xsdXAtcGx1Z2luLWJ1YmxlXCI6IFwiMC4xOS4yXCIsXG4gICAgXCJyb2xsdXAtcGx1Z2luLWNvbW1vbmpzXCI6IFwiOS4xLjNcIixcbiAgICBcInJvbGx1cC1wbHVnaW4tanNvblwiOiBcIjMuMC4wXCIsXG4gICAgXCJyb2xsdXAtcGx1Z2luLXN0cmlwLWJhbm5lclwiOiBcIjIuMC4wXCIsXG4gICAgXCJ0aHJvdWdoMlwiOiBcIjQuMC4yXCIsXG4gICAgXCJ0cmFuc2R1Y2Vycy1qc1wiOiBcIl4wLjQuMTc0XCIsXG4gICAgXCJ0c2xpbnRcIjogXCI1LjIwLjFcIixcbiAgICBcInR5cGVzY3JpcHRcIjogXCIzLjAuM1wiLFxuICAgIFwidWdsaWZ5LWpzXCI6IFwiMy4xMS4xXCIsXG4gICAgXCJ1Z2xpZnktc2F2ZS1saWNlbnNlXCI6IFwiMC40LjFcIixcbiAgICBcInZpbnlsLWJ1ZmZlclwiOiBcIjEuMC4xXCIsXG4gICAgXCJ2aW55bC1zb3VyY2Utc3RyZWFtXCI6IFwiMi4wLjBcIlxuICB9LFxuICBcImZpbGVzXCI6IFtcbiAgICBcImRpc3RcIixcbiAgICBcImNvbnRyaWJcIixcbiAgICBcIlJFQURNRS5tZFwiLFxuICAgIFwiTElDRU5TRVwiXG4gIF0sXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiaW1tdXRhYmxlXCIsXG4gICAgXCJwZXJzaXN0ZW50XCIsXG4gICAgXCJsYXp5XCIsXG4gICAgXCJkYXRhXCIsXG4gICAgXCJkYXRhc3RydWN0dXJlXCIsXG4gICAgXCJmdW5jdGlvbmFsXCIsXG4gICAgXCJjb2xsZWN0aW9uXCIsXG4gICAgXCJzdGF0ZWxlc3NcIixcbiAgICBcInNlcXVlbmNlXCIsXG4gICAgXCJpdGVyYXRpb25cIlxuICBdXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XCJJbW11dGFibGVcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiSW1tdXRhYmxlIGRhdGEgZW5jb3VyYWdlcyBwdXJlIGZ1bmN0aW9ucyAoZGF0YS1pbiwgZGF0YS1vdXQpIGFuZCBsZW5kcyBpdHNlbGZcXG50byBtdWNoIHNpbXBsZXIgYXBwbGljYXRpb24gZGV2ZWxvcG1lbnQgYW5kIGVuYWJsaW5nIHRlY2huaXF1ZXMgZnJvbVxcbmZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgc3VjaCBhcyBsYXp5IGV2YWx1YXRpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiV2hpbGUgZGVzaWduZWQgdG8gYnJpbmcgdGhlc2UgcG93ZXJmdWwgZnVuY3Rpb25hbCBjb25jZXB0cyB0byBKYXZhU2NyaXB0LCBpdFxcbnByZXNlbnRzIGFuIE9iamVjdC1PcmllbnRlZCBBUEkgZmFtaWxpYXIgdG8gSmF2YXNjcmlwdCBlbmdpbmVlcnMgYW5kIGNsb3NlbHlcXG5taXJyb3JpbmcgdGhhdCBvZiBBcnJheSwgTWFwLCBhbmQgU2V0LiBJdCBpcyBlYXN5IGFuZCBlZmZpY2llbnQgdG8gY29udmVydCB0b1xcbmFuZCBmcm9tIHBsYWluIEphdmFzY3JpcHQgdHlwZXMuXFxuXFxuIyMgSG93IHRvIHJlYWQgdGhlc2UgZG9jc1xcblxcbkluIG9yZGVyIHRvIGJldHRlciBleHBsYWluIHdoYXQga2luZHMgb2YgdmFsdWVzIHRoZSBJbW11dGFibGUuanMgQVBJIGV4cGVjdHNcXG5hbmQgcHJvZHVjZXMsIHRoaXMgZG9jdW1lbnRhdGlvbiBpcyBwcmVzZW50ZWQgaW4gYSBzdGF0aWNhbGx5IHR5cGVkIGRpYWxlY3Qgb2ZcXG5KYXZhU2NyaXB0IChsaWtlIFtGbG93XVtdIG9yIFtUeXBlU2NyaXB0XVtdKS4gWW91ICpkb24ndCBuZWVkKiB0byB1c2UgdGhlc2VcXG50eXBlIGNoZWNraW5nIHRvb2xzIGluIG9yZGVyIHRvIHVzZSBJbW11dGFibGUuanMsIGhvd2V2ZXIgYmVjb21pbmcgZmFtaWxpYXJcXG53aXRoIHRoZWlyIHN5bnRheCB3aWxsIGhlbHAgeW91IGdldCBhIGRlZXBlciB1bmRlcnN0YW5kaW5nIG9mIHRoaXMgQVBJLlxcblxcbioqQSBmZXcgZXhhbXBsZXMgYW5kIGhvdyB0byByZWFkIHRoZW0uKipcXG5cXG5BbGwgbWV0aG9kcyBkZXNjcmliZSB0aGUga2luZHMgb2YgZGF0YSB0aGV5IGFjY2VwdCBhbmQgdGhlIGtpbmRzIG9mIGRhdGFcXG50aGV5IHJldHVybi4gRm9yIGV4YW1wbGUgYSBmdW5jdGlvbiB3aGljaCBhY2NlcHRzIHR3byBudW1iZXJzIGFuZCByZXR1cm5zXFxuYSBudW1iZXIgd291bGQgbG9vayBsaWtlIHRoaXM6XFxuXFxuYGBganNcXG5zdW0oZmlyc3Q6IG51bWJlciwgc2Vjb25kOiBudW1iZXIpOiBudW1iZXJcXG5gYGBcXG5cXG5Tb21ldGltZXMsIG1ldGhvZHMgY2FuIGFjY2VwdCBkaWZmZXJlbnQga2luZHMgb2YgZGF0YSBvciByZXR1cm4gZGlmZmVyZW50XFxua2luZHMgb2YgZGF0YSwgYW5kIHRoaXMgaXMgZGVzY3JpYmVkIHdpdGggYSAqdHlwZSB2YXJpYWJsZSosIHdoaWNoIGlzXFxudHlwaWNhbGx5IGluIGFsbC1jYXBzLiBGb3IgZXhhbXBsZSwgYSBmdW5jdGlvbiB3aGljaCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZVxcbmtpbmQgb2YgZGF0YSBpdCB3YXMgcHJvdmlkZWQgd291bGQgbG9vayBsaWtlIHRoaXM6XFxuXFxuYGBganNcXG5pZGVudGl0eTxUPih2YWx1ZTogVCk6IFRcXG5gYGBcXG5cXG5UeXBlIHZhcmlhYmxlcyBhcmUgZGVmaW5lZCB3aXRoIGNsYXNzZXMgYW5kIHJlZmVycmVkIHRvIGluIG1ldGhvZHMuIEZvclxcbmV4YW1wbGUsIGEgY2xhc3MgdGhhdCBob2xkcyBvbnRvIGEgdmFsdWUgZm9yIHlvdSBtaWdodCBsb29rIGxpa2UgdGhpczpcXG5cXG5gYGBqc1xcbmNsYXNzIEJveDxUPiB7XFxuICBjb25zdHJ1Y3Rvcih2YWx1ZTogVClcXG4gIGdldFZhbHVlKCk6IFRcXG59XFxuYGBgXFxuXFxuSW4gb3JkZXIgdG8gbWFuaXB1bGF0ZSBJbW11dGFibGUgZGF0YSwgbWV0aG9kcyB0aGF0IHdlJ3JlIHVzZWQgdG8gYWZmZWN0aW5nXFxuYSBDb2xsZWN0aW9uIGluc3RlYWQgcmV0dXJuIGEgbmV3IENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZS4gVGhlIHR5cGVcXG5gdGhpc2AgcmVmZXJzIHRvIHRoZSBzYW1lIGtpbmQgb2YgY2xhc3MuIEZvciBleGFtcGxlLCBhIExpc3Qgd2hpY2ggcmV0dXJuc1xcbm5ldyBMaXN0cyB3aGVuIHlvdSBgcHVzaGAgYSB2YWx1ZSBvbnRvIGl0IG1pZ2h0IGxvb2sgbGlrZTpcXG5cXG5gYGBqc1xcbmNsYXNzIExpc3Q8VD4ge1xcbiAgcHVzaCh2YWx1ZTogVCk6IHRoaXNcXG59XFxuYGBgXFxuXFxuTWFueSBtZXRob2RzIGluIEltbXV0YWJsZS5qcyBhY2NlcHQgdmFsdWVzIHdoaWNoIGltcGxlbWVudCB0aGUgSmF2YVNjcmlwdFxcbltJdGVyYWJsZV1bXSBwcm90b2NvbCwgYW5kIG1pZ2h0IGFwcGVhciBsaWtlIGBJdGVyYWJsZTxzdHJpbmc+YCBmb3Igc29tZXRoaW5nXFxud2hpY2ggcmVwcmVzZW50cyBzZXF1ZW5jZSBvZiBzdHJpbmdzLiBUeXBpY2FsbHkgaW4gSmF2YVNjcmlwdCB3ZSB1c2UgcGxhaW5cXG5BcnJheXMgKGBbXWApIHdoZW4gYW4gSXRlcmFibGUgaXMgZXhwZWN0ZWQsIGJ1dCBhbHNvIGFsbCBvZiB0aGUgSW1tdXRhYmxlLmpzXFxuY29sbGVjdGlvbnMgYXJlIGl0ZXJhYmxlIHRoZW1zZWx2ZXMhXFxuXFxuRm9yIGV4YW1wbGUsIHRvIGdldCBhIHZhbHVlIGRlZXAgd2l0aGluIGEgc3RydWN0dXJlIG9mIGRhdGEsIHdlIG1pZ2h0IHVzZVxcbmBnZXRJbmAgd2hpY2ggZXhwZWN0cyBhbiBgSXRlcmFibGVgIHBhdGg6XFxuXFxuYGBgXFxuZ2V0SW4ocGF0aDogSXRlcmFibGU8c3RyaW5nIHwgbnVtYmVyPik6IHVua25vd25cXG5gYGBcXG5cXG5UbyB1c2UgdGhpcyBtZXRob2QsIHdlIGNvdWxkIHBhc3MgYW4gYXJyYXk6IGBkYXRhLmdldEluKFsgXFxcImtleVxcXCIsIDIgXSlgLlxcblxcblxcbk5vdGU6IEFsbCBleGFtcGxlcyBhcmUgcHJlc2VudGVkIGluIHRoZSBtb2Rlcm4gW0VTMjAxNV1bXSB2ZXJzaW9uIG9mXFxuSmF2YVNjcmlwdC4gVXNlIHRvb2xzIGxpa2UgQmFiZWwgdG8gc3VwcG9ydCBvbGRlciBicm93c2Vycy5cXG5cXG5Gb3IgZXhhbXBsZTpcXG5cXG5gYGBqc1xcbi8vIEVTMjAxNVxcbmNvbnN0IG1hcHBlZEZvbyA9IGZvby5tYXAoeCA9PiB4ICogeCk7XFxuLy8gRVM1XFxudmFyIG1hcHBlZEZvbyA9IGZvby5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggKiB4OyB9KTtcXG5gYGBcXG5cXG5bRVMyMDE1XTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9OZXdfaW5fSmF2YVNjcmlwdC9FQ01BU2NyaXB0XzZfc3VwcG9ydF9pbl9Nb3ppbGxhXFxuW1R5cGVTY3JpcHRdOiBodHRwOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9cXG5bRmxvd106IGh0dHBzOi8vZmxvd3R5cGUub3JnL1xcbltJdGVyYWJsZV06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0l0ZXJhdGlvbl9wcm90b2NvbHNcIixcIm5vdGVzXCI6W119LFwibW9kdWxlXCI6e1wiTGlzdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJMaXN0cyBhcmUgb3JkZXJlZCBpbmRleGVkIGRlbnNlIGNvbGxlY3Rpb25zLCBtdWNoIGxpa2UgYSBKYXZhU2NyaXB0XFxuQXJyYXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiTGlzdHMgYXJlIGltbXV0YWJsZSBhbmQgZnVsbHkgcGVyc2lzdGVudCB3aXRoIE8obG9nMzIgTikgZ2V0cyBhbmQgc2V0cyxcXG5hbmQgTygxKSBwdXNoIGFuZCBwb3AuXFxuXFxuTGlzdHMgaW1wbGVtZW50IERlcXVlLCB3aXRoIGVmZmljaWVudCBhZGRpdGlvbiBhbmQgcmVtb3ZhbCBmcm9tIGJvdGggdGhlXFxuZW5kIChgcHVzaGAsIGBwb3BgKSBhbmQgYmVnaW5uaW5nIChgdW5zaGlmdGAsIGBzaGlmdGApLlxcblxcblVubGlrZSBhIEphdmFTY3JpcHQgQXJyYXksIHRoZXJlIGlzIG5vIGRpc3RpbmN0aW9uIGJldHdlZW4gYW5cXG5cXFwidW5zZXRcXFwiIGluZGV4IGFuZCBhbiBpbmRleCBzZXQgdG8gYHVuZGVmaW5lZGAuIGBMaXN0I2ZvckVhY2hgIHZpc2l0cyBhbGxcXG5pbmRpY2VzIGZyb20gMCB0byBzaXplLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhleSB3ZXJlIGV4cGxpY2l0bHkgZGVmaW5lZC5cIixcIm5vdGVzXCI6W119LFwibW9kdWxlXCI6e1wiaXNMaXN0XCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBhIExpc3RcIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxuTGlzdC5pc0xpc3QoW10pOyAvLyBmYWxzZVxcbkxpc3QuaXNMaXN0KExpc3QoKSk7IC8vIHRydWVcXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVMaXN0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjoxMjB9XX19LFwib2ZcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNyZWF0ZXMgYSBuZXcgTGlzdCBjb250YWluaW5nIGB2YWx1ZXNgLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXG5MaXN0Lm9mKDEsIDIsIDMsIDQpXFxuLy8gTGlzdCBbIDEsIDIsIDMsIDQgXVxcbmBgYFxcblxcbk5vdGU6IFZhbHVlcyBhcmUgbm90IGFsdGVyZWQgb3IgY29udmVydGVkIGluIGFueSB3YXkuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcbkxpc3Qub2Yoe3g6MX0sIDIsIFszXSwgNClcXG4vLyBMaXN0IFsgeyB4OiAxIH0sIDIsIFsgMyBdLCA0IF1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZXNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoxNDF9XX19fSxcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQ3JlYXRlIGEgbmV3IGltbXV0YWJsZSBMaXN0IGNvbnRhaW5pbmcgdGhlIHZhbHVlcyBvZiB0aGUgcHJvdmlkZWRcXG5jb2xsZWN0aW9uLWxpa2UuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYExpc3RgIGlzIGEgZmFjdG9yeSBmdW5jdGlvbiBhbmQgbm90IGEgY2xhc3MsIGFuZCBkb2VzIG5vdCB1c2UgdGhlXFxuYG5ld2Aga2V5d29yZCBkdXJpbmcgY29uc3RydWN0aW9uLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBMaXN0LCBTZXQgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuXFxuY29uc3QgZW1wdHlMaXN0ID0gTGlzdCgpXFxuLy8gTGlzdCBbXVxcblxcbmNvbnN0IHBsYWluQXJyYXkgPSBbIDEsIDIsIDMsIDQgXVxcbmNvbnN0IGxpc3RGcm9tUGxhaW5BcnJheSA9IExpc3QocGxhaW5BcnJheSlcXG4vLyBMaXN0IFsgMSwgMiwgMywgNCBdXFxuXFxuY29uc3QgcGxhaW5TZXQgPSBTZXQoWyAxLCAyLCAzLCA0IF0pXFxuY29uc3QgbGlzdEZyb21QbGFpblNldCA9IExpc3QocGxhaW5TZXQpXFxuLy8gTGlzdCBbIDEsIDIsIDMsIDQgXVxcblxcbmNvbnN0IGFycmF5SXRlcmF0b3IgPSBwbGFpbkFycmF5W1N5bWJvbC5pdGVyYXRvcl0oKVxcbmNvbnN0IGxpc3RGcm9tQ29sbGVjdGlvbkFycmF5ID0gTGlzdChhcnJheUl0ZXJhdG9yKVxcbi8vIExpc3QgWyAxLCAyLCAzLCA0IF1cXG5cXG5saXN0RnJvbVBsYWluQXJyYXkuZXF1YWxzKGxpc3RGcm9tQ29sbGVjdGlvbkFycmF5KSAvLyB0cnVlXFxubGlzdEZyb21QbGFpblNldC5lcXVhbHMobGlzdEZyb21Db2xsZWN0aW9uQXJyYXkpIC8vIHRydWVcXG5saXN0RnJvbVBsYWluU2V0LmVxdWFscyhsaXN0RnJvbVBsYWluQXJyYXkpIC8vIHRydWVcXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcImxpbmVcIjoxNzV9LHtcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTc2fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjE3N31dfSxcImludGVyZmFjZVwiOntcImxpbmVcIjoxNzksXCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcImV4dGVuZHNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19XSxcImdyb3Vwc1wiOlt7XCJtZW1iZXJzXCI6e1wiI3NpemVcIjp7XCJsaW5lXCI6MTg0fX19LHtcInRpdGxlXCI6XCJQZXJzaXN0ZW50IGNoYW5nZXNcIixcIm1lbWJlcnNcIjp7XCIjc2V0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTGlzdCB3aGljaCBpbmNsdWRlcyBgdmFsdWVgIGF0IGBpbmRleGAuIElmIGBpbmRleGAgYWxyZWFkeVxcbmV4aXN0cyBpbiB0aGlzIExpc3QsIGl0IHdpbGwgYmUgcmVwbGFjZWQuXCIsXCJkZXNjcmlwdGlvblwiOlwiYGluZGV4YCBtYXkgYmUgYSBuZWdhdGl2ZSBudW1iZXIsIHdoaWNoIGluZGV4ZXMgYmFjayBmcm9tIHRoZSBlbmQgb2YgdGhlXFxuTGlzdC4gYHYuc2V0KC0xLCBcXFwidmFsdWVcXFwiKWAgc2V0cyB0aGUgbGFzdCBpdGVtIGluIHRoZSBMaXN0LlxcblxcbklmIGBpbmRleGAgbGFyZ2VyIHRoYW4gYHNpemVgLCB0aGUgcmV0dXJuZWQgTGlzdCdzIGBzaXplYCB3aWxsIGJlIGxhcmdlXFxuZW5vdWdoIHRvIGluY2x1ZGUgdGhlIGBpbmRleGAuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBvcmlnaW5hbExpc3QgPSBMaXN0KFsgMCBdKTtcXG4vLyBMaXN0IFsgMCBdXFxub3JpZ2luYWxMaXN0LnNldCgxLCAxKTtcXG4vLyBMaXN0IFsgMCwgMSBdXFxub3JpZ2luYWxMaXN0LnNldCgwLCAnb3ZlcndyaXR0ZW4nKTtcXG4vLyBMaXN0IFsgXFxcIm92ZXJ3cml0dGVuXFxcIiBdXFxub3JpZ2luYWxMaXN0LnNldCgyLCAyKTtcXG4vLyBMaXN0IFsgMCwgdW5kZWZpbmVkLCAyIF1cXG5cXG5MaXN0KCkuc2V0KDUwMDAwLCAndmFsdWUnKS5zaXplO1xcbi8vIDUwMDAxXFxuYGBgXFxuXFxuTm90ZTogYHNldGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJpbmRleFwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoyMTd9XX0sXCIjZGVsZXRlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTGlzdCB3aGljaCBleGNsdWRlcyB0aGlzIGBpbmRleGAgYW5kIHdpdGggYSBzaXplIDEgbGVzc1xcbnRoYW4gdGhpcyBMaXN0LiBWYWx1ZXMgYXQgaW5kaWNlcyBhYm92ZSBgaW5kZXhgIGFyZSBzaGlmdGVkIGRvd24gYnkgMSB0b1xcbmZpbGwgdGhlIHBvc2l0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIlRoaXMgaXMgc3lub255bW91cyB3aXRoIGBsaXN0LnNwbGljZShpbmRleCwgMSlgLlxcblxcbmBpbmRleGAgbWF5IGJlIGEgbmVnYXRpdmUgbnVtYmVyLCB3aGljaCBpbmRleGVzIGJhY2sgZnJvbSB0aGUgZW5kIG9mIHRoZVxcbkxpc3QuIGB2LmRlbGV0ZSgtMSlgIGRlbGV0ZXMgdGhlIGxhc3QgaXRlbSBpbiB0aGUgTGlzdC5cXG5cXG5Ob3RlOiBgZGVsZXRlYCBjYW5ub3QgYmUgc2FmZWx5IHVzZWQgaW4gSUU4XFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5MaXN0KFsgMCwgMSwgMiwgMywgNCBdKS5kZWxldGUoMCk7XFxuLy8gTGlzdCBbIDEsIDIsIDMsIDQgXVxcbmBgYFxcblxcblNpbmNlIGBkZWxldGUoKWAgcmUtaW5kZXhlcyB2YWx1ZXMsIGl0IHByb2R1Y2VzIGEgY29tcGxldGUgY29weSwgd2hpY2hcXG5oYXMgYE8oTilgIGNvbXBsZXhpdHkuXFxuXFxuTm90ZTogYGRlbGV0ZWAgKmNhbm5vdCogYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXFxuXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJhbGlhc1wiLFwiYm9keVwiOlwicmVtb3ZlXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJpbmRleFwiLFwidHlwZVwiOntcImtcIjoyfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MjQ2fV19LFwiI2luc2VydFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IExpc3Qgd2l0aCBgdmFsdWVgIGF0IGBpbmRleGAgd2l0aCBhIHNpemUgMSBtb3JlIHRoYW4gdGhpc1xcbkxpc3QuIFZhbHVlcyBhdCBpbmRpY2VzIGFib3ZlIGBpbmRleGAgYXJlIHNoaWZ0ZWQgb3ZlciBieSAxLlwiLFwiZGVzY3JpcHRpb25cIjpcIlRoaXMgaXMgc3lub255bW91cyB3aXRoIGBsaXN0LnNwbGljZShpbmRleCwgMCwgdmFsdWUpYC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbkxpc3QoWyAwLCAxLCAyLCAzLCA0IF0pLmluc2VydCg2LCA1KVxcbi8vIExpc3QgWyAwLCAxLCAyLCAzLCA0LCA1IF1cXG5gYGBcXG5cXG5TaW5jZSBgaW5zZXJ0KClgIHJlLWluZGV4ZXMgdmFsdWVzLCBpdCBwcm9kdWNlcyBhIGNvbXBsZXRlIGNvcHksIHdoaWNoXFxuaGFzIGBPKE4pYCBjb21wbGV4aXR5Llxcblxcbk5vdGU6IGBpbnNlcnRgICpjYW5ub3QqIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJpbmRleFwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoyNjh9XX0sXCIjY2xlYXJcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBMaXN0IHdpdGggMCBzaXplIGFuZCBubyB2YWx1ZXMgaW4gY29uc3RhbnQgdGltZS5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbkxpc3QoWyAxLCAyLCAzLCA0IF0pLmNsZWFyKClcXG4vLyBMaXN0IFtdXFxuYGBgXFxuXFxuTm90ZTogYGNsZWFyYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MjgzfV19LFwiI3B1c2hcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBMaXN0IHdpdGggdGhlIHByb3ZpZGVkIGB2YWx1ZXNgIGFwcGVuZGVkLCBzdGFydGluZyBhdCB0aGlzXFxuTGlzdCdzIGBzaXplYC5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbkxpc3QoWyAxLCAyLCAzLCA0IF0pLnB1c2goNSlcXG4vLyBMaXN0IFsgMSwgMiwgMywgNCwgNSBdXFxuYGBgXFxuXFxuTm90ZTogYHB1c2hgIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVzXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6Mjk5fV19LFwiI3BvcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IExpc3Qgd2l0aCBhIHNpemUgb25lcyBsZXNzIHRoYW4gdGhpcyBMaXN0LCBleGNsdWRpbmdcXG50aGUgbGFzdCBpbmRleCBpbiB0aGlzIExpc3QuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogdGhpcyBkaWZmZXJzIGZyb20gYEFycmF5I3BvcGAgYmVjYXVzZSBpdCByZXR1cm5zIGEgbmV3XFxuTGlzdCByYXRoZXIgdGhhbiB0aGUgcmVtb3ZlZCB2YWx1ZS4gVXNlIGBsYXN0KClgIHRvIGdldCB0aGUgbGFzdCB2YWx1ZVxcbmluIHRoaXMgTGlzdC5cXG5cXG5gYGBqc1xcbkxpc3QoWyAxLCAyLCAzLCA0IF0pLnBvcCgpXFxuLy8gTGlzdFsgMSwgMiwgMyBdXFxuYGBgXFxuXFxuTm90ZTogYHBvcGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjMxNn1dfSxcIiN1bnNoaWZ0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTGlzdCB3aXRoIHRoZSBwcm92aWRlZCBgdmFsdWVzYCBwcmVwZW5kZWQsIHNoaWZ0aW5nIG90aGVyXFxudmFsdWVzIGFoZWFkIHRvIGhpZ2hlciBpbmRpY2VzLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuTGlzdChbIDIsIDMsIDRdKS51bnNoaWZ0KDEpO1xcbi8vIExpc3QgWyAxLCAyLCAzLCA0IF1cXG5gYGBcXG5cXG5Ob3RlOiBgdW5zaGlmdGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZXNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjozMzJ9XX0sXCIjc2hpZnRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBMaXN0IHdpdGggYSBzaXplIG9uZXMgbGVzcyB0aGFuIHRoaXMgTGlzdCwgZXhjbHVkaW5nXFxudGhlIGZpcnN0IGluZGV4IGluIHRoaXMgTGlzdCwgc2hpZnRpbmcgYWxsIG90aGVyIHZhbHVlcyB0byBhIGxvd2VyIGluZGV4LlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IHRoaXMgZGlmZmVycyBmcm9tIGBBcnJheSNzaGlmdGAgYmVjYXVzZSBpdCByZXR1cm5zIGEgbmV3XFxuTGlzdCByYXRoZXIgdGhhbiB0aGUgcmVtb3ZlZCB2YWx1ZS4gVXNlIGBmaXJzdCgpYCB0byBnZXQgdGhlIGZpcnN0XFxudmFsdWUgaW4gdGhpcyBMaXN0LlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuTGlzdChbIDAsIDEsIDIsIDMsIDQgXSkuc2hpZnQoKTtcXG4vLyBMaXN0IFsgMSwgMiwgMywgNCBdXFxuYGBgXFxuXFxuTm90ZTogYHNoaWZ0YCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MzUyfV19LFwiI3VwZGF0ZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IExpc3Qgd2l0aCBhbiB1cGRhdGVkIHZhbHVlIGF0IGBpbmRleGAgd2l0aCB0aGUgcmV0dXJuXFxudmFsdWUgb2YgY2FsbGluZyBgdXBkYXRlcmAgd2l0aCB0aGUgZXhpc3RpbmcgdmFsdWUsIG9yIGBub3RTZXRWYWx1ZWAgaWZcXG5gaW5kZXhgIHdhcyBub3Qgc2V0LiBJZiBjYWxsZWQgd2l0aCBhIHNpbmdsZSBhcmd1bWVudCwgYHVwZGF0ZXJgIGlzXFxuY2FsbGVkIHdpdGggdGhlIExpc3QgaXRzZWxmLlwiLFwiZGVzY3JpcHRpb25cIjpcImBpbmRleGAgbWF5IGJlIGEgbmVnYXRpdmUgbnVtYmVyLCB3aGljaCBpbmRleGVzIGJhY2sgZnJvbSB0aGUgZW5kIG9mIHRoZVxcbkxpc3QuIGB2LnVwZGF0ZSgtMSlgIHVwZGF0ZXMgdGhlIGxhc3QgaXRlbSBpbiB0aGUgTGlzdC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmNvbnN0IGxpc3QgPSBMaXN0KFsgJ2EnLCAnYicsICdjJyBdKVxcbmNvbnN0IHJlc3VsdCA9IGxpc3QudXBkYXRlKDIsIHZhbCA9PiB2YWwudG9VcHBlckNhc2UoKSlcXG4vLyBMaXN0IFsgXFxcImFcXFwiLCBcXFwiYlxcXCIsIFxcXCJDXFxcIiBdXFxuYGBgXFxuXFxuVGhpcyBjYW4gYmUgdmVyeSB1c2VmdWwgYXMgYSB3YXkgdG8gXFxcImNoYWluXFxcIiBhIG5vcm1hbCBmdW5jdGlvbiBpbnRvIGFcXG5zZXF1ZW5jZSBvZiBtZXRob2RzLiBSeEpTIGNhbGxzIHRoaXMgXFxcImxldFxcXCIgYW5kIGxvZGFzaCBjYWxscyBpdCBcXFwidGhydVxcXCIuXFxuXFxuRm9yIGV4YW1wbGUsIHRvIHN1bSBhIExpc3QgYWZ0ZXIgbWFwcGluZyBhbmQgZmlsdGVyaW5nOlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuZnVuY3Rpb24gc3VtKGNvbGxlY3Rpb24pIHtcXG4gIHJldHVybiBjb2xsZWN0aW9uLnJlZHVjZSgoc3VtLCB4KSA9PiBzdW0gKyB4LCAwKVxcbn1cXG5cXG5MaXN0KFsgMSwgMiwgMyBdKVxcbiAgLm1hcCh4ID0+IHggKyAxKVxcbiAgLmZpbHRlcih4ID0+IHggJSAyID09PSAwKVxcbiAgLnVwZGF0ZShzdW0pXFxuLy8gNlxcbmBgYFxcblxcbk5vdGU6IGB1cGRhdGUoaW5kZXgpYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXFxuXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcImBNYXAjdXBkYXRlYFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcIm5vdFNldFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjozOTZ9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJpbmRleFwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjozOTd9LHtcInR5cGVQYXJhbXNcIjpbXCJSXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJSXCJ9fX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlJcIn0sXCJsaW5lXCI6Mzk4fV19LFwiI3NldFNpemVcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBMaXN0IHdpdGggc2l6ZSBgc2l6ZWAuIElmIGBzaXplYCBpcyBsZXNzIHRoYW4gdGhpc1xcbkxpc3QncyBzaXplLCB0aGUgbmV3IExpc3Qgd2lsbCBleGNsdWRlIHZhbHVlcyBhdCB0aGUgaGlnaGVyIGluZGljZXMuXFxuSWYgYHNpemVgIGlzIGdyZWF0ZXIgdGhhbiB0aGlzIExpc3QncyBzaXplLCB0aGUgbmV3IExpc3Qgd2lsbCBoYXZlXFxudW5kZWZpbmVkIHZhbHVlcyBmb3IgdGhlIG5ld2x5IGF2YWlsYWJsZSBpbmRpY2VzLlwiLFwiZGVzY3JpcHRpb25cIjpcIldoZW4gYnVpbGRpbmcgYSBuZXcgTGlzdCBhbmQgdGhlIGZpbmFsIHNpemUgaXMga25vd24gdXAgZnJvbnQsIGBzZXRTaXplYFxcbnVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgd2l0aE11dGF0aW9uc2AgbWF5IHJlc3VsdCBpbiB0aGUgbW9yZVxcbnBlcmZvcm1hbnQgY29uc3RydWN0aW9uLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzaXplXCIsXCJ0eXBlXCI6e1wia1wiOjJ9fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjo0MTB9XX19fSx7XCJ0aXRsZVwiOlwiRGVlcCBwZXJzaXN0ZW50IGNoYW5nZXNcIixcIm1lbWJlcnNcIjp7XCIjc2V0SW5cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBMaXN0IGhhdmluZyBzZXQgYHZhbHVlYCBhdCB0aGlzIGBrZXlQYXRoYC4gSWYgYW55IGtleXMgaW5cXG5ga2V5UGF0aGAgZG8gbm90IGV4aXN0LCBhIG5ldyBpbW11dGFibGUgTWFwIHdpbGwgYmUgY3JlYXRlZCBhdCB0aGF0IGtleS5cIixcImRlc2NyaXB0aW9uXCI6XCJJbmRleCBudW1iZXJzIGFyZSB1c2VkIGFzIGtleXMgdG8gZGV0ZXJtaW5lIHRoZSBwYXRoIHRvIGZvbGxvdyBpblxcbnRoZSBMaXN0LlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IGxpc3QgPSBMaXN0KFsgMCwgMSwgMiwgTGlzdChbIDMsIDQgXSldKVxcbmxpc3Quc2V0SW4oWzMsIDBdLCA5OTkpO1xcbi8vIExpc3QgWyAwLCAxLCAyLCBMaXN0IFsgOTk5LCA0IF0gXVxcbmBgYFxcblxcblBsYWluIEphdmFTY3JpcHQgT2JqZWN0IG9yIEFycmF5cyBtYXkgYmUgbmVzdGVkIHdpdGhpbiBhbiBJbW11dGFibGUuanNcXG5Db2xsZWN0aW9uLCBhbmQgc2V0SW4oKSBjYW4gdXBkYXRlIHRob3NlIHZhbHVlcyBhcyB3ZWxsLCB0cmVhdGluZyB0aGVtXFxuaW1tdXRhYmx5IGJ5IGNyZWF0aW5nIG5ldyBjb3BpZXMgb2YgdGhvc2UgdmFsdWVzIHdpdGggdGhlIGNoYW5nZXMgYXBwbGllZC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBsaXN0ID0gTGlzdChbIDAsIDEsIDIsIHsgcGxhaW46ICdvYmplY3QnIH1dKVxcbmxpc3Quc2V0SW4oWzMsICdwbGFpbiddLCAndmFsdWUnKTtcXG4vLyBMaXN0KFsgMCwgMSwgMiwgeyBwbGFpbjogJ3ZhbHVlJyB9XSlcXG5gYGBcXG5cXG5Ob3RlOiBgc2V0SW5gIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5UGF0aFwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjQ0NH1dfSxcIiNkZWxldGVJblwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IExpc3QgaGF2aW5nIHJlbW92ZWQgdGhlIHZhbHVlIGF0IHRoaXMgYGtleVBhdGhgLiBJZiBhbnlcXG5rZXlzIGluIGBrZXlQYXRoYCBkbyBub3QgZXhpc3QsIG5vIGNoYW5nZSB3aWxsIG9jY3VyLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IGxpc3QgPSBMaXN0KFsgMCwgMSwgMiwgTGlzdChbIDMsIDQgXSldKVxcbmxpc3QuZGVsZXRlSW4oWzMsIDBdKTtcXG4vLyBMaXN0IFsgMCwgMSwgMiwgTGlzdCBbIDQgXSBdXFxuYGBgXFxuXFxuUGxhaW4gSmF2YVNjcmlwdCBPYmplY3Qgb3IgQXJyYXlzIG1heSBiZSBuZXN0ZWQgd2l0aGluIGFuIEltbXV0YWJsZS5qc1xcbkNvbGxlY3Rpb24sIGFuZCByZW1vdmVJbigpIGNhbiB1cGRhdGUgdGhvc2UgdmFsdWVzIGFzIHdlbGwsIHRyZWF0aW5nIHRoZW1cXG5pbW11dGFibHkgYnkgY3JlYXRpbmcgbmV3IGNvcGllcyBvZiB0aG9zZSB2YWx1ZXMgd2l0aCB0aGUgY2hhbmdlcyBhcHBsaWVkLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IGxpc3QgPSBMaXN0KFsgMCwgMSwgMiwgeyBwbGFpbjogJ29iamVjdCcgfV0pXFxubGlzdC5yZW1vdmVJbihbMywgJ3BsYWluJ10pO1xcbi8vIExpc3QoWyAwLCAxLCAyLCB7fV0pXFxuYGBgXFxuXFxuTm90ZTogYGRlbGV0ZUluYCAqY2Fubm90KiBiZSBzYWZlbHkgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXFxuXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJhbGlhc1wiLFwiYm9keVwiOlwicmVtb3ZlSW5cIn1dfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NDc0fV19LFwiI3VwZGF0ZUluXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIk5vdGU6IGB1cGRhdGVJbmAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI3VwZGF0ZUluYFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5UGF0aFwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19fSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjoxN319LHtcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MTd9fX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NDgyfSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5UGF0aFwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19fSx7XCJuYW1lXCI6XCJ1cGRhdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjQ4M31dfSxcIiNtZXJnZUluXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIk5vdGU6IGBtZXJnZUluYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXFxuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcImBNYXAjbWVyZ2VJbmBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo0OTB9XX0sXCIjbWVyZ2VEZWVwSW5cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiTm90ZTogYG1lcmdlRGVlcEluYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXFxuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcImBNYXAjbWVyZ2VEZWVwSW5gXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlQYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX19LHtcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NDk3fV19fX0se1widGl0bGVcIjpcIlRyYW5zaWVudCBjaGFuZ2VzXCIsXCJtZW1iZXJzXCI6e1wiI3dpdGhNdXRhdGlvbnNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiTm90ZTogTm90IGFsbCBtZXRob2RzIGNhbiBiZSBzYWZlbHkgdXNlZCBvbiBhIG11dGFibGUgY29sbGVjdGlvbiBvciB3aXRoaW5cXG5gd2l0aE11dGF0aW9uc2AhIENoZWNrIHRoZSBkb2N1bWVudGF0aW9uIGZvciBlYWNoIG1ldGhvZCB0byBzZWUgaWYgaXRcXG5hbGxvd3MgYmVpbmcgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXFxuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcImBNYXAjd2l0aE11dGF0aW9uc2BcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm11dGF0b3JcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtdXRhYmxlXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxN319fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo1MDh9XX0sXCIjYXNNdXRhYmxlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkFuIGFsdGVybmF0aXZlIEFQSSBmb3Igd2l0aE11dGF0aW9ucygpXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogTm90IGFsbCBtZXRob2RzIGNhbiBiZSBzYWZlbHkgdXNlZCBvbiBhIG11dGFibGUgY29sbGVjdGlvbiBvciB3aXRoaW5cXG5gd2l0aE11dGF0aW9uc2AhIENoZWNrIHRoZSBkb2N1bWVudGF0aW9uIGZvciBlYWNoIG1ldGhvZCB0byBzZWUgaWYgaXRcXG5hbGxvd3MgYmVpbmcgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXFxuXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcImBNYXAjYXNNdXRhYmxlYFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo1MTl9XX0sXCIjd2FzQWx0ZXJlZFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiYE1hcCN3YXNBbHRlcmVkYFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjUyNH1dfSxcIiNhc0ltbXV0YWJsZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiYE1hcCNhc0ltbXV0YWJsZWBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NTI5fV19fX0se1widGl0bGVcIjpcIlNlcXVlbmNlIGFsZ29yaXRobXNcIixcIm1lbWJlcnNcIjp7XCIjY29uY2F0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTGlzdCB3aXRoIG90aGVyIHZhbHVlcyBvciBjb2xsZWN0aW9ucyBjb25jYXRlbmF0ZWQgdG8gdGhpcyBvbmUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYGNvbmNhdGAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwiYWxpYXNcIixcImJvZHlcIjpcIm1lcmdlXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlc09yQ29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifV19LHtcImtcIjo4LFwicGFyYW1cIjpcIkNcIn1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9XX1dfSxcImxpbmVcIjo1NDB9XX0sXCIjbWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTGlzdCB3aXRoIHZhbHVlcyBwYXNzZWQgdGhyb3VnaCBhXFxuYG1hcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5MaXN0KFsgMSwgMiBdKS5tYXAoeCA9PiAxMCAqIHgpXFxuLy8gTGlzdCBbIDEwLCAyMCBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjo1NTV9XX0sXCIjZmxhdE1hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJGbGF0LW1hcHMgdGhlIExpc3QsIHJldHVybmluZyBhIG5ldyBMaXN0LlwiLFwiZGVzY3JpcHRpb25cIjpcIlNpbWlsYXIgdG8gYGxpc3QubWFwKC4uLikuZmxhdHRlbih0cnVlKWAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6NTY1fV19LFwiI2ZpbHRlclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IExpc3Qgd2l0aCBvbmx5IHRoZSB2YWx1ZXMgZm9yIHdoaWNoIHRoZSBgcHJlZGljYXRlYFxcbmZ1bmN0aW9uIHJldHVybnMgdHJ1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgZmlsdGVyKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHJlc3VsdHMgaW5cXG5ub3QgZmlsdGVyaW5nIG91dCBhbnkgdmFsdWVzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJGXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiRlwifV19LFwibGluZVwiOjU3N30se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo1ODF9XX0sXCIjemlwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBMaXN0IFxcXCJ6aXBwZWRcXFwiIHdpdGggdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiTGlrZSBgemlwV2l0aGAsIGJ1dCB1c2luZyB0aGUgZGVmYXVsdCBgemlwcGVyYDogY3JlYXRpbmcgYW4gYEFycmF5YC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmNvbnN0IGEgPSBMaXN0KFsgMSwgMiwgMyBdKTtcXG5jb25zdCBiID0gTGlzdChbIDQsIDUsIDYgXSk7XFxuY29uc3QgYyA9IGEuemlwKGIpOyAvLyBMaXN0IFsgWyAxLCA0IF0sIFsgMiwgNSBdLCBbIDMsIDYgXSBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlVcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib3RoZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX1dfSxcImxpbmVcIjo2MDB9LHtcInR5cGVQYXJhbXNcIjpbXCJVXCIsXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fSx7XCJuYW1lXCI6XCJvdGhlcjJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfV19LFwibGluZVwiOjYwMX0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6MTd9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcImxpbmVcIjo2MDJ9XX0sXCIjemlwQWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBMaXN0IFxcXCJ6aXBwZWRcXFwiIHdpdGggdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb25zLlwiLFwiZGVzY3JpcHRpb25cIjpcIlVubGlrZSBgemlwYCwgYHppcEFsbGAgY29udGludWVzIHppcHBpbmcgdW50aWwgdGhlIGxvbmdlc3QgY29sbGVjdGlvbiBpc1xcbmV4aGF1c3RlZC4gTWlzc2luZyB2YWx1ZXMgZnJvbSBzaG9ydGVyIGNvbGxlY3Rpb25zIGFyZSBmaWxsZWQgd2l0aCBgdW5kZWZpbmVkYC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmNvbnN0IGEgPSBMaXN0KFsgMSwgMiBdKTtcXG5jb25zdCBiID0gTGlzdChbIDMsIDQsIDUgXSk7XFxuY29uc3QgYyA9IGEuemlwQWxsKGIpOyAvLyBMaXN0IFsgWyAxLCAzIF0sIFsgMiwgNCBdLCBbIHVuZGVmaW5lZCwgNSBdIF1cXG5gYGBcXG5cXG5Ob3RlOiBTaW5jZSB6aXBBbGwgd2lsbCByZXR1cm4gYSBjb2xsZWN0aW9uIGFzIGxhcmdlIGFzIHRoZSBsYXJnZXN0XFxuaW5wdXQsIHNvbWUgcmVzdWx0cyBtYXkgY29udGFpbiB1bmRlZmluZWQgdmFsdWVzLiBUeXBlU2NyaXB0IGNhbm5vdFxcbmFjY291bnQgZm9yIHRoZXNlIHdpdGhvdXQgY2FzZXMgKGFzIG9mIHYyLjUpLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJVXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19XX0sXCJsaW5lXCI6NjIzfSx7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlclwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX0se1wibmFtZVwiOlwib3RoZXIyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfSxcImxpbmVcIjo2MjR9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJsaW5lXCI6NjI1fV19LFwiI3ppcFdpdGhcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIExpc3QgXFxcInppcHBlZFxcXCIgd2l0aCB0aGUgcHJvdmlkZWQgY29sbGVjdGlvbnMgYnkgdXNpbmcgYVxcbmN1c3RvbSBgemlwcGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmNvbnN0IGEgPSBMaXN0KFsgMSwgMiwgMyBdKTtcXG5jb25zdCBiID0gTGlzdChbIDQsIDUsIDYgXSk7XFxuY29uc3QgYyA9IGEuemlwV2l0aCgoYSwgYikgPT4gYSArIGIsIGIpO1xcbi8vIExpc3QgWyA1LCA3LCA5IF1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiWlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ6aXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIm90aGVyVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifX19LHtcIm5hbWVcIjpcIm90aGVyQ29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9XX0sXCJsaW5lXCI6NjQxfSx7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiVlwiLFwiWlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ6aXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIm90aGVyVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9fSx7XCJuYW1lXCI6XCJ0aGlyZFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlpcIn19fSx7XCJuYW1lXCI6XCJvdGhlckNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19LHtcIm5hbWVcIjpcInRoaXJkQ29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTGlzdFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9XX0sXCJsaW5lXCI6NjQ1fSx7XCJ0eXBlUGFyYW1zXCI6W1wiWlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ6aXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJhbnlcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifX19LHtcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6MTd9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJMaXN0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlpcIn1dfSxcImxpbmVcIjo2NTB9XX19fV19fSxcIk1hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJJbW11dGFibGUgTWFwIGlzIGFuIHVub3JkZXJlZCBDb2xsZWN0aW9uLktleWVkIG9mIChrZXksIHZhbHVlKSBwYWlycyB3aXRoXFxuYE8obG9nMzIgTilgIGdldHMgYW5kIGBPKGxvZzMyIE4pYCBwZXJzaXN0ZW50IHNldHMuXCIsXCJkZXNjcmlwdGlvblwiOlwiSXRlcmF0aW9uIG9yZGVyIG9mIGEgTWFwIGlzIHVuZGVmaW5lZCwgaG93ZXZlciBpcyBzdGFibGUuIE11bHRpcGxlXFxuaXRlcmF0aW9ucyBvZiB0aGUgc2FtZSBNYXAgd2lsbCBpdGVyYXRlIGluIHRoZSBzYW1lIG9yZGVyLlxcblxcbk1hcCdzIGtleXMgY2FuIGJlIG9mIGFueSB0eXBlLCBhbmQgdXNlIGBJbW11dGFibGUuaXNgIHRvIGRldGVybWluZSBrZXlcXG5lcXVhbGl0eS4gVGhpcyBhbGxvd3MgdGhlIHVzZSBvZiBhbnkgdmFsdWUgKGluY2x1ZGluZyBOYU4pIGFzIGEga2V5LlxcblxcbkJlY2F1c2UgYEltbXV0YWJsZS5pc2AgcmV0dXJucyBlcXVhbGl0eSBiYXNlZCBvbiB2YWx1ZSBzZW1hbnRpY3MsIGFuZFxcbkltbXV0YWJsZSBjb2xsZWN0aW9ucyBhcmUgdHJlYXRlZCBhcyB2YWx1ZXMsIGFueSBJbW11dGFibGUgY29sbGVjdGlvbiBtYXlcXG5iZSB1c2VkIGFzIGEga2V5LlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAsIExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcbk1hcCgpLnNldChMaXN0KFsgMSBdKSwgJ2xpc3RvZm9uZScpLmdldChMaXN0KFsgMSBdKSk7XFxuLy8gJ2xpc3RvZm9uZSdcXG5gYGBcXG5cXG5BbnkgSmF2YVNjcmlwdCBvYmplY3QgbWF5IGJlIHVzZWQgYXMgYSBrZXksIGhvd2V2ZXIgc3RyaWN0IGlkZW50aXR5IGlzIHVzZWRcXG50byBldmFsdWF0ZSBrZXkgZXF1YWxpdHkuIFR3byBzaW1pbGFyIGxvb2tpbmcgb2JqZWN0cyB3aWxsIHJlcHJlc2VudCB0d29cXG5kaWZmZXJlbnQga2V5cy5cXG5cXG5JbXBsZW1lbnRlZCBieSBhIGhhc2gtYXJyYXkgbWFwcGVkIHRyaWUuXCIsXCJub3Rlc1wiOltdfSxcIm1vZHVsZVwiOntcImlzTWFwXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBhIE1hcFwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuTWFwLmlzTWFwKHt9KSAvLyBmYWxzZVxcbk1hcC5pc01hcChNYXAoKSkgLy8gdHJ1ZVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXliZU1hcFwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6Njk2fV19fX0sXCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNyZWF0ZXMgYSBuZXcgSW1tdXRhYmxlIE1hcC5cIixcImRlc2NyaXB0aW9uXCI6XCJDcmVhdGVkIHdpdGggdGhlIHNhbWUga2V5IHZhbHVlIHBhaXJzIGFzIHRoZSBwcm92aWRlZCBDb2xsZWN0aW9uLktleWVkIG9yXFxuSmF2YVNjcmlwdCBPYmplY3Qgb3IgZXhwZWN0cyBhIENvbGxlY3Rpb24gb2YgW0ssIFZdIHR1cGxlIGVudHJpZXMuXFxuXFxuTm90ZTogYE1hcGAgaXMgYSBmYWN0b3J5IGZ1bmN0aW9uIGFuZCBub3QgYSBjbGFzcywgYW5kIGRvZXMgbm90IHVzZSB0aGVcXG5gbmV3YCBrZXl3b3JkIGR1cmluZyBjb25zdHJ1Y3Rpb24uXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IE1hcCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5NYXAoeyBrZXk6IFxcXCJ2YWx1ZVxcXCIgfSlcXG5NYXAoWyBbIFxcXCJrZXlcXFwiLCBcXFwidmFsdWVcXFwiIF0gXSlcXG5gYGBcXG5cXG5LZWVwIGluIG1pbmQsIHdoZW4gdXNpbmcgSlMgb2JqZWN0cyB0byBjb25zdHJ1Y3QgSW1tdXRhYmxlIE1hcHMsIHRoYXRcXG5KYXZhU2NyaXB0IE9iamVjdCBwcm9wZXJ0aWVzIGFyZSBhbHdheXMgc3RyaW5ncywgZXZlbiBpZiB3cml0dGVuIGluIGFcXG5xdW90ZS1sZXNzIHNob3J0aGFuZCwgd2hpbGUgSW1tdXRhYmxlIE1hcHMgYWNjZXB0IGtleXMgb2YgYW55IHR5cGUuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmxldCBvYmogPSB7IDE6IFxcXCJvbmVcXFwiIH1cXG5PYmplY3Qua2V5cyhvYmopIC8vIFsgXFxcIjFcXFwiIF1cXG5hc3NlcnQuZXF1YWwob2JqW1xcXCIxXFxcIl0sIG9ialsxXSkgLy8gXFxcIm9uZVxcXCIgPT09IFxcXCJvbmVcXFwiXFxuXFxubGV0IG1hcCA9IE1hcChvYmopXFxuYXNzZXJ0Lm5vdEVxdWFsKG1hcC5nZXQoXFxcIjFcXFwiKSwgbWFwLmdldCgxKSkgLy8gXFxcIm9uZVxcXCIgIT09IHVuZGVmaW5lZFxcbmBgYFxcblxcblByb3BlcnR5IGFjY2VzcyBmb3IgSmF2YVNjcmlwdCBPYmplY3RzIGZpcnN0IGNvbnZlcnRzIHRoZSBrZXkgdG8gYSBzdHJpbmcsXFxuYnV0IHNpbmNlIEltbXV0YWJsZSBNYXAga2V5cyBjYW4gYmUgb2YgYW55IHR5cGUgdGhlIGFyZ3VtZW50IHRvIGBnZXQoKWAgaXNcXG5ub3QgYWx0ZXJlZC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJNYXBcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6NzUzfSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvYmpcIixcInR5cGVcIjp7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6M30se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjc1NH0se1widHlwZVBhcmFtc1wiOltcIktcIixcIlZcIl0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJNYXBcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6NzU1fSx7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJNYXBcIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6MTd9XX0sXCJsaW5lXCI6NzU2fV19LFwiaW50ZXJmYWNlXCI6e1wibGluZVwiOjc1OCxcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCJdLFwiZXh0ZW5kc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dLFwiZ3JvdXBzXCI6W3tcIm1lbWJlcnNcIjp7XCIjc2l6ZVwiOntcImxpbmVcIjo3NjN9fX0se1widGl0bGVcIjpcIlBlcnNpc3RlbnQgY2hhbmdlc1wiLFwibWVtYmVyc1wiOntcIiNzZXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBNYXAgYWxzbyBjb250YWluaW5nIHRoZSBuZXcga2V5LCB2YWx1ZSBwYWlyLiBJZiBhbiBlcXVpdmFsZW50XFxua2V5IGFscmVhZHkgZXhpc3RzIGluIHRoaXMgTWFwLCBpdCB3aWxsIGJlIHJlcGxhY2VkLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb3JpZ2luYWxNYXAgPSBNYXAoKVxcbmNvbnN0IG5ld2VyTWFwID0gb3JpZ2luYWxNYXAuc2V0KCdrZXknLCAndmFsdWUnKVxcbmNvbnN0IG5ld2VzdE1hcCA9IG5ld2VyTWFwLnNldCgna2V5JywgJ25ld2VyIHZhbHVlJylcXG5cXG5vcmlnaW5hbE1hcFxcbi8vIE1hcCB7fVxcbm5ld2VyTWFwXFxuLy8gTWFwIHsgXFxcImtleVxcXCI6IFxcXCJ2YWx1ZVxcXCIgfVxcbm5ld2VzdE1hcFxcbi8vIE1hcCB7IFxcXCJrZXlcXFwiOiBcXFwibmV3ZXIgdmFsdWVcXFwiIH1cXG5gYGBcXG5cXG5Ob3RlOiBgc2V0YCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6Nzg4fV19LFwiI2RlbGV0ZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IE1hcCB3aGljaCBleGNsdWRlcyB0aGlzIGBrZXlgLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBkZWxldGVgIGNhbm5vdCBiZSBzYWZlbHkgdXNlZCBpbiBJRTgsIGJ1dCBpcyBwcm92aWRlZCB0byBtaXJyb3JcXG50aGUgRVM2IGNvbGxlY3Rpb24gQVBJLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb3JpZ2luYWxNYXAgPSBNYXAoe1xcbiAga2V5OiAndmFsdWUnLFxcbiAgb3RoZXJLZXk6ICdvdGhlciB2YWx1ZSdcXG59KVxcbi8vIE1hcCB7IFxcXCJrZXlcXFwiOiBcXFwidmFsdWVcXFwiLCBcXFwib3RoZXJLZXlcXFwiOiBcXFwib3RoZXIgdmFsdWVcXFwiIH1cXG5vcmlnaW5hbE1hcC5kZWxldGUoJ290aGVyS2V5JylcXG4vLyBNYXAgeyBcXFwia2V5XFxcIjogXFxcInZhbHVlXFxcIiB9XFxuYGBgXFxuXFxuTm90ZTogYGRlbGV0ZWAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwiYWxpYXNcIixcImJvZHlcIjpcInJlbW92ZVwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6ODEyfV19LFwiI2RlbGV0ZUFsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IE1hcCB3aGljaCBleGNsdWRlcyB0aGUgcHJvdmlkZWQgYGtleXNgLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3QgbmFtZXMgPSBNYXAoeyBhOiBcXFwiQWFyb25cXFwiLCBiOiBcXFwiQmFycnlcXFwiLCBjOiBcXFwiQ29ubm9yXFxcIiB9KVxcbm5hbWVzLmRlbGV0ZUFsbChbICdhJywgJ2MnIF0pXFxuLy8gTWFwIHsgXFxcImJcXFwiOiBcXFwiQmFycnlcXFwiIH1cXG5gYGBcXG5cXG5Ob3RlOiBgZGVsZXRlQWxsYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXFxuXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJhbGlhc1wiLFwiYm9keVwiOlwicmVtb3ZlQWxsXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlzXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjgzMH1dfSxcIiNjbGVhclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IE1hcCBjb250YWluaW5nIG5vIGtleXMgb3IgdmFsdWVzLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuTWFwKHsga2V5OiAndmFsdWUnIH0pLmNsZWFyKClcXG4vLyBNYXAge31cXG5gYGBcXG5cXG5Ob3RlOiBgY2xlYXJgIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo4NDV9XX0sXCIjdXBkYXRlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTWFwIGhhdmluZyB1cGRhdGVkIHRoZSB2YWx1ZSBhdCB0aGlzIGBrZXlgIHdpdGggdGhlIHJldHVyblxcbnZhbHVlIG9mIGNhbGxpbmcgYHVwZGF0ZXJgIHdpdGggdGhlIGV4aXN0aW5nIHZhbHVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlNpbWlsYXIgdG86IGBtYXAuc2V0KGtleSwgdXBkYXRlcihtYXAuZ2V0KGtleSkpKWAuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IE1hcCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBhTWFwID0gTWFwKHsga2V5OiAndmFsdWUnIH0pXFxuY29uc3QgbmV3TWFwID0gYU1hcC51cGRhdGUoJ2tleScsIHZhbHVlID0+IHZhbHVlICsgdmFsdWUpXFxuLy8gTWFwIHsgXFxcImtleVxcXCI6IFxcXCJ2YWx1ZXZhbHVlXFxcIiB9XFxuYGBgXFxuXFxuVGhpcyBpcyBtb3N0IGNvbW1vbmx5IHVzZWQgdG8gY2FsbCBtZXRob2RzIG9uIGNvbGxlY3Rpb25zIHdpdGhpbiBhXFxuc3RydWN0dXJlIG9mIGRhdGEuIEZvciBleGFtcGxlLCBpbiBvcmRlciB0byBgLnB1c2goKWAgb250byBhIG5lc3RlZCBgTGlzdGAsXFxuYHVwZGF0ZWAgYW5kIGBwdXNoYCBjYW4gYmUgdXNlZCB0b2dldGhlcjpcXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBNYXAsIExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuY29uc3QgYU1hcCA9IE1hcCh7IG5lc3RlZExpc3Q6IExpc3QoWyAxLCAyLCAzIF0pIH0pXFxuY29uc3QgbmV3TWFwID0gYU1hcC51cGRhdGUoJ25lc3RlZExpc3QnLCBsaXN0ID0+IGxpc3QucHVzaCg0KSlcXG4vLyBNYXAgeyBcXFwibmVzdGVkTGlzdFxcXCI6IExpc3QgWyAxLCAyLCAzLCA0IF0gfVxcbmBgYFxcblxcbldoZW4gYSBgbm90U2V0VmFsdWVgIGlzIHByb3ZpZGVkLCBpdCBpcyBwcm92aWRlZCB0byB0aGUgYHVwZGF0ZXJgXFxuZnVuY3Rpb24gd2hlbiB0aGUgdmFsdWUgYXQgdGhlIGtleSBkb2VzIG5vdCBleGlzdCBpbiB0aGUgTWFwLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IE1hcCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBhTWFwID0gTWFwKHsga2V5OiAndmFsdWUnIH0pXFxuY29uc3QgbmV3TWFwID0gYU1hcC51cGRhdGUoJ25vS2V5JywgJ25vIHZhbHVlJywgdmFsdWUgPT4gdmFsdWUgKyB2YWx1ZSlcXG4vLyBNYXAgeyBcXFwia2V5XFxcIjogXFxcInZhbHVlXFxcIiwgXFxcIm5vS2V5XFxcIjogXFxcIm5vIHZhbHVlbm8gdmFsdWVcXFwiIH1cXG5gYGBcXG5cXG5Ib3dldmVyLCBpZiB0aGUgYHVwZGF0ZXJgIGZ1bmN0aW9uIHJldHVybnMgdGhlIHNhbWUgdmFsdWUgaXQgd2FzIGNhbGxlZFxcbndpdGgsIHRoZW4gbm8gY2hhbmdlIHdpbGwgb2NjdXIuIFRoaXMgaXMgc3RpbGwgdHJ1ZSBpZiBgbm90U2V0VmFsdWVgXFxuaXMgcHJvdmlkZWQuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmNvbnN0IGFNYXAgPSBNYXAoeyBhcHBsZXM6IDEwIH0pXFxuY29uc3QgbmV3TWFwID0gYU1hcC51cGRhdGUoJ29yYW5nZXMnLCAwLCB2YWwgPT4gdmFsKVxcbi8vIE1hcCB7IFxcXCJhcHBsZXNcXFwiOiAxMCB9XFxuYXNzZXJ0LnN0cmljdEVxdWFsKG5ld01hcCwgbWFwKTtcXG5gYGBcXG5cXG5Gb3IgY29kZSB1c2luZyBFUzIwMTUgb3IgbGF0ZXIsIHVzaW5nIGBub3RTZXRWYWx1ZWAgaXMgZGlzY291cmdlZCBpblxcbmZhdm9yIG9mIGZ1bmN0aW9uIHBhcmFtZXRlciBkZWZhdWx0IHZhbHVlcy4gVGhpcyBoZWxwcyB0byBhdm9pZCBhbnlcXG5wb3RlbnRpYWwgY29uZnVzaW9uIHdpdGggaWRlbnRpZnkgZnVuY3Rpb25zIGFzIGRlc2NyaWJlZCBhYm92ZS5cXG5cXG5UaGUgcHJldmlvdXMgZXhhbXBsZSBiZWhhdmVzIGRpZmZlcmVudGx5IHdoZW4gd3JpdHRlbiB3aXRoIGRlZmF1bHQgdmFsdWVzOlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IE1hcCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBhTWFwID0gTWFwKHsgYXBwbGVzOiAxMCB9KVxcbmNvbnN0IG5ld01hcCA9IGFNYXAudXBkYXRlKCdvcmFuZ2VzJywgKHZhbCA9IDApID0+IHZhbClcXG4vLyBNYXAgeyBcXFwiYXBwbGVzXFxcIjogMTAsIFxcXCJvcmFuZ2VzXFxcIjogMCB9XFxuYGBgXFxuXFxuSWYgbm8ga2V5IGlzIHByb3ZpZGVkLCB0aGVuIHRoZSBgdXBkYXRlcmAgZnVuY3Rpb24gcmV0dXJuIHZhbHVlIGlzXFxucmV0dXJuZWQgYXMgd2VsbC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuY29uc3QgYU1hcCA9IE1hcCh7IGtleTogJ3ZhbHVlJyB9KVxcbmNvbnN0IHJlc3VsdCA9IGFNYXAudXBkYXRlKGFNYXAgPT4gYU1hcC5nZXQoJ2tleScpKVxcbi8vIFxcXCJ2YWx1ZVxcXCJcXG5gYGBcXG5cXG5UaGlzIGNhbiBiZSB2ZXJ5IHVzZWZ1bCBhcyBhIHdheSB0byBcXFwiY2hhaW5cXFwiIGEgbm9ybWFsIGZ1bmN0aW9uIGludG8gYVxcbnNlcXVlbmNlIG9mIG1ldGhvZHMuIFJ4SlMgY2FsbHMgdGhpcyBcXFwibGV0XFxcIiBhbmQgbG9kYXNoIGNhbGxzIGl0IFxcXCJ0aHJ1XFxcIi5cXG5cXG5Gb3IgZXhhbXBsZSwgdG8gc3VtIHRoZSB2YWx1ZXMgaW4gYSBNYXBcXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcXCIgfVxcbi0tPlxcbmBgYGpzXFxuZnVuY3Rpb24gc3VtKGNvbGxlY3Rpb24pIHtcXG4gIHJldHVybiBjb2xsZWN0aW9uLnJlZHVjZSgoc3VtLCB4KSA9PiBzdW0gKyB4LCAwKVxcbn1cXG5cXG5NYXAoeyB4OiAxLCB5OiAyLCB6OiAzIH0pXFxuICAubWFwKHggPT4geCArIDEpXFxuICAuZmlsdGVyKHggPT4geCAlIDIgPT09IDApXFxuICAudXBkYXRlKHN1bSlcXG4vLyA2XFxuYGBgXFxuXFxuTm90ZTogYHVwZGF0ZShrZXkpYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIm5vdFNldFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo5NDl9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJ1cGRhdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjk1MH0se1widHlwZVBhcmFtc1wiOltcIlJcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlJcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiUlwifSxcImxpbmVcIjo5NTF9XX0sXCIjbWVyZ2VcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBNYXAgcmVzdWx0aW5nIGZyb20gbWVyZ2luZyB0aGUgcHJvdmlkZWQgQ29sbGVjdGlvbnNcXG4ob3IgSlMgb2JqZWN0cykgaW50byB0aGlzIE1hcC4gSW4gb3RoZXIgd29yZHMsIHRoaXMgdGFrZXMgZWFjaCBlbnRyeSBvZlxcbmVhY2ggY29sbGVjdGlvbiBhbmQgc2V0cyBpdCBvbiB0aGlzIE1hcC5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBWYWx1ZXMgcHJvdmlkZWQgdG8gYG1lcmdlYCBhcmUgc2hhbGxvd2x5IGNvbnZlcnRlZCBiZWZvcmUgYmVpbmdcXG5tZXJnZWQuIE5vIG5lc3RlZCB2YWx1ZXMgYXJlIGFsdGVyZWQuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IE1hcCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBvbmUgPSBNYXAoeyBhOiAxMCwgYjogMjAsIGM6IDMwIH0pXFxuY29uc3QgdHdvID0gTWFwKHsgYjogNDAsIGE6IDUwLCBkOiA2MCB9KVxcbm9uZS5tZXJnZSh0d28pIC8vIE1hcCB7IFxcXCJhXFxcIjogNTAsIFxcXCJiXFxcIjogNDAsIFxcXCJjXFxcIjogMzAsIFxcXCJkXFxcIjogNjAgfVxcbnR3by5tZXJnZShvbmUpIC8vIE1hcCB7IFxcXCJiXFxcIjogMjAsIFxcXCJhXFxcIjogMTAsIFxcXCJkXFxcIjogNjAsIFxcXCJjXFxcIjogMzAgfVxcbmBgYFxcblxcbk5vdGU6IGBtZXJnZWAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwiYWxpYXNcIixcImJvZHlcIjpcImNvbmNhdFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS0NcIixcIlZDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktDXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZDXCJ9XX1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIktDXCJ9XX0se1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWQ1wifV19XX0sXCJsaW5lXCI6OTc0fSx7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTWFwXCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjN9XX0se1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9XX1dfSxcImxpbmVcIjo5NzV9XX0sXCIjbWVyZ2VXaXRoXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkxpa2UgYG1lcmdlKClgLCBgbWVyZ2VXaXRoKClgIHJldHVybnMgYSBuZXcgTWFwIHJlc3VsdGluZyBmcm9tIG1lcmdpbmdcXG50aGUgcHJvdmlkZWQgQ29sbGVjdGlvbnMgKG9yIEpTIG9iamVjdHMpIGludG8gdGhpcyBNYXAsIGJ1dCB1c2VzIHRoZVxcbmBtZXJnZXJgIGZ1bmN0aW9uIGZvciBkZWFsaW5nIHdpdGggY29uZmxpY3RzLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb25lID0gTWFwKHsgYTogMTAsIGI6IDIwLCBjOiAzMCB9KVxcbmNvbnN0IHR3byA9IE1hcCh7IGI6IDQwLCBhOiA1MCwgZDogNjAgfSlcXG5vbmUubWVyZ2VXaXRoKChvbGRWYWwsIG5ld1ZhbCkgPT4gb2xkVmFsIC8gbmV3VmFsLCB0d28pXFxuLy8geyBcXFwiYVxcXCI6IDAuMiwgXFxcImJcXFwiOiAwLjUsIFxcXCJjXFxcIjogMzAsIFxcXCJkXFxcIjogNjAgfVxcbnR3by5tZXJnZVdpdGgoKG9sZFZhbCwgbmV3VmFsKSA9PiBvbGRWYWwgLyBuZXdWYWwsIG9uZSlcXG4vLyB7IFxcXCJiXFxcIjogMiwgXFxcImFcXFwiOiA1LCBcXFwiZFxcXCI6IDYwLCBcXFwiY1xcXCI6IDMwIH1cXG5gYGBcXG5cXG5Ob3RlOiBgbWVyZ2VXaXRoYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1lcmdlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm9sZFZhbFwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcIm5ld1ZhbFwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fX0se1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfSx7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XX1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjk5N31dfSxcIiNtZXJnZURlZXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiTGlrZSBgbWVyZ2UoKWAsIGJ1dCB3aGVuIHR3byBDb2xsZWN0aW9ucyBjb25mbGljdCwgaXQgbWVyZ2VzIHRoZW0gYXMgd2VsbCxcXG5yZWN1cnNpbmcgZGVlcGx5IHRocm91Z2ggdGhlIG5lc3RlZCBkYXRhLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IFZhbHVlcyBwcm92aWRlZCB0byBgbWVyZ2VgIGFyZSBzaGFsbG93bHkgY29udmVydGVkIGJlZm9yZSBiZWluZ1xcbm1lcmdlZC4gTm8gbmVzdGVkIHZhbHVlcyBhcmUgYWx0ZXJlZCB1bmxlc3MgdGhleSB3aWxsIGFsc28gYmUgbWVyZ2VkIGF0XFxuYSBkZWVwZXIgbGV2ZWwuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IE1hcCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBvbmUgPSBNYXAoeyBhOiBNYXAoeyB4OiAxMCwgeTogMTAgfSksIGI6IE1hcCh7IHg6IDIwLCB5OiA1MCB9KSB9KVxcbmNvbnN0IHR3byA9IE1hcCh7IGE6IE1hcCh7IHg6IDIgfSksIGI6IE1hcCh7IHk6IDUgfSksIGM6IE1hcCh7IHo6IDMgfSkgfSlcXG5vbmUubWVyZ2VEZWVwKHR3bylcXG4vLyBNYXAge1xcbi8vICAgXFxcImFcXFwiOiBNYXAgeyBcXFwieFxcXCI6IDIsIFxcXCJ5XFxcIjogMTAgfSxcXG4vLyAgIFxcXCJiXFxcIjogTWFwIHsgXFxcInhcXFwiOiAyMCwgXFxcInlcXFwiOiA1IH0sXFxuLy8gICBcXFwiY1xcXCI6IE1hcCB7IFxcXCJ6XFxcIjogMyB9XFxuLy8gfVxcbmBgYFxcblxcbk5vdGU6IGBtZXJnZURlZXBgIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfSx7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XX1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjEwMjV9XX0sXCIjbWVyZ2VEZWVwV2l0aFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJMaWtlIGBtZXJnZURlZXAoKWAsIGJ1dCB3aGVuIHR3byBub24tQ29sbGVjdGlvbnMgY29uZmxpY3QsIGl0IHVzZXMgdGhlXFxuYG1lcmdlcmAgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHRoZSByZXN1bHRpbmcgdmFsdWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IE1hcCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBvbmUgPSBNYXAoeyBhOiBNYXAoeyB4OiAxMCwgeTogMTAgfSksIGI6IE1hcCh7IHg6IDIwLCB5OiA1MCB9KSB9KVxcbmNvbnN0IHR3byA9IE1hcCh7IGE6IE1hcCh7IHg6IDIgfSksIGI6IE1hcCh7IHk6IDUgfSksIGM6IE1hcCh7IHo6IDMgfSkgfSlcXG5vbmUubWVyZ2VEZWVwV2l0aCgob2xkVmFsLCBuZXdWYWwpID0+IG9sZFZhbCAvIG5ld1ZhbCwgdHdvKVxcbi8vIE1hcCB7XFxuLy8gICBcXFwiYVxcXCI6IE1hcCB7IFxcXCJ4XFxcIjogNSwgXFxcInlcXFwiOiAxMCB9LFxcbi8vICAgXFxcImJcXFwiOiBNYXAgeyBcXFwieFxcXCI6IDIwLCBcXFwieVxcXCI6IDEwIH0sXFxuLy8gICBcXFwiY1xcXCI6IE1hcCB7IFxcXCJ6XFxcIjogMyB9XFxuLy8gfVxcbmBgYFxcblxcbk5vdGU6IGBtZXJnZURlZXBXaXRoYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1lcmdlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm9sZFZhbFwiLFwidHlwZVwiOntcImtcIjoxN319LHtcIm5hbWVcIjpcIm5ld1ZhbFwiLFwidHlwZVwiOntcImtcIjoxN319LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MTd9fX0se1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfSx7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XX1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjEwNDZ9XX19fSx7XCJ0aXRsZVwiOlwiRGVlcCBwZXJzaXN0ZW50IGNoYW5nZXNcIixcIm1lbWJlcnNcIjp7XCIjc2V0SW5cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBNYXAgaGF2aW5nIHNldCBgdmFsdWVgIGF0IHRoaXMgYGtleVBhdGhgLiBJZiBhbnkga2V5cyBpblxcbmBrZXlQYXRoYCBkbyBub3QgZXhpc3QsIGEgbmV3IGltbXV0YWJsZSBNYXAgd2lsbCBiZSBjcmVhdGVkIGF0IHRoYXQga2V5LlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb3JpZ2luYWxNYXAgPSBNYXAoe1xcbiAgc3ViT2JqZWN0OiBNYXAoe1xcbiAgICBzdWJLZXk6ICdzdWJ2YWx1ZScsXFxuICAgIHN1YlN1Yk9iamVjdDogTWFwKHtcXG4gICAgICBzdWJTdWJLZXk6ICdzdWJTdWJWYWx1ZSdcXG4gICAgfSlcXG4gIH0pXFxufSlcXG5cXG5jb25zdCBuZXdNYXAgPSBvcmlnaW5hbE1hcC5zZXRJbihbJ3N1Yk9iamVjdCcsICdzdWJLZXknXSwgJ2hhIGhhIScpXFxuLy8gTWFwIHtcXG4vLyAgIFxcXCJzdWJPYmplY3RcXFwiOiBNYXAge1xcbi8vICAgICBcXFwic3ViS2V5XFxcIjogXFxcImhhIGhhIVxcXCIsXFxuLy8gICAgIFxcXCJzdWJTdWJPYmplY3RcXFwiOiBNYXAgeyBcXFwic3ViU3ViS2V5XFxcIjogXFxcInN1YlN1YlZhbHVlXFxcIiB9XFxuLy8gICB9XFxuLy8gfVxcblxcbmNvbnN0IG5ld2VyTWFwID0gb3JpZ2luYWxNYXAuc2V0SW4oXFxuICBbJ3N1Yk9iamVjdCcsICdzdWJTdWJPYmplY3QnLCAnc3ViU3ViS2V5J10sXFxuICAnaGEgaGEgaGEhJ1xcbilcXG4vLyBNYXAge1xcbi8vICAgXFxcInN1Yk9iamVjdFxcXCI6IE1hcCB7XFxuLy8gICAgIFxcXCJzdWJLZXlcXFwiOiBcXFwic3VidmFsdWVcXFwiLFxcbi8vICAgICBcXFwic3ViU3ViT2JqZWN0XFxcIjogTWFwIHsgXFxcInN1YlN1YktleVxcXCI6IFxcXCJoYSBoYSBoYSFcXFwiIH1cXG4vLyAgIH1cXG4vLyB9XFxuYGBgXFxuXFxuUGxhaW4gSmF2YVNjcmlwdCBPYmplY3Qgb3IgQXJyYXlzIG1heSBiZSBuZXN0ZWQgd2l0aGluIGFuIEltbXV0YWJsZS5qc1xcbkNvbGxlY3Rpb24sIGFuZCBzZXRJbigpIGNhbiB1cGRhdGUgdGhvc2UgdmFsdWVzIGFzIHdlbGwsIHRyZWF0aW5nIHRoZW1cXG5pbW11dGFibHkgYnkgY3JlYXRpbmcgbmV3IGNvcGllcyBvZiB0aG9zZSB2YWx1ZXMgd2l0aCB0aGUgY2hhbmdlcyBhcHBsaWVkLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb3JpZ2luYWxNYXAgPSBNYXAoe1xcbiAgc3ViT2JqZWN0OiB7XFxuICAgIHN1YktleTogJ3N1YnZhbHVlJyxcXG4gICAgc3ViU3ViT2JqZWN0OiB7XFxuICAgICAgc3ViU3ViS2V5OiAnc3ViU3ViVmFsdWUnXFxuICAgIH1cXG4gIH1cXG59KVxcblxcbm9yaWdpbmFsTWFwLnNldEluKFsnc3ViT2JqZWN0JywgJ3N1YktleSddLCAnaGEgaGEhJylcXG4vLyBNYXAge1xcbi8vICAgXFxcInN1Yk9iamVjdFxcXCI6IHtcXG4vLyAgICAgc3ViS2V5OiBcXFwiaGEgaGEhXFxcIixcXG4vLyAgICAgc3ViU3ViT2JqZWN0OiB7IHN1YlN1YktleTogXFxcInN1YlN1YlZhbHVlXFxcIiB9XFxuLy8gICB9XFxuLy8gfVxcbmBgYFxcblxcbklmIGFueSBrZXkgaW4gdGhlIHBhdGggZXhpc3RzIGJ1dCBjYW5ub3QgYmUgdXBkYXRlZCAoc3VjaCBhcyBhIHByaW1pdGl2ZVxcbmxpa2UgbnVtYmVyIG9yIGEgY3VzdG9tIE9iamVjdCBsaWtlIERhdGUpLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cXG5cXG5Ob3RlOiBgc2V0SW5gIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5UGF0aFwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjExMjB9XX0sXCIjZGVsZXRlSW5cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBNYXAgaGF2aW5nIHJlbW92ZWQgdGhlIHZhbHVlIGF0IHRoaXMgYGtleVBhdGhgLiBJZiBhbnkga2V5c1xcbmluIGBrZXlQYXRoYCBkbyBub3QgZXhpc3QsIG5vIGNoYW5nZSB3aWxsIG9jY3VyLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBkZWxldGVJbmAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwiYWxpYXNcIixcImJvZHlcIjpcInJlbW92ZUluXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlQYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjExMzB9XX0sXCIjdXBkYXRlSW5cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBNYXAgaGF2aW5nIGFwcGxpZWQgdGhlIGB1cGRhdGVyYCB0byB0aGUgZW50cnkgZm91bmQgYXQgdGhlXFxua2V5UGF0aC5cIixcImRlc2NyaXB0aW9uXCI6XCJUaGlzIGlzIG1vc3QgY29tbW9ubHkgdXNlZCB0byBjYWxsIG1ldGhvZHMgb24gY29sbGVjdGlvbnMgbmVzdGVkIHdpdGhpbiBhXFxuc3RydWN0dXJlIG9mIGRhdGEuIEZvciBleGFtcGxlLCBpbiBvcmRlciB0byBgLnB1c2goKWAgb250byBhIG5lc3RlZCBgTGlzdGAsXFxuYHVwZGF0ZUluYCBhbmQgYHB1c2hgIGNhbiBiZSB1c2VkIHRvZ2V0aGVyOlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAsIExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3QgbWFwID0gTWFwKHsgaW5NYXA6IE1hcCh7IGluTGlzdDogTGlzdChbIDEsIDIsIDMgXSkgfSkgfSlcXG5jb25zdCBuZXdNYXAgPSBtYXAudXBkYXRlSW4oWydpbk1hcCcsICdpbkxpc3QnXSwgbGlzdCA9PiBsaXN0LnB1c2goNCkpXFxuLy8gTWFwIHsgXFxcImluTWFwXFxcIjogTWFwIHsgXFxcImluTGlzdFxcXCI6IExpc3QgWyAxLCAyLCAzLCA0IF0gfSB9XFxuYGBgXFxuXFxuSWYgYW55IGtleXMgaW4gYGtleVBhdGhgIGRvIG5vdCBleGlzdCwgbmV3IEltbXV0YWJsZSBgTWFwYHMgd2lsbFxcbmJlIGNyZWF0ZWQgYXQgdGhvc2Uga2V5cy4gSWYgdGhlIGBrZXlQYXRoYCBkb2VzIG5vdCBhbHJlYWR5IGNvbnRhaW4gYVxcbnZhbHVlLCB0aGUgYHVwZGF0ZXJgIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdpdGggYG5vdFNldFZhbHVlYCwgaWZcXG5wcm92aWRlZCwgb3RoZXJ3aXNlIGB1bmRlZmluZWRgLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IE1hcCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmNvbnN0IG1hcCA9IE1hcCh7IGE6IE1hcCh7IGI6IE1hcCh7IGM6IDEwIH0pIH0pIH0pXFxuY29uc3QgbmV3TWFwID0gbWFwLnVwZGF0ZUluKFsnYScsICdiJywgJ2MnXSwgdmFsID0+IHZhbCAqIDIpXFxuLy8gTWFwIHsgXFxcImFcXFwiOiBNYXAgeyBcXFwiYlxcXCI6IE1hcCB7IFxcXCJjXFxcIjogMjAgfSB9IH1cXG5gYGBcXG5cXG5JZiB0aGUgYHVwZGF0ZXJgIGZ1bmN0aW9uIHJldHVybnMgdGhlIHNhbWUgdmFsdWUgaXQgd2FzIGNhbGxlZCB3aXRoLCB0aGVuXFxubm8gY2hhbmdlIHdpbGwgb2NjdXIuIFRoaXMgaXMgc3RpbGwgdHJ1ZSBpZiBgbm90U2V0VmFsdWVgIGlzIHByb3ZpZGVkLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IE1hcCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmNvbnN0IG1hcCA9IE1hcCh7IGE6IE1hcCh7IGI6IE1hcCh7IGM6IDEwIH0pIH0pIH0pXFxuY29uc3QgbmV3TWFwID0gbWFwLnVwZGF0ZUluKFsnYScsICdiJywgJ3gnXSwgMTAwLCB2YWwgPT4gdmFsKVxcbi8vIE1hcCB7IFxcXCJhXFxcIjogTWFwIHsgXFxcImJcXFwiOiBNYXAgeyBcXFwiY1xcXCI6IDEwIH0gfSB9XFxuYXNzZXJ0LnN0cmljdEVxdWFsKG5ld01hcCwgYU1hcClcXG5gYGBcXG5cXG5Gb3IgY29kZSB1c2luZyBFUzIwMTUgb3IgbGF0ZXIsIHVzaW5nIGBub3RTZXRWYWx1ZWAgaXMgZGlzY291cmdlZCBpblxcbmZhdm9yIG9mIGZ1bmN0aW9uIHBhcmFtZXRlciBkZWZhdWx0IHZhbHVlcy4gVGhpcyBoZWxwcyB0byBhdm9pZCBhbnlcXG5wb3RlbnRpYWwgY29uZnVzaW9uIHdpdGggaWRlbnRpZnkgZnVuY3Rpb25zIGFzIGRlc2NyaWJlZCBhYm92ZS5cXG5cXG5UaGUgcHJldmlvdXMgZXhhbXBsZSBiZWhhdmVzIGRpZmZlcmVudGx5IHdoZW4gd3JpdHRlbiB3aXRoIGRlZmF1bHQgdmFsdWVzOlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IE1hcCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmNvbnN0IG1hcCA9IE1hcCh7IGE6IE1hcCh7IGI6IE1hcCh7IGM6IDEwIH0pIH0pIH0pXFxuY29uc3QgbmV3TWFwID0gbWFwLnVwZGF0ZUluKFsnYScsICdiJywgJ3gnXSwgKHZhbCA9IDEwMCkgPT4gdmFsKVxcbi8vIE1hcCB7IFxcXCJhXFxcIjogTWFwIHsgXFxcImJcXFwiOiBNYXAgeyBcXFwiY1xcXCI6IDEwLCBcXFwieFxcXCI6IDEwMCB9IH0gfVxcbmBgYFxcblxcblBsYWluIEphdmFTY3JpcHQgT2JqZWN0IG9yIEFycmF5cyBtYXkgYmUgbmVzdGVkIHdpdGhpbiBhbiBJbW11dGFibGUuanNcXG5Db2xsZWN0aW9uLCBhbmQgdXBkYXRlSW4oKSBjYW4gdXBkYXRlIHRob3NlIHZhbHVlcyBhcyB3ZWxsLCB0cmVhdGluZyB0aGVtXFxuaW1tdXRhYmx5IGJ5IGNyZWF0aW5nIG5ldyBjb3BpZXMgb2YgdGhvc2UgdmFsdWVzIHdpdGggdGhlIGNoYW5nZXMgYXBwbGllZC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBtYXAgPSBNYXAoeyBhOiB7IGI6IHsgYzogMTAgfSB9IH0pXFxuY29uc3QgbmV3TWFwID0gbWFwLnVwZGF0ZUluKFsnYScsICdiJywgJ2MnXSwgdmFsID0+IHZhbCAqIDIpXFxuLy8gTWFwIHsgXFxcImFcXFwiOiB7IGI6IHsgYzogMjAgfSB9IH1cXG5gYGBcXG5cXG5JZiBhbnkga2V5IGluIHRoZSBwYXRoIGV4aXN0cyBidXQgY2Fubm90IGJlIHVwZGF0ZWQgKHN1Y2ggYXMgYSBwcmltaXRpdmVcXG5saWtlIG51bWJlciBvciBhIGN1c3RvbSBPYmplY3QgbGlrZSBEYXRlKSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXFxuXFxuTm90ZTogYHVwZGF0ZUluYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fSx7XCJuYW1lXCI6XCJ1cGRhdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjEyMDl9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlQYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX19LHtcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MTd9fX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MTIxMH1dfSxcIiNtZXJnZUluXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkEgY29tYmluYXRpb24gb2YgYHVwZGF0ZUluYCBhbmQgYG1lcmdlYCwgcmV0dXJuaW5nIGEgbmV3IE1hcCwgYnV0XFxucGVyZm9ybWluZyB0aGUgbWVyZ2UgYXQgYSBwb2ludCBhcnJpdmVkIGF0IGJ5IGZvbGxvd2luZyB0aGUga2V5UGF0aC5cXG5JbiBvdGhlciB3b3JkcywgdGhlc2UgdHdvIGxpbmVzIGFyZSBlcXVpdmFsZW50OlwiLFwiZGVzY3JpcHRpb25cIjpcImBgYGpzXFxubWFwLnVwZGF0ZUluKFsnYScsICdiJywgJ2MnXSwgYWJjID0+IGFiYy5tZXJnZSh5KSlcXG5tYXAubWVyZ2VJbihbJ2EnLCAnYicsICdjJ10sIHkpXFxuYGBgXFxuXFxuTm90ZTogYG1lcmdlSW5gIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5UGF0aFwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19fSx7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjEyMjR9XX0sXCIjbWVyZ2VEZWVwSW5cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQSBjb21iaW5hdGlvbiBvZiBgdXBkYXRlSW5gIGFuZCBgbWVyZ2VEZWVwYCwgcmV0dXJuaW5nIGEgbmV3IE1hcCwgYnV0XFxucGVyZm9ybWluZyB0aGUgZGVlcCBtZXJnZSBhdCBhIHBvaW50IGFycml2ZWQgYXQgYnkgZm9sbG93aW5nIHRoZSBrZXlQYXRoLlxcbkluIG90aGVyIHdvcmRzLCB0aGVzZSB0d28gbGluZXMgYXJlIGVxdWl2YWxlbnQ6XCIsXCJkZXNjcmlwdGlvblwiOlwiYGBganNcXG5tYXAudXBkYXRlSW4oWydhJywgJ2InLCAnYyddLCBhYmMgPT4gYWJjLm1lcmdlRGVlcCh5KSlcXG5tYXAubWVyZ2VEZWVwSW4oWydhJywgJ2InLCAnYyddLCB5KVxcbmBgYFxcblxcbk5vdGU6IGBtZXJnZURlZXBJbmAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlQYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX19LHtcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MTIzOH1dfX19LHtcInRpdGxlXCI6XCJUcmFuc2llbnQgY2hhbmdlc1wiLFwibWVtYmVyc1wiOntcIiN3aXRoTXV0YXRpb25zXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkV2ZXJ5IHRpbWUgeW91IGNhbGwgb25lIG9mIHRoZSBhYm92ZSBmdW5jdGlvbnMsIGEgbmV3IGltbXV0YWJsZSBNYXAgaXNcXG5jcmVhdGVkLiBJZiBhIHB1cmUgZnVuY3Rpb24gY2FsbHMgYSBudW1iZXIgb2YgdGhlc2UgdG8gcHJvZHVjZSBhIGZpbmFsXFxucmV0dXJuIHZhbHVlLCB0aGVuIGEgcGVuYWx0eSBvbiBwZXJmb3JtYW5jZSBhbmQgbWVtb3J5IGhhcyBiZWVuIHBhaWQgYnlcXG5jcmVhdGluZyBhbGwgb2YgdGhlIGludGVybWVkaWF0ZSBpbW11dGFibGUgTWFwcy5cIixcImRlc2NyaXB0aW9uXCI6XCJJZiB5b3UgbmVlZCB0byBhcHBseSBhIHNlcmllcyBvZiBtdXRhdGlvbnMgdG8gcHJvZHVjZSBhIG5ldyBpbW11dGFibGVcXG5NYXAsIGB3aXRoTXV0YXRpb25zKClgIGNyZWF0ZXMgYSB0ZW1wb3JhcnkgbXV0YWJsZSBjb3B5IG9mIHRoZSBNYXAgd2hpY2hcXG5jYW4gYXBwbHkgbXV0YXRpb25zIGluIGEgaGlnaGx5IHBlcmZvcm1hbnQgbWFubmVyLiBJbiBmYWN0LCB0aGlzIGlzXFxuZXhhY3RseSBob3cgY29tcGxleCBtdXRhdGlvbnMgbGlrZSBgbWVyZ2VgIGFyZSBkb25lLlxcblxcbkFzIGFuIGV4YW1wbGUsIHRoaXMgcmVzdWx0cyBpbiB0aGUgY3JlYXRpb24gb2YgMiwgbm90IDQsIG5ldyBNYXBzOlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3QgbWFwMSA9IE1hcCgpXFxuY29uc3QgbWFwMiA9IG1hcDEud2l0aE11dGF0aW9ucyhtYXAgPT4ge1xcbiAgbWFwLnNldCgnYScsIDEpLnNldCgnYicsIDIpLnNldCgnYycsIDMpXFxufSlcXG5hc3NlcnQuZXF1YWwobWFwMS5zaXplLCAwKVxcbmFzc2VydC5lcXVhbChtYXAyLnNpemUsIDMpXFxuYGBgXFxuXFxuTm90ZTogTm90IGFsbCBtZXRob2RzIGNhbiBiZSB1c2VkIG9uIGEgbXV0YWJsZSBjb2xsZWN0aW9uIG9yIHdpdGhpblxcbmB3aXRoTXV0YXRpb25zYCEgUmVhZCB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgZWFjaCBtZXRob2QgdG8gc2VlIGlmIGl0XFxuaXMgc2FmZSB0byB1c2UgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtdXRhdG9yXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibXV0YWJsZVwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MTd9fX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MTI3MH1dfSxcIiNhc011dGFibGVcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQW5vdGhlciB3YXkgdG8gYXZvaWQgY3JlYXRpb24gb2YgaW50ZXJtZWRpYXRlIEltbXV0YWJsZSBtYXBzIGlzIHRvIGNyZWF0ZVxcbmEgbXV0YWJsZSBjb3B5IG9mIHRoaXMgY29sbGVjdGlvbi4gTXV0YWJsZSBjb3BpZXMgKmFsd2F5cyogcmV0dXJuIGB0aGlzYCxcXG5hbmQgdGh1cyBzaG91bGRuJ3QgYmUgdXNlZCBmb3IgZXF1YWxpdHkuIFlvdXIgZnVuY3Rpb24gc2hvdWxkIG5ldmVyIHJldHVyblxcbmEgbXV0YWJsZSBjb3B5IG9mIGEgY29sbGVjdGlvbiwgb25seSB1c2UgaXQgaW50ZXJuYWxseSB0byBjcmVhdGUgYSBuZXdcXG5jb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIklmIHBvc3NpYmxlLCB1c2UgYHdpdGhNdXRhdGlvbnNgIHRvIHdvcmsgd2l0aCB0ZW1wb3JhcnkgbXV0YWJsZSBjb3BpZXMgYXNcXG5pdCBwcm92aWRlcyBhbiBlYXNpZXIgdG8gdXNlIEFQSSBhbmQgY29uc2lkZXJzIG1hbnkgY29tbW9uIG9wdGltaXphdGlvbnMuXFxuXFxuTm90ZTogaWYgdGhlIGNvbGxlY3Rpb24gaXMgYWxyZWFkeSBtdXRhYmxlLCBgYXNNdXRhYmxlYCByZXR1cm5zIGl0c2VsZi5cXG5cXG5Ob3RlOiBOb3QgYWxsIG1ldGhvZHMgY2FuIGJlIHVzZWQgb24gYSBtdXRhYmxlIGNvbGxlY3Rpb24gb3Igd2l0aGluXFxuYHdpdGhNdXRhdGlvbnNgISBSZWFkIHRoZSBkb2N1bWVudGF0aW9uIGZvciBlYWNoIG1ldGhvZCB0byBzZWUgaWYgaXRcXG5pcyBzYWZlIHRvIHVzZSBpbiBgd2l0aE11dGF0aW9uc2AuXFxuXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcImBNYXAjYXNJbW11dGFibGVgXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjEyOTB9XX0sXCIjd2FzQWx0ZXJlZFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRydWUgaWYgdGhpcyBpcyBhIG11dGFibGUgY29weSAoc2VlIGBhc011dGFibGUoKWApIGFuZCBtdXRhdGl2ZVxcbmFsdGVyYXRpb25zIGhhdmUgYmVlbiBhcHBsaWVkLlxcblwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI2FzTXV0YWJsZWBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjoxMjk4fV19LFwiI2FzSW1tdXRhYmxlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRoZSB5aW4gdG8gYGFzTXV0YWJsZWAncyB5YW5nLiBCZWNhdXNlIGl0IGFwcGxpZXMgdG8gbXV0YWJsZSBjb2xsZWN0aW9ucyxcXG50aGlzIG9wZXJhdGlvbiBpcyAqbXV0YWJsZSogYW5kIG1heSByZXR1cm4gaXRzZWxmICh0aG91Z2ggbWF5IG5vdFxcbnJldHVybiBpdHNlbGYsIGkuZS4gaWYgdGhlIHJlc3VsdCBpcyBhbiBlbXB0eSBjb2xsZWN0aW9uKS4gT25jZVxcbnBlcmZvcm1lZCwgdGhlIG9yaWdpbmFsIG11dGFibGUgY29weSBtdXN0IG5vIGxvbmdlciBiZSBtdXRhdGVkIHNpbmNlIGl0XFxubWF5IGJlIHRoZSBpbW11dGFibGUgcmVzdWx0LlwiLFwiZGVzY3JpcHRpb25cIjpcIklmIHBvc3NpYmxlLCB1c2UgYHdpdGhNdXRhdGlvbnNgIHRvIHdvcmsgd2l0aCB0ZW1wb3JhcnkgbXV0YWJsZSBjb3BpZXMgYXNcXG5pdCBwcm92aWRlcyBhbiBlYXNpZXIgdG8gdXNlIEFQSSBhbmQgY29uc2lkZXJzIG1hbnkgY29tbW9uIG9wdGltaXphdGlvbnMuXFxuXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcImBNYXAjYXNNdXRhYmxlYFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxMzEyfV19fX0se1widGl0bGVcIjpcIlNlcXVlbmNlIGFsZ29yaXRobXNcIixcIm1lbWJlcnNcIjp7XCIjbWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgTWFwIHdpdGggdmFsdWVzIHBhc3NlZCB0aHJvdWdoIGFcXG5gbWFwcGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCIgICAgTWFwKHsgYTogMSwgYjogMiB9KS5tYXAoeCA9PiAxMCAqIHgpXFxuICAgIC8vIE1hcCB7IGE6IDEwLCBiOiAyMCB9XCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk1cIn19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTWFwXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjEzMjN9XX0sXCIjbWFwS2V5c1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiQ29sbGVjdGlvbi5LZXllZC5tYXBLZXlzXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjoxMzMxfV19LFwiI21hcEVudHJpZXNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcIkNvbGxlY3Rpb24uS2V5ZWQubWFwRW50cmllc1wifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS01cIixcIlZNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImVudHJ5XCIsXCJ0eXBlXCI6e1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19LHtcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZNXCJ9XX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTWFwXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZNXCJ9XX0sXCJsaW5lXCI6MTMzOX1dfSxcIiNmbGF0TWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkZsYXQtbWFwcyB0aGUgTWFwLCByZXR1cm5pbmcgYSBuZXcgTWFwLlwiLFwiZGVzY3JpcHRpb25cIjpcIlNpbWlsYXIgdG8gYGRhdGEubWFwKC4uLikuZmxhdHRlbih0cnVlKWAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktNXCIsXCJWTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLTVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWTVwifV19XX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTWFwXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZNXCJ9XX0sXCJsaW5lXCI6MTM0OX1dfSxcIiNmaWx0ZXJcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBNYXAgd2l0aCBvbmx5IHRoZSBlbnRyaWVzIGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWBcXG5mdW5jdGlvbiByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYGZpbHRlcigpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCByZXN1bHRzIGluXFxubm90IGZpbHRlcmluZyBvdXQgYW55IHZhbHVlcy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiRlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIkZcIn1dfSxcImxpbmVcIjoxMzYxfSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxN319fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MTM2NX1dfSxcIiNmbGlwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJDb2xsZWN0aW9uLktleWVkLmZsaXBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTWFwXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifV19LFwibGluZVwiOjEzNzN9XX19fV19fSxcIk9yZGVyZWRNYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQSB0eXBlIG9mIE1hcCB0aGF0IGhhcyB0aGUgYWRkaXRpb25hbCBndWFyYW50ZWUgdGhhdCB0aGUgaXRlcmF0aW9uIG9yZGVyIG9mXFxuZW50cmllcyB3aWxsIGJlIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IHdlcmUgc2V0KCkuXCIsXCJkZXNjcmlwdGlvblwiOlwiVGhlIGl0ZXJhdGlvbiBiZWhhdmlvciBvZiBPcmRlcmVkTWFwIGlzIHRoZSBzYW1lIGFzIG5hdGl2ZSBFUzYgTWFwIGFuZFxcbkphdmFTY3JpcHQgT2JqZWN0Llxcblxcbk5vdGUgdGhhdCBgT3JkZXJlZE1hcGAgYXJlIG1vcmUgZXhwZW5zaXZlIHRoYW4gbm9uLW9yZGVyZWQgYE1hcGAgYW5kIG1heVxcbmNvbnN1bWUgbW9yZSBtZW1vcnkuIGBPcmRlcmVkTWFwI3NldGAgaXMgYW1vcnRpemVkIE8obG9nMzIgTiksIGJ1dCBub3RcXG5zdGFibGUuXCIsXCJub3Rlc1wiOltdfSxcIm1vZHVsZVwiOntcImlzT3JkZXJlZE1hcFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYW4gT3JkZXJlZE1hcC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVPcmRlcmVkTWFwXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjoxMzk0fV19fX0sXCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNyZWF0ZXMgYSBuZXcgSW1tdXRhYmxlIE9yZGVyZWRNYXAuXCIsXCJkZXNjcmlwdGlvblwiOlwiQ3JlYXRlZCB3aXRoIHRoZSBzYW1lIGtleSB2YWx1ZSBwYWlycyBhcyB0aGUgcHJvdmlkZWQgQ29sbGVjdGlvbi5LZXllZCBvclxcbkphdmFTY3JpcHQgT2JqZWN0IG9yIGV4cGVjdHMgYSBDb2xsZWN0aW9uIG9mIFtLLCBWXSB0dXBsZSBlbnRyaWVzLlxcblxcblRoZSBpdGVyYXRpb24gb3JkZXIgb2Yga2V5LXZhbHVlIHBhaXJzIHByb3ZpZGVkIHRvIHRoaXMgY29uc3RydWN0b3Igd2lsbFxcbmJlIHByZXNlcnZlZCBpbiB0aGUgT3JkZXJlZE1hcC5cXG5cXG4gICAgbGV0IG5ld09yZGVyZWRNYXAgPSBPcmRlcmVkTWFwKHtrZXk6IFxcXCJ2YWx1ZVxcXCJ9KVxcbiAgICBsZXQgbmV3T3JkZXJlZE1hcCA9IE9yZGVyZWRNYXAoW1tcXFwia2V5XFxcIiwgXFxcInZhbHVlXFxcIl1dKVxcblxcbk5vdGU6IGBPcmRlcmVkTWFwYCBpcyBhIGZhY3RvcnkgZnVuY3Rpb24gYW5kIG5vdCBhIGNsYXNzLCBhbmQgZG9lcyBub3QgdXNlXFxudGhlIGBuZXdgIGtleXdvcmQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkTWFwXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjE0MTJ9LHtcInR5cGVQYXJhbXNcIjpbXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm9ialwiLFwidHlwZVwiOntcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZE1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6M30se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjE0MTN9LHtcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCJdLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZE1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjoxNDE0fSx7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkTWFwXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19LFwibGluZVwiOjE0MTV9XX0sXCJpbnRlcmZhY2VcIjp7XCJsaW5lXCI6MTQxNyxcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCJdLFwiZXh0ZW5kc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIk1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfV0sXCJncm91cHNcIjpbe1wibWVtYmVyc1wiOntcIiNzaXplXCI6e1wibGluZVwiOjE0MjJ9LFwiI3NldFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IE9yZGVyZWRNYXAgYWxzbyBjb250YWluaW5nIHRoZSBuZXcga2V5LCB2YWx1ZSBwYWlyLiBJZiBhblxcbmVxdWl2YWxlbnQga2V5IGFscmVhZHkgZXhpc3RzIGluIHRoaXMgT3JkZXJlZE1hcCwgaXQgd2lsbCBiZSByZXBsYWNlZFxcbndoaWxlIG1haW50YWluaW5nIHRoZSBleGlzdGluZyBvcmRlci5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgT3JkZXJlZE1hcCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBvcmlnaW5hbE1hcCA9IE9yZGVyZWRNYXAoe2E6MSwgYjoxLCBjOjF9KVxcbmNvbnN0IHVwZGF0ZWRNYXAgPSBvcmlnaW5hbE1hcC5zZXQoJ2InLCAyKVxcblxcbm9yaWdpbmFsTWFwXFxuLy8gT3JkZXJlZE1hcCB7YTogMSwgYjogMSwgYzogMX1cXG51cGRhdGVkTWFwXFxuLy8gT3JkZXJlZE1hcCB7YTogMSwgYjogMiwgYzogMX1cXG5gYGBcXG5cXG5Ob3RlOiBgc2V0YCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MTQ0M31dfSxcIiNtZXJnZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IE9yZGVyZWRNYXAgcmVzdWx0aW5nIGZyb20gbWVyZ2luZyB0aGUgcHJvdmlkZWQgQ29sbGVjdGlvbnNcXG4ob3IgSlMgb2JqZWN0cykgaW50byB0aGlzIE9yZGVyZWRNYXAuIEluIG90aGVyIHdvcmRzLCB0aGlzIHRha2VzIGVhY2hcXG5lbnRyeSBvZiBlYWNoIGNvbGxlY3Rpb24gYW5kIHNldHMgaXQgb24gdGhpcyBPcmRlcmVkTWFwLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IFZhbHVlcyBwcm92aWRlZCB0byBgbWVyZ2VgIGFyZSBzaGFsbG93bHkgY29udmVydGVkIGJlZm9yZSBiZWluZ1xcbm1lcmdlZC4gTm8gbmVzdGVkIHZhbHVlcyBhcmUgYWx0ZXJlZC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgT3JkZXJlZE1hcCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBvbmUgPSBPcmRlcmVkTWFwKHsgYTogMTAsIGI6IDIwLCBjOiAzMCB9KVxcbmNvbnN0IHR3byA9IE9yZGVyZWRNYXAoeyBiOiA0MCwgYTogNTAsIGQ6IDYwIH0pXFxub25lLm1lcmdlKHR3bykgLy8gT3JkZXJlZE1hcCB7IFxcXCJhXFxcIjogNTAsIFxcXCJiXFxcIjogNDAsIFxcXCJjXFxcIjogMzAsIFxcXCJkXFxcIjogNjAgfVxcbnR3by5tZXJnZShvbmUpIC8vIE9yZGVyZWRNYXAgeyBcXFwiYlxcXCI6IDIwLCBcXFwiYVxcXCI6IDEwLCBcXFwiZFxcXCI6IDYwLCBcXFwiY1xcXCI6IDMwIH1cXG5gYGBcXG5cXG5Ob3RlOiBgbWVyZ2VgIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cXG5cIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcImFsaWFzXCIsXCJib2R5XCI6XCJjb25jYXRcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktDXCIsXCJWQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLQ1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWQ1wifV19XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkTWFwXCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiS0NcIn1dfSx7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZDXCJ9XX1dfSxcImxpbmVcIjoxNDY2fSx7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZE1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjozfV19LHtcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifV19XX0sXCJsaW5lXCI6MTQ2N31dfX19LHtcInRpdGxlXCI6XCJTZXF1ZW5jZSBhbGdvcml0aG1zXCIsXCJtZW1iZXJzXCI6e1wiI21hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IE9yZGVyZWRNYXAgd2l0aCB2YWx1ZXMgcGFzc2VkIHRocm91Z2ggYVxcbmBtYXBwZXJgIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIiAgICBPcmRlcmVkTWFwKHsgYTogMSwgYjogMiB9KS5tYXAoeCA9PiAxMCAqIHgpXFxuICAgIC8vIE9yZGVyZWRNYXAgeyBcXFwiYVxcXCI6IDEwLCBcXFwiYlxcXCI6IDIwIH1cXG5cXG5Ob3RlOiBgbWFwKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHByb2R1Y2VkIHRoZSBzYW1lXFxudmFsdWUgYXQgZXZlcnkgc3RlcC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkTWFwXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjE0ODN9XX0sXCIjbWFwS2V5c1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiQ29sbGVjdGlvbi5LZXllZC5tYXBLZXlzXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRNYXBcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6MTQ5MX1dfSxcIiNtYXBFbnRyaWVzXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJDb2xsZWN0aW9uLktleWVkLm1hcEVudHJpZXNcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktNXCIsXCJWTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJlbnRyeVwiLFwidHlwZVwiOntcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19fSx7XCJuYW1lXCI6XCJpbmRleFwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLTVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWTVwifV19fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRNYXBcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS01cIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVk1cIn1dfSxcImxpbmVcIjoxNDk5fV19LFwiI2ZsYXRNYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRmxhdC1tYXBzIHRoZSBPcmRlcmVkTWFwLCByZXR1cm5pbmcgYSBuZXcgT3JkZXJlZE1hcC5cIixcImRlc2NyaXB0aW9uXCI6XCJTaW1pbGFyIHRvIGBkYXRhLm1hcCguLi4pLmZsYXR0ZW4odHJ1ZSlgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJLTVwiLFwiVk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS01cIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVk1cIn1dfV19fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRNYXBcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS01cIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVk1cIn1dfSxcImxpbmVcIjoxNTA5fV19LFwiI2ZpbHRlclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IE9yZGVyZWRNYXAgd2l0aCBvbmx5IHRoZSBlbnRyaWVzIGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWBcXG5mdW5jdGlvbiByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYGZpbHRlcigpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCByZXN1bHRzIGluXFxubm90IGZpbHRlcmluZyBvdXQgYW55IHZhbHVlcy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiRlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRNYXBcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJGXCJ9XX0sXCJsaW5lXCI6MTUyMX0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MTd9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjE1MjV9XX0sXCIjZmxpcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiQ29sbGVjdGlvbi5LZXllZC5mbGlwXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRNYXBcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9XX0sXCJsaW5lXCI6MTUzM31dfX19XX19LFwiU2V0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkEgQ29sbGVjdGlvbiBvZiB1bmlxdWUgdmFsdWVzIHdpdGggYE8obG9nMzIgTilgIGFkZHMgYW5kIGhhcy5cIixcImRlc2NyaXB0aW9uXCI6XCJXaGVuIGl0ZXJhdGluZyBhIFNldCwgdGhlIGVudHJpZXMgd2lsbCBiZSAodmFsdWUsIHZhbHVlKSBwYWlycy4gSXRlcmF0aW9uXFxub3JkZXIgb2YgYSBTZXQgaXMgdW5kZWZpbmVkLCBob3dldmVyIGlzIHN0YWJsZS4gTXVsdGlwbGUgaXRlcmF0aW9ucyBvZiB0aGVcXG5zYW1lIFNldCB3aWxsIGl0ZXJhdGUgaW4gdGhlIHNhbWUgb3JkZXIuXFxuXFxuU2V0IHZhbHVlcywgbGlrZSBNYXAga2V5cywgbWF5IGJlIG9mIGFueSB0eXBlLiBFcXVhbGl0eSBpcyBkZXRlcm1pbmVkIHVzaW5nXFxuYEltbXV0YWJsZS5pc2AsIGVuYWJsaW5nIFNldHMgdG8gdW5pcXVlbHkgaW5jbHVkZSBvdGhlciBJbW11dGFibGVcXG5jb2xsZWN0aW9ucywgY3VzdG9tIHZhbHVlIHR5cGVzLCBhbmQgTmFOLlwiLFwibm90ZXNcIjpbXX0sXCJtb2R1bGVcIjp7XCJpc1NldFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYSBTZXRcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVTZXRcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjE1NTN9XX19LFwib2ZcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNyZWF0ZXMgYSBuZXcgU2V0IGNvbnRhaW5pbmcgYHZhbHVlc2AuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVzXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoxNTU4fV19fSxcImZyb21LZXlzXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJgU2V0LmZyb21LZXlzKClgIGNyZWF0ZXMgYSBuZXcgaW1tdXRhYmxlIFNldCBjb250YWluaW5nIHRoZSBrZXlzIGZyb21cXG50aGlzIENvbGxlY3Rpb24gb3IgSmF2YVNjcmlwdCBPYmplY3QuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjoxN31dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoxNTY0fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib2JqXCIsXCJ0eXBlXCI6e1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6MTd9fV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXRcIixcImFyZ3NcIjpbe1wia1wiOjN9XX0sXCJsaW5lXCI6MTU2NX1dfX0sXCJpbnRlcnNlY3RcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcImBTZXQuaW50ZXJzZWN0KClgIGNyZWF0ZXMgYSBuZXcgaW1tdXRhYmxlIFNldCB0aGF0IGlzIHRoZSBpbnRlcnNlY3Rpb24gb2ZcXG5hIGNvbGxlY3Rpb24gb2Ygb3RoZXIgc2V0cy5cIixcImRlc2NyaXB0aW9uXCI6XCJgYGBqc1xcbmNvbnN0IHsgU2V0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IGludGVyc2VjdGVkID0gU2V0LmludGVyc2VjdChbXFxuICBTZXQoWyAnYScsICdiJywgJ2MnIF0pXFxuICBTZXQoWyAnYycsICdhJywgJ3QnIF0pXFxuXSlcXG4vLyBTZXQgWyBcXFwiYVxcXCIsIFxcXCJjXFxcIiBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwic2V0c1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoxNTgwfV19fSxcInVuaW9uXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJgU2V0LnVuaW9uKClgIGNyZWF0ZXMgYSBuZXcgaW1tdXRhYmxlIFNldCB0aGF0IGlzIHRoZSB1bmlvbiBvZiBhXFxuY29sbGVjdGlvbiBvZiBvdGhlciBzZXRzLlwiLFwiZGVzY3JpcHRpb25cIjpcImBgYGpzXFxuY29uc3QgeyBTZXQgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3QgdW5pb25lZCA9IFNldC51bmlvbihbXFxuICBTZXQoWyAnYScsICdiJywgJ2MnIF0pXFxuICBTZXQoWyAnYycsICdhJywgJ3QnIF0pXFxuXSlcXG4vLyBTZXQgWyBcXFwiYVxcXCIsIFxcXCJiXFxcIiwgXFxcImNcXFwiLCBcXFwidFxcXCIgXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInNldHNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTU5NX1dfX19LFwiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDcmVhdGUgYSBuZXcgaW1tdXRhYmxlIFNldCBjb250YWluaW5nIHRoZSB2YWx1ZXMgb2YgdGhlIHByb3ZpZGVkXFxuY29sbGVjdGlvbi1saWtlLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBTZXRgIGlzIGEgZmFjdG9yeSBmdW5jdGlvbiBhbmQgbm90IGEgY2xhc3MsIGFuZCBkb2VzIG5vdCB1c2UgdGhlXFxuYG5ld2Aga2V5d29yZCBkdXJpbmcgY29uc3RydWN0aW9uLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJsaW5lXCI6MTYwNX0se1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjE2MDZ9LHtcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoxNjA3fV19LFwiaW50ZXJmYWNlXCI6e1wibGluZVwiOjE2MDksXCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcImV4dGVuZHNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX1dLFwiZ3JvdXBzXCI6W3tcIm1lbWJlcnNcIjp7XCIjc2l6ZVwiOntcImxpbmVcIjoxNjE0fX19LHtcInRpdGxlXCI6XCJQZXJzaXN0ZW50IGNoYW5nZXNcIixcIm1lbWJlcnNcIjp7XCIjYWRkXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU2V0IHdoaWNoIGFsc28gaW5jbHVkZXMgdGhpcyB2YWx1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgYWRkYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MTYyM31dfSxcIiNkZWxldGVcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBTZXQgd2hpY2ggZXhjbHVkZXMgdGhpcyB2YWx1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgZGVsZXRlYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXFxuXFxuTm90ZTogYGRlbGV0ZWAgKipjYW5ub3QqKiBiZSBzYWZlbHkgdXNlZCBpbiBJRTgsIHVzZSBgcmVtb3ZlYCBpZlxcbnN1cHBvcnRpbmcgb2xkIGJyb3dzZXJzLlxcblwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwiYWxpYXNcIixcImJvZHlcIjpcInJlbW92ZVwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoxNjM1fV19LFwiI2NsZWFyXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU2V0IGNvbnRhaW5pbmcgbm8gdmFsdWVzLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBjbGVhcmAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjE2NDN9XX0sXCIjdW5pb25cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIFNldCBpbmNsdWRpbmcgYW55IHZhbHVlIGZyb20gYGNvbGxlY3Rpb25zYCB0aGF0IGRvZXMgbm90IGFscmVhZHlcXG5leGlzdCBpbiB0aGlzIFNldC5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgdW5pb25gIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcImFsaWFzXCIsXCJib2R5XCI6XCJtZXJnZVwifSx7XCJuYW1lXCI6XCJhbGlhc1wiLFwiYm9keVwiOlwiY29uY2F0XCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIkNcIn1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIkNcIn1dfV19LFwibGluZVwiOjE2NTN9XX0sXCIjaW50ZXJzZWN0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBTZXQgd2hpY2ggaGFzIHJlbW92ZWQgYW55IHZhbHVlcyBub3QgYWxzbyBjb250YWluZWRcXG53aXRoaW4gYGNvbGxlY3Rpb25zYC5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgaW50ZXJzZWN0YCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjE2NjN9XX0sXCIjc3VidHJhY3RcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIFNldCBleGNsdWRpbmcgYW55IHZhbHVlcyBjb250YWluZWQgd2l0aGluIGBjb2xsZWN0aW9uc2AuXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IE9yZGVyZWRTZXQgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuT3JkZXJlZFNldChbIDEsIDIsIDMgXSkuc3VidHJhY3QoWzEsIDNdKVxcbi8vIE9yZGVyZWRTZXQgWzJdXFxuYGBgXFxuXFxuTm90ZTogYHN1YnRyYWN0YCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjE2Nzd9XX19fSx7XCJ0aXRsZVwiOlwiVHJhbnNpZW50IGNoYW5nZXNcIixcIm1lbWJlcnNcIjp7XCIjd2l0aE11dGF0aW9uc1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJOb3RlOiBOb3QgYWxsIG1ldGhvZHMgY2FuIGJlIHVzZWQgb24gYSBtdXRhYmxlIGNvbGxlY3Rpb24gb3Igd2l0aGluXFxuYHdpdGhNdXRhdGlvbnNgISBDaGVjayB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgZWFjaCBtZXRob2QgdG8gc2VlIGlmIGl0XFxubWVudGlvbnMgYmVpbmcgc2FmZSB0byB1c2UgaW4gYHdpdGhNdXRhdGlvbnNgLlxcblwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI3dpdGhNdXRhdGlvbnNgXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtdXRhdG9yXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibXV0YWJsZVwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MTd9fX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MTY4OX1dfSxcIiNhc011dGFibGVcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiTm90ZTogTm90IGFsbCBtZXRob2RzIGNhbiBiZSB1c2VkIG9uIGEgbXV0YWJsZSBjb2xsZWN0aW9uIG9yIHdpdGhpblxcbmB3aXRoTXV0YXRpb25zYCEgQ2hlY2sgdGhlIGRvY3VtZW50YXRpb24gZm9yIGVhY2ggbWV0aG9kIHRvIHNlZSBpZiBpdFxcbm1lbnRpb25zIGJlaW5nIHNhZmUgdG8gdXNlIGluIGB3aXRoTXV0YXRpb25zYC5cXG5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiYE1hcCNhc011dGFibGVgXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjE2OTh9XX0sXCIjd2FzQWx0ZXJlZFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiYE1hcCN3YXNBbHRlcmVkYFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjE3MDN9XX0sXCIjYXNJbW11dGFibGVcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcImBNYXAjYXNJbW11dGFibGVgXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjE3MDh9XX19fSx7XCJ0aXRsZVwiOlwiU2VxdWVuY2UgYWxnb3JpdGhtc1wiLFwibWVtYmVyc1wiOntcIiNtYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBTZXQgd2l0aCB2YWx1ZXMgcGFzc2VkIHRocm91Z2ggYVxcbmBtYXBwZXJgIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIiAgICBTZXQoWzEsMl0pLm1hcCh4ID0+IDEwICogeClcXG4gICAgLy8gU2V0IFsxMCwyMF1cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjE3MTl9XX0sXCIjZmxhdE1hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJGbGF0LW1hcHMgdGhlIFNldCwgcmV0dXJuaW5nIGEgbmV3IFNldC5cIixcImRlc2NyaXB0aW9uXCI6XCJTaW1pbGFyIHRvIGBzZXQubWFwKC4uLikuZmxhdHRlbih0cnVlKWAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6MTcyOX1dfSxcIiNmaWx0ZXJcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBTZXQgd2l0aCBvbmx5IHRoZSB2YWx1ZXMgZm9yIHdoaWNoIHRoZSBgcHJlZGljYXRlYFxcbmZ1bmN0aW9uIHJldHVybnMgdHJ1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgZmlsdGVyKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHJlc3VsdHMgaW5cXG5ub3QgZmlsdGVyaW5nIG91dCBhbnkgdmFsdWVzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJGXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIkZcIn1dfSxcImxpbmVcIjoxNzQxfSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxN319fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MTc0NX1dfX19XX19LFwiT3JkZXJlZFNldFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJBIHR5cGUgb2YgU2V0IHRoYXQgaGFzIHRoZSBhZGRpdGlvbmFsIGd1YXJhbnRlZSB0aGF0IHRoZSBpdGVyYXRpb24gb3JkZXIgb2ZcXG52YWx1ZXMgd2lsbCBiZSB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSB3ZXJlIGBhZGRgZWQuXCIsXCJkZXNjcmlwdGlvblwiOlwiVGhlIGl0ZXJhdGlvbiBiZWhhdmlvciBvZiBPcmRlcmVkU2V0IGlzIHRoZSBzYW1lIGFzIG5hdGl2ZSBFUzYgU2V0Llxcblxcbk5vdGUgdGhhdCBgT3JkZXJlZFNldGAgYXJlIG1vcmUgZXhwZW5zaXZlIHRoYW4gbm9uLW9yZGVyZWQgYFNldGAgYW5kIG1heVxcbmNvbnN1bWUgbW9yZSBtZW1vcnkuIGBPcmRlcmVkU2V0I2FkZGAgaXMgYW1vcnRpemVkIE8obG9nMzIgTiksIGJ1dCBub3RcXG5zdGFibGUuXCIsXCJub3Rlc1wiOltdfSxcIm1vZHVsZVwiOntcImlzT3JkZXJlZFNldFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYW4gT3JkZXJlZFNldC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVPcmRlcmVkU2V0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjoxNzY3fV19fSxcIm9mXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDcmVhdGVzIGEgbmV3IE9yZGVyZWRTZXQgY29udGFpbmluZyBgdmFsdWVzYC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZXNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoxNzcyfV19fSxcImZyb21LZXlzXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJgT3JkZXJlZFNldC5mcm9tS2V5cygpYCBjcmVhdGVzIGEgbmV3IGltbXV0YWJsZSBPcmRlcmVkU2V0IGNvbnRhaW5pbmdcXG50aGUga2V5cyBmcm9tIHRoaXMgQ29sbGVjdGlvbiBvciBKYXZhU2NyaXB0IE9iamVjdC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjE3fV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoxNzc4fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib2JqXCIsXCJ0eXBlXCI6e1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6MTd9fV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkU2V0XCIsXCJhcmdzXCI6W3tcImtcIjozfV19LFwibGluZVwiOjE3Nzl9XX19fSxcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQ3JlYXRlIGEgbmV3IGltbXV0YWJsZSBPcmRlcmVkU2V0IGNvbnRhaW5pbmcgdGhlIHZhbHVlcyBvZiB0aGUgcHJvdmlkZWRcXG5jb2xsZWN0aW9uLWxpa2UuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYE9yZGVyZWRTZXRgIGlzIGEgZmFjdG9yeSBmdW5jdGlvbiBhbmQgbm90IGEgY2xhc3MsIGFuZCBkb2VzIG5vdCB1c2VcXG50aGUgYG5ld2Aga2V5d29yZCBkdXJpbmcgY29uc3RydWN0aW9uLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRTZXRcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwibGluZVwiOjE3ODl9LHtcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZFNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTc5MH0se1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoxNzkxfV19LFwiaW50ZXJmYWNlXCI6e1wibGluZVwiOjE3OTMsXCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcImV4dGVuZHNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJTZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19XSxcImdyb3Vwc1wiOlt7XCJtZW1iZXJzXCI6e1wiI3NpemVcIjp7XCJsaW5lXCI6MTc5OH0sXCIjdW5pb25cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhbiBPcmRlcmVkU2V0IGluY2x1ZGluZyBhbnkgdmFsdWUgZnJvbSBgY29sbGVjdGlvbnNgIHRoYXQgZG9lc1xcbm5vdCBhbHJlYWR5IGV4aXN0IGluIHRoaXMgT3JkZXJlZFNldC5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgdW5pb25gIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcImFsaWFzXCIsXCJib2R5XCI6XCJtZXJnZVwifSx7XCJuYW1lXCI6XCJhbGlhc1wiLFwiYm9keVwiOlwiY29uY2F0XCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIkNcIn1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRTZXRcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9XX1dfSxcImxpbmVcIjoxODA4fV19fX0se1widGl0bGVcIjpcIlNlcXVlbmNlIGFsZ29yaXRobXNcIixcIm1lbWJlcnNcIjp7XCIjbWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU2V0IHdpdGggdmFsdWVzIHBhc3NlZCB0aHJvdWdoIGFcXG5gbWFwcGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCIgICAgT3JkZXJlZFNldChbIDEsIDIgXSkubWFwKHggPT4gMTAgKiB4KVxcbiAgICAvLyBPcmRlcmVkU2V0IFsxMCwgMjBdXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk1cIn19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZFNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6MTgyMX1dfSxcIiNmbGF0TWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkZsYXQtbWFwcyB0aGUgT3JkZXJlZFNldCwgcmV0dXJuaW5nIGEgbmV3IE9yZGVyZWRTZXQuXCIsXCJkZXNjcmlwdGlvblwiOlwiU2ltaWxhciB0byBgc2V0Lm1hcCguLi4pLmZsYXR0ZW4odHJ1ZSlgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjoxODMxfV19LFwiI2ZpbHRlclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IE9yZGVyZWRTZXQgd2l0aCBvbmx5IHRoZSB2YWx1ZXMgZm9yIHdoaWNoIHRoZSBgcHJlZGljYXRlYFxcbmZ1bmN0aW9uIHJldHVybnMgdHJ1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgZmlsdGVyKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHJlc3VsdHMgaW5cXG5ub3QgZmlsdGVyaW5nIG91dCBhbnkgdmFsdWVzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJGXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZFNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJGXCJ9XX0sXCJsaW5lXCI6MTg0M30se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MTd9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjE4NDd9XX0sXCIjemlwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYW4gT3JkZXJlZFNldCBvZiB0aGUgc2FtZSB0eXBlIFxcXCJ6aXBwZWRcXFwiIHdpdGggdGhlIHByb3ZpZGVkXFxuY29sbGVjdGlvbnMuXCIsXCJkZXNjcmlwdGlvblwiOlwiTGlrZSBgemlwV2l0aGAsIGJ1dCB1c2luZyB0aGUgZGVmYXVsdCBgemlwcGVyYDogY3JlYXRpbmcgYW4gYEFycmF5YC5cXG5cXG5gYGBqc1xcbmNvbnN0IGEgPSBPcmRlcmVkU2V0KFsgMSwgMiwgMyBdKVxcbmNvbnN0IGIgPSBPcmRlcmVkU2V0KFsgNCwgNSwgNiBdKVxcbmNvbnN0IGMgPSBhLnppcChiKVxcbi8vIE9yZGVyZWRTZXQgWyBbIDEsIDQgXSwgWyAyLCA1IF0sIFsgMywgNiBdIF1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlclwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZFNldFwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfV19LFwibGluZVwiOjE4NjV9LHtcInR5cGVQYXJhbXNcIjpbXCJVXCIsXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyMVwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX0se1wibmFtZVwiOlwib3RoZXIyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkU2V0XCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfSxcImxpbmVcIjoxODY2fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRTZXRcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwibGluZVwiOjE4Njd9XX0sXCIjemlwQWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBPcmRlcmVkU2V0IG9mIHRoZSBzYW1lIHR5cGUgXFxcInppcHBlZFxcXCIgd2l0aCB0aGUgcHJvdmlkZWRcXG5jb2xsZWN0aW9ucy5cIixcImRlc2NyaXB0aW9uXCI6XCJVbmxpa2UgYHppcGAsIGB6aXBBbGxgIGNvbnRpbnVlcyB6aXBwaW5nIHVudGlsIHRoZSBsb25nZXN0IGNvbGxlY3Rpb24gaXNcXG5leGhhdXN0ZWQuIE1pc3NpbmcgdmFsdWVzIGZyb20gc2hvcnRlciBjb2xsZWN0aW9ucyBhcmUgZmlsbGVkIHdpdGggYHVuZGVmaW5lZGAuXFxuXFxuYGBganNcXG5jb25zdCBhID0gT3JkZXJlZFNldChbIDEsIDIgXSk7XFxuY29uc3QgYiA9IE9yZGVyZWRTZXQoWyAzLCA0LCA1IF0pO1xcbmNvbnN0IGMgPSBhLnppcEFsbChiKTsgLy8gT3JkZXJlZFNldCBbIFsgMSwgMyBdLCBbIDIsIDQgXSwgWyB1bmRlZmluZWQsIDUgXSBdXFxuYGBgXFxuXFxuTm90ZTogU2luY2UgemlwQWxsIHdpbGwgcmV0dXJuIGEgY29sbGVjdGlvbiBhcyBsYXJnZSBhcyB0aGUgbGFyZ2VzdFxcbmlucHV0LCBzb21lIHJlc3VsdHMgbWF5IGNvbnRhaW4gdW5kZWZpbmVkIHZhbHVlcy4gVHlwZVNjcmlwdCBjYW5ub3RcXG5hY2NvdW50IGZvciB0aGVzZSB3aXRob3V0IGNhc2VzIChhcyBvZiB2Mi41KS5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlclwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZFNldFwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfV19LFwibGluZVwiOjE4ODZ9LHtcInR5cGVQYXJhbXNcIjpbXCJVXCIsXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyMVwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX0se1wibmFtZVwiOlwib3RoZXIyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkU2V0XCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfSxcImxpbmVcIjoxODg3fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9yZGVyZWRTZXRcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwibGluZVwiOjE4ODh9XX0sXCIjemlwV2l0aFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGFuIE9yZGVyZWRTZXQgb2YgdGhlIHNhbWUgdHlwZSBcXFwiemlwcGVkXFxcIiB3aXRoIHRoZSBwcm92aWRlZFxcbmNvbGxlY3Rpb25zIGJ5IHVzaW5nIGEgY3VzdG9tIGB6aXBwZXJgIGZ1bmN0aW9uLlxcblwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJTZXEuSW5kZXhlZC56aXBXaXRoXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJVXCIsXCJaXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInppcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwib3RoZXJWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlVcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9fX0se1wibmFtZVwiOlwib3RoZXJDb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlpcIn1dfSxcImxpbmVcIjoxODk2fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiVlwiLFwiWlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ6aXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIm90aGVyVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9fSx7XCJuYW1lXCI6XCJ0aGlyZFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlpcIn19fSx7XCJuYW1lXCI6XCJvdGhlckNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19LHtcIm5hbWVcIjpcInRoaXJkQ29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZFNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9XX0sXCJsaW5lXCI6MTkwMH0se1widHlwZVBhcmFtc1wiOltcIlpcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiemlwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiYW55XCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlpcIn19fSx7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT3JkZXJlZFNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9XX0sXCJsaW5lXCI6MTkwNX1dfX19XX19LFwiU3RhY2tcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiU3RhY2tzIGFyZSBpbmRleGVkIGNvbGxlY3Rpb25zIHdoaWNoIHN1cHBvcnQgdmVyeSBlZmZpY2llbnQgTygxKSBhZGRpdGlvblxcbmFuZCByZW1vdmFsIGZyb20gdGhlIGZyb250IHVzaW5nIGB1bnNoaWZ0KHYpYCBhbmQgYHNoaWZ0KClgLlwiLFwiZGVzY3JpcHRpb25cIjpcIkZvciBmYW1pbGlhcml0eSwgU3RhY2sgYWxzbyBwcm92aWRlcyBgcHVzaCh2KWAsIGBwb3AoKWAsIGFuZCBgcGVlaygpYCwgYnV0XFxuYmUgYXdhcmUgdGhhdCB0aGV5IGFsc28gb3BlcmF0ZSBvbiB0aGUgZnJvbnQgb2YgdGhlIGxpc3QsIHVubGlrZSBMaXN0IG9yXFxuYSBKYXZhU2NyaXB0IEFycmF5Llxcblxcbk5vdGU6IGByZXZlcnNlKClgIG9yIGFueSBpbmhlcmVudCByZXZlcnNlIHRyYXZlcnNhbCAoYHJlZHVjZVJpZ2h0YCxcXG5gbGFzdEluZGV4T2ZgLCBldGMuKSBpcyBub3QgZWZmaWNpZW50IHdpdGggYSBTdGFjay5cXG5cXG5TdGFjayBpcyBpbXBsZW1lbnRlZCB3aXRoIGEgU2luZ2xlLUxpbmtlZCBMaXN0LlwiLFwibm90ZXNcIjpbXX0sXCJtb2R1bGVcIjp7XCJpc1N0YWNrXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBhIFN0YWNrXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlU3RhY2tcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjE5MzF9XX19LFwib2ZcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNyZWF0ZXMgYSBuZXcgU3RhY2sgY29udGFpbmluZyBgdmFsdWVzYC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZXNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTdGFja1wiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTkzNn1dfX19LFwiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDcmVhdGUgYSBuZXcgaW1tdXRhYmxlIFN0YWNrIGNvbnRhaW5pbmcgdGhlIHZhbHVlcyBvZiB0aGUgcHJvdmlkZWRcXG5jb2xsZWN0aW9uLWxpa2UuXCIsXCJkZXNjcmlwdGlvblwiOlwiVGhlIGl0ZXJhdGlvbiBvcmRlciBvZiB0aGUgcHJvdmlkZWQgY29sbGVjdGlvbiBpcyBwcmVzZXJ2ZWQgaW4gdGhlXFxucmVzdWx0aW5nIGBTdGFja2AuXFxuXFxuTm90ZTogYFN0YWNrYCBpcyBhIGZhY3RvcnkgZnVuY3Rpb24gYW5kIG5vdCBhIGNsYXNzLCBhbmQgZG9lcyBub3QgdXNlIHRoZVxcbmBuZXdgIGtleXdvcmQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTdGFja1wiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJsaW5lXCI6MTk0OX0se1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTdGFja1wiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTk1MH0se1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTdGFja1wiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MTk1MX1dfSxcImludGVyZmFjZVwiOntcImxpbmVcIjoxOTUzLFwidHlwZVBhcmFtc1wiOltcIlRcIl0sXCJleHRlbmRzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfV0sXCJncm91cHNcIjpbe1wibWVtYmVyc1wiOntcIiNzaXplXCI6e1wibGluZVwiOjE5NTh9fX0se1widGl0bGVcIjpcIlJlYWRpbmcgdmFsdWVzXCIsXCJtZW1iZXJzXCI6e1wiI3BlZWtcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQWxpYXMgZm9yIGBTdGFjay5maXJzdCgpYC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6MTF9XX0sXCJsaW5lXCI6MTk2NX1dfX19LHtcInRpdGxlXCI6XCJQZXJzaXN0ZW50IGNoYW5nZXNcIixcIm1lbWJlcnNcIjp7XCIjY2xlYXJcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBTdGFjayB3aXRoIDAgc2l6ZSBhbmQgbm8gdmFsdWVzLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBjbGVhcmAgY2FuIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlN0YWNrXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoxOTc1fV19LFwiI3Vuc2hpZnRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBTdGFjayB3aXRoIHRoZSBwcm92aWRlZCBgdmFsdWVzYCBwcmVwZW5kZWQsIHNoaWZ0aW5nIG90aGVyXFxudmFsdWVzIGFoZWFkIHRvIGhpZ2hlciBpbmRpY2VzLlwiLFwiZGVzY3JpcHRpb25cIjpcIlRoaXMgaXMgdmVyeSBlZmZpY2llbnQgZm9yIFN0YWNrLlxcblxcbk5vdGU6IGB1bnNoaWZ0YCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlN0YWNrXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoxOTg1fV19LFwiI3Vuc2hpZnRBbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiTGlrZSBgU3RhY2sjdW5zaGlmdGAsIGJ1dCBhY2NlcHRzIGEgY29sbGVjdGlvbiByYXRoZXIgdGhhbiB2YXJhcmdzLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGB1bnNoaWZ0QWxsYCBjYW4gYmUgdXNlZCBpbiBgd2l0aE11dGF0aW9uc2AuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU3RhY2tcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjE5OTJ9XX0sXCIjc2hpZnRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBTdGFjayB3aXRoIGEgc2l6ZSBvbmVzIGxlc3MgdGhhbiB0aGlzIFN0YWNrLCBleGNsdWRpbmdcXG50aGUgZmlyc3QgaXRlbSBpbiB0aGlzIFN0YWNrLCBzaGlmdGluZyBhbGwgb3RoZXIgdmFsdWVzIHRvIGEgbG93ZXIgaW5kZXguXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogdGhpcyBkaWZmZXJzIGZyb20gYEFycmF5I3NoaWZ0YCBiZWNhdXNlIGl0IHJldHVybnMgYSBuZXdcXG5TdGFjayByYXRoZXIgdGhhbiB0aGUgcmVtb3ZlZCB2YWx1ZS4gVXNlIGBmaXJzdCgpYCBvciBgcGVlaygpYCB0byBnZXQgdGhlXFxuZmlyc3QgdmFsdWUgaW4gdGhpcyBTdGFjay5cXG5cXG5Ob3RlOiBgc2hpZnRgIGNhbiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTdGFja1wiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MjAwNH1dfSxcIiNwdXNoXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkFsaWFzIGZvciBgU3RhY2sjdW5zaGlmdGAgYW5kIGlzIG5vdCBlcXVpdmFsZW50IHRvIGBMaXN0I3B1c2hgLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZXNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTdGFja1wiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MjAwOX1dfSxcIiNwdXNoQWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkFsaWFzIGZvciBgU3RhY2sjdW5zaGlmdEFsbGAuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU3RhY2tcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjIwMTR9XX0sXCIjcG9wXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkFsaWFzIGZvciBgU3RhY2sjc2hpZnRgIGFuZCBpcyBub3QgZXF1aXZhbGVudCB0byBgTGlzdCNwb3BgLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlN0YWNrXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoyMDE5fV19fX0se1widGl0bGVcIjpcIlRyYW5zaWVudCBjaGFuZ2VzXCIsXCJtZW1iZXJzXCI6e1wiI3dpdGhNdXRhdGlvbnNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiTm90ZTogTm90IGFsbCBtZXRob2RzIGNhbiBiZSB1c2VkIG9uIGEgbXV0YWJsZSBjb2xsZWN0aW9uIG9yIHdpdGhpblxcbmB3aXRoTXV0YXRpb25zYCEgQ2hlY2sgdGhlIGRvY3VtZW50YXRpb24gZm9yIGVhY2ggbWV0aG9kIHRvIHNlZSBpZiBpdFxcbm1lbnRpb25zIGJlaW5nIHNhZmUgdG8gdXNlIGluIGB3aXRoTXV0YXRpb25zYC5cXG5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiYE1hcCN3aXRoTXV0YXRpb25zYFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibXV0YXRvclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm11dGFibGVcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjIwMzF9XX0sXCIjYXNNdXRhYmxlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIk5vdGU6IE5vdCBhbGwgbWV0aG9kcyBjYW4gYmUgdXNlZCBvbiBhIG11dGFibGUgY29sbGVjdGlvbiBvciB3aXRoaW5cXG5gd2l0aE11dGF0aW9uc2AhIENoZWNrIHRoZSBkb2N1bWVudGF0aW9uIGZvciBlYWNoIG1ldGhvZCB0byBzZWUgaWYgaXRcXG5tZW50aW9ucyBiZWluZyBzYWZlIHRvIHVzZSBpbiBgd2l0aE11dGF0aW9uc2AuXFxuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcImBNYXAjYXNNdXRhYmxlYFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoyMDQwfV19LFwiI3dhc0FsdGVyZWRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcImBNYXAjd2FzQWx0ZXJlZGBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjoyMDQ1fV19LFwiI2FzSW1tdXRhYmxlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI2FzSW1tdXRhYmxlYFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoyMDUwfV19fX0se1widGl0bGVcIjpcIlNlcXVlbmNlIGFsZ29yaXRobXNcIixcIm1lbWJlcnNcIjp7XCIjY29uY2F0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU3RhY2sgd2l0aCBvdGhlciBjb2xsZWN0aW9ucyBjb25jYXRlbmF0ZWQgdG8gdGhpcyBvbmUuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVzT3JDb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9XX0se1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU3RhY2tcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9XX1dfSxcImxpbmVcIjoyMDU3fV19LFwiI21hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFN0YWNrIHdpdGggdmFsdWVzIHBhc3NlZCB0aHJvdWdoIGFcXG5gbWFwcGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCIgICAgU3RhY2soWyAxLCAyIF0pLm1hcCh4ID0+IDEwICogeClcXG4gICAgLy8gU3RhY2sgWyAxMCwgMjAgXVxcblxcbk5vdGU6IGBtYXAoKWAgYWx3YXlzIHJldHVybnMgYSBuZXcgaW5zdGFuY2UsIGV2ZW4gaWYgaXQgcHJvZHVjZWQgdGhlIHNhbWVcXG52YWx1ZSBhdCBldmVyeSBzdGVwLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk1cIn19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU3RhY2tcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjIwNjl9XX0sXCIjZmxhdE1hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJGbGF0LW1hcHMgdGhlIFN0YWNrLCByZXR1cm5pbmcgYSBuZXcgU3RhY2suXCIsXCJkZXNjcmlwdGlvblwiOlwiU2ltaWxhciB0byBgc3RhY2subWFwKC4uLikuZmxhdHRlbih0cnVlKWAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU3RhY2tcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjIwNzl9XX0sXCIjZmlsdGVyXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU2V0IHdpdGggb25seSB0aGUgdmFsdWVzIGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWBcXG5mdW5jdGlvbiByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYGZpbHRlcigpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCByZXN1bHRzIGluXFxubm90IGZpbHRlcmluZyBvdXQgYW55IHZhbHVlcy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiRlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiRlwifV19LFwibGluZVwiOjIwOTF9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxN319fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MjA5NX1dfSxcIiN6aXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIFN0YWNrIFxcXCJ6aXBwZWRcXFwiIHdpdGggdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb25zLlwiLFwiZGVzY3JpcHRpb25cIjpcIkxpa2UgYHppcFdpdGhgLCBidXQgdXNpbmcgdGhlIGRlZmF1bHQgYHppcHBlcmA6IGNyZWF0aW5nIGFuIGBBcnJheWAuXFxuXFxuYGBganNcXG5jb25zdCBhID0gU3RhY2soWyAxLCAyLCAzIF0pO1xcbmNvbnN0IGIgPSBTdGFjayhbIDQsIDUsIDYgXSk7XFxuY29uc3QgYyA9IGEuemlwKGIpOyAvLyBTdGFjayBbIFsgMSwgNCBdLCBbIDIsIDUgXSwgWyAzLCA2IF0gXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJVXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTdGFja1wiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfV19LFwibGluZVwiOjIxMTF9LHtcInR5cGVQYXJhbXNcIjpbXCJVXCIsXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fSx7XCJuYW1lXCI6XCJvdGhlcjJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlN0YWNrXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfSxcImxpbmVcIjoyMTEyfSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlN0YWNrXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcImxpbmVcIjoyMTEzfV19LFwiI3ppcEFsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgU3RhY2sgXFxcInppcHBlZFxcXCIgd2l0aCB0aGUgcHJvdmlkZWQgY29sbGVjdGlvbnMuXCIsXCJkZXNjcmlwdGlvblwiOlwiVW5saWtlIGB6aXBgLCBgemlwQWxsYCBjb250aW51ZXMgemlwcGluZyB1bnRpbCB0aGUgbG9uZ2VzdCBjb2xsZWN0aW9uIGlzXFxuZXhoYXVzdGVkLiBNaXNzaW5nIHZhbHVlcyBmcm9tIHNob3J0ZXIgY29sbGVjdGlvbnMgYXJlIGZpbGxlZCB3aXRoIGB1bmRlZmluZWRgLlxcblxcbmBgYGpzXFxuY29uc3QgYSA9IFN0YWNrKFsgMSwgMiBdKTtcXG5jb25zdCBiID0gU3RhY2soWyAzLCA0LCA1IF0pO1xcbmNvbnN0IGMgPSBhLnppcEFsbChiKTsgLy8gU3RhY2sgWyBbIDEsIDMgXSwgWyAyLCA0IF0sIFsgdW5kZWZpbmVkLCA1IF0gXVxcbmBgYFxcblxcbk5vdGU6IFNpbmNlIHppcEFsbCB3aWxsIHJldHVybiBhIGNvbGxlY3Rpb24gYXMgbGFyZ2UgYXMgdGhlIGxhcmdlc3RcXG5pbnB1dCwgc29tZSByZXN1bHRzIG1heSBjb250YWluIHVuZGVmaW5lZCB2YWx1ZXMuIFR5cGVTY3JpcHQgY2Fubm90XFxuYWNjb3VudCBmb3IgdGhlc2Ugd2l0aG91dCBjYXNlcyAoYXMgb2YgdjIuNSkuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlVcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib3RoZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlN0YWNrXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19XX0sXCJsaW5lXCI6MjEzMX0se1widHlwZVBhcmFtc1wiOltcIlVcIixcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib3RoZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19LHtcIm5hbWVcIjpcIm90aGVyMlwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU3RhY2tcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfV19LFwibGluZVwiOjIxMzJ9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU3RhY2tcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwibGluZVwiOjIxMzN9XX0sXCIjemlwV2l0aFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgU3RhY2sgXFxcInppcHBlZFxcXCIgd2l0aCB0aGUgcHJvdmlkZWQgY29sbGVjdGlvbnMgYnkgdXNpbmcgYVxcbmN1c3RvbSBgemlwcGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJgYGBqc1xcbmNvbnN0IGEgPSBTdGFjayhbIDEsIDIsIDMgXSk7XFxuY29uc3QgYiA9IFN0YWNrKFsgNCwgNSwgNiBdKTtcXG5jb25zdCBjID0gYS56aXBXaXRoKChhLCBiKSA9PiBhICsgYiwgYik7XFxuLy8gU3RhY2sgWyA1LCA3LCA5IF1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiWlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ6aXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIm90aGVyVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifX19LHtcIm5hbWVcIjpcIm90aGVyQ29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU3RhY2tcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifV19LFwibGluZVwiOjIxNDZ9LHtcInR5cGVQYXJhbXNcIjpbXCJVXCIsXCJWXCIsXCJaXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInppcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwib3RoZXJWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlVcIn19LHtcIm5hbWVcIjpcInRoaXJkVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifX19LHtcIm5hbWVcIjpcIm90aGVyQ29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX0se1wibmFtZVwiOlwidGhpcmRDb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTdGFja1wiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9XX0sXCJsaW5lXCI6MjE1MH0se1widHlwZVBhcmFtc1wiOltcIlpcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiemlwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiYW55XCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlpcIn19fSx7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU3RhY2tcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifV19LFwibGluZVwiOjIxNTV9XX19fV19fSxcIlJhbmdlXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgU2VxLkluZGV4ZWQgb2YgbnVtYmVycyBmcm9tIGBzdGFydGAgKGluY2x1c2l2ZSkgdG8gYGVuZGBcXG4oZXhjbHVzaXZlKSwgYnkgYHN0ZXBgLCB3aGVyZSBgc3RhcnRgIGRlZmF1bHRzIHRvIDAsIGBzdGVwYCB0byAxLCBhbmQgYGVuZGAgdG9cXG5pbmZpbml0eS4gV2hlbiBgc3RhcnRgIGlzIGVxdWFsIHRvIGBlbmRgLCByZXR1cm5zIGVtcHR5IHJhbmdlLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBSYW5nZWAgaXMgYSBmYWN0b3J5IGZ1bmN0aW9uIGFuZCBub3QgYSBjbGFzcywgYW5kIGRvZXMgbm90IHVzZSB0aGVcXG5gbmV3YCBrZXl3b3JkIGR1cmluZyBjb25zdHJ1Y3Rpb24uXFxuXFxuYGBganNcXG5jb25zdCB7IFJhbmdlIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcblJhbmdlKCkgLy8gWyAwLCAxLCAyLCAzLCAuLi4gXVxcblJhbmdlKDEwKSAvLyBbIDEwLCAxMSwgMTIsIDEzLCAuLi4gXVxcblJhbmdlKDEwLCAxNSkgLy8gWyAxMCwgMTEsIDEyLCAxMywgMTQgXVxcblJhbmdlKDEwLCAzMCwgNSkgLy8gWyAxMCwgMTUsIDIwLCAyNSBdXFxuUmFuZ2UoMzAsIDEwLCA1KSAvLyBbIDMwLCAyNSwgMjAsIDE1IF1cXG5SYW5nZSgzMCwgMzAsIDUpIC8vIFtdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInN0YXJ0XCIsXCJ0eXBlXCI6e1wia1wiOjJ9LFwib3B0aW9uYWxcIjp0cnVlfSx7XCJuYW1lXCI6XCJlbmRcIixcInR5cGVcIjp7XCJrXCI6Mn0sXCJvcHRpb25hbFwiOnRydWV9LHtcIm5hbWVcIjpcInN0ZXBcIixcInR5cGVcIjp7XCJrXCI6Mn0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoyfV19LFwibGluZVwiOjIxODB9XX19LFwiUmVwZWF0XCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgU2VxLkluZGV4ZWQgb2YgYHZhbHVlYCByZXBlYXRlZCBgdGltZXNgIHRpbWVzLiBXaGVuIGB0aW1lc2AgaXNcXG5ub3QgZGVmaW5lZCwgcmV0dXJucyBhbiBpbmZpbml0ZSBgU2VxYCBvZiBgdmFsdWVgLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IGBSZXBlYXRgIGlzIGEgZmFjdG9yeSBmdW5jdGlvbiBhbmQgbm90IGEgY2xhc3MsIGFuZCBkb2VzIG5vdCB1c2UgdGhlXFxuYG5ld2Aga2V5d29yZCBkdXJpbmcgY29uc3RydWN0aW9uLlxcblxcbmBgYGpzXFxuY29uc3QgeyBSZXBlYXQgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuUmVwZWF0KCdmb28nKSAvLyBbICdmb28nLCAnZm9vJywgJ2ZvbycsIC4uLiBdXFxuUmVwZWF0KCdiYXInLCA0KSAvLyBbICdiYXInLCAnYmFyJywgJ2JhcicsICdiYXInIF1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcInRpbWVzXCIsXCJ0eXBlXCI6e1wia1wiOjJ9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MjE5Nn1dfX0sXCJSZWNvcmRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQSByZWNvcmQgaXMgc2ltaWxhciB0byBhIEpTIG9iamVjdCwgYnV0IGVuZm9yY2VzIGEgc3BlY2lmaWMgc2V0IG9mIGFsbG93ZWRcXG5zdHJpbmcga2V5cywgYW5kIGhhcyBkZWZhdWx0IHZhbHVlcy5cIixcImRlc2NyaXB0aW9uXCI6XCJUaGUgYFJlY29yZCgpYCBmdW5jdGlvbiBwcm9kdWNlcyBuZXcgUmVjb3JkIEZhY3Rvcmllcywgd2hpY2ggd2hlbiBjYWxsZWRcXG5jcmVhdGUgUmVjb3JkIGluc3RhbmNlcy5cXG5cXG5gYGBqc1xcbmNvbnN0IHsgUmVjb3JkIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IEFCUmVjb3JkID0gUmVjb3JkKHsgYTogMSwgYjogMiB9KVxcbmNvbnN0IG15UmVjb3JkID0gQUJSZWNvcmQoeyBiOiAzIH0pXFxuYGBgXFxuXFxuUmVjb3JkcyBhbHdheXMgaGF2ZSBhIHZhbHVlIGZvciB0aGUga2V5cyB0aGV5IGRlZmluZS4gYHJlbW92ZWBpbmcgYSBrZXlcXG5mcm9tIGEgcmVjb3JkIHNpbXBseSByZXNldHMgaXQgdG8gdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoYXQga2V5LlxcblxcbmBgYGpzXFxubXlSZWNvcmQuc2l6ZSAvLyAyXFxubXlSZWNvcmQuZ2V0KCdhJykgLy8gMVxcbm15UmVjb3JkLmdldCgnYicpIC8vIDNcXG5jb25zdCBteVJlY29yZFdpdGhvdXRCID0gbXlSZWNvcmQucmVtb3ZlKCdiJylcXG5teVJlY29yZFdpdGhvdXRCLmdldCgnYicpIC8vIDJcXG5teVJlY29yZFdpdGhvdXRCLnNpemUgLy8gMlxcbmBgYFxcblxcblZhbHVlcyBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3Igbm90IGZvdW5kIGluIHRoZSBSZWNvcmQgdHlwZSB3aWxsXFxuYmUgaWdub3JlZC4gRm9yIGV4YW1wbGUsIGluIHRoaXMgY2FzZSwgQUJSZWNvcmQgaXMgcHJvdmlkZWQgYSBrZXkgXFxcInhcXFwiIGV2ZW5cXG50aG91Z2ggb25seSBcXFwiYVxcXCIgYW5kIFxcXCJiXFxcIiBoYXZlIGJlZW4gZGVmaW5lZC4gVGhlIHZhbHVlIGZvciBcXFwieFxcXCIgd2lsbCBiZVxcbmlnbm9yZWQgZm9yIHRoaXMgcmVjb3JkLlxcblxcbmBgYGpzXFxuY29uc3QgbXlSZWNvcmQgPSBBQlJlY29yZCh7IGI6IDMsIHg6IDEwIH0pXFxubXlSZWNvcmQuZ2V0KCd4JykgLy8gdW5kZWZpbmVkXFxuYGBgXFxuXFxuQmVjYXVzZSBSZWNvcmRzIGhhdmUgYSBrbm93biBzZXQgb2Ygc3RyaW5nIGtleXMsIHByb3BlcnR5IGdldCBhY2Nlc3Mgd29ya3NcXG5hcyBleHBlY3RlZCwgaG93ZXZlciBwcm9wZXJ0eSBzZXRzIHdpbGwgdGhyb3cgYW4gRXJyb3IuXFxuXFxuTm90ZTogSUU4IGRvZXMgbm90IHN1cHBvcnQgcHJvcGVydHkgYWNjZXNzLiBPbmx5IHVzZSBgZ2V0KClgIHdoZW5cXG5zdXBwb3J0aW5nIElFOC5cXG5cXG5gYGBqc1xcbm15UmVjb3JkLmIgLy8gM1xcbm15UmVjb3JkLmIgPSA1IC8vIHRocm93cyBFcnJvclxcbmBgYFxcblxcblJlY29yZCBUeXBlcyBjYW4gYmUgZXh0ZW5kZWQgYXMgd2VsbCwgYWxsb3dpbmcgZm9yIGN1c3RvbSBtZXRob2RzIG9uIHlvdXJcXG5SZWNvcmQuIFRoaXMgaXMgbm90IGEgY29tbW9uIHBhdHRlcm4gaW4gZnVuY3Rpb25hbCBlbnZpcm9ubWVudHMsIGJ1dCBpcyBpblxcbm1hbnkgSlMgcHJvZ3JhbXMuXFxuXFxuSG93ZXZlciBSZWNvcmQgVHlwZXMgYXJlIG1vcmUgcmVzdHJpY3RlZCB0aGFuIHR5cGljYWwgSmF2YVNjcmlwdCBjbGFzc2VzLlxcblRoZXkgZG8gbm90IHVzZSBhIGNsYXNzIGNvbnN0cnVjdG9yLCB3aGljaCBhbHNvIG1lYW5zIHRoZXkgY2Fubm90IHVzZVxcbmNsYXNzIHByb3BlcnRpZXMgKHNpbmNlIHRob3NlIGFyZSB0ZWNobmljYWxseSBwYXJ0IG9mIGEgY29uc3RydWN0b3IpLlxcblxcbldoaWxlIFJlY29yZCBUeXBlcyBjYW4gYmUgc3ludGFjdGljYWxseSBjcmVhdGVkIHdpdGggdGhlIEphdmFTY3JpcHQgYGNsYXNzYFxcbmZvcm0sIHRoZSByZXN1bHRpbmcgUmVjb3JkIGZ1bmN0aW9uIGlzIGFjdHVhbGx5IGEgZmFjdG9yeSBmdW5jdGlvbiwgbm90IGFcXG5jbGFzcyBjb25zdHJ1Y3Rvci4gRXZlbiB0aG91Z2ggUmVjb3JkIFR5cGVzIGFyZSBub3QgY2xhc3NlcywgSmF2YVNjcmlwdFxcbmN1cnJlbnRseSByZXF1aXJlcyB0aGUgdXNlIG9mIGBuZXdgIHdoZW4gY3JlYXRpbmcgbmV3IFJlY29yZCBpbnN0YW5jZXMgaWZcXG50aGV5IGFyZSBkZWZpbmVkIGFzIGEgYGNsYXNzYC5cXG5cXG5gYGBcXG5jbGFzcyBBQlJlY29yZCBleHRlbmRzIFJlY29yZCh7IGE6IDEsIGI6IDIgfSkge1xcbiAgZ2V0QUIoKSB7XFxuICAgIHJldHVybiB0aGlzLmEgKyB0aGlzLmI7XFxuICB9XFxufVxcblxcbnZhciBteVJlY29yZCA9IG5ldyBBQlJlY29yZCh7YjogM30pXFxubXlSZWNvcmQuZ2V0QUIoKSAvLyA0XFxuYGBgXFxuXFxuXFxuKipGbG93IFR5cGluZyBSZWNvcmRzOioqXFxuXFxuSW1tdXRhYmxlLmpzIGV4cG9ydHMgdHdvIEZsb3cgdHlwZXMgZGVzaWduZWQgdG8gbWFrZSBpdCBlYXNpZXIgdG8gdXNlXFxuUmVjb3JkcyB3aXRoIGZsb3cgdHlwZWQgY29kZSwgYFJlY29yZE9mPFRQcm9wcz5gIGFuZCBgUmVjb3JkRmFjdG9yeTxUUHJvcHM+YC5cXG5cXG5XaGVuIGRlZmluaW5nIGEgbmV3IGtpbmQgb2YgUmVjb3JkIGZhY3RvcnkgZnVuY3Rpb24sIHVzZSBhIGZsb3cgdHlwZSB0aGF0XFxuZGVzY3JpYmVzIHRoZSB2YWx1ZXMgdGhlIHJlY29yZCBjb250YWlucyBhbG9uZyB3aXRoIGBSZWNvcmRGYWN0b3J5PFRQcm9wcz5gLlxcblRvIHR5cGUgaW5zdGFuY2VzIG9mIHRoZSBSZWNvcmQgKHdoaWNoIHRoZSBmYWN0b3J5IGZ1bmN0aW9uIHJldHVybnMpLFxcbnVzZSBgUmVjb3JkT2Y8VFByb3BzPmAuXFxuXFxuVHlwaWNhbGx5LCBuZXcgUmVjb3JkIGRlZmluaXRpb25zIHdpbGwgZXhwb3J0IGJvdGggdGhlIFJlY29yZCBmYWN0b3J5XFxuZnVuY3Rpb24gYXMgd2VsbCBhcyB0aGUgUmVjb3JkIGluc3RhbmNlIHR5cGUgZm9yIHVzZSBpbiBvdGhlciBjb2RlLlxcblxcbmBgYGpzXFxuaW1wb3J0IHR5cGUgeyBSZWNvcmRGYWN0b3J5LCBSZWNvcmRPZiB9IGZyb20gJ2ltbXV0YWJsZSc7XFxuXFxuLy8gVXNlIFJlY29yZEZhY3Rvcnk8VFByb3BzPiBmb3IgZGVmaW5pbmcgbmV3IFJlY29yZCBmYWN0b3J5IGZ1bmN0aW9ucy5cXG50eXBlIFBvaW50M0RQcm9wcyA9IHsgeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlciB9O1xcbmNvbnN0IGRlZmF1bHRWYWx1ZXM6IFBvaW50M0RQcm9wcyA9IHsgeDogMCwgeTogMCwgejogMCB9O1xcbmNvbnN0IG1ha2VQb2ludDNEOiBSZWNvcmRGYWN0b3J5PFBvaW50M0RQcm9wcz4gPSBSZWNvcmQoZGVmYXVsdFZhbHVlcyk7XFxuZXhwb3J0IG1ha2VQb2ludDNEO1xcblxcbi8vIFVzZSBSZWNvcmRPZjxUPiBmb3IgZGVmaW5pbmcgbmV3IGluc3RhbmNlcyBvZiB0aGF0IFJlY29yZC5cXG5leHBvcnQgdHlwZSBQb2ludDNEID0gUmVjb3JkT2Y8UG9pbnQzRFByb3BzPjtcXG5jb25zdCBzb21lM0RQb2ludDogUG9pbnQzRCA9IG1ha2VQb2ludDNEKHsgeDogMTAsIHk6IDIwLCB6OiAzMCB9KTtcXG5gYGBcXG5cXG4qKkZsb3cgVHlwaW5nIFJlY29yZCBTdWJjbGFzc2VzOioqXFxuXFxuUmVjb3JkcyBjYW4gYmUgc3ViY2xhc3NlZCBhcyBhIG1lYW5zIHRvIGFkZCBhZGRpdGlvbmFsIG1ldGhvZHMgdG8gUmVjb3JkXFxuaW5zdGFuY2VzLiBUaGlzIGlzIGdlbmVyYWxseSBkaXNjb3VyYWdlZCBpbiBmYXZvciBvZiBhIG1vcmUgZnVuY3Rpb25hbCBBUEksXFxuc2luY2UgU3ViY2xhc3NlcyBoYXZlIHNvbWUgbWlub3Igb3ZlcmhlYWQuIEhvd2V2ZXIgdGhlIGFiaWxpdHkgdG8gY3JlYXRlXFxuYSByaWNoIEFQSSBvbiBSZWNvcmQgdHlwZXMgY2FuIGJlIHF1aXRlIHZhbHVhYmxlLlxcblxcbldoZW4gdXNpbmcgRmxvdyB0byB0eXBlIFN1YmNsYXNzZXMsIGRvIG5vdCB1c2UgYFJlY29yZEZhY3Rvcnk8VFByb3BzPmAsXFxuaW5zdGVhZCBhcHBseSB0aGUgcHJvcHMgdHlwZSB3aGVuIHN1YmNsYXNzaW5nOlxcblxcbmBgYGpzXFxudHlwZSBQZXJzb25Qcm9wcyA9IHtuYW1lOiBzdHJpbmcsIGFnZTogbnVtYmVyfTtcXG5jb25zdCBkZWZhdWx0VmFsdWVzOiBQZXJzb25Qcm9wcyA9IHtuYW1lOiAnQXJpc3RvdGxlJywgYWdlOiAyNDAwfTtcXG5jb25zdCBQZXJzb25SZWNvcmQgPSBSZWNvcmQoZGVmYXVsdFZhbHVlcyk7XFxuY2xhc3MgUGVyc29uIGV4dGVuZHMgUGVyc29uUmVjb3JkPFBlcnNvblByb3BzPiB7XFxuICBnZXROYW1lKCk6IHN0cmluZyB7XFxuICAgIHJldHVybiB0aGlzLmdldCgnbmFtZScpXFxuICB9XFxuXFxuICBzZXROYW1lKG5hbWU6IHN0cmluZyk6IHRoaXMge1xcbiAgICByZXR1cm4gdGhpcy5zZXQoJ25hbWUnLCBuYW1lKTtcXG4gIH1cXG59XFxuYGBgXFxuXFxuKipDaG9vc2luZyBSZWNvcmRzIHZzIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cyoqXFxuXFxuUmVjb3JkcyBvZmZlciBhIHBlcnNpc3RlbnRseSBpbW11dGFibGUgYWx0ZXJuYXRpdmUgdG8gcGxhaW4gSmF2YVNjcmlwdFxcbm9iamVjdHMsIGhvd2V2ZXIgdGhleSdyZSBub3QgcmVxdWlyZWQgdG8gYmUgdXNlZCB3aXRoaW4gSW1tdXRhYmxlLmpzXFxuY29sbGVjdGlvbnMuIEluIGZhY3QsIHRoZSBkZWVwLWFjY2VzcyBhbmQgZGVlcC11cGRhdGluZyBmdW5jdGlvbnNcXG5saWtlIGBnZXRJbigpYCBhbmQgYHNldEluKClgIHdvcmsgd2l0aCBwbGFpbiBKYXZhU2NyaXB0IE9iamVjdHMgYXMgd2VsbC5cXG5cXG5EZWNpZGluZyB0byB1c2UgUmVjb3JkcyBvciBPYmplY3RzIGluIHlvdXIgYXBwbGljYXRpb24gc2hvdWxkIGJlIGluZm9ybWVkXFxuYnkgdGhlIHRyYWRlb2ZmcyBhbmQgcmVsYXRpdmUgYmVuZWZpdHMgb2YgZWFjaDpcXG5cXG4tICpSdW50aW1lIGltbXV0YWJpbGl0eSo6IHBsYWluIEpTIG9iamVjdHMgbWF5IGJlIGNhcmVmdWxseSB0cmVhdGVkIGFzXFxuICBpbW11dGFibGUsIGhvd2V2ZXIgUmVjb3JkIGluc3RhbmNlcyB3aWxsICp0aHJvdyogaWYgYXR0ZW1wdGVkIHRvIGJlXFxuICBtdXRhdGVkIGRpcmVjdGx5LiBSZWNvcmRzIHByb3ZpZGUgdGhpcyBhZGRpdGlvbmFsIGd1YXJhbnRlZSwgaG93ZXZlciBhdFxcbiAgc29tZSBtYXJnaW5hbCBydW50aW1lIGNvc3QuIFdoaWxlIEpTIG9iamVjdHMgYXJlIG11dGFibGUgYnkgbmF0dXJlLCB0aGVcXG4gIHVzZSBvZiB0eXBlLWNoZWNraW5nIHRvb2xzIGxpa2UgW0Zsb3ddKGh0dHBzOi8vbWVkaXVtLmNvbS9AZ2NhbnRpL2ltbXV0YWJpbGl0eS13aXRoLWZsb3ctZmFhMDUwYTFhZWY0KVxcbiAgY2FuIGhlbHAgZ2FpbiBjb25maWRlbmNlIGluIGNvZGUgd3JpdHRlbiB0byBmYXZvciBpbW11dGFiaWxpdHkuXFxuXFxuLSAqVmFsdWUgZXF1YWxpdHkqOiBSZWNvcmRzIHVzZSB2YWx1ZSBlcXVhbGl0eSB3aGVuIGNvbXBhcmVkIHdpdGggYGlzKClgXFxuICBvciBgcmVjb3JkLmVxdWFscygpYC4gVGhhdCBpcywgdHdvIFJlY29yZHMgd2l0aCB0aGUgc2FtZSBrZXlzIGFuZCB2YWx1ZXNcXG4gIGFyZSBlcXVhbC4gUGxhaW4gb2JqZWN0cyB1c2UgKnJlZmVyZW5jZSBlcXVhbGl0eSouIFR3byBvYmplY3RzIHdpdGggdGhlXFxuICBzYW1lIGtleXMgYW5kIHZhbHVlcyBhcmUgbm90IGVxdWFsIHNpbmNlIHRoZXkgYXJlIGRpZmZlcmVudCBvYmplY3RzLlxcbiAgVGhpcyBpcyBpbXBvcnRhbnQgdG8gY29uc2lkZXIgd2hlbiB1c2luZyBvYmplY3RzIGFzIGtleXMgaW4gYSBgTWFwYCBvclxcbiAgdmFsdWVzIGluIGEgYFNldGAsIHdoaWNoIHVzZSBlcXVhbGl0eSB3aGVuIHJldHJpZXZpbmcgdmFsdWVzLlxcblxcbi0gKkFQSSBtZXRob2RzKjogUmVjb3JkcyBoYXZlIGEgZnVsbCBmZWF0dXJlZCBBUEksIHdpdGggbWV0aG9kcyBsaWtlXFxuICBgLmdldEluKClgLCBhbmQgYC5lcXVhbHMoKWAuIFRoZXNlIGNhbiBtYWtlIHdvcmtpbmcgd2l0aCB0aGVzZSB2YWx1ZXNcXG4gIGVhc2llciwgYnV0IGNvbWVzIGF0IHRoZSBjb3N0IG9mIG5vdCBhbGxvd2luZyBrZXlzIHdpdGggdGhvc2UgbmFtZXMuXFxuXFxuLSAqRGVmYXVsdCB2YWx1ZXMqOiBSZWNvcmRzIHByb3ZpZGUgZGVmYXVsdCB2YWx1ZXMgZm9yIGV2ZXJ5IGtleSwgd2hpY2hcXG4gIGNhbiBiZSB1c2VmdWwgd2hlbiBjb25zdHJ1Y3RpbmcgUmVjb3JkcyB3aXRoIG9mdGVuIHVuY2hhbmdpbmcgdmFsdWVzLlxcbiAgSG93ZXZlciBkZWZhdWx0IHZhbHVlcyBjYW4gbWFrZSB1c2luZyBGbG93IGFuZCBUeXBlU2NyaXB0IG1vcmUgbGFib3Jpb3VzLlxcblxcbi0gKlNlcmlhbGl6YXRpb24qOiBSZWNvcmRzIHVzZSBhIGN1c3RvbSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiB0b1xcbiAgZWZmaWNpZW50bHkgc3RvcmUgYW5kIHVwZGF0ZSB0aGVpciB2YWx1ZXMuIENvbnZlcnRpbmcgdG8gYW5kIGZyb20gdGhpc1xcbiAgZm9ybSBpc24ndCBmcmVlLiBJZiBjb252ZXJ0aW5nIFJlY29yZHMgdG8gcGxhaW4gb2JqZWN0cyBpcyBjb21tb24sXFxuICBjb25zaWRlciBzdGlja2luZyB3aXRoIHBsYWluIG9iamVjdHMgdG8gYmVnaW4gd2l0aC5cIixcIm5vdGVzXCI6W119LFwibW9kdWxlXCI6e1wiaXNSZWNvcmRcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgYG1heWJlUmVjb3JkYCBpcyBhbiBpbnN0YW5jZSBvZiBhIFJlY29yZC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVSZWNvcmRcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjIzNjV9XX19LFwiZ2V0RGVzY3JpcHRpdmVOYW1lXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZWNvcmRzIGFsbG93IHBhc3NpbmcgYSBzZWNvbmQgcGFyYW1ldGVyIHRvIHN1cHBseSBhIGRlc2NyaXB0aXZlIG5hbWVcXG50aGF0IGFwcGVhcnMgd2hlbiBjb252ZXJ0aW5nIGEgUmVjb3JkIHRvIGEgc3RyaW5nIG9yIGluIGFueSBlcnJvclxcbm1lc3NhZ2VzLiBBIGRlc2NyaXB0aXZlIG5hbWUgZm9yIGFueSByZWNvcmQgY2FuIGJlIGFjY2Vzc2VkIGJ5IHVzaW5nIHRoaXNcXG5tZXRob2QuIElmIG9uZSB3YXMgbm90IHByb3ZpZGVkLCB0aGUgc3RyaW5nIFxcXCJSZWNvcmRcXFwiIGlzIHJldHVybmVkLlwiLFwiZGVzY3JpcHRpb25cIjpcImBgYGpzXFxuY29uc3QgeyBSZWNvcmQgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3QgUGVyc29uID0gUmVjb3JkKHtcXG4gIG5hbWU6IG51bGxcXG59LCAnUGVyc29uJylcXG5cXG52YXIgbWUgPSBQZXJzb24oeyBuYW1lOiAnTXkgTmFtZScgfSlcXG5tZS50b1N0cmluZygpIC8vIFxcXCJQZXJzb24geyBcXFwibmFtZVxcXCI6IFxcXCJNeSBOYW1lXFxcIiB9XFxcIlxcblJlY29yZC5nZXREZXNjcmlwdGl2ZU5hbWUobWUpIC8vIFxcXCJQZXJzb25cXFwiXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInJlY29yZFwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiUmVjb3JkXCIsXCJhcmdzXCI6W3tcImtcIjo0LFwibWVtYmVyc1wiOltdfV19fV0sXCJ0eXBlXCI6e1wia1wiOjN9LFwibGluZVwiOjIzODR9XX19LFwiRmFjdG9yeVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJBIFJlY29yZC5GYWN0b3J5IGlzIGNyZWF0ZWQgYnkgdGhlIGBSZWNvcmQoKWAgZnVuY3Rpb24uIFJlY29yZCBpbnN0YW5jZXNcXG5hcmUgY3JlYXRlZCBieSBwYXNzaW5nIGl0IHNvbWUgb2YgdGhlIGFjY2VwdGVkIHZhbHVlcyBmb3IgdGhhdCBSZWNvcmRcXG50eXBlOlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IFJlY29yZCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbi8vIG1ha2VQZXJzb24gaXMgYSBSZWNvcmQgRmFjdG9yeSBmdW5jdGlvblxcbmNvbnN0IG1ha2VQZXJzb24gPSBSZWNvcmQoeyBuYW1lOiBudWxsLCBmYXZvcml0ZUNvbG9yOiAndW5rbm93bicgfSk7XFxuXFxuLy8gYWxhbiBpcyBhIFJlY29yZCBpbnN0YW5jZVxcbmNvbnN0IGFsYW4gPSBtYWtlUGVyc29uKHsgbmFtZTogJ0FsYW4nIH0pO1xcbmBgYFxcblxcbk5vdGUgdGhhdCBSZWNvcmQgRmFjdG9yaWVzIHJldHVybiBgUmVjb3JkPFRQcm9wcz4gJiBSZWFkb25seTxUUHJvcHM+YCxcXG50aGlzIGFsbG93cyB1c2Ugb2YgYm90aCB0aGUgUmVjb3JkIGluc3RhbmNlIEFQSSwgYW5kIGRpcmVjdCBwcm9wZXJ0eVxcbmFjY2VzcyBvbiB0aGUgcmVzdWx0aW5nIGluc3RhbmNlczpcXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBSZWNvcmQgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO2NvbnN0IG1ha2VQZXJzb24gPSBSZWNvcmQoeyBuYW1lOiBudWxsLCBmYXZvcml0ZUNvbG9yOiAndW5rbm93bicgfSk7Y29uc3QgYWxhbiA9IG1ha2VQZXJzb24oeyBuYW1lOiAnQWxhbicgfSk7XFxcIiB9XFxuLS0+XFxuYGBganNcXG4vLyBVc2UgdGhlIFJlY29yZCBBUElcXG5jb25zb2xlLmxvZygnUmVjb3JkIEFQSTogJyArIGFsYW4uZ2V0KCduYW1lJykpXFxuXFxuLy8gT3IgZGlyZWN0IHByb3BlcnR5IGFjY2VzcyAoUmVhZG9ubHkpXFxuY29uc29sZS5sb2coJ3Byb3BlcnR5IGFjY2VzczogJyArIGFsYW4ubmFtZSlcXG5gYGBcXG5cXG4qKkZsb3cgVHlwaW5nIFJlY29yZHM6KipcXG5cXG5Vc2UgdGhlIGBSZWNvcmRGYWN0b3J5PFRQcm9wcz5gIEZsb3cgdHlwZSB0byBnZXQgaGlnaCBxdWFsaXR5IHR5cGUgY2hlY2tpbmcgb2ZcXG5SZWNvcmRzOlxcblxcbmBgYGpzXFxuaW1wb3J0IHR5cGUgeyBSZWNvcmRGYWN0b3J5LCBSZWNvcmRPZiB9IGZyb20gJ2ltbXV0YWJsZSc7XFxuXFxuLy8gVXNlIFJlY29yZEZhY3Rvcnk8VFByb3BzPiBmb3IgZGVmaW5pbmcgbmV3IFJlY29yZCBmYWN0b3J5IGZ1bmN0aW9ucy5cXG50eXBlIFBlcnNvblByb3BzID0geyBuYW1lOiA/c3RyaW5nLCBmYXZvcml0ZUNvbG9yOiBzdHJpbmcgfTtcXG5jb25zdCBtYWtlUGVyc29uOiBSZWNvcmRGYWN0b3J5PFBlcnNvblByb3BzPiA9IFJlY29yZCh7IG5hbWU6IG51bGwsIGZhdm9yaXRlQ29sb3I6ICd1bmtub3duJyB9KTtcXG5cXG4vLyBVc2UgUmVjb3JkT2Y8VD4gZm9yIGRlZmluaW5nIG5ldyBpbnN0YW5jZXMgb2YgdGhhdCBSZWNvcmQuXFxudHlwZSBQZXJzb24gPSBSZWNvcmRPZjxQZXJzb25Qcm9wcz47XFxuY29uc3QgYWxhbjogUGVyc29uID0gbWFrZVBlcnNvbih7IG5hbWU6ICdBbGFuJyB9KTtcXG5gYGBcIixcIm5vdGVzXCI6W119LFwibW9kdWxlXCI6e30sXCJpbnRlcmZhY2VcIjp7XCJsaW5lXCI6MjQzNixcInR5cGVQYXJhbXNcIjpbXCJUUHJvcHNcIl0sXCJncm91cHNcIjpbe1wibWVtYmVyc1wiOntcIiNkaXNwbGF5TmFtZVwiOntcImxpbmVcIjoyNDQ0fX19XX0sXCJjYWxsXCI6e1wic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVFByb3BzXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlc1wiLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiUGFydGlhbFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn1dfSx7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjozfSx7XCJrXCI6MTd9XX1dfV19LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEzLFwidHlwZXNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJSZWNvcmRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9XX0se1wia1wiOjksXCJuYW1lXCI6XCJSZWFkb25seVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn1dfV19LFwibGluZVwiOjI0NDd9XX19fSxcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVW5saWtlIG90aGVyIHR5cGVzIGluIEltbXV0YWJsZS5qcywgdGhlIGBSZWNvcmQoKWAgZnVuY3Rpb24gY3JlYXRlcyBhIG5ld1xcblJlY29yZCBGYWN0b3J5LCB3aGljaCBpcyBhIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBSZWNvcmQgaW5zdGFuY2VzLlwiLFwiZGVzY3JpcHRpb25cIjpcIlNlZSBhYm92ZSBmb3IgZXhhbXBsZXMgb2YgdXNpbmcgYFJlY29yZCgpYC5cXG5cXG5Ob3RlOiBgUmVjb3JkYCBpcyBhIGZhY3RvcnkgZnVuY3Rpb24gYW5kIG5vdCBhIGNsYXNzLCBhbmQgZG9lcyBub3QgdXNlIHRoZVxcbmBuZXdgIGtleXdvcmQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVFByb3BzXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImRlZmF1bHRWYWx1ZXNcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn19LHtcIm5hbWVcIjpcIm5hbWVcIixcInR5cGVcIjp7XCJrXCI6M30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlJlY29yZC5GYWN0b3J5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRQcm9wc1wifV19LFwibGluZVwiOjI0NTl9XX0sXCJpbnRlcmZhY2VcIjp7XCJsaW5lXCI6MjQ2MSxcInR5cGVQYXJhbXNcIjpbXCJUUHJvcHNcIl0sXCJncm91cHNcIjpbe1widGl0bGVcIjpcIlJlYWRpbmcgdmFsdWVzXCIsXCJtZW1iZXJzXCI6e1wiI2hhc1wiOntcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjoyNDY1fV19LFwiI2dldFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3ZpZGVkIGtleSwgd2hpY2ggbWF5IGJlIHRoZVxcbmRlZmF1bHQgdmFsdWUgZGVmaW5lZCB3aGVuIGNyZWF0aW5nIHRoZSBSZWNvcmQgZmFjdG9yeSBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJJZiB0aGUgcmVxdWVzdGVkIGtleSBpcyBub3QgZGVmaW5lZCBieSB0aGlzIFJlY29yZCB0eXBlLCB0aGVuXFxubm90U2V0VmFsdWUgd2lsbCBiZSByZXR1cm5lZCBpZiBwcm92aWRlZC4gTm90ZSB0aGF0IHRoaXMgc2NlbmFyaW8gd291bGRcXG5wcm9kdWNlIGFuIGVycm9yIHdoZW4gdXNpbmcgRmxvdyBvciBUeXBlU2NyaXB0LlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJLXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIm5vdFNldFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxNSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn0sXCJpbmRleFwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LFwibGluZVwiOjI0NzV9LHtcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSxcImxpbmVcIjoyNDc2fV19fX0se1widGl0bGVcIjpcIlJlYWRpbmcgZGVlcCB2YWx1ZXNcIixcIm1lbWJlcnNcIjp7XCIjaGFzSW5cIjp7XCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlQYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX19XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6MjQ4MH1dfSxcIiNnZXRJblwiOntcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX1dLFwidHlwZVwiOntcImtcIjoxN30sXCJsaW5lXCI6MjQ4MX1dfX19LHtcInRpdGxlXCI6XCJWYWx1ZSBlcXVhbGl0eVwiLFwibWVtYmVyc1wiOntcIiNlcXVhbHNcIjp7XCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlclwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6MjQ4NX1dfSxcIiNoYXNoQ29kZVwiOntcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoyfSxcImxpbmVcIjoyNDg2fV19fX0se1widGl0bGVcIjpcIlBlcnNpc3RlbnQgY2hhbmdlc1wiLFwibWVtYmVyc1wiOntcIiNzZXRcIjp7XCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJLXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE1LFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRQcm9wc1wifSxcImluZGV4XCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjI0OTB9XX0sXCIjdXBkYXRlXCI6e1wic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJ1cGRhdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTUsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9LFwiaW5kZXhcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fX1dLFwidHlwZVwiOntcImtcIjoxNSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn0sXCJpbmRleFwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19fX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MjQ5MX1dfSxcIiNtZXJnZVwiOntcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIlBhcnRpYWxcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9XX0se1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6M30se1wia1wiOjE3fV19XX1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjI0OTJ9XX0sXCIjbWVyZ2VEZWVwXCI6e1wic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiUGFydGlhbFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn1dfSx7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjozfSx7XCJrXCI6MTd9XX1dfV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MjQ5M31dfSxcIiNtZXJnZVdpdGhcIjp7XCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtZXJnZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvbGRWYWxcIixcInR5cGVcIjp7XCJrXCI6MTd9fSx7XCJuYW1lXCI6XCJuZXdWYWxcIixcInR5cGVcIjp7XCJrXCI6MTd9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTYsXCJvcGVyYXRvclwiOlwia2V5b2ZcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19LHtcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIlBhcnRpYWxcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9XX0se1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6M30se1wia1wiOjE3fV19XX1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjI0OTV9XX0sXCIjbWVyZ2VEZWVwV2l0aFwiOntcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1lcmdlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm9sZFZhbFwiLFwidHlwZVwiOntcImtcIjoxN319LHtcIm5hbWVcIjpcIm5ld1ZhbFwiLFwidHlwZVwiOntcImtcIjoxN319LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MTd9fX0se1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiUGFydGlhbFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn1dfSx7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjozfSx7XCJrXCI6MTd9XX1dfV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MjQ5OX1dfSxcIiNkZWxldGVcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiB0aGlzIFJlY29yZCB0eXBlIHdpdGggdGhlIHZhbHVlIGZvciB0aGVcXG5zcGVjaWZpYyBrZXkgc2V0IHRvIGl0cyBkZWZhdWx0IHZhbHVlLlxcblwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwiYWxpYXNcIixcImJvZHlcIjpcInJlbW92ZVwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoyNTEwfV19LFwiI2NsZWFyXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhpcyBSZWNvcmQgdHlwZSB3aXRoIGFsbCB2YWx1ZXMgc2V0XFxudG8gdGhlaXIgZGVmYXVsdCB2YWx1ZXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MjUxN31dfX19LHtcInRpdGxlXCI6XCJEZWVwIHBlcnNpc3RlbnQgY2hhbmdlc1wiLFwibWVtYmVyc1wiOntcIiNzZXRJblwiOntcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoyNTIxfV19LFwiI3VwZGF0ZUluXCI6e1wic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5UGF0aFwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19fSx7XCJuYW1lXCI6XCJ1cGRhdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjI1MjJ9XX0sXCIjbWVyZ2VJblwiOntcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoyNTIzfV19LFwiI21lcmdlRGVlcEluXCI6e1wic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5UGF0aFwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19fSx7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjI1MjR9XX0sXCIjZGVsZXRlSW5cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJhbGlhc1wiLFwiYm9keVwiOlwicmVtb3ZlSW5cIn1dfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MjUyOX1dfX19LHtcInRpdGxlXCI6XCJDb252ZXJzaW9uIHRvIEphdmFTY3JpcHQgdHlwZXNcIixcIm1lbWJlcnNcIjp7XCIjdG9KU1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJEZWVwbHkgY29udmVydHMgdGhpcyBSZWNvcmQgdG8gZXF1aXZhbGVudCBuYXRpdmUgSmF2YVNjcmlwdCBPYmplY3QuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogVGhpcyBtZXRob2QgbWF5IG5vdCBiZSBvdmVycmlkZGVuLiBPYmplY3RzIHdpdGggY3VzdG9tXFxuc2VyaWFsaXphdGlvbiB0byBwbGFpbiBKUyBtYXkgb3ZlcnJpZGUgdG9KU09OKCkgaW5zdGVhZC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6MTd9fV19LFwibGluZVwiOjI1NDB9XX0sXCIjdG9KU09OXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIFJlY29yZCB0byBlcXVpdmFsZW50IG5hdGl2ZSBKYXZhU2NyaXB0IE9iamVjdC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9LFwibGluZVwiOjI1NDV9XX0sXCIjdG9PYmplY3RcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiU2hhbGxvd2x5IGNvbnZlcnRzIHRoaXMgUmVjb3JkIHRvIGVxdWl2YWxlbnQgSmF2YVNjcmlwdCBPYmplY3QuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRQcm9wc1wifSxcImxpbmVcIjoyNTUwfV19fX0se1widGl0bGVcIjpcIlRyYW5zaWVudCBjaGFuZ2VzXCIsXCJtZW1iZXJzXCI6e1wiI3dpdGhNdXRhdGlvbnNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiTm90ZTogTm90IGFsbCBtZXRob2RzIGNhbiBiZSB1c2VkIG9uIGEgbXV0YWJsZSBjb2xsZWN0aW9uIG9yIHdpdGhpblxcbmB3aXRoTXV0YXRpb25zYCEgT25seSBgc2V0YCBtYXkgYmUgdXNlZCBtdXRhdGl2ZWx5LlxcblwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI3dpdGhNdXRhdGlvbnNgXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtdXRhdG9yXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibXV0YWJsZVwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MTd9fX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MjU2MH1dfSxcIiNhc011dGFibGVcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcImBNYXAjYXNNdXRhYmxlYFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoyNTY1fV19LFwiI3dhc0FsdGVyZWRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcImBNYXAjd2FzQWx0ZXJlZGBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjoyNTcwfV19LFwiI2FzSW1tdXRhYmxlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgTWFwI2FzSW1tdXRhYmxlYFwifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoyNTc1fV19fX0se1widGl0bGVcIjpcIlNlcXVlbmNlIGFsZ29yaXRobXNcIixcIm1lbWJlcnNcIjp7XCIjdG9TZXFcIjp7XCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTYsXCJvcGVyYXRvclwiOlwia2V5b2ZcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn19LHtcImtcIjoxNSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn0sXCJpbmRleFwiOntcImtcIjoxNixcIm9wZXJhdG9yXCI6XCJrZXlvZlwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRQcm9wc1wifX19XX0sXCJsaW5lXCI6MjU3OX1dfSxcIiNbU3ltYm9sLml0ZXJhdG9yXVwiOntcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVJdGVyYXRvclwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6MTYsXCJvcGVyYXRvclwiOlwia2V5b2ZcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn19LHtcImtcIjoxNSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn0sXCJpbmRleFwiOntcImtcIjoxNixcIm9wZXJhdG9yXCI6XCJrZXlvZlwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRQcm9wc1wifX19XX1dfSxcImxpbmVcIjoyNTgxfV19fX1dfX0sXCJTZXFcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiYFNlcWAgZGVzY3JpYmVzIGEgbGF6eSBvcGVyYXRpb24sIGFsbG93aW5nIHRoZW0gdG8gZWZmaWNpZW50bHkgY2hhaW5cXG51c2Ugb2YgYWxsIHRoZSBoaWdoZXItb3JkZXIgY29sbGVjdGlvbiBtZXRob2RzIChzdWNoIGFzIGBtYXBgIGFuZCBgZmlsdGVyYClcXG5ieSBub3QgY3JlYXRpbmcgaW50ZXJtZWRpYXRlIGNvbGxlY3Rpb25zLlwiLFwiZGVzY3JpcHRpb25cIjpcIioqU2VxIGlzIGltbXV0YWJsZSoqIOKAlCBPbmNlIGEgU2VxIGlzIGNyZWF0ZWQsIGl0IGNhbm5vdCBiZVxcbmNoYW5nZWQsIGFwcGVuZGVkIHRvLCByZWFycmFuZ2VkIG9yIG90aGVyd2lzZSBtb2RpZmllZC4gSW5zdGVhZCwgYW55XFxubXV0YXRpdmUgbWV0aG9kIGNhbGxlZCBvbiBhIGBTZXFgIHdpbGwgcmV0dXJuIGEgbmV3IGBTZXFgLlxcblxcbioqU2VxIGlzIGxhenkqKiDigJQgYFNlcWAgZG9lcyBhcyBsaXR0bGUgd29yayBhcyBuZWNlc3NhcnkgdG8gcmVzcG9uZCB0byBhbnlcXG5tZXRob2QgY2FsbC4gVmFsdWVzIGFyZSBvZnRlbiBjcmVhdGVkIGR1cmluZyBpdGVyYXRpb24sIGluY2x1ZGluZyBpbXBsaWNpdFxcbml0ZXJhdGlvbiB3aGVuIHJlZHVjaW5nIG9yIGNvbnZlcnRpbmcgdG8gYSBjb25jcmV0ZSBkYXRhIHN0cnVjdHVyZSBzdWNoIGFzXFxuYSBgTGlzdGAgb3IgSmF2YVNjcmlwdCBgQXJyYXlgLlxcblxcbkZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nIHBlcmZvcm1zIG5vIHdvcmssIGJlY2F1c2UgdGhlIHJlc3VsdGluZ1xcbmBTZXFgJ3MgdmFsdWVzIGFyZSBuZXZlciBpdGVyYXRlZDpcXG5cXG5gYGBqc1xcbmNvbnN0IHsgU2VxIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG9kZFNxdWFyZXMgPSBTZXEoWyAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4IF0pXFxuICAuZmlsdGVyKHggPT4geCAlIDIgIT09IDApXFxuICAubWFwKHggPT4geCAqIHgpXFxuYGBgXFxuXFxuT25jZSB0aGUgYFNlcWAgaXMgdXNlZCwgaXQgcGVyZm9ybXMgb25seSB0aGUgd29yayBuZWNlc3NhcnkuIEluIHRoaXNcXG5leGFtcGxlLCBubyBpbnRlcm1lZGlhdGUgYXJyYXlzIGFyZSBldmVyIGNyZWF0ZWQsIGZpbHRlciBpcyBjYWxsZWQgdGhyZWVcXG50aW1lcywgYW5kIG1hcCBpcyBvbmx5IGNhbGxlZCBvbmNlOlxcblxcbmBgYGpzXFxub2RkU3F1YXJlcy5nZXQoMSk7IC8vIDlcXG5gYGBcXG5cXG5BbnkgY29sbGVjdGlvbiBjYW4gYmUgY29udmVydGVkIHRvIGEgbGF6eSBTZXEgd2l0aCBgU2VxKClgLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3QgbWFwID0gTWFwKHsgYTogMSwgYjogMiwgYzogMyB9KVxcbmNvbnN0IGxhenlTZXEgPSBTZXEobWFwKVxcbmBgYFxcblxcbmBTZXFgIGFsbG93cyBmb3IgdGhlIGVmZmljaWVudCBjaGFpbmluZyBvZiBvcGVyYXRpb25zLCBhbGxvd2luZyBmb3IgdGhlXFxuZXhwcmVzc2lvbiBvZiBsb2dpYyB0aGF0IGNhbiBvdGhlcndpc2UgYmUgdmVyeSB0ZWRpb3VzOlxcblxcbmBgYGpzXFxubGF6eVNlcVxcbiAgLmZsaXAoKVxcbiAgLm1hcChrZXkgPT4ga2V5LnRvVXBwZXJDYXNlKCkpXFxuICAuZmxpcCgpXFxuLy8gU2VxIHsgQTogMSwgQjogMSwgQzogMSB9XFxuYGBgXFxuXFxuQXMgd2VsbCBhcyBleHByZXNzaW5nIGxvZ2ljIHRoYXQgd291bGQgb3RoZXJ3aXNlIHNlZW0gbWVtb3J5IG9yIHRpbWVcXG5saW1pdGVkLCBmb3IgZXhhbXBsZSBgUmFuZ2VgIGlzIGEgc3BlY2lhbCBraW5kIG9mIExhenkgc2VxdWVuY2UuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IFJhbmdlIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcblJhbmdlKDEsIEluZmluaXR5KVxcbiAgLnNraXAoMTAwMClcXG4gIC5tYXAobiA9PiAtbilcXG4gIC5maWx0ZXIobiA9PiBuICUgMiA9PT0gMClcXG4gIC50YWtlKDIpXFxuICAucmVkdWNlKChyLCBuKSA9PiByICogbiwgMSlcXG4vLyAxMDA2MDA4XFxuYGBgXFxuXFxuU2VxIGlzIG9mdGVuIHVzZWQgdG8gcHJvdmlkZSBhIHJpY2ggY29sbGVjdGlvbiBBUEkgdG8gSmF2YVNjcmlwdCBPYmplY3QuXFxuXFxuYGBganNcXG5TZXEoeyB4OiAwLCB5OiAxLCB6OiAyIH0pLm1hcCh2ID0+IHYgKiAyKS50b09iamVjdCgpO1xcbi8vIHsgeDogMCwgeTogMiwgejogNCB9XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcIm1vZHVsZVwiOntcImlzU2VxXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGBtYXliZVNlcWAgaXMgYSBTZXEsIGl0IGlzIG5vdCBiYWNrZWQgYnkgYSBjb25jcmV0ZVxcbnN0cnVjdHVyZSBzdWNoIGFzIE1hcCwgTGlzdCwgb3IgU2V0LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXliZVNlcVwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6MjY3M31dfX0sXCJLZXllZFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJgU2VxYCB3aGljaCByZXByZXNlbnRzIGtleS12YWx1ZSBwYWlycy5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwibW9kdWxlXCI6e30sXCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkFsd2F5cyByZXR1cm5zIGEgU2VxLktleWVkLCBpZiBpbnB1dCBpcyBub3Qga2V5ZWQsIGV4cGVjdHMgYW5cXG5jb2xsZWN0aW9uIG9mIFtLLCBWXSB0dXBsZXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYFNlcS5LZXllZGAgaXMgYSBjb252ZXJzaW9uIGZ1bmN0aW9uIGFuZCBub3QgYSBjbGFzcywgYW5kIGRvZXMgbm90XFxudXNlIHRoZSBgbmV3YCBrZXl3b3JkIGR1cmluZyBjb25zdHJ1Y3Rpb24uXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktcIixcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjI2ODh9LHtcInR5cGVQYXJhbXNcIjpbXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm9ialwiLFwidHlwZVwiOntcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjozfSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6MjY4OX0se1widHlwZVBhcmFtc1wiOltcIktcIixcIlZcIl0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6MjY5MH0se1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19LFwibGluZVwiOjI2OTF9XX0sXCJpbnRlcmZhY2VcIjp7XCJsaW5lXCI6MjY5MyxcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCJdLFwiZXh0ZW5kc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSx7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dLFwiZ3JvdXBzXCI6W3tcIm1lbWJlcnNcIjp7XCIjdG9KU1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJEZWVwbHkgY29udmVydHMgdGhpcyBLZXllZCBTZXEgdG8gZXF1aXZhbGVudCBuYXRpdmUgSmF2YVNjcmlwdCBPYmplY3QuXCIsXCJkZXNjcmlwdGlvblwiOlwiQ29udmVydHMga2V5cyB0byBTdHJpbmdzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk9iamVjdFwifSxcImxpbmVcIjoyNjk5fV19LFwiI3RvSlNPTlwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJTaGFsbG93bHkgY29udmVydHMgdGhpcyBLZXllZCBTZXEgdG8gZXF1aXZhbGVudCBuYXRpdmUgSmF2YVNjcmlwdCBPYmplY3QuXCIsXCJkZXNjcmlwdGlvblwiOlwiQ29udmVydHMga2V5cyB0byBTdHJpbmdzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XX0sXCJsaW5lXCI6MjcwNn1dfSxcIiN0b0FycmF5XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIGNvbGxlY3Rpb24gdG8gYW4gQXJyYXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfSxcImxpbmVcIjoyNzExfV19LFwiI3RvU2VxXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgaXRzZWxmXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MjcxNn1dfSxcIiNjb25jYXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBTZXEgd2l0aCBvdGhlciBjb2xsZWN0aW9ucyBjb25jYXRlbmF0ZWQgdG8gdGhpcyBvbmUuXCIsXCJkZXNjcmlwdGlvblwiOlwiQWxsIGVudHJpZXMgd2lsbCBiZSBwcmVzZW50IGluIHRoZSByZXN1bHRpbmcgU2VxLCBldmVuIGlmIHRoZXlcXG5oYXZlIHRoZSBzYW1lIGtleS5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS0NcIixcIlZDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktDXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZDXCJ9XX1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIktDXCJ9XX0se1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWQ1wifV19XX0sXCJsaW5lXCI6MjcyNH0se1widHlwZVBhcmFtc1wiOltcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjozfV19LHtcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifV19XX0sXCJsaW5lXCI6MjcyNX1dfSxcIiNtYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBTZXEuS2V5ZWQgd2l0aCB2YWx1ZXMgcGFzc2VkIHRocm91Z2ggYVxcbmBtYXBwZXJgIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcImBgYGpzXFxuY29uc3QgeyBTZXEgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuU2VxLktleWVkKHsgYTogMSwgYjogMiB9KS5tYXAoeCA9PiAxMCAqIHgpXFxuLy8gU2VxIHsgXFxcImFcXFwiOiAxMCwgXFxcImJcXFwiOiAyMCB9XFxuYGBgXFxuXFxuTm90ZTogYG1hcCgpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCBwcm9kdWNlZCB0aGVcXG5zYW1lIHZhbHVlIGF0IGV2ZXJ5IHN0ZXAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk1cIn19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjI3NDB9XX0sXCIjbWFwS2V5c1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcInNlZVwiLFwiYm9keVwiOlwiQ29sbGVjdGlvbi5LZXllZC5tYXBLZXlzXCJ9XX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjoyNzQ4fV19LFwiI21hcEVudHJpZXNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOlt7XCJuYW1lXCI6XCJzZWVcIixcImJvZHlcIjpcIkNvbGxlY3Rpb24uS2V5ZWQubWFwRW50cmllc1wifV19LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS01cIixcIlZNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImVudHJ5XCIsXCJ0eXBlXCI6e1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19LHtcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZNXCJ9XX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZNXCJ9XX0sXCJsaW5lXCI6Mjc1Nn1dfSxcIiNmbGF0TWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkZsYXQtbWFwcyB0aGUgU2VxLCByZXR1cm5pbmcgYSBTZXEgb2YgdGhlIHNhbWUgdHlwZS5cIixcImRlc2NyaXB0aW9uXCI6XCJTaW1pbGFyIHRvIGBzZXEubWFwKC4uLikuZmxhdHRlbih0cnVlKWAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktNXCIsXCJWTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLTVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWTVwifV19XX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZNXCJ9XX0sXCJsaW5lXCI6Mjc2Nn1dfSxcIiNmaWx0ZXJcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBTZXEgd2l0aCBvbmx5IHRoZSBlbnRyaWVzIGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWBcXG5mdW5jdGlvbiByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYGZpbHRlcigpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCByZXN1bHRzIGluXFxubm90IGZpbHRlcmluZyBvdXQgYW55IHZhbHVlcy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiRlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIkZcIn1dfSxcImxpbmVcIjoyNzc4fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxN319fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6Mjc4Mn1dfSxcIiNmbGlwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJDb2xsZWN0aW9uLktleWVkLmZsaXBcIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifV19LFwibGluZVwiOjI3OTB9XX19fV19fSxcIkluZGV4ZWRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiYFNlcWAgd2hpY2ggcmVwcmVzZW50cyBhbiBvcmRlcmVkIGluZGV4ZWQgbGlzdCBvZiB2YWx1ZXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcIm1vZHVsZVwiOntcIm9mXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJQcm92aWRlcyBhbiBTZXEuSW5kZXhlZCBvZiB0aGUgdmFsdWVzIHByb3ZpZGVkLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoyODAyfV19fX0sXCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkFsd2F5cyByZXR1cm5zIFNlcS5JbmRleGVkLCBkaXNjYXJkaW5nIGFzc29jaWF0ZWQga2V5cyBhbmRcXG5zdXBwbHlpbmcgaW5jcmVtZW50aW5nIGluZGljZXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYFNlcS5JbmRleGVkYCBpcyBhIGNvbnZlcnNpb24gZnVuY3Rpb24gYW5kIG5vdCBhIGNsYXNzLCBhbmQgZG9lc1xcbm5vdCB1c2UgdGhlIGBuZXdgIGtleXdvcmQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJsaW5lXCI6MjgxMn0se1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MjgxM30se1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MjgxNH1dfSxcImludGVyZmFjZVwiOntcImxpbmVcIjoyODE2LFwidHlwZVBhcmFtc1wiOltcIlRcIl0sXCJleHRlbmRzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiU2VxXCIsXCJhcmdzXCI6W3tcImtcIjoyfSx7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0se1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19XSxcImdyb3Vwc1wiOlt7XCJtZW1iZXJzXCI6e1wiI3RvSlNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRGVlcGx5IGNvbnZlcnRzIHRoaXMgSW5kZXhlZCBTZXEgdG8gZXF1aXZhbGVudCBuYXRpdmUgSmF2YVNjcmlwdCBBcnJheS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJsaW5lXCI6MjgyMH1dfSxcIiN0b0pTT05cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiU2hhbGxvd2x5IGNvbnZlcnRzIHRoaXMgSW5kZXhlZCBTZXEgdG8gZXF1aXZhbGVudCBuYXRpdmUgSmF2YVNjcmlwdCBBcnJheS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MjgyNX1dfSxcIiN0b0FycmF5XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIGNvbGxlY3Rpb24gdG8gYW4gQXJyYXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjI4MzB9XX0sXCIjdG9TZXFcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBpdHNlbGZcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoyODM1fV19LFwiI2NvbmNhdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFNlcSB3aXRoIG90aGVyIGNvbGxlY3Rpb25zIGNvbmNhdGVuYXRlZCB0byB0aGlzIG9uZS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZXNPckNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIkNcIn1dfSx7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIkNcIn1dfV19LFwibGluZVwiOjI4NDB9XX0sXCIjbWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU2VxLkluZGV4ZWQgd2l0aCB2YWx1ZXMgcGFzc2VkIHRocm91Z2ggYVxcbmBtYXBwZXJgIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcImBgYGpzXFxuY29uc3QgeyBTZXEgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuU2VxLkluZGV4ZWQoWyAxLCAyIF0pLm1hcCh4ID0+IDEwICogeClcXG4vLyBTZXEgWyAxMCwgMjAgXVxcbmBgYFxcblxcbk5vdGU6IGBtYXAoKWAgYWx3YXlzIHJldHVybnMgYSBuZXcgaW5zdGFuY2UsIGV2ZW4gaWYgaXQgcHJvZHVjZWQgdGhlXFxuc2FtZSB2YWx1ZSBhdCBldmVyeSBzdGVwLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk1cIn19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjI4NTV9XX0sXCIjZmxhdE1hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJGbGF0LW1hcHMgdGhlIFNlcSwgcmV0dXJuaW5nIGEgYSBTZXEgb2YgdGhlIHNhbWUgdHlwZS5cIixcImRlc2NyaXB0aW9uXCI6XCJTaW1pbGFyIHRvIGBzZXEubWFwKC4uLikuZmxhdHRlbih0cnVlKWAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjI4NjV9XX0sXCIjZmlsdGVyXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU2VxIHdpdGggb25seSB0aGUgdmFsdWVzIGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWBcXG5mdW5jdGlvbiByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYGZpbHRlcigpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCByZXN1bHRzIGluXFxubm90IGZpbHRlcmluZyBvdXQgYW55IHZhbHVlcy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiRlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJGXCJ9XX0sXCJsaW5lXCI6Mjg3N30se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjoyODgxfV19LFwiI3ppcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgU2VxIFxcXCJ6aXBwZWRcXFwiIHdpdGggdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb25zLlwiLFwiZGVzY3JpcHRpb25cIjpcIkxpa2UgYHppcFdpdGhgLCBidXQgdXNpbmcgdGhlIGRlZmF1bHQgYHppcHBlcmA6IGNyZWF0aW5nIGFuIGBBcnJheWAuXFxuXFxuYGBganNcXG5jb25zdCBhID0gU2VxKFsgMSwgMiwgMyBdKTtcXG5jb25zdCBiID0gU2VxKFsgNCwgNSwgNiBdKTtcXG5jb25zdCBjID0gYS56aXAoYik7IC8vIFNlcSBbIFsgMSwgNCBdLCBbIDIsIDUgXSwgWyAzLCA2IF0gXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJVXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfV19LFwibGluZVwiOjI4OTd9LHtcInR5cGVQYXJhbXNcIjpbXCJVXCIsXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fSx7XCJuYW1lXCI6XCJvdGhlcjJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfSxcImxpbmVcIjoyODk4fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcImxpbmVcIjoyODk5fV19LFwiI3ppcEFsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgU2VxIFxcXCJ6aXBwZWRcXFwiIHdpdGggdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb25zLlwiLFwiZGVzY3JpcHRpb25cIjpcIlVubGlrZSBgemlwYCwgYHppcEFsbGAgY29udGludWVzIHppcHBpbmcgdW50aWwgdGhlIGxvbmdlc3QgY29sbGVjdGlvbiBpc1xcbmV4aGF1c3RlZC4gTWlzc2luZyB2YWx1ZXMgZnJvbSBzaG9ydGVyIGNvbGxlY3Rpb25zIGFyZSBmaWxsZWQgd2l0aCBgdW5kZWZpbmVkYC5cXG5cXG5gYGBqc1xcbmNvbnN0IGEgPSBTZXEoWyAxLCAyIF0pO1xcbmNvbnN0IGIgPSBTZXEoWyAzLCA0LCA1IF0pO1xcbmNvbnN0IGMgPSBhLnppcEFsbChiKTsgLy8gU2VxIFsgWyAxLCAzIF0sIFsgMiwgNCBdLCBbIHVuZGVmaW5lZCwgNSBdIF1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlclwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX1dfSxcImxpbmVcIjoyOTEzfSx7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlclwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX0se1wibmFtZVwiOlwib3RoZXIyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX0sXCJsaW5lXCI6MjkxNH0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6MTd9XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJsaW5lXCI6MjkxNX1dfSxcIiN6aXBXaXRoXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBTZXEgXFxcInppcHBlZFxcXCIgd2l0aCB0aGUgcHJvdmlkZWQgY29sbGVjdGlvbnMgYnkgdXNpbmcgYVxcbmN1c3RvbSBgemlwcGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJgYGBqc1xcbmNvbnN0IGEgPSBTZXEoWyAxLCAyLCAzIF0pO1xcbmNvbnN0IGIgPSBTZXEoWyA0LCA1LCA2IF0pO1xcbmNvbnN0IGMgPSBhLnppcFdpdGgoKGEsIGIpID0+IGEgKyBiLCBiKTtcXG4vLyBTZXEgWyA1LCA3LCA5IF1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiWlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ6aXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIm90aGVyVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifX19LHtcIm5hbWVcIjpcIm90aGVyQ29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifV19LFwibGluZVwiOjI5Mjh9LHtcInR5cGVQYXJhbXNcIjpbXCJVXCIsXCJWXCIsXCJaXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInppcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwib3RoZXJWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlVcIn19LHtcIm5hbWVcIjpcInRoaXJkVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifX19LHtcIm5hbWVcIjpcIm90aGVyQ29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX0se1wibmFtZVwiOlwidGhpcmRDb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9XX0sXCJsaW5lXCI6MjkzMn0se1widHlwZVBhcmFtc1wiOltcIlpcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiemlwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiYW55XCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlpcIn19fSx7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiWlwifV19LFwibGluZVwiOjI5Mzd9XX19fV19fSxcIlNldFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJgU2VxYCB3aGljaCByZXByZXNlbnRzIGEgc2V0IG9mIHZhbHVlcy5cIixcImRlc2NyaXB0aW9uXCI6XCJCZWNhdXNlIGBTZXFgIGFyZSBvZnRlbiBsYXp5LCBgU2VxLlNldGAgZG9lcyBub3QgcHJvdmlkZSB0aGUgc2FtZSBndWFyYW50ZWVcXG5vZiB2YWx1ZSB1bmlxdWVuZXNzIGFzIHRoZSBjb25jcmV0ZSBgU2V0YC5cIixcIm5vdGVzXCI6W119LFwibW9kdWxlXCI6e1wib2ZcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBTZXEuU2V0IG9mIHRoZSBwcm92aWRlZCB2YWx1ZXNcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZXNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoyOTU1fV19fX0sXCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkFsd2F5cyByZXR1cm5zIGEgU2VxLlNldCwgZGlzY2FyZGluZyBhc3NvY2lhdGVkIGluZGljZXMgb3Iga2V5cy5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgU2VxLlNldGAgaXMgYSBjb252ZXJzaW9uIGZ1bmN0aW9uIGFuZCBub3QgYSBjbGFzcywgYW5kIGRvZXMgbm90XFxudXNlIHRoZSBgbmV3YCBrZXl3b3JkIGR1cmluZyBjb25zdHJ1Y3Rpb24uXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJsaW5lXCI6Mjk2NH0se1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoyOTY1fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5TZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjI5NjZ9XX0sXCJpbnRlcmZhY2VcIjp7XCJsaW5lXCI6Mjk2OCxcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwiZXh0ZW5kc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSx7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfV0sXCJncm91cHNcIjpbe1wibWVtYmVyc1wiOntcIiN0b0pTXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkRlZXBseSBjb252ZXJ0cyB0aGlzIFNldCBTZXEgdG8gZXF1aXZhbGVudCBuYXRpdmUgSmF2YVNjcmlwdCBBcnJheS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJsaW5lXCI6Mjk3Mn1dfSxcIiN0b0pTT05cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiU2hhbGxvd2x5IGNvbnZlcnRzIHRoaXMgU2V0IFNlcSB0byBlcXVpdmFsZW50IG5hdGl2ZSBKYXZhU2NyaXB0IEFycmF5LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjoyOTc3fV19LFwiI3RvQXJyYXlcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiU2hhbGxvd2x5IGNvbnZlcnRzIHRoaXMgY29sbGVjdGlvbiB0byBhbiBBcnJheS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6Mjk4Mn1dfSxcIiN0b1NlcVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGl0c2VsZlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjI5ODd9XX0sXCIjY29uY2F0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU2VxIHdpdGggb3RoZXIgY29sbGVjdGlvbnMgY29uY2F0ZW5hdGVkIHRvIHRoaXMgb25lLlwiLFwiZGVzY3JpcHRpb25cIjpcIkFsbCBlbnRyaWVzIHdpbGwgYmUgcHJlc2VudCBpbiB0aGUgcmVzdWx0aW5nIFNlcSwgZXZlbiBpZiB0aGV5XFxuYXJlIGR1cGxpY2F0ZXMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlVcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfV19LFwibGluZVwiOjI5OTV9XX0sXCIjbWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgU2VxLlNldCB3aXRoIHZhbHVlcyBwYXNzZWQgdGhyb3VnaCBhXFxuYG1hcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiYGBganNcXG5TZXEuU2V0KFsgMSwgMiBdKS5tYXAoeCA9PiAxMCAqIHgpXFxuLy8gU2VxIHsgMTAsIDIwIH1cXG5gYGBcXG5cXG5Ob3RlOiBgbWFwKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHByb2R1Y2VkIHRoZVxcbnNhbWUgdmFsdWUgYXQgZXZlcnkgc3RlcC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjozMDA5fV19LFwiI2ZsYXRNYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRmxhdC1tYXBzIHRoZSBTZXEsIHJldHVybmluZyBhIFNlcSBvZiB0aGUgc2FtZSB0eXBlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlNpbWlsYXIgdG8gYHNlcS5tYXAoLi4uKS5mbGF0dGVuKHRydWUpYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6MzAxOX1dfSxcIiNmaWx0ZXJcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBTZXEgd2l0aCBvbmx5IHRoZSB2YWx1ZXMgZm9yIHdoaWNoIHRoZSBgcHJlZGljYXRlYFxcbmZ1bmN0aW9uIHJldHVybnMgdHJ1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgZmlsdGVyKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHJlc3VsdHMgaW5cXG5ub3QgZmlsdGVyaW5nIG91dCBhbnkgdmFsdWVzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJGXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJGXCJ9XX0sXCJsaW5lXCI6MzAzMX0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MTd9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjMwMzV9XX19fV19fX0sXCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNyZWF0ZXMgYSBTZXEuXCIsXCJkZXNjcmlwdGlvblwiOlwiUmV0dXJucyBhIHBhcnRpY3VsYXIga2luZCBvZiBgU2VxYCBiYXNlZCBvbiB0aGUgaW5wdXQuXFxuXFxuICAqIElmIGEgYFNlcWAsIHRoYXQgc2FtZSBgU2VxYC5cXG4gICogSWYgYW4gYENvbGxlY3Rpb25gLCBhIGBTZXFgIG9mIHRoZSBzYW1lIGtpbmQgKEtleWVkLCBJbmRleGVkLCBvciBTZXQpLlxcbiAgKiBJZiBhbiBBcnJheS1saWtlLCBhbiBgU2VxLkluZGV4ZWRgLlxcbiAgKiBJZiBhbiBJdGVyYWJsZSBPYmplY3QsIGFuIGBTZXEuSW5kZXhlZGAuXFxuICAqIElmIGFuIE9iamVjdCwgYSBgU2VxLktleWVkYC5cXG5cXG5Ob3RlOiBBbiBJdGVyYXRvciBpdHNlbGYgd2lsbCBiZSB0cmVhdGVkIGFzIGFuIG9iamVjdCwgYmVjb21pbmcgYSBgU2VxLktleWVkYCxcXG53aGljaCBpcyB1c3VhbGx5IG5vdCB3aGF0IHlvdSB3YW50LiBZb3Ugc2hvdWxkIHR1cm4geW91ciBJdGVyYXRvciBPYmplY3QgaW50b1xcbmFuIGl0ZXJhYmxlIG9iamVjdCBieSBkZWZpbmluZyBhIFN5bWJvbC5pdGVyYXRvciAob3IgQEBpdGVyYXRvcikgbWV0aG9kIHdoaWNoXFxucmV0dXJucyBgdGhpc2AuXFxuXFxuTm90ZTogYFNlcWAgaXMgYSBjb252ZXJzaW9uIGZ1bmN0aW9uIGFuZCBub3QgYSBjbGFzcywgYW5kIGRvZXMgbm90IHVzZSB0aGVcXG5gbmV3YCBrZXl3b3JkIGR1cmluZyBjb25zdHJ1Y3Rpb24uXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwic2VxXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiU1wifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlNcIn0sXCJsaW5lXCI6MzA2Mn0se1widHlwZVBhcmFtc1wiOltcIktcIixcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjMwNjN9LHtcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjozMDY0fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5TZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjMwNjV9LHtcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjMwNjZ9LHtcInR5cGVQYXJhbXNcIjpbXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm9ialwiLFwidHlwZVwiOntcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjozfSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6MzA2N30se1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19LFwibGluZVwiOjMwNjh9XX0sXCJpbnRlcmZhY2VcIjp7XCJsaW5lXCI6MzA3MCxcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCJdLFwiZXh0ZW5kc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dLFwiZ3JvdXBzXCI6W3tcIm1lbWJlcnNcIjp7XCIjc2l6ZVwiOntcImxpbmVcIjozMDgyfX19LHtcInRpdGxlXCI6XCJGb3JjZSBldmFsdWF0aW9uXCIsXCJtZW1iZXJzXCI6e1wiI2NhY2hlUmVzdWx0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkJlY2F1c2UgU2VxdWVuY2VzIGFyZSBsYXp5IGFuZCBkZXNpZ25lZCB0byBiZSBjaGFpbmVkIHRvZ2V0aGVyLCB0aGV5IGRvXFxubm90IGNhY2hlIHRoZWlyIHJlc3VsdHMuIEZvciBleGFtcGxlLCB0aGlzIG1hcCBmdW5jdGlvbiBpcyBjYWxsZWQgYSB0b3RhbFxcbm9mIDYgdGltZXMsIGFzIGVhY2ggYGpvaW5gIGl0ZXJhdGVzIHRoZSBTZXEgb2YgdGhyZWUgdmFsdWVzLlwiLFwiZGVzY3JpcHRpb25cIjpcIiAgICB2YXIgc3F1YXJlcyA9IFNlcShbIDEsIDIsIDMgXSkubWFwKHggPT4geCAqIHgpXFxuICAgIHNxdWFyZXMuam9pbigpICsgc3F1YXJlcy5qb2luKClcXG5cXG5JZiB5b3Uga25vdyBhIGBTZXFgIHdpbGwgYmUgdXNlZCBtdWx0aXBsZSB0aW1lcywgaXQgbWF5IGJlIG1vcmVcXG5lZmZpY2llbnQgdG8gZmlyc3QgY2FjaGUgaXQgaW4gbWVtb3J5LiBIZXJlLCB0aGUgbWFwIGZ1bmN0aW9uIGlzIGNhbGxlZFxcbm9ubHkgMyB0aW1lcy5cXG5cXG4gICAgdmFyIHNxdWFyZXMgPSBTZXEoWyAxLCAyLCAzIF0pLm1hcCh4ID0+IHggKiB4KS5jYWNoZVJlc3VsdCgpXFxuICAgIHNxdWFyZXMuam9pbigpICsgc3F1YXJlcy5qb2luKClcXG5cXG5Vc2UgdGhpcyBtZXRob2QganVkaWNpb3VzbHksIGFzIGl0IG11c3QgZnVsbHkgZXZhbHVhdGUgYSBTZXEgd2hpY2ggY2FuIGJlXFxuYSBidXJkZW4gb24gbWVtb3J5IGFuZCBwb3NzaWJseSBwZXJmb3JtYW5jZS5cXG5cXG5Ob3RlOiBhZnRlciBjYWxsaW5nIGBjYWNoZVJlc3VsdGAsIGEgU2VxIHdpbGwgYWx3YXlzIGhhdmUgYSBgc2l6ZWAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MzEwN31dfX19LHtcInRpdGxlXCI6XCJTZXF1ZW5jZSBhbGdvcml0aG1zXCIsXCJtZW1iZXJzXCI6e1wiI21hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFNlcSB3aXRoIHZhbHVlcyBwYXNzZWQgdGhyb3VnaCBhXFxuYG1hcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiYGBganNcXG5jb25zdCB7IFNlcSB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5TZXEoWyAxLCAyIF0pLm1hcCh4ID0+IDEwICogeClcXG4vLyBTZXEgWyAxMCwgMjAgXVxcbmBgYFxcblxcbk5vdGU6IGBtYXAoKWAgYWx3YXlzIHJldHVybnMgYSBuZXcgaW5zdGFuY2UsIGV2ZW4gaWYgaXQgcHJvZHVjZWQgdGhlIHNhbWVcXG52YWx1ZSBhdCBldmVyeSBzdGVwLlxcbk5vdGU6IHVzZWQgb25seSBmb3Igc2V0cy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXFcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6MzEyNH0se1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk1cIn19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjMxNDN9XX0sXCIjZmxhdE1hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJGbGF0LW1hcHMgdGhlIFNlcSwgcmV0dXJuaW5nIGEgU2VxIG9mIHRoZSBzYW1lIHR5cGUuXCIsXCJkZXNjcmlwdGlvblwiOlwiU2ltaWxhciB0byBgc2VxLm1hcCguLi4pLmZsYXR0ZW4odHJ1ZSlgLlxcbk5vdGU6IFVzZWQgb25seSBmb3Igc2V0cy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19LFwibGluZVwiOjMxNTN9LHtcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXFcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6MzE2NH1dfSxcIiNmaWx0ZXJcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBTZXEgd2l0aCBvbmx5IHRoZSB2YWx1ZXMgZm9yIHdoaWNoIHRoZSBgcHJlZGljYXRlYFxcbmZ1bmN0aW9uIHJldHVybnMgdHJ1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgZmlsdGVyKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHJlc3VsdHMgaW5cXG5ub3QgZmlsdGVyaW5nIG91dCBhbnkgdmFsdWVzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJGXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiRlwifV19LFwibGluZVwiOjMxNzZ9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjozMTgwfV19fX1dfX0sXCJDb2xsZWN0aW9uXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRoZSBgQ29sbGVjdGlvbmAgaXMgYSBzZXQgb2YgKGtleSwgdmFsdWUpIGVudHJpZXMgd2hpY2ggY2FuIGJlIGl0ZXJhdGVkLCBhbmRcXG5pcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIGNvbGxlY3Rpb25zIGluIGBpbW11dGFibGVgLCBhbGxvd2luZyB0aGVtIHRvXFxubWFrZSB1c2Ugb2YgYWxsIHRoZSBDb2xsZWN0aW9uIG1ldGhvZHMgKHN1Y2ggYXMgYG1hcGAgYW5kIGBmaWx0ZXJgKS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBBIGNvbGxlY3Rpb24gaXMgYWx3YXlzIGl0ZXJhdGVkIGluIHRoZSBzYW1lIG9yZGVyLCBob3dldmVyIHRoYXQgb3JkZXJcXG5tYXkgbm90IGFsd2F5cyBiZSB3ZWxsIGRlZmluZWQsIGFzIGlzIHRoZSBjYXNlIGZvciB0aGUgYE1hcGAgYW5kIGBTZXRgLlxcblxcbkNvbGxlY3Rpb24gaXMgdGhlIGFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGNvbmNyZXRlIGRhdGEgc3RydWN0dXJlcy4gSXRcXG5jYW5ub3QgYmUgY29uc3RydWN0ZWQgZGlyZWN0bHkuXFxuXFxuSW1wbGVtZW50YXRpb25zIHNob3VsZCBleHRlbmQgb25lIG9mIHRoZSBzdWJjbGFzc2VzLCBgQ29sbGVjdGlvbi5LZXllZGAsXFxuYENvbGxlY3Rpb24uSW5kZXhlZGAsIG9yIGBDb2xsZWN0aW9uLlNldGAuXCIsXCJub3Rlc1wiOltdfSxcIm1vZHVsZVwiOntcIktleWVkXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIktleWVkIENvbGxlY3Rpb25zIGhhdmUgZGlzY3JldGUga2V5cyB0aWVkIHRvIGVhY2ggdmFsdWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiV2hlbiBpdGVyYXRpbmcgYENvbGxlY3Rpb24uS2V5ZWRgLCBlYWNoIGl0ZXJhdGlvbiB3aWxsIHlpZWxkIGEgYFtLLCBWXWBcXG50dXBsZSwgaW4gb3RoZXIgd29yZHMsIGBDb2xsZWN0aW9uI2VudHJpZXNgIGlzIHRoZSBkZWZhdWx0IGl0ZXJhdG9yIGZvclxcbktleWVkIENvbGxlY3Rpb25zLlwiLFwibm90ZXNcIjpbXX0sXCJtb2R1bGVcIjp7fSxcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQ3JlYXRlcyBhIENvbGxlY3Rpb24uS2V5ZWRcIixcImRlc2NyaXB0aW9uXCI6XCJTaW1pbGFyIHRvIGBDb2xsZWN0aW9uKClgLCBob3dldmVyIGl0IGV4cGVjdHMgY29sbGVjdGlvbi1saWtlcyBvZiBbSywgVl1cXG50dXBsZXMgaWYgbm90IGNvbnN0cnVjdGVkIGZyb20gYSBDb2xsZWN0aW9uLktleWVkIG9yIEpTIE9iamVjdC5cXG5cXG5Ob3RlOiBgQ29sbGVjdGlvbi5LZXllZGAgaXMgYSBjb252ZXJzaW9uIGZ1bmN0aW9uIGFuZCBub3QgYSBjbGFzcywgYW5kXFxuZG9lcyBub3QgdXNlIHRoZSBgbmV3YCBrZXl3b3JkIGR1cmluZyBjb25zdHJ1Y3Rpb24uXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktcIixcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjozMjQxfSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvYmpcIixcInR5cGVcIjp7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjN9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjozMjQyfV19LFwiaW50ZXJmYWNlXCI6e1wibGluZVwiOjMyNDQsXCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiXSxcImV4dGVuZHNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XSxcImdyb3Vwc1wiOlt7XCJtZW1iZXJzXCI6e1wiI3RvSlNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRGVlcGx5IGNvbnZlcnRzIHRoaXMgS2V5ZWQgY29sbGVjdGlvbiB0byBlcXVpdmFsZW50IG5hdGl2ZSBKYXZhU2NyaXB0IE9iamVjdC5cIixcImRlc2NyaXB0aW9uXCI6XCJDb252ZXJ0cyBrZXlzIHRvIFN0cmluZ3MuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT2JqZWN0XCJ9LFwibGluZVwiOjMyNTB9XX0sXCIjdG9KU09OXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIEtleWVkIGNvbGxlY3Rpb24gdG8gZXF1aXZhbGVudCBuYXRpdmUgSmF2YVNjcmlwdCBPYmplY3QuXCIsXCJkZXNjcmlwdGlvblwiOlwiQ29udmVydHMga2V5cyB0byBTdHJpbmdzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XX0sXCJsaW5lXCI6MzI1N31dfSxcIiN0b0FycmF5XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIGNvbGxlY3Rpb24gdG8gYW4gQXJyYXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfSxcImxpbmVcIjozMjYyfV19LFwiI3RvU2VxXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgU2VxLktleWVkLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjozMjY4fV19fX0se1widGl0bGVcIjpcIlNlcXVlbmNlIGZ1bmN0aW9uc1wiLFwibWVtYmVyc1wiOntcIiNmbGlwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbi5LZXllZCBvZiB0aGUgc2FtZSB0eXBlIHdoZXJlIHRoZSBrZXlzIGFuZCB2YWx1ZXNcXG5oYXZlIGJlZW4gZmxpcHBlZC5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbk1hcCh7IGE6ICd6JywgYjogJ3knIH0pLmZsaXAoKVxcbi8vIE1hcCB7IFxcXCJ6XFxcIjogXFxcImFcXFwiLCBcXFwieVxcXCI6IFxcXCJiXFxcIiB9XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIktcIn1dfSxcImxpbmVcIjozMjg0fV19LFwiI2NvbmNhdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gd2l0aCBvdGhlciBjb2xsZWN0aW9ucyBjb25jYXRlbmF0ZWQgdG8gdGhpcyBvbmUuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktDXCIsXCJWQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLQ1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWQ1wifV19XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiS0NcIn1dfSx7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZDXCJ9XX1dfSxcImxpbmVcIjozMjg5fSx7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjozfV19LHtcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifV19XX0sXCJsaW5lXCI6MzI5MH1dfSxcIiNtYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uLktleWVkIHdpdGggdmFsdWVzIHBhc3NlZCB0aHJvdWdoIGFcXG5gbWFwcGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJgYGBqc1xcbmNvbnN0IHsgQ29sbGVjdGlvbiB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5Db2xsZWN0aW9uLktleWVkKHsgYTogMSwgYjogMiB9KS5tYXAoeCA9PiAxMCAqIHgpXFxuLy8gU2VxIHsgXFxcImFcXFwiOiAxMCwgXFxcImJcXFwiOiAyMCB9XFxuYGBgXFxuXFxuTm90ZTogYG1hcCgpYCBhbHdheXMgcmV0dXJucyBhIG5ldyBpbnN0YW5jZSwgZXZlbiBpZiBpdCBwcm9kdWNlZCB0aGVcXG5zYW1lIHZhbHVlIGF0IGV2ZXJ5IHN0ZXAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk1cIn19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjozMzA1fV19LFwiI21hcEtleXNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uLktleWVkIG9mIHRoZSBzYW1lIHR5cGUgd2l0aCBrZXlzIHBhc3NlZCB0aHJvdWdoXFxuYSBgbWFwcGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbk1hcCh7IGE6IDEsIGI6IDIgfSkubWFwS2V5cyh4ID0+IHgudG9VcHBlckNhc2UoKSlcXG4vLyBNYXAgeyBcXFwiQVxcXCI6IDEsIFxcXCJCXFxcIjogMiB9XFxuYGBgXFxuXFxuTm90ZTogYG1hcEtleXMoKWAgYWx3YXlzIHJldHVybnMgYSBuZXcgaW5zdGFuY2UsIGV2ZW4gaWYgaXQgcHJvZHVjZWRcXG50aGUgc2FtZSBrZXkgYXQgZXZlcnkgc3RlcC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjMzMjR9XX0sXCIjbWFwRW50cmllc1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24uS2V5ZWQgb2YgdGhlIHNhbWUgdHlwZSB3aXRoIGVudHJpZXNcXG4oW2tleSwgdmFsdWVdIHR1cGxlcykgcGFzc2VkIHRocm91Z2ggYSBgbWFwcGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbk1hcCh7IGE6IDEsIGI6IDIgfSlcXG4gIC5tYXBFbnRyaWVzKChbIGssIHYgXSkgPT4gWyBrLnRvVXBwZXJDYXNlKCksIHYgKiAyIF0pXFxuLy8gTWFwIHsgXFxcIkFcXFwiOiAyLCBcXFwiQlxcXCI6IDQgfVxcbmBgYFxcblxcbk5vdGU6IGBtYXBFbnRyaWVzKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHByb2R1Y2VkXFxudGhlIHNhbWUgZW50cnkgYXQgZXZlcnkgc3RlcC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS01cIixcIlZNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImVudHJ5XCIsXCJ0eXBlXCI6e1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19LHtcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZNXCJ9XX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLTVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWTVwifV19LFwibGluZVwiOjMzNDR9XX0sXCIjZmxhdE1hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJGbGF0LW1hcHMgdGhlIENvbGxlY3Rpb24sIHJldHVybmluZyBhIENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZS5cIixcImRlc2NyaXB0aW9uXCI6XCJTaW1pbGFyIHRvIGBjb2xsZWN0aW9uLm1hcCguLi4pLmZsYXR0ZW4odHJ1ZSlgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJLTVwiLFwiVk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS01cIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVk1cIn1dfV19fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uS2V5ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS01cIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVk1cIn1dfSxcImxpbmVcIjozMzU0fV19LFwiI2ZpbHRlclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gd2l0aCBvbmx5IHRoZSB2YWx1ZXMgZm9yIHdoaWNoIHRoZSBgcHJlZGljYXRlYFxcbmZ1bmN0aW9uIHJldHVybnMgdHJ1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgZmlsdGVyKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHJlc3VsdHMgaW5cXG5ub3QgZmlsdGVyaW5nIG91dCBhbnkgdmFsdWVzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJGXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIkZcIn1dfSxcImxpbmVcIjozMzY2fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxN319fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MzM3MH1dfSxcIiNbU3ltYm9sLml0ZXJhdG9yXVwiOntcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVJdGVyYXRvclwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfV19LFwibGluZVwiOjMzNzV9XX19fV19fSxcIkluZGV4ZWRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiSW5kZXhlZCBDb2xsZWN0aW9ucyBoYXZlIGluY3JlbWVudGluZyBudW1lcmljIGtleXMuIFRoZXkgZXhoaWJpdFxcbnNsaWdodGx5IGRpZmZlcmVudCBiZWhhdmlvciB0aGFuIGBDb2xsZWN0aW9uLktleWVkYCBmb3Igc29tZSBtZXRob2RzIGluIG9yZGVyXFxudG8gYmV0dGVyIG1pcnJvciB0aGUgYmVoYXZpb3Igb2YgSmF2YVNjcmlwdCdzIGBBcnJheWAsIGFuZCBhZGQgbWV0aG9kc1xcbndoaWNoIGRvIG5vdCBtYWtlIHNlbnNlIG9uIG5vbi1pbmRleGVkIENvbGxlY3Rpb25zIHN1Y2ggYXMgYGluZGV4T2ZgLlwiLFwiZGVzY3JpcHRpb25cIjpcIlVubGlrZSBKYXZhU2NyaXB0IGFycmF5cywgYENvbGxlY3Rpb24uSW5kZXhlZGBzIGFyZSBhbHdheXMgZGVuc2UuIFxcXCJVbnNldFxcXCJcXG5pbmRpY2VzIGFuZCBgdW5kZWZpbmVkYCBpbmRpY2VzIGFyZSBpbmRpc3Rpbmd1aXNoYWJsZSwgYW5kIGFsbCBpbmRpY2VzIGZyb21cXG4wIHRvIGBzaXplYCBhcmUgdmlzaXRlZCB3aGVuIGl0ZXJhdGVkLlxcblxcbkFsbCBDb2xsZWN0aW9uLkluZGV4ZWQgbWV0aG9kcyByZXR1cm4gcmUtaW5kZXhlZCBDb2xsZWN0aW9ucy4gSW4gb3RoZXIgd29yZHMsXFxuaW5kaWNlcyBhbHdheXMgc3RhcnQgYXQgMCBhbmQgaW5jcmVtZW50IHVudGlsIHNpemUuIElmIHlvdSB3aXNoIHRvXFxucHJlc2VydmUgaW5kaWNlcywgdXNpbmcgdGhlbSBhcyBrZXlzLCBjb252ZXJ0IHRvIGEgQ29sbGVjdGlvbi5LZXllZCBieVxcbmNhbGxpbmcgYHRvS2V5ZWRTZXFgLlwiLFwibm90ZXNcIjpbXX0sXCJtb2R1bGVcIjp7fSxcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQ3JlYXRlcyBhIG5ldyBDb2xsZWN0aW9uLkluZGV4ZWQuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYENvbGxlY3Rpb24uSW5kZXhlZGAgaXMgYSBjb252ZXJzaW9uIGZ1bmN0aW9uIGFuZCBub3QgYSBjbGFzcywgYW5kXFxuZG9lcyBub3QgdXNlIHRoZSBgbmV3YCBrZXl3b3JkIGR1cmluZyBjb25zdHJ1Y3Rpb24uXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjM0MDJ9XX0sXCJpbnRlcmZhY2VcIjp7XCJsaW5lXCI6MzQwNCxcInR5cGVQYXJhbXNcIjpbXCJUXCJdLFwiZXh0ZW5kc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfV0sXCJncm91cHNcIjpbe1wibWVtYmVyc1wiOntcIiN0b0pTXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkRlZXBseSBjb252ZXJ0cyB0aGlzIEluZGV4ZWQgY29sbGVjdGlvbiB0byBlcXVpdmFsZW50IG5hdGl2ZSBKYXZhU2NyaXB0IEFycmF5LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcImxpbmVcIjozNDA4fV19LFwiI3RvSlNPTlwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJTaGFsbG93bHkgY29udmVydHMgdGhpcyBJbmRleGVkIGNvbGxlY3Rpb24gdG8gZXF1aXZhbGVudCBuYXRpdmUgSmF2YVNjcmlwdCBBcnJheS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MzQxM31dfSxcIiN0b0FycmF5XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIGNvbGxlY3Rpb24gdG8gYW4gQXJyYXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjM0MTh9XX19fSx7XCJ0aXRsZVwiOlwiUmVhZGluZyB2YWx1ZXNcIixcIm1lbWJlcnNcIjp7XCIjZ2V0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgaW5kZXgsIG9yIG5vdFNldFZhbHVlIGlmXFxudGhlIGluZGV4IGlzIGJleW9uZCB0aGUgYm91bmRzIG9mIHRoZSBDb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcImBpbmRleGAgbWF5IGJlIGEgbmVnYXRpdmUgbnVtYmVyLCB3aGljaCBpbmRleGVzIGJhY2sgZnJvbSB0aGUgZW5kIG9mIHRoZVxcbkNvbGxlY3Rpb24uIGBzLmdldCgtMSlgIGdldHMgdGhlIGxhc3QgaXRlbSBpbiB0aGUgQ29sbGVjdGlvbi5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTlNWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifX1dLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiTlNWXCJ9XX0sXCJsaW5lXCI6MzQyOX0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fV0sXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6MTF9XX0sXCJsaW5lXCI6MzQzMH1dfX19LHtcInRpdGxlXCI6XCJDb252ZXJzaW9uIHRvIFNlcVwiLFwibWVtYmVyc1wiOntcIiN0b1NlcVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIFNlcS5JbmRleGVkLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjozNDM5fV19LFwiI2Zyb21FbnRyeVNlcVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJJZiB0aGlzIGlzIGEgY29sbGVjdGlvbiBvZiBba2V5LCB2YWx1ZV0gZW50cnkgdHVwbGVzLCBpdCB3aWxsIHJldHVybiBhXFxuU2VxLktleWVkIG9mIHRob3NlIGVudHJpZXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19LFwibGluZVwiOjM0NDV9XX19fSx7XCJ0aXRsZVwiOlwiQ29tYmluYXRpb25cIixcIm1lbWJlcnNcIjp7XCIjaW50ZXJwb3NlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgd2l0aCBgc2VwYXJhdG9yYCBiZXR3ZWVuIGVhY2ggaXRlbVxcbmluIHRoaXMgQ29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwic2VwYXJhdG9yXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6MzQ1NH1dfSxcIiNpbnRlcmxlYXZlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgd2l0aCB0aGUgcHJvdmlkZWQgYGNvbGxlY3Rpb25zYFxcbmludGVybGVhdmVkIGludG8gdGhpcyBjb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIlRoZSByZXN1bHRpbmcgQ29sbGVjdGlvbiBpbmNsdWRlcyB0aGUgZmlyc3QgaXRlbSBmcm9tIGVhY2gsIHRoZW4gdGhlXFxuc2Vjb25kIGZyb20gZWFjaCwgZXRjLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJyZXF1aXJlKCdpbW11dGFibGUnKVxcXCJ9XFxuLS0+XFxuYGBganNcXG5jb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuTGlzdChbIDEsIDIsIDMgXSkuaW50ZXJsZWF2ZShMaXN0KFsgJ0EnLCAnQicsICdDJyBdKSlcXG4vLyBMaXN0IFsgMSwgXFxcIkFcXFwiLCAyLCBcXFwiQlxcXCIsIDMsIFxcXCJDXFxcIiBdXFxuYGBgXFxuXFxuVGhlIHNob3J0ZXN0IENvbGxlY3Rpb24gc3RvcHMgaW50ZXJsZWF2ZS5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcXCIgfVxcbi0tPlxcbmBgYGpzXFxuTGlzdChbIDEsIDIsIDMgXSkuaW50ZXJsZWF2ZShcXG4gIExpc3QoWyAnQScsICdCJyBdKSxcXG4gIExpc3QoWyAnWCcsICdZJywgJ1onIF0pXFxuKVxcbi8vIExpc3QgWyAxLCBcXFwiQVxcXCIsIFxcXCJYXFxcIiwgMiwgXFxcIkJcXFwiLCBcXFwiWVxcXCIgXVxcbmBgYFxcblxcblNpbmNlIGBpbnRlcmxlYXZlKClgIHJlLWluZGV4ZXMgdmFsdWVzLCBpdCBwcm9kdWNlcyBhIGNvbXBsZXRlIGNvcHksXFxud2hpY2ggaGFzIGBPKE4pYCBjb21wbGV4aXR5Llxcblxcbk5vdGU6IGBpbnRlcmxlYXZlYCAqY2Fubm90KiBiZSB1c2VkIGluIGB3aXRoTXV0YXRpb25zYC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjM0OTB9XX0sXCIjc3BsaWNlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNwbGljZSByZXR1cm5zIGEgbmV3IGluZGV4ZWQgQ29sbGVjdGlvbiBieSByZXBsYWNpbmcgYSByZWdpb24gb2YgdGhpc1xcbkNvbGxlY3Rpb24gd2l0aCBuZXcgdmFsdWVzLiBJZiB2YWx1ZXMgYXJlIG5vdCBwcm92aWRlZCwgaXQgb25seSBza2lwcyB0aGVcXG5yZWdpb24gdG8gYmUgcmVtb3ZlZC5cIixcImRlc2NyaXB0aW9uXCI6XCJgaW5kZXhgIG1heSBiZSBhIG5lZ2F0aXZlIG51bWJlciwgd2hpY2ggaW5kZXhlcyBiYWNrIGZyb20gdGhlIGVuZCBvZiB0aGVcXG5Db2xsZWN0aW9uLiBgcy5zcGxpY2UoLTIpYCBzcGxpY2VzIGFmdGVyIHRoZSBzZWNvbmQgdG8gbGFzdCBpdGVtLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbkxpc3QoWyAnYScsICdiJywgJ2MnLCAnZCcgXSkuc3BsaWNlKDEsIDIsICdxJywgJ3InLCAncycpXFxuLy8gTGlzdCBbIFxcXCJhXFxcIiwgXFxcInFcXFwiLCBcXFwiclxcXCIsIFxcXCJzXFxcIiwgXFxcImRcXFwiIF1cXG5gYGBcXG5cXG5TaW5jZSBgc3BsaWNlKClgIHJlLWluZGV4ZXMgdmFsdWVzLCBpdCBwcm9kdWNlcyBhIGNvbXBsZXRlIGNvcHksIHdoaWNoXFxuaGFzIGBPKE4pYCBjb21wbGV4aXR5Llxcblxcbk5vdGU6IGBzcGxpY2VgICpjYW5ub3QqIGJlIHVzZWQgaW4gYHdpdGhNdXRhdGlvbnNgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJpbmRleFwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwicmVtb3ZlTnVtXCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZXNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjozNTEyfV19LFwiI3ppcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIFxcXCJ6aXBwZWRcXFwiIHdpdGggdGhlIHByb3ZpZGVkXFxuY29sbGVjdGlvbnMuXCIsXCJkZXNjcmlwdGlvblwiOlwiTGlrZSBgemlwV2l0aGAsIGJ1dCB1c2luZyB0aGUgZGVmYXVsdCBgemlwcGVyYDogY3JlYXRpbmcgYW4gYEFycmF5YC5cXG5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZVxcbiAgICAgeyBcXFwicHJlYW1ibGVcXFwiOiBcXFwiY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcXCIgfVxcbi0tPlxcbmBgYGpzXFxuY29uc3QgYSA9IExpc3QoWyAxLCAyLCAzIF0pO1xcbmNvbnN0IGIgPSBMaXN0KFsgNCwgNSwgNiBdKTtcXG5jb25zdCBjID0gYS56aXAoYik7IC8vIExpc3QgWyBbIDEsIDQgXSwgWyAyLCA1IF0sIFsgMywgNiBdIF1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlclwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19XX0sXCJsaW5lXCI6MzUzNH0se1widHlwZVBhcmFtc1wiOltcIlVcIixcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib3RoZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19LHtcIm5hbWVcIjpcIm90aGVyMlwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfSxcImxpbmVcIjozNTM1fSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJsaW5lXCI6MzUzNn1dfSxcIiN6aXBBbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIENvbGxlY3Rpb24gXFxcInppcHBlZFxcXCIgd2l0aCB0aGUgcHJvdmlkZWQgY29sbGVjdGlvbnMuXCIsXCJkZXNjcmlwdGlvblwiOlwiVW5saWtlIGB6aXBgLCBgemlwQWxsYCBjb250aW51ZXMgemlwcGluZyB1bnRpbCB0aGUgbG9uZ2VzdCBjb2xsZWN0aW9uIGlzXFxuZXhoYXVzdGVkLiBNaXNzaW5nIHZhbHVlcyBmcm9tIHNob3J0ZXIgY29sbGVjdGlvbnMgYXJlIGZpbGxlZCB3aXRoIGB1bmRlZmluZWRgLlxcblxcbmBgYGpzXFxuY29uc3QgYSA9IExpc3QoWyAxLCAyIF0pO1xcbmNvbnN0IGIgPSBMaXN0KFsgMywgNCwgNSBdKTtcXG5jb25zdCBjID0gYS56aXBBbGwoYik7IC8vIExpc3QgWyBbIDEsIDMgXSwgWyAyLCA0IF0sIFsgdW5kZWZpbmVkLCA1IF0gXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJVXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX1dfSxcImxpbmVcIjozNTUwfSx7XCJ0eXBlUGFyYW1zXCI6W1wiVVwiLFwiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvdGhlclwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfX0se1wibmFtZVwiOlwib3RoZXIyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfV19LFwibGluZVwiOjM1NTF9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSxcImxpbmVcIjozNTUyfV19LFwiI3ppcFdpdGhcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZSBcXFwiemlwcGVkXFxcIiB3aXRoIHRoZSBwcm92aWRlZFxcbmNvbGxlY3Rpb25zIGJ5IHVzaW5nIGEgY3VzdG9tIGB6aXBwZXJgIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlXFxuICAgICB7IFxcXCJwcmVhbWJsZVxcXCI6IFxcXCJjb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxcIiB9XFxuLS0+XFxuYGBganNcXG5jb25zdCBhID0gTGlzdChbIDEsIDIsIDMgXSk7XFxuY29uc3QgYiA9IExpc3QoWyA0LCA1LCA2IF0pO1xcbmNvbnN0IGMgPSBhLnppcFdpdGgoKGEsIGIpID0+IGEgKyBiLCBiKTtcXG4vLyBMaXN0IFsgNSwgNywgOSBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlVcIixcIlpcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiemlwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJvdGhlclZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlpcIn19fSx7XCJuYW1lXCI6XCJvdGhlckNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJVXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9XX0sXCJsaW5lXCI6MzU2OH0se1widHlwZVBhcmFtc1wiOltcIlVcIixcIlZcIixcIlpcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiemlwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJvdGhlclZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifX0se1wibmFtZVwiOlwidGhpcmRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9fX0se1wibmFtZVwiOlwib3RoZXJDb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19fSx7XCJuYW1lXCI6XCJ0aGlyZENvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjE3fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJaXCJ9XX0sXCJsaW5lXCI6MzU3Mn0se1widHlwZVBhcmFtc1wiOltcIlpcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiemlwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiYW55XCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlpcIn19fSx7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlpcIn1dfSxcImxpbmVcIjozNTc3fV19fX0se1widGl0bGVcIjpcIlNlYXJjaCBmb3IgdmFsdWVcIixcIm1lbWJlcnNcIjp7XCIjaW5kZXhPZlwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIHZhbHVlIGNhbiBiZSBmb3VuZCBpbiB0aGVcXG5Db2xsZWN0aW9uLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwic2VhcmNoVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjJ9LFwibGluZVwiOjM1ODl9XX0sXCIjbGFzdEluZGV4T2ZcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyB0aGUgbGFzdCBpbmRleCBhdCB3aGljaCBhIGdpdmVuIHZhbHVlIGNhbiBiZSBmb3VuZCBpbiB0aGVcXG5Db2xsZWN0aW9uLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwic2VhcmNoVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjJ9LFwibGluZVwiOjM1OTV9XX0sXCIjZmluZEluZGV4XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdGhlIGZpcnN0IGluZGV4IGluIHRoZSBDb2xsZWN0aW9uIHdoZXJlIGEgdmFsdWUgc2F0aXNmaWVzIHRoZVxcbnByb3ZpZGVkIHByZWRpY2F0ZSBmdW5jdGlvbi4gT3RoZXJ3aXNlIC0xIGlzIHJldHVybmVkLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjJ9LFwibGluZVwiOjM2MDF9XX0sXCIjZmluZExhc3RJbmRleFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSBsYXN0IGluZGV4IGluIHRoZSBDb2xsZWN0aW9uIHdoZXJlIGEgdmFsdWUgc2F0aXNmaWVzIHRoZVxcbnByb3ZpZGVkIHByZWRpY2F0ZSBmdW5jdGlvbi4gT3RoZXJ3aXNlIC0xIGlzIHJldHVybmVkLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImluZGV4XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjJ9LFwibGluZVwiOjM2MTB9XX19fSx7XCJ0aXRsZVwiOlwiU2VxdWVuY2UgYWxnb3JpdGhtc1wiLFwibWVtYmVyc1wiOntcIiNjb25jYXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIHdpdGggb3RoZXIgY29sbGVjdGlvbnMgY29uY2F0ZW5hdGVkIHRvIHRoaXMgb25lLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlc09yQ29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifV19LHtcImtcIjo4LFwicGFyYW1cIjpcIkNcIn1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIkNcIn1dfV19LFwibGluZVwiOjM2MjB9XX0sXCIjbWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbi5JbmRleGVkIHdpdGggdmFsdWVzIHBhc3NlZCB0aHJvdWdoIGFcXG5gbWFwcGVyYCBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJgYGBqc1xcbmNvbnN0IHsgQ29sbGVjdGlvbiB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5Db2xsZWN0aW9uLkluZGV4ZWQoWzEsMl0pLm1hcCh4ID0+IDEwICogeClcXG4vLyBTZXEgWyAxLCAyIF1cXG5gYGBcXG5cXG5Ob3RlOiBgbWFwKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHByb2R1Y2VkIHRoZVxcbnNhbWUgdmFsdWUgYXQgZXZlcnkgc3RlcC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6MzYzNX1dfSxcIiNmbGF0TWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkZsYXQtbWFwcyB0aGUgQ29sbGVjdGlvbiwgcmV0dXJuaW5nIGEgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlNpbWlsYXIgdG8gYGNvbGxlY3Rpb24ubWFwKC4uLikuZmxhdHRlbih0cnVlKWAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjozNjQ1fV19LFwiI2ZpbHRlclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gd2l0aCBvbmx5IHRoZSB2YWx1ZXMgZm9yIHdoaWNoIHRoZSBgcHJlZGljYXRlYFxcbmZ1bmN0aW9uIHJldHVybnMgdHJ1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgZmlsdGVyKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHJlc3VsdHMgaW5cXG5ub3QgZmlsdGVyaW5nIG91dCBhbnkgdmFsdWVzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJGXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJGXCJ9XX0sXCJsaW5lXCI6MzY1N30se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaW5kZXhcIixcInR5cGVcIjp7XCJrXCI6Mn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjozNjYxfV19LFwiI1tTeW1ib2wuaXRlcmF0b3JdXCI6e1wic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZUl0ZXJhdG9yXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjozNjY2fV19fX1dfX0sXCJTZXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiU2V0IENvbGxlY3Rpb25zIG9ubHkgcmVwcmVzZW50IHZhbHVlcy4gVGhleSBoYXZlIG5vIGFzc29jaWF0ZWQga2V5cyBvclxcbmluZGljZXMuIER1cGxpY2F0ZSB2YWx1ZXMgYXJlIHBvc3NpYmxlIGluIHRoZSBsYXp5IGBTZXEuU2V0YHMsIGhvd2V2ZXJcXG50aGUgY29uY3JldGUgYFNldGAgQ29sbGVjdGlvbiBkb2VzIG5vdCBhbGxvdyBkdXBsaWNhdGUgdmFsdWVzLlwiLFwiZGVzY3JpcHRpb25cIjpcIkNvbGxlY3Rpb24gbWV0aG9kcyBvbiBDb2xsZWN0aW9uLlNldCBzdWNoIGFzIGBtYXBgIGFuZCBgZm9yRWFjaGAgd2lsbCBwcm92aWRlXFxudGhlIHZhbHVlIGFzIGJvdGggdGhlIGZpcnN0IGFuZCBzZWNvbmQgYXJndW1lbnRzIHRvIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cXG5cXG5gYGBqc1xcbmNvbnN0IHsgQ29sbGVjdGlvbiB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBzZXEgPSBDb2xsZWN0aW9uLlNldChbICdBJywgJ0InLCAnQycgXSlcXG4vLyBTZXEgeyBcXFwiQVxcXCIsIFxcXCJCXFxcIiwgXFxcIkNcXFwiIH1cXG5zZXEuZm9yRWFjaCgodiwgaykgPT5cXG4gYXNzZXJ0LmVxdWFsKHYsIGspXFxuKVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJtb2R1bGVcIjp7fSxcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiU2ltaWxhciB0byBgQ29sbGVjdGlvbigpYCwgYnV0IGFsd2F5cyByZXR1cm5zIGEgQ29sbGVjdGlvbi5TZXQuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYENvbGxlY3Rpb24uU2V0YCBpcyBhIGZhY3RvcnkgZnVuY3Rpb24gYW5kIG5vdCBhIGNsYXNzLCBhbmQgZG9lc1xcbm5vdCB1c2UgdGhlIGBuZXdgIGtleXdvcmQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjozNjk1fV19LFwiaW50ZXJmYWNlXCI6e1wibGluZVwiOjM2OTcsXCJ0eXBlUGFyYW1zXCI6W1wiVFwiXSxcImV4dGVuZHNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19XSxcImdyb3Vwc1wiOlt7XCJtZW1iZXJzXCI6e1wiI3RvSlNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRGVlcGx5IGNvbnZlcnRzIHRoaXMgU2V0IGNvbGxlY3Rpb24gdG8gZXF1aXZhbGVudCBuYXRpdmUgSmF2YVNjcmlwdCBBcnJheS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJsaW5lXCI6MzcwMX1dfSxcIiN0b0pTT05cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiU2hhbGxvd2x5IGNvbnZlcnRzIHRoaXMgU2V0IGNvbGxlY3Rpb24gdG8gZXF1aXZhbGVudCBuYXRpdmUgSmF2YVNjcmlwdCBBcnJheS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9XX0sXCJsaW5lXCI6MzcwNn1dfSxcIiN0b0FycmF5XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIGNvbGxlY3Rpb24gdG8gYW4gQXJyYXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjM3MTF9XX0sXCIjdG9TZXFcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBTZXEuU2V0LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5TZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjM3MTd9XX19fSx7XCJ0aXRsZVwiOlwiU2VxdWVuY2UgYWxnb3JpdGhtc1wiLFwibWVtYmVyc1wiOntcIiNjb25jYXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIHdpdGggb3RoZXIgY29sbGVjdGlvbnMgY29uY2F0ZW5hdGVkIHRvIHRoaXMgb25lLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJVXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlVcIn1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uU2V0XCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVVwifV19XX0sXCJsaW5lXCI6MzcyNH1dfSxcIiNtYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uLlNldCB3aXRoIHZhbHVlcyBwYXNzZWQgdGhyb3VnaCBhXFxuYG1hcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiYGBgXFxuQ29sbGVjdGlvbi5TZXQoWyAxLCAyIF0pLm1hcCh4ID0+IDEwICogeClcXG4vLyBTZXEgeyAxLCAyIH1cXG5gYGBcXG5cXG5Ob3RlOiBgbWFwKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHByb2R1Y2VkIHRoZVxcbnNhbWUgdmFsdWUgYXQgZXZlcnkgc3RlcC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLlNldFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6MzczOH1dfSxcIiNmbGF0TWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkZsYXQtbWFwcyB0aGUgQ29sbGVjdGlvbiwgcmV0dXJuaW5nIGEgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlNpbWlsYXIgdG8gYGNvbGxlY3Rpb24ubWFwKC4uLikuZmxhdHRlbih0cnVlKWAuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk1cIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiTVwifV19fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb24uU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjozNzQ4fV19LFwiI2ZpbHRlclwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gd2l0aCBvbmx5IHRoZSB2YWx1ZXMgZm9yIHdoaWNoIHRoZSBgcHJlZGljYXRlYFxcbmZ1bmN0aW9uIHJldHVybnMgdHJ1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgZmlsdGVyKClgIGFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIGl0IHJlc3VsdHMgaW5cXG5ub3QgZmlsdGVyaW5nIG91dCBhbnkgdmFsdWVzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJGXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5TZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiRlwifV19LFwibGluZVwiOjM3NjB9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjozNzY0fV19LFwiI1tTeW1ib2wuaXRlcmF0b3JdXCI6e1wic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZUl0ZXJhdG9yXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlRcIn1dfSxcImxpbmVcIjozNzY5fV19fX1dfX19LFwiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDcmVhdGVzIGEgQ29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJUaGUgdHlwZSBvZiBDb2xsZWN0aW9uIGNyZWF0ZWQgaXMgYmFzZWQgb24gdGhlIGlucHV0LlxcblxcbiAgKiBJZiBhbiBgQ29sbGVjdGlvbmAsIHRoYXQgc2FtZSBgQ29sbGVjdGlvbmAuXFxuICAqIElmIGFuIEFycmF5LWxpa2UsIGFuIGBDb2xsZWN0aW9uLkluZGV4ZWRgLlxcbiAgKiBJZiBhbiBPYmplY3Qgd2l0aCBhbiBJdGVyYXRvciBkZWZpbmVkLCBhbiBgQ29sbGVjdGlvbi5JbmRleGVkYC5cXG4gICogSWYgYW4gT2JqZWN0LCBhbiBgQ29sbGVjdGlvbi5LZXllZGAuXFxuXFxuVGhpcyBtZXRob2RzIGZvcmNlcyB0aGUgY29udmVyc2lvbiBvZiBPYmplY3RzIGFuZCBTdHJpbmdzIHRvIENvbGxlY3Rpb25zLlxcbklmIHlvdSB3YW50IHRvIGVuc3VyZSB0aGF0IGEgQ29sbGVjdGlvbiBvZiBvbmUgaXRlbSBpcyByZXR1cm5lZCwgdXNlXFxuYFNlcS5vZmAuXFxuXFxuTm90ZTogQW4gSXRlcmF0b3IgaXRzZWxmIHdpbGwgYmUgdHJlYXRlZCBhcyBhbiBvYmplY3QsIGJlY29taW5nIGEgYFNlcS5LZXllZGAsXFxud2hpY2ggaXMgdXN1YWxseSBub3Qgd2hhdCB5b3Ugd2FudC4gWW91IHNob3VsZCB0dXJuIHlvdXIgSXRlcmF0b3IgT2JqZWN0IGludG9cXG5hbiBpdGVyYWJsZSBvYmplY3QgYnkgZGVmaW5pbmcgYSBTeW1ib2wuaXRlcmF0b3IgKG9yIEBAaXRlcmF0b3IpIG1ldGhvZCB3aGljaFxcbnJldHVybnMgYHRoaXNgLlxcblxcbk5vdGU6IGBDb2xsZWN0aW9uYCBpcyBhIGNvbnZlcnNpb24gZnVuY3Rpb24gYW5kIG5vdCBhIGNsYXNzLCBhbmQgZG9lcyBub3RcXG51c2UgdGhlIGBuZXdgIGtleXdvcmQgZHVyaW5nIGNvbnN0cnVjdGlvbi5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiSVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiSVwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIklcIn0sXCJsaW5lXCI6Mzc5Nn0se1widHlwZVBhcmFtc1wiOltcIlRcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFwifV19LFwibGluZVwiOjM3OTd9LHtcInR5cGVQYXJhbXNcIjpbXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm9ialwiLFwidHlwZVwiOntcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dfX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6M30se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjM3OTh9XX0sXCJpbnRlcmZhY2VcIjp7XCJsaW5lXCI6MzgwMCxcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCJdLFwiZXh0ZW5kc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIlZhbHVlT2JqZWN0XCJ9XSxcImdyb3Vwc1wiOlt7XCJ0aXRsZVwiOlwiVmFsdWUgZXF1YWxpdHlcIixcIm1lbWJlcnNcIjp7XCIjZXF1YWxzXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgdGhpcyBhbmQgdGhlIG90aGVyIENvbGxlY3Rpb24gaGF2ZSB2YWx1ZSBlcXVhbGl0eSwgYXMgZGVmaW5lZFxcbmJ5IGBJbW11dGFibGUuaXMoKWAuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogVGhpcyBpcyBlcXVpdmFsZW50IHRvIGBJbW11dGFibGUuaXModGhpcywgb3RoZXIpYCwgYnV0IHByb3ZpZGVkIHRvXFxuYWxsb3cgZm9yIGNoYWluZWQgZXhwcmVzc2lvbnMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjozODExfV19LFwiI2hhc2hDb2RlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNvbXB1dGVzIGFuZCByZXR1cm5zIHRoZSBoYXNoZWQgaWRlbnRpdHkgZm9yIHRoaXMgQ29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJUaGUgYGhhc2hDb2RlYCBvZiBhIENvbGxlY3Rpb24gaXMgdXNlZCB0byBkZXRlcm1pbmUgcG90ZW50aWFsIGVxdWFsaXR5LFxcbmFuZCBpcyB1c2VkIHdoZW4gYWRkaW5nIHRoaXMgdG8gYSBgU2V0YCBvciBhcyBhIGtleSBpbiBhIGBNYXBgLCBlbmFibGluZ1xcbmxvb2t1cCB2aWEgYSBkaWZmZXJlbnQgaW5zdGFuY2UuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGVcXG4gICAgIHsgXFxcInByZWFtYmxlXFxcIjogXFxcImNvbnN0IHsgU2V0LCAgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXFwiIH1cXG4tLT5cXG5gYGBqc1xcbmNvbnN0IGEgPSBMaXN0KFsgMSwgMiwgMyBdKTtcXG5jb25zdCBiID0gTGlzdChbIDEsIDIsIDMgXSk7XFxuYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKGEsIGIpOyAvLyBkaWZmZXJlbnQgaW5zdGFuY2VzXFxuY29uc3Qgc2V0ID0gU2V0KFsgYSBdKTtcXG5hc3NlcnQuZXF1YWwoc2V0LmhhcyhiKSwgdHJ1ZSk7XFxuYGBgXFxuXFxuSWYgdHdvIHZhbHVlcyBoYXZlIHRoZSBzYW1lIGBoYXNoQ29kZWAsIHRoZXkgYXJlIFtub3QgZ3VhcmFudGVlZFxcbnRvIGJlIGVxdWFsXVtIYXNoIENvbGxpc2lvbl0uIElmIHR3byB2YWx1ZXMgaGF2ZSBkaWZmZXJlbnQgYGhhc2hDb2RlYHMsXFxudGhleSBtdXN0IG5vdCBiZSBlcXVhbC5cXG5cXG5bSGFzaCBDb2xsaXNpb25dOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbGxpc2lvbl8oY29tcHV0ZXJfc2NpZW5jZSlcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjJ9LFwibGluZVwiOjM4Mzd9XX19fSx7XCJ0aXRsZVwiOlwiUmVhZGluZyB2YWx1ZXNcIixcIm1lbWJlcnNcIjp7XCIjZ2V0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQga2V5LCBvciBub3RTZXRWYWx1ZSBpZlxcbnRoZSBDb2xsZWN0aW9uIGRvZXMgbm90IGNvbnRhaW4gdGhpcyBrZXkuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogaXQgaXMgcG9zc2libGUgYSBrZXkgbWF5IGJlIGFzc29jaWF0ZWQgd2l0aCBhbiBgdW5kZWZpbmVkYCB2YWx1ZSxcXG5zbyBpZiBgbm90U2V0VmFsdWVgIGlzIG5vdCBwcm92aWRlZCBhbmQgdGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYCxcXG50aGF0IGRvZXMgbm90IGd1YXJhbnRlZSB0aGUga2V5IHdhcyBub3QgZm91bmQuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIk5TVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifX1dLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiTlNWXCJ9XX0sXCJsaW5lXCI6Mzg1MH0se1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjoxMX1dfSxcImxpbmVcIjozODUxfV19LFwiI2hhc1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGEga2V5IGV4aXN0cyB3aXRoaW4gdGhpcyBgQ29sbGVjdGlvbmAsIHVzaW5nIGBJbW11dGFibGUuaXNgXFxudG8gZGV0ZXJtaW5lIGVxdWFsaXR5XCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6Mzg1N31dfSxcIiNpbmNsdWRlc1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGEgdmFsdWUgZXhpc3RzIHdpdGhpbiB0aGlzIGBDb2xsZWN0aW9uYCwgdXNpbmcgYEltbXV0YWJsZS5pc2BcXG50byBkZXRlcm1pbmUgZXF1YWxpdHlcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W3tcIm5hbWVcIjpcImFsaWFzXCIsXCJib2R5XCI6XCJjb250YWluc1wifV19LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjM4NjR9XX0sXCIjZmlyc3RcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiSW4gY2FzZSB0aGUgYENvbGxlY3Rpb25gIGlzIG5vdCBlbXB0eSByZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZVxcbmBDb2xsZWN0aW9uYC5cXG5JbiBjYXNlIHRoZSBgQ29sbGVjdGlvbmAgaXMgZW1wdHkgcmV0dXJucyB0aGUgb3B0aW9uYWwgZGVmYXVsdFxcbnZhbHVlIGlmIHByb3ZpZGVkLCBpZiBubyBkZWZhdWx0IHZhbHVlIGlzIHByb3ZpZGVkIHJldHVybnMgdW5kZWZpbmVkLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJOU1ZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifV19LFwibGluZVwiOjM4NzN9XX0sXCIjbGFzdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJJbiBjYXNlIHRoZSBgQ29sbGVjdGlvbmAgaXMgbm90IGVtcHR5IHJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGVcXG5gQ29sbGVjdGlvbmAuXFxuSW4gY2FzZSB0aGUgYENvbGxlY3Rpb25gIGlzIGVtcHR5IHJldHVybnMgdGhlIG9wdGlvbmFsIGRlZmF1bHRcXG52YWx1ZSBpZiBwcm92aWRlZCwgaWYgbm8gZGVmYXVsdCB2YWx1ZSBpcyBwcm92aWRlZCByZXR1cm5zIHVuZGVmaW5lZC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTlNWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm5vdFNldFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiTlNWXCJ9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn1dfSxcImxpbmVcIjozODgxfV19fX0se1widGl0bGVcIjpcIlJlYWRpbmcgZGVlcCB2YWx1ZXNcIixcIm1lbWJlcnNcIjp7XCIjZ2V0SW5cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyB0aGUgdmFsdWUgZm91bmQgYnkgZm9sbG93aW5nIGEgcGF0aCBvZiBrZXlzIG9yIGluZGljZXMgdGhyb3VnaFxcbm5lc3RlZCBDb2xsZWN0aW9ucy5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwLCBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IGRlZXBEYXRhID0gTWFwKHsgeDogTGlzdChbIE1hcCh7IHk6IDEyMyB9KSBdKSB9KTtcXG5kZWVwRGF0YS5nZXRJbihbJ3gnLCAwLCAneSddKSAvLyAxMjNcXG5gYGBcXG5cXG5QbGFpbiBKYXZhU2NyaXB0IE9iamVjdCBvciBBcnJheXMgbWF5IGJlIG5lc3RlZCB3aXRoaW4gYW4gSW1tdXRhYmxlLmpzXFxuQ29sbGVjdGlvbiwgYW5kIGdldEluKCkgY2FuIGFjY2VzcyB0aG9zZSB2YWx1ZXMgYXMgd2VsbDpcXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwLCBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IGRlZXBEYXRhID0gTWFwKHsgeDogWyB7IHk6IDEyMyB9IF0gfSk7XFxuZGVlcERhdGEuZ2V0SW4oWyd4JywgMCwgJ3knXSkgLy8gMTIzXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInNlYXJjaEtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjE3fSxcImxpbmVcIjozOTA2fV19LFwiI2hhc0luXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgdGhlIHJlc3VsdCBvZiBmb2xsb3dpbmcgYSBwYXRoIG9mIGtleXMgb3IgaW5kaWNlcyB0aHJvdWdoIG5lc3RlZFxcbkNvbGxlY3Rpb25zIHJlc3VsdHMgaW4gYSBzZXQgdmFsdWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInNlYXJjaEtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjozOTEyfV19fX0se1widGl0bGVcIjpcIlBlcnNpc3RlbnQgY2hhbmdlc1wiLFwibWVtYmVyc1wiOntcIiN1cGRhdGVcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVGhpcyBjYW4gYmUgdmVyeSB1c2VmdWwgYXMgYSB3YXkgdG8gXFxcImNoYWluXFxcIiBhIG5vcm1hbCBmdW5jdGlvbiBpbnRvIGFcXG5zZXF1ZW5jZSBvZiBtZXRob2RzLiBSeEpTIGNhbGxzIHRoaXMgXFxcImxldFxcXCIgYW5kIGxvZGFzaCBjYWxscyBpdCBcXFwidGhydVxcXCIuXCIsXCJkZXNjcmlwdGlvblwiOlwiRm9yIGV4YW1wbGUsIHRvIHN1bSBhIFNlcSBhZnRlciBtYXBwaW5nIGFuZCBmaWx0ZXJpbmc6XFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IFNlcSB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5cXG5mdW5jdGlvbiBzdW0oY29sbGVjdGlvbikge1xcbiAgcmV0dXJuIGNvbGxlY3Rpb24ucmVkdWNlKChzdW0sIHgpID0+IHN1bSArIHgsIDApXFxufVxcblxcblNlcShbIDEsIDIsIDMgXSlcXG4gIC5tYXAoeCA9PiB4ICsgMSlcXG4gIC5maWx0ZXIoeCA9PiB4ICUgMiA9PT0gMClcXG4gIC51cGRhdGUoc3VtKVxcbi8vIDZcXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiUlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ1cGRhdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiUlwifX19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJSXCJ9LFwibGluZVwiOjM5Mzd9XX19fSx7XCJ0aXRsZVwiOlwiQ29udmVyc2lvbiB0byBKYXZhU2NyaXB0IHR5cGVzXCIsXCJtZW1iZXJzXCI6e1wiI3RvSlNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRGVlcGx5IGNvbnZlcnRzIHRoaXMgQ29sbGVjdGlvbiB0byBlcXVpdmFsZW50IG5hdGl2ZSBKYXZhU2NyaXB0IEFycmF5IG9yIE9iamVjdC5cIixcImRlc2NyaXB0aW9uXCI6XCJgQ29sbGVjdGlvbi5JbmRleGVkYCwgYW5kIGBDb2xsZWN0aW9uLlNldGAgYmVjb21lIGBBcnJheWAsIHdoaWxlXFxuYENvbGxlY3Rpb24uS2V5ZWRgIGJlY29tZSBgT2JqZWN0YCwgY29udmVydGluZyBrZXlzIHRvIFN0cmluZ3MuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LHtcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX1dfV19LFwibGluZVwiOjM5NDh9XX0sXCIjdG9KU09OXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlNoYWxsb3dseSBjb252ZXJ0cyB0aGlzIENvbGxlY3Rpb24gdG8gZXF1aXZhbGVudCBuYXRpdmUgSmF2YVNjcmlwdCBBcnJheSBvciBPYmplY3QuXCIsXCJkZXNjcmlwdGlvblwiOlwiYENvbGxlY3Rpb24uSW5kZXhlZGAsIGFuZCBgQ29sbGVjdGlvbi5TZXRgIGJlY29tZSBgQXJyYXlgLCB3aGlsZVxcbmBDb2xsZWN0aW9uLktleWVkYCBiZWNvbWUgYE9iamVjdGAsIGNvbnZlcnRpbmcga2V5cyB0byBTdHJpbmdzLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSx7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XX1dfSxcImxpbmVcIjozOTU2fV19LFwiI3RvQXJyYXlcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiU2hhbGxvd2x5IGNvbnZlcnRzIHRoaXMgY29sbGVjdGlvbiB0byBhbiBBcnJheS5cIixcImRlc2NyaXB0aW9uXCI6XCJgQ29sbGVjdGlvbi5JbmRleGVkYCwgYW5kIGBDb2xsZWN0aW9uLlNldGAgcHJvZHVjZSBhbiBBcnJheSBvZiB2YWx1ZXMuXFxuYENvbGxlY3Rpb24uS2V5ZWRgIHByb2R1Y2UgYW4gQXJyYXkgb2YgW2tleSwgdmFsdWVdIHR1cGxlcy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0se1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfV19XX0sXCJsaW5lXCI6Mzk2NH1dfSxcIiN0b09iamVjdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJTaGFsbG93bHkgY29udmVydHMgdGhpcyBDb2xsZWN0aW9uIHRvIGFuIE9iamVjdC5cIixcImRlc2NyaXB0aW9uXCI6XCJDb252ZXJ0cyBrZXlzIHRvIFN0cmluZ3MuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dfSxcImxpbmVcIjozOTcxfV19fX0se1widGl0bGVcIjpcIkNvbnZlcnNpb24gdG8gQ29sbGVjdGlvbnNcIixcIm1lbWJlcnNcIjp7XCIjdG9NYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQ29udmVydHMgdGhpcyBDb2xsZWN0aW9uIHRvIGEgTWFwLCBUaHJvd3MgaWYga2V5cyBhcmUgbm90IGhhc2hhYmxlLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IFRoaXMgaXMgZXF1aXZhbGVudCB0byBgTWFwKHRoaXMudG9LZXllZFNlcSgpKWAsIGJ1dCBwcm92aWRlZFxcbmZvciBjb252ZW5pZW5jZSBhbmQgdG8gYWxsb3cgZm9yIGNoYWluZWQgZXhwcmVzc2lvbnMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiTWFwXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjM5ODJ9XX0sXCIjdG9PcmRlcmVkTWFwXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNvbnZlcnRzIHRoaXMgQ29sbGVjdGlvbiB0byBhIE1hcCwgbWFpbnRhaW5pbmcgdGhlIG9yZGVyIG9mIGl0ZXJhdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gYE9yZGVyZWRNYXAodGhpcy50b0tleWVkU2VxKCkpYCwgYnV0XFxucHJvdmlkZWQgZm9yIGNvbnZlbmllbmNlIGFuZCB0byBhbGxvdyBmb3IgY2hhaW5lZCBleHByZXNzaW9ucy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkTWFwXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjM5OTB9XX0sXCIjdG9TZXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQ29udmVydHMgdGhpcyBDb2xsZWN0aW9uIHRvIGEgU2V0LCBkaXNjYXJkaW5nIGtleXMuIFRocm93cyBpZiB2YWx1ZXNcXG5hcmUgbm90IGhhc2hhYmxlLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IFRoaXMgaXMgZXF1aXZhbGVudCB0byBgU2V0KHRoaXMpYCwgYnV0IHByb3ZpZGVkIHRvIGFsbG93IGZvclxcbmNoYWluZWQgZXhwcmVzc2lvbnMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjozOTk5fV19LFwiI3RvT3JkZXJlZFNldFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDb252ZXJ0cyB0aGlzIENvbGxlY3Rpb24gdG8gYSBTZXQsIG1haW50YWluaW5nIHRoZSBvcmRlciBvZiBpdGVyYXRpb24gYW5kXFxuZGlzY2FyZGluZyBrZXlzLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IFRoaXMgaXMgZXF1aXZhbGVudCB0byBgT3JkZXJlZFNldCh0aGlzLnZhbHVlU2VxKCkpYCwgYnV0IHByb3ZpZGVkXFxuZm9yIGNvbnZlbmllbmNlIGFuZCB0byBhbGxvdyBmb3IgY2hhaW5lZCBleHByZXNzaW9ucy5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJPcmRlcmVkU2V0XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSxcImxpbmVcIjo0MDA4fV19LFwiI3RvTGlzdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDb252ZXJ0cyB0aGlzIENvbGxlY3Rpb24gdG8gYSBMaXN0LCBkaXNjYXJkaW5nIGtleXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiVGhpcyBpcyBzaW1pbGFyIHRvIGBMaXN0KGNvbGxlY3Rpb24pYCwgYnV0IHByb3ZpZGVkIHRvIGFsbG93IGZvciBjaGFpbmVkXFxuZXhwcmVzc2lvbnMuIEhvd2V2ZXIsIHdoZW4gY2FsbGVkIG9uIGBNYXBgIG9yIG90aGVyIGtleWVkIGNvbGxlY3Rpb25zLFxcbmBjb2xsZWN0aW9uLnRvTGlzdCgpYCBkaXNjYXJkcyB0aGUga2V5cyBhbmQgY3JlYXRlcyBhIGxpc3Qgb2Ygb25seSB0aGVcXG52YWx1ZXMsIHdoZXJlYXMgYExpc3QoY29sbGVjdGlvbilgIGNyZWF0ZXMgYSBsaXN0IG9mIGVudHJ5IHR1cGxlcy5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTWFwLCBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbnZhciBteU1hcCA9IE1hcCh7IGE6ICdBcHBsZScsIGI6ICdCYW5hbmEnIH0pXFxuTGlzdChteU1hcCkgLy8gTGlzdCBbIFsgXFxcImFcXFwiLCBcXFwiQXBwbGVcXFwiIF0sIFsgXFxcImJcXFwiLCBcXFwiQmFuYW5hXFxcIiBdIF1cXG5teU1hcC50b0xpc3QoKSAvLyBMaXN0IFsgXFxcIkFwcGxlXFxcIiwgXFxcIkJhbmFuYVxcXCIgXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkxpc3RcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjQwMjZ9XX0sXCIjdG9TdGFja1wiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJDb252ZXJ0cyB0aGlzIENvbGxlY3Rpb24gdG8gYSBTdGFjaywgZGlzY2FyZGluZyBrZXlzLiBUaHJvd3MgaWYgdmFsdWVzXFxuYXJlIG5vdCBoYXNoYWJsZS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gYFN0YWNrKHRoaXMpYCwgYnV0IHByb3ZpZGVkIHRvIGFsbG93IGZvclxcbmNoYWluZWQgZXhwcmVzc2lvbnMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU3RhY2tcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjQwMzV9XX19fSx7XCJ0aXRsZVwiOlwiQ29udmVyc2lvbiB0byBTZXFcIixcIm1lbWJlcnNcIjp7XCIjdG9TZXFcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQ29udmVydHMgdGhpcyBDb2xsZWN0aW9uIHRvIGEgU2VxIG9mIHRoZSBzYW1lIGtpbmQgKGluZGV4ZWQsXFxua2V5ZWQsIG9yIHNldCkuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjQwNDR9XX0sXCIjdG9LZXllZFNlcVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgU2VxLktleWVkIGZyb20gdGhpcyBDb2xsZWN0aW9uIHdoZXJlIGluZGljZXMgYXJlIHRyZWF0ZWQgYXMga2V5cy5cIixcImRlc2NyaXB0aW9uXCI6XCJUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byBvcGVyYXRlIG9uIGFuXFxuQ29sbGVjdGlvbi5JbmRleGVkIGFuZCBwcmVzZXJ2ZSB0aGUgW2luZGV4LCB2YWx1ZV0gcGFpcnMuXFxuXFxuVGhlIHJldHVybmVkIFNlcSB3aWxsIGhhdmUgaWRlbnRpY2FsIGl0ZXJhdGlvbiBvcmRlciBhc1xcbnRoaXMgQ29sbGVjdGlvbi5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgU2VxIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IGluZGV4ZWRTZXEgPSBTZXEoWyAnQScsICdCJywgJ0MnIF0pXFxuLy8gU2VxIFsgXFxcIkFcXFwiLCBcXFwiQlxcXCIsIFxcXCJDXFxcIiBdXFxuaW5kZXhlZFNlcS5maWx0ZXIodiA9PiB2ID09PSAnQicpXFxuLy8gU2VxIFsgXFxcIkJcXFwiIF1cXG5jb25zdCBrZXllZFNlcSA9IGluZGV4ZWRTZXEudG9LZXllZFNlcSgpXFxuLy8gU2VxIHsgMDogXFxcIkFcXFwiLCAxOiBcXFwiQlxcXCIsIDI6IFxcXCJDXFxcIiB9XFxua2V5ZWRTZXEuZmlsdGVyKHYgPT4gdiA9PT0gJ0InKVxcbi8vIFNlcSB7IDE6IFxcXCJCXFxcIiB9XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjQwNjh9XX0sXCIjdG9JbmRleGVkU2VxXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYW4gU2VxLkluZGV4ZWQgb2YgdGhlIHZhbHVlcyBvZiB0aGlzIENvbGxlY3Rpb24sIGRpc2NhcmRpbmcga2V5cy5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6NDA3M31dfSxcIiN0b1NldFNlcVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgU2VxLlNldCBvZiB0aGUgdmFsdWVzIG9mIHRoaXMgQ29sbGVjdGlvbiwgZGlzY2FyZGluZyBrZXlzLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5TZXRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjQwNzh9XX19fSx7XCJ0aXRsZVwiOlwiSXRlcmF0b3JzXCIsXCJtZW1iZXJzXCI6e1wiI2tleXNcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiQW4gaXRlcmF0b3Igb2YgdGhpcyBgQ29sbGVjdGlvbmAncyBrZXlzLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IHRoaXMgd2lsbCByZXR1cm4gYW4gRVM2IGl0ZXJhdG9yIHdoaWNoIGRvZXMgbm90IHN1cHBvcnRcXG5JbW11dGFibGUuanMgc2VxdWVuY2UgYWxnb3JpdGhtcy4gVXNlIGBrZXlTZXFgIGluc3RlYWQsIGlmIHRoaXMgaXNcXG53aGF0IHlvdSB3YW50LlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlSXRlcmF0b3JcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifV19LFwibGluZVwiOjQwOTB9XX0sXCIjdmFsdWVzXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkFuIGl0ZXJhdG9yIG9mIHRoaXMgYENvbGxlY3Rpb25gJ3MgdmFsdWVzLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IHRoaXMgd2lsbCByZXR1cm4gYW4gRVM2IGl0ZXJhdG9yIHdoaWNoIGRvZXMgbm90IHN1cHBvcnRcXG5JbW11dGFibGUuanMgc2VxdWVuY2UgYWxnb3JpdGhtcy4gVXNlIGB2YWx1ZVNlcWAgaW5zdGVhZCwgaWYgdGhpcyBpc1xcbndoYXQgeW91IHdhbnQuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVJdGVyYXRvclwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6NDA5OX1dfSxcIiNlbnRyaWVzXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkFuIGl0ZXJhdG9yIG9mIHRoaXMgYENvbGxlY3Rpb25gJ3MgZW50cmllcyBhcyBgWyBrZXksIHZhbHVlIF1gIHR1cGxlcy5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiB0aGlzIHdpbGwgcmV0dXJuIGFuIEVTNiBpdGVyYXRvciB3aGljaCBkb2VzIG5vdCBzdXBwb3J0XFxuSW1tdXRhYmxlLmpzIHNlcXVlbmNlIGFsZ29yaXRobXMuIFVzZSBgZW50cnlTZXFgIGluc3RlYWQsIGlmIHRoaXMgaXNcXG53aGF0IHlvdSB3YW50LlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlSXRlcmF0b3JcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX1dfSxcImxpbmVcIjo0MTA4fV19fX0se1widGl0bGVcIjpcIkNvbGxlY3Rpb25zIChTZXEpXCIsXCJtZW1iZXJzXCI6e1wiI2tleVNlcVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IFNlcS5JbmRleGVkIG9mIHRoZSBrZXlzIG9mIHRoaXMgQ29sbGVjdGlvbixcXG5kaXNjYXJkaW5nIHZhbHVlcy5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJTZXEuSW5kZXhlZFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9XX0sXCJsaW5lXCI6NDExN31dfSxcIiN2YWx1ZVNlcVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGFuIFNlcS5JbmRleGVkIG9mIHRoZSB2YWx1ZXMgb2YgdGhpcyBDb2xsZWN0aW9uLCBkaXNjYXJkaW5nIGtleXMuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLkluZGV4ZWRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjQxMjJ9XX0sXCIjZW50cnlTZXFcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBTZXEuSW5kZXhlZCBvZiBba2V5LCB2YWx1ZV0gdHVwbGVzLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIlNlcS5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX0sXCJsaW5lXCI6NDEyN31dfX19LHtcInRpdGxlXCI6XCJTZXF1ZW5jZSBhbGdvcml0aG1zXCIsXCJtZW1iZXJzXCI6e1wiI21hcFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZSB3aXRoIHZhbHVlcyBwYXNzZWQgdGhyb3VnaCBhXFxuYG1hcHBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IENvbGxlY3Rpb24gfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuQ29sbGVjdGlvbih7IGE6IDEsIGI6IDIgfSkubWFwKHggPT4gMTAgKiB4KVxcbi8vIFNlcSB7IFxcXCJhXFxcIjogMTAsIFxcXCJiXFxcIjogMjAgfVxcbmBgYFxcblxcbk5vdGU6IGBtYXAoKWAgYWx3YXlzIHJldHVybnMgYSBuZXcgaW5zdGFuY2UsIGV2ZW4gaWYgaXQgcHJvZHVjZWQgdGhlIHNhbWVcXG52YWx1ZSBhdCBldmVyeSBzdGVwLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkNvbGxlY3Rpb25cIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX0sXCJsaW5lXCI6NDE0Nn1dfSxcIiNmaWx0ZXJcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgd2l0aCBvbmx5IHRoZSBlbnRyaWVzIGZvciB3aGljaFxcbnRoZSBgcHJlZGljYXRlYCBmdW5jdGlvbiByZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IE1hcCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5NYXAoeyBhOiAxLCBiOiAyLCBjOiAzLCBkOiA0fSkuZmlsdGVyKHggPT4geCAlIDIgPT09IDApXFxuLy8gTWFwIHsgXFxcImJcXFwiOiAyLCBcXFwiZFxcXCI6IDQgfVxcbmBgYFxcblxcbk5vdGU6IGBmaWx0ZXIoKWAgYWx3YXlzIHJldHVybnMgYSBuZXcgaW5zdGFuY2UsIGV2ZW4gaWYgaXQgcmVzdWx0cyBpblxcbm5vdCBmaWx0ZXJpbmcgb3V0IGFueSB2YWx1ZXMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiRlwifV19LFwibGluZVwiOjQxNzN9LHtcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo0MTc3fV19LFwiI2ZpbHRlck5vdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZSB3aXRoIG9ubHkgdGhlIGVudHJpZXMgZm9yIHdoaWNoXFxudGhlIGBwcmVkaWNhdGVgIGZ1bmN0aW9uIHJldHVybnMgZmFsc2UuXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IE1hcCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5NYXAoeyBhOiAxLCBiOiAyLCBjOiAzLCBkOiA0fSkuZmlsdGVyTm90KHggPT4geCAlIDIgPT09IDApXFxuLy8gTWFwIHsgXFxcImFcXFwiOiAxLCBcXFwiY1xcXCI6IDMgfVxcbmBgYFxcblxcbk5vdGU6IGBmaWx0ZXJOb3QoKWAgYWx3YXlzIHJldHVybnMgYSBuZXcgaW5zdGFuY2UsIGV2ZW4gaWYgaXQgcmVzdWx0cyBpblxcbm5vdCBmaWx0ZXJpbmcgb3V0IGFueSB2YWx1ZXMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NDE5Nn1dfSxcIiNyZXZlcnNlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIGluIHJldmVyc2Ugb3JkZXIuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NDIwNH1dfSxcIiNzb3J0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIHdoaWNoIGluY2x1ZGVzIHRoZSBzYW1lIGVudHJpZXMsXFxuc3RhYmx5IHNvcnRlZCBieSB1c2luZyBhIGBjb21wYXJhdG9yYC5cIixcImRlc2NyaXB0aW9uXCI6XCJJZiBhIGBjb21wYXJhdG9yYCBpcyBub3QgcHJvdmlkZWQsIGEgZGVmYXVsdCBjb21wYXJhdG9yIHVzZXMgYDxgIGFuZCBgPmAuXFxuXFxuYGNvbXBhcmF0b3IodmFsdWVBLCB2YWx1ZUIpYDpcXG5cXG4gICogUmV0dXJucyBgMGAgaWYgdGhlIGVsZW1lbnRzIHNob3VsZCBub3QgYmUgc3dhcHBlZC5cXG4gICogUmV0dXJucyBgLTFgIChvciBhbnkgbmVnYXRpdmUgbnVtYmVyKSBpZiBgdmFsdWVBYCBjb21lcyBiZWZvcmUgYHZhbHVlQmBcXG4gICogUmV0dXJucyBgMWAgKG9yIGFueSBwb3NpdGl2ZSBudW1iZXIpIGlmIGB2YWx1ZUFgIGNvbWVzIGFmdGVyIGB2YWx1ZUJgXFxuICAqIElzIHB1cmUsIGkuZS4gaXQgbXVzdCBhbHdheXMgcmV0dXJuIHRoZSBzYW1lIHZhbHVlIGZvciB0aGUgc2FtZSBwYWlyXFxuICAgIG9mIHZhbHVlcy5cXG5cXG5XaGVuIHNvcnRpbmcgY29sbGVjdGlvbnMgd2hpY2ggaGF2ZSBubyBkZWZpbmVkIG9yZGVyLCB0aGVpciBvcmRlcmVkXFxuZXF1aXZhbGVudHMgd2lsbCBiZSByZXR1cm5lZC4gZS5nLiBgbWFwLnNvcnQoKWAgcmV0dXJucyBPcmRlcmVkTWFwLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuTWFwKHsgXFxcImNcXFwiOiAzLCBcXFwiYVxcXCI6IDEsIFxcXCJiXFxcIjogMiB9KS5zb3J0KChhLCBiKSA9PiB7XFxuICBpZiAoYSA8IGIpIHsgcmV0dXJuIC0xOyB9XFxuICBpZiAoYSA+IGIpIHsgcmV0dXJuIDE7IH1cXG4gIGlmIChhID09PSBiKSB7IHJldHVybiAwOyB9XFxufSk7XFxuLy8gT3JkZXJlZE1hcCB7IFxcXCJhXFxcIjogMSwgXFxcImJcXFwiOiAyLCBcXFwiY1xcXCI6IDMgfVxcbmBgYFxcblxcbk5vdGU6IGBzb3J0KClgIEFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIHRoZSBvcmlnaW5hbCB3YXNcXG5hbHJlYWR5IHNvcnRlZC5cXG5cXG5Ob3RlOiBUaGlzIGlzIGFsd2F5cyBhbiBlYWdlciBvcGVyYXRpb24uXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbXBhcmF0b3JcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZUFcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZUJcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjJ9fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NDIzOX1dfSxcIiNzb3J0QnlcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiTGlrZSBgc29ydGAsIGJ1dCBhbHNvIGFjY2VwdHMgYSBgY29tcGFyYXRvclZhbHVlTWFwcGVyYCB3aGljaCBhbGxvd3MgZm9yXFxuc29ydGluZyBieSBtb3JlIHNvcGhpc3RpY2F0ZWQgbWVhbnM6XCIsXCJkZXNjcmlwdGlvblwiOlwiICAgIGhpdHRlcnMuc29ydEJ5KGhpdHRlciA9PiBoaXR0ZXIuYXZnSGl0cylcXG5cXG5Ob3RlOiBgc29ydEJ5KClgIEFsd2F5cyByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCBldmVuIGlmIHRoZSBvcmlnaW5hbCB3YXNcXG5hbHJlYWR5IHNvcnRlZC5cXG5cXG5Ob3RlOiBUaGlzIGlzIGFsd2F5cyBhbiBlYWdlciBvcGVyYXRpb24uXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29tcGFyYXRvclZhbHVlTWFwcGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19fSx7XCJuYW1lXCI6XCJjb21wYXJhdG9yXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVBXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwidmFsdWVCXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX1dLFwidHlwZVwiOntcImtcIjoyfX0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjQyNTJ9XX0sXCIjZ3JvdXBCeVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgYENvbGxlY3Rpb24uS2V5ZWRgIG9mIGBDb2xsZWN0aW9uLktleWVkc2AsIGdyb3VwZWQgYnkgdGhlIHJldHVyblxcbnZhbHVlIG9mIHRoZSBgZ3JvdXBlcmAgZnVuY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogVGhpcyBpcyBhbHdheXMgYW4gZWFnZXIgb3BlcmF0aW9uLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBMaXN0LCBNYXAgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3QgbGlzdE9mTWFwcyA9IExpc3QoW1xcbiAgTWFwKHsgdjogMCB9KSxcXG4gIE1hcCh7IHY6IDEgfSksXFxuICBNYXAoeyB2OiAxIH0pLFxcbiAgTWFwKHsgdjogMCB9KSxcXG4gIE1hcCh7IHY6IDIgfSlcXG5dKVxcbmNvbnN0IGdyb3Vwc09mTWFwcyA9IGxpc3RPZk1hcHMuZ3JvdXBCeSh4ID0+IHguZ2V0KCd2JykpXFxuLy8gTWFwIHtcXG4vLyAgIDA6IExpc3QgWyBNYXB7IFxcXCJ2XFxcIjogMCB9LCBNYXAgeyBcXFwidlxcXCI6IDAgfSBdLFxcbi8vICAgMTogTGlzdCBbIE1hcHsgXFxcInZcXFwiOiAxIH0sIE1hcCB7IFxcXCJ2XFxcIjogMSB9IF0sXFxuLy8gICAyOiBMaXN0IFsgTWFweyBcXFwidlxcXCI6IDIgfSBdLFxcbi8vIH1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiR1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJncm91cGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkdcIn19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiU2VxLktleWVkXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIkdcIn0se1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19XX0sXCJsaW5lXCI6NDI4MX1dfX19LHtcInRpdGxlXCI6XCJTaWRlIGVmZmVjdHNcIixcIm1lbWJlcnNcIjp7XCIjZm9yRWFjaFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUaGUgYHNpZGVFZmZlY3RgIGlzIGV4ZWN1dGVkIGZvciBldmVyeSBlbnRyeSBpbiB0aGUgQ29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJVbmxpa2UgYEFycmF5I2ZvckVhY2hgLCBpZiBhbnkgY2FsbCBvZiBgc2lkZUVmZmVjdGAgcmV0dXJuc1xcbmBmYWxzZWAsIHRoZSBpdGVyYXRpb24gd2lsbCBzdG9wLiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZW50cmllcyBpdGVyYXRlZFxcbihpbmNsdWRpbmcgdGhlIGxhc3QgaXRlcmF0aW9uIHdoaWNoIHJldHVybmVkIGZhbHNlKS5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwic2lkZUVmZmVjdFwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MTd9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6Mn0sXCJsaW5lXCI6NDI5Nn1dfX19LHtcInRpdGxlXCI6XCJDcmVhdGluZyBzdWJzZXRzXCIsXCJtZW1iZXJzXCI6e1wiI3NsaWNlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIHJlcHJlc2VudGluZyBhIHBvcnRpb24gb2YgdGhpc1xcbkNvbGxlY3Rpb24gZnJvbSBzdGFydCB1cCB0byBidXQgbm90IGluY2x1ZGluZyBlbmQuXCIsXCJkZXNjcmlwdGlvblwiOlwiSWYgYmVnaW4gaXMgbmVnYXRpdmUsIGl0IGlzIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIENvbGxlY3Rpb24uIGUuZy5cXG5gc2xpY2UoLTIpYCByZXR1cm5zIGEgQ29sbGVjdGlvbiBvZiB0aGUgbGFzdCB0d28gZW50cmllcy4gSWYgaXQgaXMgbm90XFxucHJvdmlkZWQgdGhlIG5ldyBDb2xsZWN0aW9uIHdpbGwgYmVnaW4gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGlzIENvbGxlY3Rpb24uXFxuXFxuSWYgZW5kIGlzIG5lZ2F0aXZlLCBpdCBpcyBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBDb2xsZWN0aW9uLiBlLmcuXFxuYHNsaWNlKDAsIC0xKWAgcmV0dXJucyBhIENvbGxlY3Rpb24gb2YgZXZlcnl0aGluZyBidXQgdGhlIGxhc3QgZW50cnkuIElmXFxuaXQgaXMgbm90IHByb3ZpZGVkLCB0aGUgbmV3IENvbGxlY3Rpb24gd2lsbCBjb250aW51ZSB0aHJvdWdoIHRoZSBlbmQgb2ZcXG50aGlzIENvbGxlY3Rpb24uXFxuXFxuSWYgdGhlIHJlcXVlc3RlZCBzbGljZSBpcyBlcXVpdmFsZW50IHRvIHRoZSBjdXJyZW50IENvbGxlY3Rpb24sIHRoZW4gaXRcXG53aWxsIHJldHVybiBpdHNlbGYuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImJlZ2luXCIsXCJ0eXBlXCI6e1wia1wiOjJ9LFwib3B0aW9uYWxcIjp0cnVlfSx7XCJuYW1lXCI6XCJlbmRcIixcInR5cGVcIjp7XCJrXCI6Mn0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjQzMjB9XX0sXCIjcmVzdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZSBjb250YWluaW5nIGFsbCBlbnRyaWVzIGV4Y2VwdFxcbnRoZSBmaXJzdC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo0MzI2fV19LFwiI2J1dExhc3RcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgY29udGFpbmluZyBhbGwgZW50cmllcyBleGNlcHRcXG50aGUgbGFzdC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo0MzMyfV19LFwiI3NraXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgd2hpY2ggZXhjbHVkZXMgdGhlIGZpcnN0IGBhbW91bnRgXFxuZW50cmllcyBmcm9tIHRoaXMgQ29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiYW1vdW50XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo0MzM4fV19LFwiI3NraXBMYXN0XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIHdoaWNoIGV4Y2x1ZGVzIHRoZSBsYXN0IGBhbW91bnRgXFxuZW50cmllcyBmcm9tIHRoaXMgQ29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiYW1vdW50XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo0MzQ0fV19LFwiI3NraXBXaGlsZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZSB3aGljaCBpbmNsdWRlcyBlbnRyaWVzIHN0YXJ0aW5nXFxuZnJvbSB3aGVuIGBwcmVkaWNhdGVgIGZpcnN0IHJldHVybnMgZmFsc2UuXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuTGlzdChbICdkb2cnLCAnZnJvZycsICdjYXQnLCAnaGF0JywgJ2dvZCcgXSlcXG4gIC5za2lwV2hpbGUoeCA9PiB4Lm1hdGNoKC9nLykpXFxuLy8gTGlzdCBbIFxcXCJjYXRcXFwiLCBcXFwiaGF0XFxcIiwgXFxcImdvZFxcXCIgXVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTB9LFwibGluZVwiOjQzNTh9XX0sXCIjc2tpcFVudGlsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIHdoaWNoIGluY2x1ZGVzIGVudHJpZXMgc3RhcnRpbmdcXG5mcm9tIHdoZW4gYHByZWRpY2F0ZWAgZmlyc3QgcmV0dXJucyB0cnVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBMaXN0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbkxpc3QoWyAnZG9nJywgJ2Zyb2cnLCAnY2F0JywgJ2hhdCcsICdnb2QnIF0pXFxuICAuc2tpcFVudGlsKHggPT4geC5tYXRjaCgvaGF0LykpXFxuLy8gTGlzdCBbIFxcXCJoYXRcXFwiLCBcXFwiZ29kXFxcIiBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NDM3NX1dfSxcIiN0YWtlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBuZXcgQ29sbGVjdGlvbiBvZiB0aGUgc2FtZSB0eXBlIHdoaWNoIGluY2x1ZGVzIHRoZSBmaXJzdCBgYW1vdW50YFxcbmVudHJpZXMgZnJvbSB0aGlzIENvbGxlY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImFtb3VudFwiLFwidHlwZVwiOntcImtcIjoyfX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NDM4NH1dfSxcIiN0YWtlTGFzdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZSB3aGljaCBpbmNsdWRlcyB0aGUgbGFzdCBgYW1vdW50YFxcbmVudHJpZXMgZnJvbSB0aGlzIENvbGxlY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImFtb3VudFwiLFwidHlwZVwiOntcImtcIjoyfX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NDM5MH1dfSxcIiN0YWtlV2hpbGVcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgd2hpY2ggaW5jbHVkZXMgZW50cmllcyBmcm9tIHRoaXNcXG5Db2xsZWN0aW9uIGFzIGxvbmcgYXMgdGhlIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCI8IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgTGlzdCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5MaXN0KFsgJ2RvZycsICdmcm9nJywgJ2NhdCcsICdoYXQnLCAnZ29kJyBdKVxcbiAgLnRha2VXaGlsZSh4ID0+IHgubWF0Y2goL28vKSlcXG4vLyBMaXN0IFsgXFxcImRvZ1xcXCIsIFxcXCJmcm9nXFxcIiBdXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMH0sXCJsaW5lXCI6NDQwNH1dfSxcIiN0YWtlVW50aWxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIG5ldyBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUgd2hpY2ggaW5jbHVkZXMgZW50cmllcyBmcm9tIHRoaXNcXG5Db2xsZWN0aW9uIGFzIGxvbmcgYXMgdGhlIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2UuXCIsXCJkZXNjcmlwdGlvblwiOlwiPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IExpc3QgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuTGlzdChbICdkb2cnLCAnZnJvZycsICdjYXQnLCAnaGF0JywgJ2dvZCcgXSlcXG4gIC50YWtlVW50aWwoeCA9PiB4Lm1hdGNoKC9hdC8pKVxcbi8vIExpc3QgWyBcXFwiZG9nXFxcIiwgXFxcImZyb2dcXFwiIF1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEwfSxcImxpbmVcIjo0NDIxfV19fX0se1widGl0bGVcIjpcIkNvbWJpbmF0aW9uXCIsXCJtZW1iZXJzXCI6e1wiI2NvbmNhdFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgbmV3IENvbGxlY3Rpb24gb2YgdGhlIHNhbWUgdHlwZSB3aXRoIG90aGVyIHZhbHVlcyBhbmRcXG5jb2xsZWN0aW9uLWxpa2UgY29uY2F0ZW5hdGVkIHRvIHRoaXMgb25lLlwiLFwiZGVzY3JpcHRpb25cIjpcIkZvciBTZXFzLCBhbGwgZW50cmllcyB3aWxsIGJlIHByZXNlbnQgaW4gdGhlIHJlc3VsdGluZyBTZXEsIGV2ZW4gaWYgdGhleVxcbmhhdmUgdGhlIHNhbWUga2V5LlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZXNPckNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfSxcImxpbmVcIjo0NDM2fV19LFwiI2ZsYXR0ZW5cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRmxhdHRlbnMgbmVzdGVkIENvbGxlY3Rpb25zLlwiLFwiZGVzY3JpcHRpb25cIjpcIldpbGwgZGVlcGx5IGZsYXR0ZW4gdGhlIENvbGxlY3Rpb24gYnkgZGVmYXVsdCwgcmV0dXJuaW5nIGEgQ29sbGVjdGlvbiBvZiB0aGVcXG5zYW1lIHR5cGUsIGJ1dCBhIGBkZXB0aGAgY2FuIGJlIHByb3ZpZGVkIGluIHRoZSBmb3JtIG9mIGEgbnVtYmVyIG9yXFxuYm9vbGVhbiAod2hlcmUgdHJ1ZSBtZWFucyB0byBzaGFsbG93bHkgZmxhdHRlbiBvbmUgbGV2ZWwpLiBBIGRlcHRoIG9mIDBcXG4ob3Igc2hhbGxvdzogZmFsc2UpIHdpbGwgZGVlcGx5IGZsYXR0ZW4uXFxuXFxuRmxhdHRlbnMgb25seSBvdGhlcnMgQ29sbGVjdGlvbiwgbm90IEFycmF5cyBvciBPYmplY3RzLlxcblxcbk5vdGU6IGBmbGF0dGVuKHRydWUpYCBvcGVyYXRlcyBvbiBDb2xsZWN0aW9uPHVua25vd24sIENvbGxlY3Rpb248SywgVj4+IGFuZFxcbnJldHVybnMgQ29sbGVjdGlvbjxLLCBWPlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJkZXB0aFwiLFwidHlwZVwiOntcImtcIjoyfSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfSxcImxpbmVcIjo0NDUxfSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwic2hhbGxvd1wiLFwidHlwZVwiOntcImtcIjoxfSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfSxcImxpbmVcIjo0NDUyfV19LFwiI2ZsYXRNYXBcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiRmxhdC1tYXBzIHRoZSBDb2xsZWN0aW9uLCByZXR1cm5pbmcgYSBDb2xsZWN0aW9uIG9mIHRoZSBzYW1lIHR5cGUuXCIsXCJkZXNjcmlwdGlvblwiOlwiU2ltaWxhciB0byBgY29sbGVjdGlvbi5tYXAoLi4uKS5mbGF0dGVuKHRydWUpYC5cXG5Vc2VkIGZvciBEaWN0aW9uYXJpZXMgb25seS5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiTVwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJNXCJ9XX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIk1cIn1dfSxcImxpbmVcIjo0NDU5fSx7XCJ0eXBlUGFyYW1zXCI6W1wiS01cIixcIlZNXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZNXCJ9XX1dfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJDb2xsZWN0aW9uXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIktNXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZNXCJ9XX0sXCJsaW5lXCI6NDQ3MH1dfX19LHtcInRpdGxlXCI6XCJSZWR1Y2luZyBhIHZhbHVlXCIsXCJtZW1iZXJzXCI6e1wiI3JlZHVjZVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZWR1Y2VzIHRoZSBDb2xsZWN0aW9uIHRvIGEgdmFsdWUgYnkgY2FsbGluZyB0aGUgYHJlZHVjZXJgIGZvciBldmVyeSBlbnRyeVxcbmluIHRoZSBDb2xsZWN0aW9uIGFuZCBwYXNzaW5nIGFsb25nIHRoZSByZWR1Y2VkIHZhbHVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIklmIGBpbml0aWFsUmVkdWN0aW9uYCBpcyBub3QgcHJvdmlkZWQsIHRoZSBmaXJzdCBpdGVtIGluIHRoZVxcbkNvbGxlY3Rpb24gd2lsbCBiZSB1c2VkLlxcblwiLFwibm90ZXNcIjpbe1wibmFtZVwiOlwic2VlXCIsXCJib2R5XCI6XCJgQXJyYXkjcmVkdWNlYC5cIn1dfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIlJcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicmVkdWNlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInJlZHVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlJcIn19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJSXCJ9fX0se1wibmFtZVwiOlwiaW5pdGlhbFJlZHVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlJcIn19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiUlwifSxcImxpbmVcIjo0NDg2fSx7XCJ0eXBlUGFyYW1zXCI6W1wiUlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJyZWR1Y2VyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicmVkdWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJSXCJ9XX19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJSXCJ9fX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlJcIn0sXCJsaW5lXCI6NDQ5MX1dfSxcIiNyZWR1Y2VSaWdodFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZWR1Y2VzIHRoZSBDb2xsZWN0aW9uIGluIHJldmVyc2UgKGZyb20gdGhlIHJpZ2h0IHNpZGUpLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IFNpbWlsYXIgdG8gdGhpcy5yZXZlcnNlKCkucmVkdWNlKCksIGFuZCBwcm92aWRlZCBmb3IgcGFyaXR5XFxud2l0aCBgQXJyYXkjcmVkdWNlUmlnaHRgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJSXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInJlZHVjZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJyZWR1Y3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJSXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiUlwifX19LHtcIm5hbWVcIjpcImluaXRpYWxSZWR1Y3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJSXCJ9fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlJcIn0sXCJsaW5lXCI6NDUwMX0se1widHlwZVBhcmFtc1wiOltcIlJcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicmVkdWNlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInJlZHVjdGlvblwiLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiUlwifV19fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiUlwifX19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJSXCJ9LFwibGluZVwiOjQ1MDZ9XX0sXCIjZXZlcnlcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydWUgZm9yIGFsbCBlbnRyaWVzIGluIHRoZSBDb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6NDUxM31dfSxcIiNzb21lXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnVlIGZvciBhbnkgZW50cnkgaW4gdGhlIENvbGxlY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcInByZWRpY2F0ZVwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6MX19fSx7XCJuYW1lXCI6XCJjb250ZXh0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo0NTIxfV19LFwiI2pvaW5cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiSm9pbnMgdmFsdWVzIHRvZ2V0aGVyIGFzIGEgc3RyaW5nLCBpbnNlcnRpbmcgYSBzZXBhcmF0b3IgYmV0d2VlbiBlYWNoLlxcblRoZSBkZWZhdWx0IHNlcGFyYXRvciBpcyBgXFxcIixcXFwiYC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwic2VwYXJhdG9yXCIsXCJ0eXBlXCI6e1wia1wiOjN9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjN9LFwibGluZVwiOjQ1MzB9XX0sXCIjaXNFbXB0eVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRydWUgaWYgdGhpcyBDb2xsZWN0aW9uIGluY2x1ZGVzIG5vIHZhbHVlcy5cIixcImRlc2NyaXB0aW9uXCI6XCJGb3Igc29tZSBsYXp5IGBTZXFgLCBgaXNFbXB0eWAgbWlnaHQgbmVlZCB0byBpdGVyYXRlIHRvIGRldGVybWluZVxcbmVtcHRpbmVzcy4gQXQgbW9zdCBvbmUgaXRlcmF0aW9uIHdpbGwgb2NjdXIuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo0NTM4fV19LFwiI2NvdW50XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdGhlIHNpemUgb2YgdGhpcyBDb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIlJlZ2FyZGxlc3Mgb2YgaWYgdGhpcyBDb2xsZWN0aW9uIGNhbiBkZXNjcmliZSBpdHMgc2l6ZSBsYXppbHkgKHNvbWUgU2Vxc1xcbmNhbm5vdCksIHRoaXMgbWV0aG9kIHdpbGwgYWx3YXlzIHJldHVybiB0aGUgY29ycmVjdCBzaXplLiBFLmcuIGl0XFxuZXZhbHVhdGVzIGEgbGF6eSBgU2VxYCBpZiBuZWNlc3NhcnkuXFxuXFxuSWYgYHByZWRpY2F0ZWAgaXMgcHJvdmlkZWQsIHRoZW4gdGhpcyByZXR1cm5zIHRoZSBjb3VudCBvZiBlbnRyaWVzIGluIHRoZVxcbkNvbGxlY3Rpb24gZm9yIHdoaWNoIHRoZSBgcHJlZGljYXRlYCByZXR1cm5zIHRydWUuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoyfSxcImxpbmVcIjo0NTUwfSx7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjJ9LFwibGluZVwiOjQ1NTF9XX0sXCIjY291bnRCeVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgYFNlcS5LZXllZGAgb2YgY291bnRzLCBncm91cGVkIGJ5IHRoZSByZXR1cm4gdmFsdWUgb2ZcXG50aGUgYGdyb3VwZXJgIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIk5vdGU6IFRoaXMgaXMgbm90IGEgbGF6eSBvcGVyYXRpb24uXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkdcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiZ3JvdXBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJHXCJ9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIk1hcFwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJHXCJ9LHtcImtcIjoyfV19LFwibGluZVwiOjQ1NjJ9XX19fSx7XCJ0aXRsZVwiOlwiU2VhcmNoIGZvciB2YWx1ZVwiLFwibWVtYmVyc1wiOntcIiNmaW5kXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdGhlIGZpcnN0IHZhbHVlIGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnVlLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9LHtcIm5hbWVcIjpcIm5vdFNldFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjExfV19LFwibGluZVwiOjQ1NzN9XX0sXCIjZmluZExhc3RcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyB0aGUgbGFzdCB2YWx1ZSBmb3Igd2hpY2ggdGhlIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgcHJlZGljYXRlYCB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBlbnRyeSBpbiByZXZlcnNlLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9LHtcIm5hbWVcIjpcIm5vdFNldFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjExfV19LFwibGluZVwiOjQ1ODR9XX0sXCIjZmluZEVudHJ5XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdGhlIGZpcnN0IFtrZXksIHZhbHVlXSBlbnRyeSBmb3Igd2hpY2ggdGhlIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSx7XCJrXCI6MTF9XX0sXCJsaW5lXCI6NDU5M31dfSxcIiNmaW5kTGFzdEVudHJ5XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdGhlIGxhc3QgW2tleSwgdmFsdWVdIGVudHJ5IGZvciB3aGljaCB0aGUgYHByZWRpY2F0ZWBcXG5yZXR1cm5zIHRydWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogYHByZWRpY2F0ZWAgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggZW50cnkgaW4gcmV2ZXJzZS5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfSx7XCJrXCI6MTF9XX0sXCJsaW5lXCI6NDYwNX1dfSxcIiNmaW5kS2V5XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdGhlIGtleSBmb3Igd2hpY2ggdGhlIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicHJlZGljYXRlXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjEwfX1dLFwidHlwZVwiOntcImtcIjoxfX19LHtcIm5hbWVcIjpcImNvbnRleHRcIixcInR5cGVcIjp7XCJrXCI6MTd9LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifSx7XCJrXCI6MTF9XX0sXCJsaW5lXCI6NDYxNH1dfSxcIiNmaW5kTGFzdEtleVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSBsYXN0IGtleSBmb3Igd2hpY2ggdGhlIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJOb3RlOiBgcHJlZGljYXRlYCB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBlbnRyeSBpbiByZXZlcnNlLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJwcmVkaWNhdGVcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjF9fX0se1wibmFtZVwiOlwiY29udGV4dFwiLFwidHlwZVwiOntcImtcIjoxN30sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjoxMX1dfSxcImxpbmVcIjo0NjI0fV19LFwiI2tleU9mXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgdGhlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIHNlYXJjaCB2YWx1ZSwgb3IgdW5kZWZpbmVkLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzZWFyY2hWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjoxMX1dfSxcImxpbmVcIjo0NjMyfV19LFwiI2xhc3RLZXlPZlwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSBsYXN0IGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIHNlYXJjaCB2YWx1ZSwgb3IgdW5kZWZpbmVkLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJzZWFyY2hWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjoxMX1dfSxcImxpbmVcIjo0NjM3fV19LFwiI21heFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlIGluIHRoaXMgY29sbGVjdGlvbi4gSWYgYW55IHZhbHVlcyBhcmVcXG5jb21wYXJhdGl2ZWx5IGVxdWl2YWxlbnQsIHRoZSBmaXJzdCBvbmUgZm91bmQgd2lsbCBiZSByZXR1cm5lZC5cIixcImRlc2NyaXB0aW9uXCI6XCJUaGUgYGNvbXBhcmF0b3JgIGlzIHVzZWQgaW4gdGhlIHNhbWUgd2F5IGFzIGBDb2xsZWN0aW9uI3NvcnRgLiBJZiBpdCBpcyBub3RcXG5wcm92aWRlZCwgdGhlIGRlZmF1bHQgY29tcGFyYXRvciBpcyBgPmAuXFxuXFxuV2hlbiB0d28gdmFsdWVzIGFyZSBjb25zaWRlcmVkIGVxdWl2YWxlbnQsIHRoZSBmaXJzdCBlbmNvdW50ZXJlZCB3aWxsIGJlXFxucmV0dXJuZWQuIE90aGVyd2lzZSwgYG1heGAgd2lsbCBvcGVyYXRlIGluZGVwZW5kZW50IG9mIHRoZSBvcmRlciBvZiBpbnB1dFxcbmFzIGxvbmcgYXMgdGhlIGNvbXBhcmF0b3IgaXMgY29tbXV0YXRpdmUuIFRoZSBkZWZhdWx0IGNvbXBhcmF0b3IgYD5gIGlzXFxuY29tbXV0YXRpdmUgKm9ubHkqIHdoZW4gdHlwZXMgZG8gbm90IGRpZmZlci5cXG5cXG5JZiBgY29tcGFyYXRvcmAgcmV0dXJucyAwIGFuZCBlaXRoZXIgdmFsdWUgaXMgTmFOLCB1bmRlZmluZWQsIG9yIG51bGwsXFxudGhhdCB2YWx1ZSB3aWxsIGJlIHJldHVybmVkLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb21wYXJhdG9yXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVBXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwidmFsdWVCXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjoyfX0sXCJvcHRpb25hbFwiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjoxMX1dfSxcImxpbmVcIjo0NjU0fV19LFwiI21heEJ5XCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkxpa2UgYG1heGAsIGJ1dCBhbHNvIGFjY2VwdHMgYSBgY29tcGFyYXRvclZhbHVlTWFwcGVyYCB3aGljaCBhbGxvd3MgZm9yXFxuY29tcGFyaW5nIGJ5IG1vcmUgc29waGlzdGljYXRlZCBtZWFuczpcIixcImRlc2NyaXB0aW9uXCI6XCIgICAgaGl0dGVycy5tYXhCeShoaXR0ZXIgPT4gaGl0dGVyLmF2Z0hpdHMpO1xcblwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbXBhcmF0b3JWYWx1ZU1hcHBlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwiaXRlclwiLFwidHlwZVwiOntcImtcIjoxMH19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fX0se1wibmFtZVwiOlwiY29tcGFyYXRvclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlQVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcInZhbHVlQlwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19XSxcInR5cGVcIjp7XCJrXCI6Mn19LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6MTF9XX0sXCJsaW5lXCI6NDY2M31dfSxcIiNtaW5cIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZSBpbiB0aGlzIGNvbGxlY3Rpb24uIElmIGFueSB2YWx1ZXMgYXJlXFxuY29tcGFyYXRpdmVseSBlcXVpdmFsZW50LCB0aGUgZmlyc3Qgb25lIGZvdW5kIHdpbGwgYmUgcmV0dXJuZWQuXCIsXCJkZXNjcmlwdGlvblwiOlwiVGhlIGBjb21wYXJhdG9yYCBpcyB1c2VkIGluIHRoZSBzYW1lIHdheSBhcyBgQ29sbGVjdGlvbiNzb3J0YC4gSWYgaXQgaXMgbm90XFxucHJvdmlkZWQsIHRoZSBkZWZhdWx0IGNvbXBhcmF0b3IgaXMgYDxgLlxcblxcbldoZW4gdHdvIHZhbHVlcyBhcmUgY29uc2lkZXJlZCBlcXVpdmFsZW50LCB0aGUgZmlyc3QgZW5jb3VudGVyZWQgd2lsbCBiZVxcbnJldHVybmVkLiBPdGhlcndpc2UsIGBtaW5gIHdpbGwgb3BlcmF0ZSBpbmRlcGVuZGVudCBvZiB0aGUgb3JkZXIgb2YgaW5wdXRcXG5hcyBsb25nIGFzIHRoZSBjb21wYXJhdG9yIGlzIGNvbW11dGF0aXZlLiBUaGUgZGVmYXVsdCBjb21wYXJhdG9yIGA8YCBpc1xcbmNvbW11dGF0aXZlICpvbmx5KiB3aGVuIHR5cGVzIGRvIG5vdCBkaWZmZXIuXFxuXFxuSWYgYGNvbXBhcmF0b3JgIHJldHVybnMgMCBhbmQgZWl0aGVyIHZhbHVlIGlzIE5hTiwgdW5kZWZpbmVkLCBvciBudWxsLFxcbnRoYXQgdmFsdWUgd2lsbCBiZSByZXR1cm5lZC5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29tcGFyYXRvclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlQVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcInZhbHVlQlwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6Mn19LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6MTF9XX0sXCJsaW5lXCI6NDY4M31dfSxcIiNtaW5CeVwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJMaWtlIGBtaW5gLCBidXQgYWxzbyBhY2NlcHRzIGEgYGNvbXBhcmF0b3JWYWx1ZU1hcHBlcmAgd2hpY2ggYWxsb3dzIGZvclxcbmNvbXBhcmluZyBieSBtb3JlIHNvcGhpc3RpY2F0ZWQgbWVhbnM6XCIsXCJkZXNjcmlwdGlvblwiOlwiICAgIGhpdHRlcnMubWluQnkoaGl0dGVyID0+IGhpdHRlci5hdmdIaXRzKTtcXG5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb21wYXJhdG9yVmFsdWVNYXBwZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6MTB9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX19LHtcIm5hbWVcIjpcImNvbXBhcmF0b3JcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZUFcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZUJcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjJ9fSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjExfV19LFwibGluZVwiOjQ2OTJ9XX19fSx7XCJ0aXRsZVwiOlwiQ29tcGFyaXNvblwiLFwibWVtYmVyc1wiOntcIiNpc1N1YnNldFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGBpdGVyYCBpbmNsdWRlcyBldmVyeSB2YWx1ZSBpbiB0aGlzIENvbGxlY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIml0ZXJcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo0NzAzfV19LFwiI2lzU3VwZXJzZXRcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiB0aGlzIENvbGxlY3Rpb24gaW5jbHVkZXMgZXZlcnkgdmFsdWUgaW4gYGl0ZXJgLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJpdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6NDcwOH1dfX19XX19LFwiVmFsdWVPYmplY3RcIjp7XCJpbnRlcmZhY2VcIjp7XCJsaW5lXCI6NDcxNCxcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUaGUgaW50ZXJmYWNlIHRvIGZ1bGZpbGwgdG8gcXVhbGlmeSBhcyBhIFZhbHVlIE9iamVjdC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwiZ3JvdXBzXCI6W3tcIm1lbWJlcnNcIjp7XCIjZXF1YWxzXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgdGhpcyBhbmQgdGhlIG90aGVyIENvbGxlY3Rpb24gaGF2ZSB2YWx1ZSBlcXVhbGl0eSwgYXMgZGVmaW5lZFxcbmJ5IGBJbW11dGFibGUuaXMoKWAuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogVGhpcyBpcyBlcXVpdmFsZW50IHRvIGBJbW11dGFibGUuaXModGhpcywgb3RoZXIpYCwgYnV0IHByb3ZpZGVkIHRvXFxuYWxsb3cgZm9yIGNoYWluZWQgZXhwcmVzc2lvbnMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm90aGVyXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo0NzIyfV19LFwiI2hhc2hDb2RlXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkNvbXB1dGVzIGFuZCByZXR1cm5zIHRoZSBoYXNoZWQgaWRlbnRpdHkgZm9yIHRoaXMgQ29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJUaGUgYGhhc2hDb2RlYCBvZiBhIENvbGxlY3Rpb24gaXMgdXNlZCB0byBkZXRlcm1pbmUgcG90ZW50aWFsIGVxdWFsaXR5LFxcbmFuZCBpcyB1c2VkIHdoZW4gYWRkaW5nIHRoaXMgdG8gYSBgU2V0YCBvciBhcyBhIGtleSBpbiBhIGBNYXBgLCBlbmFibGluZ1xcbmxvb2t1cCB2aWEgYSBkaWZmZXJlbnQgaW5zdGFuY2UuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IExpc3QsIFNldCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxuY29uc3QgYSA9IExpc3QoWyAxLCAyLCAzIF0pO1xcbmNvbnN0IGIgPSBMaXN0KFsgMSwgMiwgMyBdKTtcXG5hc3NlcnQubm90U3RyaWN0RXF1YWwoYSwgYik7IC8vIGRpZmZlcmVudCBpbnN0YW5jZXNcXG5jb25zdCBzZXQgPSBTZXQoWyBhIF0pO1xcbmFzc2VydC5lcXVhbChzZXQuaGFzKGIpLCB0cnVlKTtcXG5gYGBcXG5cXG5Ob3RlOiBoYXNoQ29kZSgpIE1VU1QgcmV0dXJuIGEgVWludDMyIG51bWJlci4gVGhlIGVhc2llc3Qgd2F5IHRvXFxuZ3VhcmFudGVlIHRoaXMgaXMgdG8gcmV0dXJuIGBteUhhc2ggfCAwYCBmcm9tIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uLlxcblxcbklmIHR3byB2YWx1ZXMgaGF2ZSB0aGUgc2FtZSBgaGFzaENvZGVgLCB0aGV5IGFyZSBbbm90IGd1YXJhbnRlZWRcXG50byBiZSBlcXVhbF1bSGFzaCBDb2xsaXNpb25dLiBJZiB0d28gdmFsdWVzIGhhdmUgZGlmZmVyZW50IGBoYXNoQ29kZWBzLFxcbnRoZXkgbXVzdCBub3QgYmUgZXF1YWwuXFxuXFxuTm90ZTogYGhhc2hDb2RlKClgIGlzIG5vdCBndWFyYW50ZWVkIHRvIGFsd2F5cyBiZSBjYWxsZWQgYmVmb3JlXFxuYGVxdWFscygpYC4gTW9zdCBidXQgbm90IGFsbCBJbW11dGFibGUuanMgY29sbGVjdGlvbnMgdXNlIGhhc2ggY29kZXMgdG9cXG5vcmdhbml6ZSB0aGVpciBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMsIHdoaWxlIGFsbCBJbW11dGFibGUuanNcXG5jb2xsZWN0aW9ucyB1c2UgZXF1YWxpdHkgZHVyaW5nIGxvb2t1cHMuXFxuXFxuW0hhc2ggQ29sbGlzaW9uXTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2xsaXNpb25fKGNvbXB1dGVyX3NjaWVuY2UpXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVwiOntcImtcIjoyfSxcImxpbmVcIjo0NzU1fV19fX1dfX0sXCJmcm9tSlNcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIkRlZXBseSBjb252ZXJ0cyBwbGFpbiBKUyBvYmplY3RzIGFuZCBhcnJheXMgdG8gSW1tdXRhYmxlIE1hcHMgYW5kIExpc3RzLlwiLFwiZGVzY3JpcHRpb25cIjpcIklmIGEgYHJldml2ZXJgIGlzIG9wdGlvbmFsbHkgcHJvdmlkZWQsIGl0IHdpbGwgYmUgY2FsbGVkIHdpdGggZXZlcnlcXG5jb2xsZWN0aW9uIGFzIGEgU2VxIChiZWdpbm5pbmcgd2l0aCB0aGUgbW9zdCBuZXN0ZWQgY29sbGVjdGlvbnNcXG5hbmQgcHJvY2VlZGluZyB0byB0aGUgdG9wLWxldmVsIGNvbGxlY3Rpb24gaXRzZWxmKSwgYWxvbmcgd2l0aCB0aGUga2V5XFxucmVmZXJyaW5nIHRvIGVhY2ggY29sbGVjdGlvbiBhbmQgdGhlIHBhcmVudCBKUyBvYmplY3QgcHJvdmlkZWQgYXMgYHRoaXNgLlxcbkZvciB0aGUgdG9wIGxldmVsLCBvYmplY3QsIHRoZSBrZXkgd2lsbCBiZSBgXFxcIlxcXCJgLiBUaGlzIGByZXZpdmVyYCBpcyBleHBlY3RlZFxcbnRvIHJldHVybiBhIG5ldyBJbW11dGFibGUgQ29sbGVjdGlvbiwgYWxsb3dpbmcgZm9yIGN1c3RvbSBjb252ZXJzaW9ucyBmcm9tXFxuZGVlcCBKUyBvYmplY3RzLiBGaW5hbGx5LCBhIGBwYXRoYCBpcyBwcm92aWRlZCB3aGljaCBpcyB0aGUgc2VxdWVuY2Ugb2ZcXG5rZXlzIHRvIHRoaXMgdmFsdWUgZnJvbSB0aGUgc3RhcnRpbmcgdmFsdWUuXFxuXFxuYHJldml2ZXJgIGFjdHMgc2ltaWxhcmx5IHRvIHRoZSBbc2FtZSBwYXJhbWV0ZXIgaW4gYEpTT04ucGFyc2VgXVsxXS5cXG5cXG5JZiBgcmV2aXZlcmAgaXMgbm90IHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBiZWhhdmlvciB3aWxsIGNvbnZlcnQgT2JqZWN0c1xcbmludG8gTWFwcyBhbmQgQXJyYXlzIGludG8gTGlzdHMgbGlrZSBzbzpcXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgZnJvbUpTLCBpc0tleWVkIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XFxuICByZXR1cm4gaXNLZXllZCh2YWx1ZSkgPyB2YWx1ZS50b01hcCgpIDogdmFsdWUudG9MaXN0KClcXG59XFxuYGBgXFxuXFxuYGZyb21KU2AgaXMgY29uc2VydmF0aXZlIGluIGl0cyBjb252ZXJzaW9uLiBJdCB3aWxsIG9ubHkgY29udmVydFxcbmFycmF5cyB3aGljaCBwYXNzIGBBcnJheS5pc0FycmF5YCB0byBMaXN0cywgYW5kIG9ubHkgcmF3IG9iamVjdHMgKG5vIGN1c3RvbVxcbnByb3RvdHlwZSkgdG8gTWFwLlxcblxcbkFjY29yZGluZ2x5LCB0aGlzIGV4YW1wbGUgY29udmVydHMgbmF0aXZlIEpTIGRhdGEgdG8gT3JkZXJlZE1hcCBhbmQgTGlzdDpcXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgZnJvbUpTLCBpc0tleWVkIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmZyb21KUyh7IGE6IHtiOiBbMTAsIDIwLCAzMF19LCBjOiA0MH0sIGZ1bmN0aW9uIChrZXksIHZhbHVlLCBwYXRoKSB7XFxuICBjb25zb2xlLmxvZyhrZXksIHZhbHVlLCBwYXRoKVxcbiAgcmV0dXJuIGlzS2V5ZWQodmFsdWUpID8gdmFsdWUudG9PcmRlcmVkTWFwKCkgOiB2YWx1ZS50b0xpc3QoKVxcbn0pXFxuXFxuPiBcXFwiYlxcXCIsIFsgMTAsIDIwLCAzMCBdLCBbIFxcXCJhXFxcIiwgXFxcImJcXFwiIF1cXG4+IFxcXCJhXFxcIiwge2I6IFsxMCwgMjAsIDMwXX0sIFsgXFxcImFcXFwiIF1cXG4+IFxcXCJcXFwiLCB7YToge2I6IFsxMCwgMjAsIDMwXX0sIGM6IDQwfSwgW11cXG5gYGBcXG5cXG5LZWVwIGluIG1pbmQsIHdoZW4gdXNpbmcgSlMgb2JqZWN0cyB0byBjb25zdHJ1Y3QgSW1tdXRhYmxlIE1hcHMsIHRoYXRcXG5KYXZhU2NyaXB0IE9iamVjdCBwcm9wZXJ0aWVzIGFyZSBhbHdheXMgc3RyaW5ncywgZXZlbiBpZiB3cml0dGVuIGluIGFcXG5xdW90ZS1sZXNzIHNob3J0aGFuZCwgd2hpbGUgSW1tdXRhYmxlIE1hcHMgYWNjZXB0IGtleXMgb2YgYW55IHR5cGUuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IE1hcCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5sZXQgb2JqID0geyAxOiBcXFwib25lXFxcIiB9O1xcbk9iamVjdC5rZXlzKG9iaik7IC8vIFsgXFxcIjFcXFwiIF1cXG5hc3NlcnQuZXF1YWwob2JqW1xcXCIxXFxcIl0sIG9ialsxXSk7IC8vIFxcXCJvbmVcXFwiID09PSBcXFwib25lXFxcIlxcblxcbmxldCBtYXAgPSBNYXAob2JqKTtcXG5hc3NlcnQubm90RXF1YWwobWFwLmdldChcXFwiMVxcXCIpLCBtYXAuZ2V0KDEpKTsgLy8gXFxcIm9uZVxcXCIgIT09IHVuZGVmaW5lZFxcbmBgYFxcblxcblByb3BlcnR5IGFjY2VzcyBmb3IgSmF2YVNjcmlwdCBPYmplY3RzIGZpcnN0IGNvbnZlcnRzIHRoZSBrZXkgdG8gYSBzdHJpbmcsXFxuYnV0IHNpbmNlIEltbXV0YWJsZSBNYXAga2V5cyBjYW4gYmUgb2YgYW55IHR5cGUgdGhlIGFyZ3VtZW50IHRvIGBnZXQoKWAgaXNcXG5ub3QgYWx0ZXJlZC5cXG5cXG5bMV06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0pTT04vcGFyc2UjRXhhbXBsZS4zQV9Vc2luZ190aGVfcmV2aXZlcl9wYXJhbWV0ZXJcXG4gICAgIFxcXCJVc2luZyB0aGUgcmV2aXZlciBwYXJhbWV0ZXJcXFwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImpzVmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fSx7XCJuYW1lXCI6XCJyZXZpdmVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjN9LHtcImtcIjoyfV19fSx7XCJuYW1lXCI6XCJzZXF1ZW5jZVwiLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5LZXllZFwiLFwiYXJnc1wiOlt7XCJrXCI6M30se1wia1wiOjE3fV19LHtcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvbi5JbmRleGVkXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfV19fSx7XCJuYW1lXCI6XCJwYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6M30se1wia1wiOjJ9XX1dfSxcIm9wdGlvbmFsXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjoxN319LFwib3B0aW9uYWxcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjE3fSxcImxpbmVcIjo0ODI0fV19fSxcImlzXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJWYWx1ZSBlcXVhbGl0eSBjaGVjayB3aXRoIHNlbWFudGljcyBzaW1pbGFyIHRvIGBPYmplY3QuaXNgLCBidXQgdHJlYXRzXFxuSW1tdXRhYmxlIGBDb2xsZWN0aW9uYHMgYXMgdmFsdWVzLCBlcXVhbCBpZiB0aGUgc2Vjb25kIGBDb2xsZWN0aW9uYCBpbmNsdWRlc1xcbmVxdWl2YWxlbnQgdmFsdWVzLlwiLFwiZGVzY3JpcHRpb25cIjpcIkl0J3MgdXNlZCB0aHJvdWdob3V0IEltbXV0YWJsZSB3aGVuIGNoZWNraW5nIGZvciBlcXVhbGl0eSwgaW5jbHVkaW5nIGBNYXBgXFxua2V5IGVxdWFsaXR5IGFuZCBgU2V0YCBtZW1iZXJzaGlwLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBNYXAsIGlzIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG1hcDEgPSBNYXAoeyBhOiAxLCBiOiAxLCBjOiAxIH0pXFxuY29uc3QgbWFwMiA9IE1hcCh7IGE6IDEsIGI6IDEsIGM6IDEgfSlcXG5hc3NlcnQuZXF1YWwobWFwMSAhPT0gbWFwMiwgdHJ1ZSlcXG5hc3NlcnQuZXF1YWwoT2JqZWN0LmlzKG1hcDEsIG1hcDIpLCBmYWxzZSlcXG5hc3NlcnQuZXF1YWwoaXMobWFwMSwgbWFwMiksIHRydWUpXFxuYGBgXFxuXFxuYGlzKClgIGNvbXBhcmVzIHByaW1pdGl2ZSB0eXBlcyBsaWtlIHN0cmluZ3MgYW5kIG51bWJlcnMsIEltbXV0YWJsZS5qc1xcbmNvbGxlY3Rpb25zIGxpa2UgYE1hcGAgYW5kIGBMaXN0YCwgYnV0IGFsc28gYW55IGN1c3RvbSBvYmplY3Qgd2hpY2hcXG5pbXBsZW1lbnRzIGBWYWx1ZU9iamVjdGAgYnkgcHJvdmlkaW5nIGBlcXVhbHMoKWAgYW5kIGBoYXNoQ29kZSgpYCBtZXRob2RzLlxcblxcbk5vdGU6IFVubGlrZSBgT2JqZWN0LmlzYCwgYEltbXV0YWJsZS5pc2AgYXNzdW1lcyBgMGAgYW5kIGAtMGAgYXJlIHRoZSBzYW1lXFxudmFsdWUsIG1hdGNoaW5nIHRoZSBiZWhhdmlvciBvZiBFUzYgTWFwIGtleSBlcXVhbGl0eS5cIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiZmlyc3RcIixcInR5cGVcIjp7XCJrXCI6MTd9fSx7XCJuYW1lXCI6XCJzZWNvbmRcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjQ4NTh9XX19LFwiaGFzaFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVGhlIGBoYXNoKClgIGZ1bmN0aW9uIGlzIGFuIGltcG9ydGFudCBwYXJ0IG9mIGhvdyBJbW11dGFibGUgZGV0ZXJtaW5lcyBpZlxcbnR3byB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQgYW5kIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGhvdyB0byBzdG9yZSB0aG9zZVxcbnZhbHVlcy4gUHJvdmlkZWQgd2l0aCBhbnkgdmFsdWUsIGBoYXNoKClgIHdpbGwgcmV0dXJuIGEgMzEtYml0IGludGVnZXIuXCIsXCJkZXNjcmlwdGlvblwiOlwiV2hlbiBkZXNpZ25pbmcgT2JqZWN0cyB3aGljaCBtYXkgYmUgZXF1YWwsIGl0J3MgaW1wb3J0YW50IHRoYXQgd2hlbiBhXFxuYC5lcXVhbHMoKWAgbWV0aG9kIHJldHVybnMgdHJ1ZSwgdGhhdCBib3RoIHZhbHVlcyBgLmhhc2hDb2RlKClgIG1ldGhvZFxcbnJldHVybiB0aGUgc2FtZSB2YWx1ZS4gYGhhc2goKWAgbWF5IGJlIHVzZWQgdG8gcHJvZHVjZSB0aG9zZSB2YWx1ZXMuXFxuXFxuRm9yIG5vbi1JbW11dGFibGUgT2JqZWN0cyB0aGF0IGRvIG5vdCBwcm92aWRlIGEgYC5oYXNoQ29kZSgpYCBmdW5jdGlvbnNcXG4oaW5jbHVkaW5nIHBsYWluIE9iamVjdHMsIHBsYWluIEFycmF5cywgRGF0ZSBvYmplY3RzLCBldGMpLCBhIHVuaXF1ZSBoYXNoXFxudmFsdWUgd2lsbCBiZSBjcmVhdGVkIGZvciBlYWNoICppbnN0YW5jZSouIFRoYXQgaXMsIHRoZSBjcmVhdGUgaGFzaFxcbnJlcHJlc2VudHMgcmVmZXJlbnRpYWwgZXF1YWxpdHksIGFuZCBub3QgdmFsdWUgZXF1YWxpdHkgZm9yIE9iamVjdHMuIFRoaXNcXG5lbnN1cmVzIHRoYXQgaWYgdGhhdCBPYmplY3QgaXMgbXV0YXRlZCBvdmVyIHRpbWUgdGhhdCBpdHMgaGFzaCBjb2RlIHdpbGxcXG5yZW1haW4gY29uc2lzdGVudCwgYWxsb3dpbmcgT2JqZWN0cyB0byBiZSB1c2VkIGFzIGtleXMgYW5kIHZhbHVlcyBpblxcbkltbXV0YWJsZS5qcyBjb2xsZWN0aW9ucy5cXG5cXG5Ob3RlIHRoYXQgYGhhc2goKWAgYXR0ZW1wdHMgdG8gYmFsYW5jZSBiZXR3ZWVuIHNwZWVkIGFuZCBhdm9pZGluZ1xcbmNvbGxpc2lvbnMsIGhvd2V2ZXIgaXQgbWFrZXMgbm8gYXR0ZW1wdCB0byBwcm9kdWNlIHNlY3VyZSBoYXNoZXMuXFxuXFxuKk5ldyBpbiBWZXJzaW9uIDQuMCpcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjJ9LFwibGluZVwiOjQ4ODJ9XX19LFwiaXNJbW11dGFibGVcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgYG1heWJlSW1tdXRhYmxlYCBpcyBhbiBJbW11dGFibGUgQ29sbGVjdGlvbiBvciBSZWNvcmQuXCIsXCJkZXNjcmlwdGlvblwiOlwiTm90ZTogU3RpbGwgcmV0dXJucyB0cnVlIGV2ZW4gaWYgdGhlIGNvbGxlY3Rpb25zIGlzIHdpdGhpbiBhIGB3aXRoTXV0YXRpb25zKClgLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBpc0ltbXV0YWJsZSwgTWFwLCBMaXN0LCBTdGFjayB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxuaXNJbW11dGFibGUoW10pOyAvLyBmYWxzZVxcbmlzSW1tdXRhYmxlKHt9KTsgLy8gZmFsc2VcXG5pc0ltbXV0YWJsZShNYXAoKSk7IC8vIHRydWVcXG5pc0ltbXV0YWJsZShMaXN0KCkpOyAvLyB0cnVlXFxuaXNJbW11dGFibGUoU3RhY2soKSk7IC8vIHRydWVcXG5pc0ltbXV0YWJsZShNYXAoKS5hc011dGFibGUoKSk7IC8vIHRydWVcXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVJbW11dGFibGVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjQ5MDB9XX19LFwiaXNDb2xsZWN0aW9uXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGBtYXliZUNvbGxlY3Rpb25gIGlzIGEgQ29sbGVjdGlvbiwgb3IgYW55IG9mIGl0cyBzdWJjbGFzc2VzLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBpc0NvbGxlY3Rpb24sIE1hcCwgTGlzdCwgU3RhY2sgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcbmlzQ29sbGVjdGlvbihbXSk7IC8vIGZhbHNlXFxuaXNDb2xsZWN0aW9uKHt9KTsgLy8gZmFsc2VcXG5pc0NvbGxlY3Rpb24oTWFwKCkpOyAvLyB0cnVlXFxuaXNDb2xsZWN0aW9uKExpc3QoKSk7IC8vIHRydWVcXG5pc0NvbGxlY3Rpb24oU3RhY2soKSk7IC8vIHRydWVcXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVDb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo0OTE1fV19fSxcImlzS2V5ZWRcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgYG1heWJlS2V5ZWRgIGlzIGEgQ29sbGVjdGlvbi5LZXllZCwgb3IgYW55IG9mIGl0cyBzdWJjbGFzc2VzLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBpc0tleWVkLCBNYXAsIExpc3QsIFN0YWNrIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXG5pc0tleWVkKFtdKTsgLy8gZmFsc2VcXG5pc0tleWVkKHt9KTsgLy8gZmFsc2VcXG5pc0tleWVkKE1hcCgpKTsgLy8gdHJ1ZVxcbmlzS2V5ZWQoTGlzdCgpKTsgLy8gZmFsc2VcXG5pc0tleWVkKFN0YWNrKCkpOyAvLyBmYWxzZVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXliZUtleWVkXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo0OTMwfV19fSxcImlzSW5kZXhlZFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVJbmRleGVkYCBpcyBhIENvbGxlY3Rpb24uSW5kZXhlZCwgb3IgYW55IG9mIGl0cyBzdWJjbGFzc2VzLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBpc0luZGV4ZWQsIE1hcCwgTGlzdCwgU3RhY2ssIFNldCB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJyk7XFxuaXNJbmRleGVkKFtdKTsgLy8gZmFsc2VcXG5pc0luZGV4ZWQoe30pOyAvLyBmYWxzZVxcbmlzSW5kZXhlZChNYXAoKSk7IC8vIGZhbHNlXFxuaXNJbmRleGVkKExpc3QoKSk7IC8vIHRydWVcXG5pc0luZGV4ZWQoU3RhY2soKSk7IC8vIHRydWVcXG5pc0luZGV4ZWQoU2V0KCkpOyAvLyBmYWxzZVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXliZUluZGV4ZWRcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjQ5NDZ9XX19LFwiaXNBc3NvY2lhdGl2ZVwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVBc3NvY2lhdGl2ZWAgaXMgZWl0aGVyIGEgS2V5ZWQgb3IgSW5kZXhlZCBDb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBpc0Fzc29jaWF0aXZlLCBNYXAsIExpc3QsIFN0YWNrLCBTZXQgfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpO1xcbmlzQXNzb2NpYXRpdmUoW10pOyAvLyBmYWxzZVxcbmlzQXNzb2NpYXRpdmUoe30pOyAvLyBmYWxzZVxcbmlzQXNzb2NpYXRpdmUoTWFwKCkpOyAvLyB0cnVlXFxuaXNBc3NvY2lhdGl2ZShMaXN0KCkpOyAvLyB0cnVlXFxuaXNBc3NvY2lhdGl2ZShTdGFjaygpKTsgLy8gdHJ1ZVxcbmlzQXNzb2NpYXRpdmUoU2V0KCkpOyAvLyBmYWxzZVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXliZUFzc29jaWF0aXZlXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo0OTYyfV19fSxcImlzT3JkZXJlZFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVPcmRlcmVkYCBpcyBhIENvbGxlY3Rpb24gd2hlcmUgaXRlcmF0aW9uIG9yZGVyIGlzIHdlbGxcXG5kZWZpbmVkLiBUcnVlIGZvciBDb2xsZWN0aW9uLkluZGV4ZWQgYXMgd2VsbCBhcyBPcmRlcmVkTWFwIGFuZCBPcmRlcmVkU2V0LlwiLFwiZGVzY3JpcHRpb25cIjpcIjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBpc09yZGVyZWQsIE1hcCwgT3JkZXJlZE1hcCwgTGlzdCwgU2V0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKTtcXG5pc09yZGVyZWQoW10pOyAvLyBmYWxzZVxcbmlzT3JkZXJlZCh7fSk7IC8vIGZhbHNlXFxuaXNPcmRlcmVkKE1hcCgpKTsgLy8gZmFsc2VcXG5pc09yZGVyZWQoT3JkZXJlZE1hcCgpKTsgLy8gdHJ1ZVxcbmlzT3JkZXJlZChMaXN0KCkpOyAvLyB0cnVlXFxuaXNPcmRlcmVkKFNldCgpKTsgLy8gZmFsc2VcXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVPcmRlcmVkXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo0OTc5fV19fSxcImlzVmFsdWVPYmplY3RcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgYG1heWJlVmFsdWVgIGlzIGEgSmF2YVNjcmlwdCBPYmplY3Qgd2hpY2ggaGFzICpib3RoKiBgZXF1YWxzKClgXFxuYW5kIGBoYXNoQ29kZSgpYCBtZXRob2RzLlwiLFwiZGVzY3JpcHRpb25cIjpcIkFueSB0d28gaW5zdGFuY2VzIG9mICp2YWx1ZSBvYmplY3RzKiBjYW4gYmUgY29tcGFyZWQgZm9yIHZhbHVlIGVxdWFsaXR5IHdpdGhcXG5gSW1tdXRhYmxlLmlzKClgIGFuZCBjYW4gYmUgdXNlZCBhcyBrZXlzIGluIGEgYE1hcGAgb3IgbWVtYmVycyBpbiBhIGBTZXRgLlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXliZVZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo0OTg4fV19fSxcImlzU2VxXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJUcnVlIGlmIGBtYXliZVNlcWAgaXMgYSBTZXEuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlU2VxXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo0OTk0fV19fSxcImlzTGlzdFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVMaXN0YCBpcyBhIExpc3QuXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlTGlzdFwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6NDk5OX1dfX0sXCJpc01hcFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVNYXBgIGlzIGEgTWFwLlwiLFwiZGVzY3JpcHRpb25cIjpcIkFsc28gdHJ1ZSBmb3IgT3JkZXJlZE1hcHMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlTWFwXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo1MDA2fV19fSxcImlzT3JkZXJlZE1hcFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVPcmRlcmVkTWFwYCBpcyBhbiBPcmRlcmVkTWFwLlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXliZU9yZGVyZWRNYXBcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjUwMTF9XX19LFwiaXNTdGFja1wiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVTdGFja2AgaXMgYSBTdGFjay5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVTdGFja1wiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6NTAxNn1dfX0sXCJpc1NldFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVTZXRgIGlzIGEgU2V0LlwiLFwiZGVzY3JpcHRpb25cIjpcIkFsc28gdHJ1ZSBmb3IgT3JkZXJlZFNldHMuXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1heWJlU2V0XCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxfSxcImxpbmVcIjo1MDIzfV19fSxcImlzT3JkZXJlZFNldFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiVHJ1ZSBpZiBgbWF5YmVPcmRlcmVkU2V0YCBpcyBhbiBPcmRlcmVkU2V0LlwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtYXliZU9yZGVyZWRTZXRcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjUwMjh9XX19LFwiaXNSZWNvcmRcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlRydWUgaWYgYG1heWJlUmVjb3JkYCBpcyBhIFJlY29yZC5cIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwibWF5YmVSZWNvcmRcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjUwMzN9XX19LFwiZ2V0XCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSB2YWx1ZSB3aXRoaW4gdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoZVxcbnByb3ZpZGVkIGtleSwgb3Igbm90U2V0VmFsdWUgaWYgdGhlIGtleSBpcyBub3QgZGVmaW5lZCBpbiB0aGUgY29sbGVjdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJBIGZ1bmN0aW9uYWwgYWx0ZXJuYXRpdmUgdG8gYGNvbGxlY3Rpb24uZ2V0KGtleSlgIHdoaWNoIHdpbGwgYWxzbyB3b3JrIG9uXFxucGxhaW4gT2JqZWN0cyBhbmQgQXJyYXlzIGFzIGFuIGFsdGVybmF0aXZlIGZvciBgY29sbGVjdGlvbltrZXldYC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgZ2V0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmdldChbICdkb2cnLCAnZnJvZycsICdjYXQnIF0sIDIpIC8vICdmcm9nJ1xcbmdldCh7IHg6IDEyMywgeTogNDU2IH0sICd4JykgLy8gMTIzXFxuZ2V0KHsgeDogMTIzLCB5OiA0NTYgfSwgJ3onLCAnaWZOb3RTZXQnKSAvLyAnaWZOb3RTZXQnXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktcIixcIlZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX1dLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjExfV19LFwibGluZVwiOjUwNTJ9LHtcInR5cGVQYXJhbXNcIjpbXCJLXCIsXCJWXCIsXCJOU1ZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQ29sbGVjdGlvblwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn19XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifV19LFwibGluZVwiOjUwNTN9LHtcInR5cGVQYXJhbXNcIjpbXCJUUHJvcHNcIixcIktcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicmVjb3JkXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJSZWNvcmRcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVFByb3BzXCJ9XX19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIm5vdFNldFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxNSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn0sXCJpbmRleFwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LFwibGluZVwiOjUwNTR9LHtcInR5cGVQYXJhbXNcIjpbXCJWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn1dfX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fV0sXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6MTF9XX0sXCJsaW5lXCI6NTA1NX0se1widHlwZVBhcmFtc1wiOltcIlZcIixcIk5TVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn19XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifV19LFwibGluZVwiOjUwNTZ9LHtcInR5cGVQYXJhbXNcIjpbXCJDXCIsXCJLXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm9iamVjdFwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcIm5vdFNldFZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE3fX1dLFwidHlwZVwiOntcImtcIjoxNSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwiaW5kZXhcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSxcImxpbmVcIjo1MDU3fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV19fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjoxMX1dfSxcImxpbmVcIjo1MDU4fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiLFwiTlNWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XX19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn19XSxcInR5cGVcIjp7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9LHtcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifV19LFwibGluZVwiOjUwNTl9XX19LFwiaGFzXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRydWUgaWYgdGhlIGtleSBpcyBkZWZpbmVkIGluIHRoZSBwcm92aWRlZCBjb2xsZWN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIkEgZnVuY3Rpb25hbCBhbHRlcm5hdGl2ZSB0byBgY29sbGVjdGlvbi5oYXMoa2V5KWAgd2hpY2ggd2lsbCBhbHNvIHdvcmsgd2l0aFxcbnBsYWluIE9iamVjdHMgYW5kIEFycmF5cyBhcyBhbiBhbHRlcm5hdGl2ZSBmb3JcXG5gY29sbGVjdGlvbi5oYXNPd25Qcm9wZXJ0eShrZXkpYC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgaGFzIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmhhcyhbICdkb2cnLCAnZnJvZycsICdjYXQnIF0sIDIpIC8vIHRydWVcXG5oYXMoWyAnZG9nJywgJ2Zyb2cnLCAnY2F0JyBdLCA1KSAvLyBmYWxzZVxcbmhhcyh7IHg6IDEyMywgeTogNDU2IH0sICd4JykgLy8gdHJ1ZVxcbmhhcyh7IHg6IDEyMywgeTogNDU2IH0sICd6JykgLy8gZmFsc2VcXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiT2JqZWN0XCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjF9LFwibGluZVwiOjUwNzd9XX19LFwicmVtb3ZlXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgY29weSBvZiB0aGUgY29sbGVjdGlvbiB3aXRoIHRoZSB2YWx1ZSBhdCBrZXkgcmVtb3ZlZC5cIixcImRlc2NyaXB0aW9uXCI6XCJBIGZ1bmN0aW9uYWwgYWx0ZXJuYXRpdmUgdG8gYGNvbGxlY3Rpb24ucmVtb3ZlKGtleSlgIHdoaWNoIHdpbGwgYWxzbyB3b3JrXFxud2l0aCBwbGFpbiBPYmplY3RzIGFuZCBBcnJheXMgYXMgYW4gYWx0ZXJuYXRpdmUgZm9yXFxuYGRlbGV0ZSBjb2xsZWN0aW9uQ29weVtrZXldYC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgcmVtb3ZlIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG9yaWdpbmFsQXJyYXkgPSBbICdkb2cnLCAnZnJvZycsICdjYXQnIF1cXG5yZW1vdmUob3JpZ2luYWxBcnJheSwgMSkgLy8gWyAnZG9nJywgJ2NhdCcgXVxcbmNvbnNvbGUubG9nKG9yaWdpbmFsQXJyYXkpIC8vIFsgJ2RvZycsICdmcm9nJywgJ2NhdCcgXVxcbmNvbnN0IG9yaWdpbmFsT2JqZWN0ID0geyB4OiAxMjMsIHk6IDQ1NiB9XFxucmVtb3ZlKG9yaWdpbmFsT2JqZWN0LCAneCcpIC8vIHsgeTogNDU2IH1cXG5jb25zb2xlLmxvZyhvcmlnaW5hbE9iamVjdCkgLy8geyB4OiAxMjMsIHk6IDQ1NiB9XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktcIixcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUwOTd9LHtcInR5cGVQYXJhbXNcIjpbXCJUUHJvcHNcIixcIkNcIixcIktcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUwOTh9LHtcInR5cGVQYXJhbXNcIjpbXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6Mn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUwOTl9LHtcInR5cGVQYXJhbXNcIjpbXCJDXCIsXCJLXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjo1MTAwfSx7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiLFwiS1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJsaW5lXCI6NTEwMX1dfX0sXCJzZXRcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBjb3B5IG9mIHRoZSBjb2xsZWN0aW9uIHdpdGggdGhlIHZhbHVlIGF0IGtleSBzZXQgdG8gdGhlIHByb3ZpZGVkXFxudmFsdWUuXCIsXCJkZXNjcmlwdGlvblwiOlwiQSBmdW5jdGlvbmFsIGFsdGVybmF0aXZlIHRvIGBjb2xsZWN0aW9uLnNldChrZXksIHZhbHVlKWAgd2hpY2ggd2lsbCBhbHNvXFxud29yayB3aXRoIHBsYWluIE9iamVjdHMgYW5kIEFycmF5cyBhcyBhbiBhbHRlcm5hdGl2ZSBmb3JcXG5gY29sbGVjdGlvbkNvcHlba2V5XSA9IHZhbHVlYC5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgc2V0IH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG9yaWdpbmFsQXJyYXkgPSBbICdkb2cnLCAnZnJvZycsICdjYXQnIF1cXG5zZXQob3JpZ2luYWxBcnJheSwgMSwgJ2NvdycpIC8vIFsgJ2RvZycsICdjb3cnLCAnY2F0JyBdXFxuY29uc29sZS5sb2cob3JpZ2luYWxBcnJheSkgLy8gWyAnZG9nJywgJ2Zyb2cnLCAnY2F0JyBdXFxuY29uc3Qgb3JpZ2luYWxPYmplY3QgPSB7IHg6IDEyMywgeTogNDU2IH1cXG5zZXQob3JpZ2luYWxPYmplY3QsICd4JywgNzg5KSAvLyB7IHg6IDc4OSwgeTogNDU2IH1cXG5jb25zb2xlLmxvZyhvcmlnaW5hbE9iamVjdCkgLy8geyB4OiAxMjMsIHk6IDQ1NiB9XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIktcIixcIlZcIixcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJsaW5lXCI6NTEyMn0se1widHlwZVBhcmFtc1wiOltcIlRQcm9wc1wiLFwiQ1wiLFwiS1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJyZWNvcmRcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxNSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn0sXCJpbmRleFwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjo1MTIzfSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiLFwiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjJ9fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUxMjR9LHtcInR5cGVQYXJhbXNcIjpbXCJDXCIsXCJLXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm9iamVjdFwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjE1LFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJpbmRleFwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjo1MTI1fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiLFwiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fSx7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUxMjZ9XX19LFwidXBkYXRlXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgY29weSBvZiB0aGUgY29sbGVjdGlvbiB3aXRoIHRoZSB2YWx1ZSBhdCBrZXkgc2V0IHRvIHRoZSByZXN1bHQgb2ZcXG5wcm92aWRpbmcgdGhlIGV4aXN0aW5nIHZhbHVlIHRvIHRoZSB1cGRhdGluZyBmdW5jdGlvbi5cIixcImRlc2NyaXB0aW9uXCI6XCJBIGZ1bmN0aW9uYWwgYWx0ZXJuYXRpdmUgdG8gYGNvbGxlY3Rpb24udXBkYXRlKGtleSwgZm4pYCB3aGljaCB3aWxsIGFsc29cXG53b3JrIHdpdGggcGxhaW4gT2JqZWN0cyBhbmQgQXJyYXlzIGFzIGFuIGFsdGVybmF0aXZlIGZvclxcbmBjb2xsZWN0aW9uQ29weVtrZXldID0gZm4oY29sbGVjdGlvbltrZXldKWAuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IHVwZGF0ZSB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBvcmlnaW5hbEFycmF5ID0gWyAnZG9nJywgJ2Zyb2cnLCAnY2F0JyBdXFxudXBkYXRlKG9yaWdpbmFsQXJyYXksIDEsIHZhbCA9PiB2YWwudG9VcHBlckNhc2UoKSkgLy8gWyAnZG9nJywgJ0ZST0cnLCAnY2F0JyBdXFxuY29uc29sZS5sb2cob3JpZ2luYWxBcnJheSkgLy8gWyAnZG9nJywgJ2Zyb2cnLCAnY2F0JyBdXFxuY29uc3Qgb3JpZ2luYWxPYmplY3QgPSB7IHg6IDEyMywgeTogNDU2IH1cXG51cGRhdGUob3JpZ2luYWxPYmplY3QsICd4JywgdmFsID0+IHZhbCAqIDYpIC8vIHsgeDogNzM4LCB5OiA0NTYgfVxcbmNvbnNvbGUubG9nKG9yaWdpbmFsT2JqZWN0KSAvLyB7IHg6IDEyMywgeTogNDU2IH1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiLFwiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjo1MTQ3fSx7XCJ0eXBlUGFyYW1zXCI6W1wiS1wiLFwiVlwiLFwiQ1wiLFwiTlNWXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJub3RTZXRWYWx1ZVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifSx7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn1dfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjo1MTQ4fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVFByb3BzXCIsXCJDXCIsXCJLXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInJlY29yZFwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxNSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn0sXCJpbmRleFwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjE1LFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRQcm9wc1wifSxcImluZGV4XCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX19fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjo1MTQ5fSx7XCJ0eXBlUGFyYW1zXCI6W1wiVFByb3BzXCIsXCJDXCIsXCJLXCIsXCJOU1ZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwicmVjb3JkXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn19LHtcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjoxNSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJUUHJvcHNcIn0sXCJpbmRleFwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcImtcIjo4LFwicGFyYW1cIjpcIk5TVlwifV19fV0sXCJ0eXBlXCI6e1wia1wiOjE1LFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlRQcm9wc1wifSxcImluZGV4XCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX19fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjo1MTUwfSx7XCJ0eXBlUGFyYW1zXCI6W1wiVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwidXBkYXRlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19fV0sXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX0sXCJsaW5lXCI6NTE1MX0se1widHlwZVBhcmFtc1wiOltcIlZcIixcIk5TVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9XX19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoyfX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn19LHtcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiTlNWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fX1dLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifV19LFwibGluZVwiOjUxNTJ9LHtcInR5cGVQYXJhbXNcIjpbXCJDXCIsXCJLXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm9iamVjdFwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIktcIn19LHtcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxNSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwiaW5kZXhcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fX1dLFwidHlwZVwiOntcImtcIjoxNSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwiaW5kZXhcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fX19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUxNTN9LHtcInR5cGVQYXJhbXNcIjpbXCJDXCIsXCJLXCIsXCJOU1ZcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwib2JqZWN0XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn19LHtcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjoxNSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwiaW5kZXhcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn1dfX1dLFwidHlwZVwiOntcImtcIjoxNSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwiaW5kZXhcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fX19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUxNTR9LHtcInR5cGVQYXJhbXNcIjpbXCJWXCIsXCJDXCIsXCJLXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJLXCJ9fSx7XCJuYW1lXCI6XCJ1cGRhdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX19XSxcInR5cGVcIjp7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIlZcIn19XX0sXCJsaW5lXCI6NTE1NX0se1widHlwZVBhcmFtc1wiOltcIlZcIixcIkNcIixcIktcIixcIk5TVlwiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiS1wifX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJOU1ZcIn19LHtcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo4LFwicGFyYW1cIjpcIlZcIn0se1wia1wiOjgsXCJwYXJhbVwiOlwiTlNWXCJ9XX19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJWXCJ9fX1dLFwidHlwZVwiOntcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiVlwifX1dfSxcImxpbmVcIjo1MTU2fV19fSxcImdldEluXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRoZSB2YWx1ZSBhdCB0aGUgcHJvdmlkZWQga2V5IHBhdGggc3RhcnRpbmcgYXQgdGhlIHByb3ZpZGVkXFxuY29sbGVjdGlvbiwgb3Igbm90U2V0VmFsdWUgaWYgdGhlIGtleSBwYXRoIGlzIG5vdCBkZWZpbmVkLlwiLFwiZGVzY3JpcHRpb25cIjpcIkEgZnVuY3Rpb25hbCBhbHRlcm5hdGl2ZSB0byBgY29sbGVjdGlvbi5nZXRJbihrZXlwYXRoKWAgd2hpY2ggd2lsbCBhbHNvXFxud29yayB3aXRoIHBsYWluIE9iamVjdHMgYW5kIEFycmF5cy5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgZ2V0SW4gfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuZ2V0SW4oeyB4OiB7IHk6IHsgejogMTIzIH19fSwgWyd4JywgJ3knLCAneiddKSAvLyAxMjNcXG5nZXRJbih7IHg6IHsgeTogeyB6OiAxMjMgfX19LCBbJ3gnLCAncScsICdwJ10sICdpZk5vdFNldCcpIC8vICdpZk5vdFNldCdcXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjoxN319LHtcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fSxcImxpbmVcIjo1MTcyfV19fSxcImhhc0luXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIHRydWUgaWYgdGhlIGtleSBwYXRoIGlzIGRlZmluZWQgaW4gdGhlIHByb3ZpZGVkIGNvbGxlY3Rpb24uXCIsXCJkZXNjcmlwdGlvblwiOlwiQSBmdW5jdGlvbmFsIGFsdGVybmF0aXZlIHRvIGBjb2xsZWN0aW9uLmhhc0luKGtleXBhdGgpYCB3aGljaCB3aWxsIGFsc29cXG53b3JrIHdpdGggcGxhaW4gT2JqZWN0cyBhbmQgQXJyYXlzLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBoYXNJbiB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5oYXNJbih7IHg6IHsgeTogeyB6OiAxMjMgfX19LCBbJ3gnLCAneScsICd6J10pIC8vIHRydWVcXG5oYXNJbih7IHg6IHsgeTogeyB6OiAxMjMgfX19LCBbJ3gnLCAncScsICdwJ10pIC8vIGZhbHNlXFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1wicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6MTd9fSx7XCJuYW1lXCI6XCJrZXlQYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX19XSxcInR5cGVcIjp7XCJrXCI6MX0sXCJsaW5lXCI6NTE4N31dfX0sXCJyZW1vdmVJblwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIGNvcHkgb2YgdGhlIGNvbGxlY3Rpb24gd2l0aCB0aGUgdmFsdWUgYXQgdGhlIGtleSBwYXRoIHJlbW92ZWQuXCIsXCJkZXNjcmlwdGlvblwiOlwiQSBmdW5jdGlvbmFsIGFsdGVybmF0aXZlIHRvIGBjb2xsZWN0aW9uLnJlbW92ZUluKGtleXBhdGgpYCB3aGljaCB3aWxsIGFsc29cXG53b3JrIHdpdGggcGxhaW4gT2JqZWN0cyBhbmQgQXJyYXlzLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyByZW1vdmVJbiB9ID0gcmVxdWlyZSgnaW1tdXRhYmxlJylcXG5jb25zdCBvcmlnaW5hbCA9IHsgeDogeyB5OiB7IHo6IDEyMyB9fX1cXG5yZW1vdmVJbihvcmlnaW5hbCwgWyd4JywgJ3knLCAneiddKSAvLyB7IHg6IHsgeToge319fVxcbmNvbnNvbGUubG9nKG9yaWdpbmFsKSAvLyB7IHg6IHsgeTogeyB6OiAxMjMgfX19XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJsaW5lXCI6NTIwM31dfX0sXCJzZXRJblwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIGNvcHkgb2YgdGhlIGNvbGxlY3Rpb24gd2l0aCB0aGUgdmFsdWUgYXQgdGhlIGtleSBwYXRoIHNldCB0byB0aGVcXG5wcm92aWRlZCB2YWx1ZS5cIixcImRlc2NyaXB0aW9uXCI6XCJBIGZ1bmN0aW9uYWwgYWx0ZXJuYXRpdmUgdG8gYGNvbGxlY3Rpb24uc2V0SW4oa2V5cGF0aClgIHdoaWNoIHdpbGwgYWxzb1xcbndvcmsgd2l0aCBwbGFpbiBPYmplY3RzIGFuZCBBcnJheXMuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IHNldEluIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG9yaWdpbmFsID0geyB4OiB7IHk6IHsgejogMTIzIH19fVxcbnNldEluKG9yaWdpbmFsLCBbJ3gnLCAneScsICd6J10sIDQ1NikgLy8geyB4OiB7IHk6IHsgejogNDU2IH19fVxcbmNvbnNvbGUubG9nKG9yaWdpbmFsKSAvLyB7IHg6IHsgeTogeyB6OiAxMjMgfX19XFxuYGBgXCIsXCJub3Rlc1wiOltdfSxcInNpZ25hdHVyZXNcIjpbe1widHlwZVBhcmFtc1wiOltcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjo1MjIwfV19fSxcInVwZGF0ZUluXCI6e1wiY2FsbFwiOntcImRvY1wiOntcInN5bm9wc2lzXCI6XCJSZXR1cm5zIGEgY29weSBvZiB0aGUgY29sbGVjdGlvbiB3aXRoIHRoZSB2YWx1ZSBhdCBrZXkgcGF0aCBzZXQgdG8gdGhlXFxucmVzdWx0IG9mIHByb3ZpZGluZyB0aGUgZXhpc3RpbmcgdmFsdWUgdG8gdGhlIHVwZGF0aW5nIGZ1bmN0aW9uLlwiLFwiZGVzY3JpcHRpb25cIjpcIkEgZnVuY3Rpb25hbCBhbHRlcm5hdGl2ZSB0byBgY29sbGVjdGlvbi51cGRhdGVJbihrZXlwYXRoKWAgd2hpY2ggd2lsbCBhbHNvXFxud29yayB3aXRoIHBsYWluIE9iamVjdHMgYW5kIEFycmF5cy5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgdXBkYXRlSW4gfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb3JpZ2luYWwgPSB7IHg6IHsgeTogeyB6OiAxMjMgfX19XFxudXBkYXRlSW4ob3JpZ2luYWwsIFsneCcsICd5JywgJ3onXSwgdmFsID0+IHZhbCAqIDYpIC8vIHsgeDogeyB5OiB7IHo6IDczOCB9fX1cXG5jb25zb2xlLmxvZyhvcmlnaW5hbCkgLy8geyB4OiB7IHk6IHsgejogMTIzIH19fVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJrZXlQYXRoXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX19LHtcIm5hbWVcIjpcInVwZGF0ZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJ2YWx1ZVwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MTd9fX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJsaW5lXCI6NTIzN30se1widHlwZVBhcmFtc1wiOltcIkNcIl0sXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImtleVBhdGhcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfX0se1wibmFtZVwiOlwibm90U2V0VmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fSx7XCJuYW1lXCI6XCJ1cGRhdGVyXCIsXCJ0eXBlXCI6e1wia1wiOjcsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwidmFsdWVcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUyMzh9XX19LFwibWVyZ2VcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBjb3B5IG9mIHRoZSBjb2xsZWN0aW9uIHdpdGggdGhlIHJlbWFpbmluZyBjb2xsZWN0aW9ucyBtZXJnZWQgaW4uXCIsXCJkZXNjcmlwdGlvblwiOlwiQSBmdW5jdGlvbmFsIGFsdGVybmF0aXZlIHRvIGBjb2xsZWN0aW9uLm1lcmdlKClgIHdoaWNoIHdpbGwgYWxzbyB3b3JrIHdpdGhcXG5wbGFpbiBPYmplY3RzIGFuZCBBcnJheXMuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IG1lcmdlIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG9yaWdpbmFsID0geyB4OiAxMjMsIHk6IDQ1NiB9XFxubWVyZ2Uob3JpZ2luYWwsIHsgeTogNzg5LCB6OiAnYWJjJyB9KSAvLyB7IHg6IDEyMywgeTogNzg5LCB6OiAnYWJjJyB9XFxuY29uc29sZS5sb2cob3JpZ2luYWwpIC8vIHsgeDogMTIzLCB5OiA0NTYgfVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0se1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfV19LHtcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX1dfV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJsaW5lXCI6NTI1NH1dfX0sXCJtZXJnZVdpdGhcIjp7XCJjYWxsXCI6e1wiZG9jXCI6e1wic3lub3BzaXNcIjpcIlJldHVybnMgYSBjb3B5IG9mIHRoZSBjb2xsZWN0aW9uIHdpdGggdGhlIHJlbWFpbmluZyBjb2xsZWN0aW9ucyBtZXJnZWQgaW4sXFxuY2FsbGluZyB0aGUgYG1lcmdlcmAgZnVuY3Rpb24gd2hlbmV2ZXIgYW4gZXhpc3RpbmcgdmFsdWUgaXMgZW5jb3VudGVyZWQuXCIsXCJkZXNjcmlwdGlvblwiOlwiQSBmdW5jdGlvbmFsIGFsdGVybmF0aXZlIHRvIGBjb2xsZWN0aW9uLm1lcmdlV2l0aCgpYCB3aGljaCB3aWxsIGFsc28gd29ya1xcbndpdGggcGxhaW4gT2JqZWN0cyBhbmQgQXJyYXlzLlxcblxcbjwhLS0gcnVua2l0OmFjdGl2YXRlIC0tPlxcbmBgYGpzXFxuY29uc3QgeyBtZXJnZVdpdGggfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb3JpZ2luYWwgPSB7IHg6IDEyMywgeTogNDU2IH1cXG5tZXJnZVdpdGgoXFxuICAob2xkVmFsLCBuZXdWYWwpID0+IG9sZFZhbCArIG5ld1ZhbCxcXG4gIG9yaWdpbmFsLFxcbiAgeyB5OiA3ODksIHo6ICdhYmMnIH1cXG4pIC8vIHsgeDogMTIzLCB5OiAxMjQ1LCB6OiAnYWJjJyB9XFxuY29uc29sZS5sb2cob3JpZ2luYWwpIC8vIHsgeDogMTIzLCB5OiA0NTYgfVxcbmBgYFwiLFwibm90ZXNcIjpbXX0sXCJzaWduYXR1cmVzXCI6W3tcInR5cGVQYXJhbXNcIjpbXCJDXCJdLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm1lcmdlclwiLFwidHlwZVwiOntcImtcIjo3LFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcIm9sZFZhbFwiLFwidHlwZVwiOntcImtcIjoxN319LHtcIm5hbWVcIjpcIm5ld1ZhbFwiLFwidHlwZVwiOntcImtcIjoxN319LHtcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjoxN319XSxcInR5cGVcIjp7XCJrXCI6MTd9fX0se1wibmFtZVwiOlwiY29sbGVjdGlvblwiLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn19LHtcIm5hbWVcIjpcImNvbGxlY3Rpb25zXCIsXCJ0eXBlXCI6e1wia1wiOjksXCJuYW1lXCI6XCJBcnJheVwiLFwiYXJnc1wiOlt7XCJrXCI6MTIsXCJ0eXBlc1wiOlt7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxN31dfSx7XCJrXCI6OSxcIm5hbWVcIjpcIkl0ZXJhYmxlXCIsXCJhcmdzXCI6W3tcImtcIjoxNCxcInR5cGVzXCI6W3tcImtcIjoxN30se1wia1wiOjE3fV19XX0se1wia1wiOjQsXCJtZW1iZXJzXCI6W3tcImluZGV4XCI6dHJ1ZSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6M319XSxcInR5cGVcIjp7XCJrXCI6MTd9fV19XX1dfSxcInZhckFyZ3NcIjp0cnVlfV0sXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifSxcImxpbmVcIjo1Mjc4fV19fSxcIm1lcmdlRGVlcFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIGNvcHkgb2YgdGhlIGNvbGxlY3Rpb24gd2l0aCB0aGUgcmVtYWluaW5nIGNvbGxlY3Rpb25zIG1lcmdlZCBpblxcbmRlZXBseSAocmVjdXJzaXZlbHkpLlwiLFwiZGVzY3JpcHRpb25cIjpcIkEgZnVuY3Rpb25hbCBhbHRlcm5hdGl2ZSB0byBgY29sbGVjdGlvbi5tZXJnZURlZXAoKWAgd2hpY2ggd2lsbCBhbHNvIHdvcmtcXG53aXRoIHBsYWluIE9iamVjdHMgYW5kIEFycmF5cy5cXG5cXG48IS0tIHJ1bmtpdDphY3RpdmF0ZSAtLT5cXG5gYGBqc1xcbmNvbnN0IHsgbWVyZ2VEZWVwIH0gPSByZXF1aXJlKCdpbW11dGFibGUnKVxcbmNvbnN0IG9yaWdpbmFsID0geyB4OiB7IHk6IDEyMyB9fVxcbm1lcmdlRGVlcChvcmlnaW5hbCwgeyB4OiB7IHo6IDQ1NiB9fSkgLy8geyB4OiB7IHk6IDEyMywgejogNDU2IH19XFxuY29uc29sZS5sb2cob3JpZ2luYWwpIC8vIHsgeDogeyB5OiAxMjMgfX1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJjb2xsZWN0aW9uXCIsXCJ0eXBlXCI6e1wia1wiOjgsXCJwYXJhbVwiOlwiQ1wifX0se1wibmFtZVwiOlwiY29sbGVjdGlvbnNcIixcInR5cGVcIjp7XCJrXCI6OSxcIm5hbWVcIjpcIkFycmF5XCIsXCJhcmdzXCI6W3tcImtcIjoxMixcInR5cGVzXCI6W3tcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE3fV19LHtcImtcIjo5LFwibmFtZVwiOlwiSXRlcmFibGVcIixcImFyZ3NcIjpbe1wia1wiOjE0LFwidHlwZXNcIjpbe1wia1wiOjE3fSx7XCJrXCI6MTd9XX1dfSx7XCJrXCI6NCxcIm1lbWJlcnNcIjpbe1wiaW5kZXhcIjp0cnVlLFwicGFyYW1zXCI6W3tcIm5hbWVcIjpcImtleVwiLFwidHlwZVwiOntcImtcIjozfX1dLFwidHlwZVwiOntcImtcIjoxN319XX1dfV19LFwidmFyQXJnc1wiOnRydWV9XSxcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9LFwibGluZVwiOjUyOTl9XX19LFwibWVyZ2VEZWVwV2l0aFwiOntcImNhbGxcIjp7XCJkb2NcIjp7XCJzeW5vcHNpc1wiOlwiUmV0dXJucyBhIGNvcHkgb2YgdGhlIGNvbGxlY3Rpb24gd2l0aCB0aGUgcmVtYWluaW5nIGNvbGxlY3Rpb25zIG1lcmdlZCBpblxcbmRlZXBseSAocmVjdXJzaXZlbHkpLCBjYWxsaW5nIHRoZSBgbWVyZ2VyYCBmdW5jdGlvbiB3aGVuZXZlciBhbiBleGlzdGluZ1xcbnZhbHVlIGlzIGVuY291bnRlcmVkLlwiLFwiZGVzY3JpcHRpb25cIjpcIkEgZnVuY3Rpb25hbCBhbHRlcm5hdGl2ZSB0byBgY29sbGVjdGlvbi5tZXJnZURlZXBXaXRoKClgIHdoaWNoIHdpbGwgYWxzb1xcbndvcmsgd2l0aCBwbGFpbiBPYmplY3RzIGFuZCBBcnJheXMuXFxuXFxuPCEtLSBydW5raXQ6YWN0aXZhdGUgLS0+XFxuYGBganNcXG5jb25zdCB7IG1lcmdlRGVlcFdpdGggfSA9IHJlcXVpcmUoJ2ltbXV0YWJsZScpXFxuY29uc3Qgb3JpZ2luYWwgPSB7IHg6IHsgeTogMTIzIH19XFxubWVyZ2VEZWVwV2l0aChcXG4gIChvbGRWYWwsIG5ld1ZhbCkgPT4gb2xkVmFsICsgbmV3VmFsLFxcbiAgb3JpZ2luYWwsXFxuICB7IHg6IHsgeTogNDU2IH19XFxuKSAvLyB7IHg6IHsgeTogNTc5IH19XFxuY29uc29sZS5sb2cob3JpZ2luYWwpIC8vIHsgeDogeyB5OiAxMjMgfX1cXG5gYGBcIixcIm5vdGVzXCI6W119LFwic2lnbmF0dXJlc1wiOlt7XCJ0eXBlUGFyYW1zXCI6W1wiQ1wiXSxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJtZXJnZXJcIixcInR5cGVcIjp7XCJrXCI6NyxcInBhcmFtc1wiOlt7XCJuYW1lXCI6XCJvbGRWYWxcIixcInR5cGVcIjp7XCJrXCI6MTd9fSx7XCJuYW1lXCI6XCJuZXdWYWxcIixcInR5cGVcIjp7XCJrXCI6MTd9fSx7XCJuYW1lXCI6XCJrZXlcIixcInR5cGVcIjp7XCJrXCI6MTd9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX19LHtcIm5hbWVcIjpcImNvbGxlY3Rpb25cIixcInR5cGVcIjp7XCJrXCI6OCxcInBhcmFtXCI6XCJDXCJ9fSx7XCJuYW1lXCI6XCJjb2xsZWN0aW9uc1wiLFwidHlwZVwiOntcImtcIjo5LFwibmFtZVwiOlwiQXJyYXlcIixcImFyZ3NcIjpbe1wia1wiOjEyLFwidHlwZXNcIjpbe1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTd9XX0se1wia1wiOjksXCJuYW1lXCI6XCJJdGVyYWJsZVwiLFwiYXJnc1wiOlt7XCJrXCI6MTQsXCJ0eXBlc1wiOlt7XCJrXCI6MTd9LHtcImtcIjoxN31dfV19LHtcImtcIjo0LFwibWVtYmVyc1wiOlt7XCJpbmRleFwiOnRydWUsXCJwYXJhbXNcIjpbe1wibmFtZVwiOlwia2V5XCIsXCJ0eXBlXCI6e1wia1wiOjN9fV0sXCJ0eXBlXCI6e1wia1wiOjE3fX1dfV19XX0sXCJ2YXJBcmdzXCI6dHJ1ZX1dLFwidHlwZVwiOntcImtcIjo4LFwicGFyYW1cIjpcIkNcIn0sXCJsaW5lXCI6NTMyNH1dfX19fSxcImltbXV0YWJsZVwiOntcIm1vZHVsZVwiOnt9fX0iLCJ2YXIgVHlwZUtpbmQgPSB7XG4gIEFueTogMCxcblxuICBCb29sZWFuOiAxLFxuICBOdW1iZXI6IDIsXG4gIFN0cmluZzogMyxcbiAgT2JqZWN0OiA0LFxuICBBcnJheTogNSxcbiAgTmV2ZXI6IDYsXG4gIEZ1bmN0aW9uOiA3LFxuXG4gIFBhcmFtOiA4LFxuICBUeXBlOiA5LFxuXG4gIFRoaXM6IDEwLFxuICBVbmRlZmluZWQ6IDExLFxuICBVbmlvbjogMTIsXG4gIEludGVyc2VjdGlvbjogMTMsXG4gIFR1cGxlOiAxNCxcbiAgSW5kZXhlZDogMTUsXG4gIE9wZXJhdG9yOiAxNixcblxuICBVbmtub3duOiAxNyxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZUtpbmQ7XG4iLCJ2YXIgJF9fMD0gICAgcmVxdWlyZSgnLi4vLi4vJyksU2VxPSRfXzAuU2VxO1xuLy8gTm90ZTogaW50ZW50aW9uYWxseSB1c2luZyByYXcgZGVmcywgbm90IGdldFR5cGVEZWZzIHRvIGF2b2lkIGNpcmN1bGFyIHJlZi5cbnZhciBkZWZzID0gcmVxdWlyZSgnLi4vZ2VuZXJhdGVkL2ltbXV0YWJsZS5kLmpzb24nKTtcblxuZnVuY3Rpb24gY29sbGVjdE1lbWJlckdyb3VwcyhpbnRlcmZhY2VEZWYsIG9wdGlvbnMpIHtcbiAgdmFyIG1lbWJlcnMgPSB7fTtcblxuICBpZiAoaW50ZXJmYWNlRGVmKSB7XG4gICAgY29sbGVjdEZyb21EZWYoaW50ZXJmYWNlRGVmKTtcbiAgfVxuXG4gIHZhciBncm91cHMgPSB7ICcnOiBbXSB9O1xuXG4gIGlmIChvcHRpb25zLnNob3dJbkdyb3Vwcykge1xuICAgIFNlcShtZW1iZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG1lbWJlcikgIHtcbiAgICAgIChncm91cHNbbWVtYmVyLmdyb3VwXSB8fCAoZ3JvdXBzW21lbWJlci5ncm91cF0gPSBbXSkpLnB1c2gobWVtYmVyKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBncm91cHNbJyddID0gU2VxKG1lbWJlcnMpXG4gICAgICAuc29ydEJ5KGZ1bmN0aW9uKG1lbWJlcikgIHtyZXR1cm4gbWVtYmVyLm1lbWJlck5hbWU7fSlcbiAgICAgIC50b0FycmF5KCk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMuc2hvd0luaGVyaXRlZCkge1xuICAgIGdyb3VwcyA9IFNlcShncm91cHMpXG4gICAgICAubWFwKGZ1bmN0aW9uKG1lbWJlcnMpICB7cmV0dXJuIG1lbWJlcnMuZmlsdGVyKGZ1bmN0aW9uKG1lbWJlcikgIHtyZXR1cm4gIW1lbWJlci5pbmhlcml0ZWQ7fSk7fSlcbiAgICAgIC50b09iamVjdCgpO1xuICB9XG5cbiAgcmV0dXJuIGdyb3VwcztcblxuICBmdW5jdGlvbiBjb2xsZWN0RnJvbURlZihkZWYsIG5hbWUpIHtcbiAgICBkZWYuZ3JvdXBzICYmXG4gICAgICBkZWYuZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24oZykgIHtcbiAgICAgICAgU2VxKGcubWVtYmVycykuZm9yRWFjaChmdW5jdGlvbihtZW1iZXJEZWYsIG1lbWJlck5hbWUpICB7XG4gICAgICAgICAgY29sbGVjdE1lbWJlcihnLnRpdGxlIHx8ICcnLCBtZW1iZXJOYW1lLCBtZW1iZXJEZWYpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgZGVmLmV4dGVuZHMgJiZcbiAgICAgIGRlZi5leHRlbmRzLmZvckVhY2goZnVuY3Rpb24oZSkgIHtcbiAgICAgICAgdmFyIHN1cGVyTW9kdWxlID0gZGVmcy5JbW11dGFibGU7XG4gICAgICAgIGUubmFtZS5zcGxpdCgnLicpLmZvckVhY2goZnVuY3Rpb24ocGFydCkgIHtcbiAgICAgICAgICBzdXBlck1vZHVsZSA9XG4gICAgICAgICAgICBzdXBlck1vZHVsZSAmJiBzdXBlck1vZHVsZS5tb2R1bGUgJiYgc3VwZXJNb2R1bGUubW9kdWxlW3BhcnRdO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHN1cGVySW50ZXJmYWNlID0gc3VwZXJNb2R1bGUgJiYgc3VwZXJNb2R1bGUuaW50ZXJmYWNlO1xuICAgICAgICBpZiAoc3VwZXJJbnRlcmZhY2UpIHtcbiAgICAgICAgICBjb2xsZWN0RnJvbURlZihzdXBlckludGVyZmFjZSwgZS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICBmdW5jdGlvbiBjb2xsZWN0TWVtYmVyKGdyb3VwLCBtZW1iZXJOYW1lLCBtZW1iZXJEZWYpIHtcbiAgICAgIHZhciBtZW1iZXIgPSBtZW1iZXJzW21lbWJlck5hbWVdO1xuICAgICAgaWYgKG1lbWJlcikge1xuICAgICAgICBpZiAoIW1lbWJlci5pbmhlcml0ZWQpIHtcbiAgICAgICAgICBtZW1iZXIub3ZlcnJpZGVzID0geyBuYW1lOm5hbWUsIGRlZjpkZWYsIG1lbWJlckRlZjptZW1iZXJEZWYgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1lbWJlci5ncm91cCAmJiBncm91cCkge1xuICAgICAgICAgIG1lbWJlci5ncm91cCA9IGdyb3VwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZW1iZXIgPSB7XG4gICAgICAgICAgZ3JvdXA6Z3JvdXAsXG4gICAgICAgICAgbWVtYmVyTmFtZTogbWVtYmVyTmFtZS5zdWJzdHIoMSksXG4gICAgICAgICAgbWVtYmVyRGVmOm1lbWJlckRlZixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRlZiAhPT0gaW50ZXJmYWNlRGVmKSB7XG4gICAgICAgICAgbWVtYmVyLmluaGVyaXRlZCA9IHsgbmFtZTpuYW1lLCBkZWY6ZGVmIH07XG4gICAgICAgIH1cbiAgICAgICAgbWVtYmVyc1ttZW1iZXJOYW1lXSA9IG1lbWJlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb2xsZWN0TWVtYmVyR3JvdXBzO1xuIiwidmFyIG1hcmtkb3duRG9jcyA9IHJlcXVpcmUoJy4vbWFya2Rvd25Eb2NzJyk7XG52YXIgZGVmcyA9IHJlcXVpcmUoJy4uL2dlbmVyYXRlZC9pbW11dGFibGUuZC5qc29uJyk7XG5cbm1hcmtkb3duRG9jcyhkZWZzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZzO1xuIiwidmFyIG1hcmtlZCA9IHJlcXVpcmUoJ21hcmtlZCcpO1xudmFyICRfXzA9ICAgIHJlcXVpcmUoJy4uLy4uLycpLFNlcT0kX18wLlNlcTtcbnZhciBwcmlzbSA9IHJlcXVpcmUoJy4vcHJpc20nKTtcbnZhciBjb2xsZWN0TWVtYmVyR3JvdXBzID0gcmVxdWlyZSgnLi9jb2xsZWN0TWVtYmVyR3JvdXBzJyk7XG4vLyBOb3RlOiBpbnRlbnRpb25hbGx5IHVzaW5nIHJhdyBkZWZzLCBub3QgZ2V0VHlwZURlZnMgdG8gYXZvaWQgY2lyY3VsYXIgcmVmLlxudmFyIGRlZnMgPSByZXF1aXJlKCcuLi9nZW5lcmF0ZWQvaW1tdXRhYmxlLmQuanNvbicpO1xuXG5mdW5jdGlvbiBjb2xsZWN0QWxsTWVtYmVyc0ZvckFsbFR5cGVzKGRlZnMpIHtcbiAgdmFyIGFsbE1lbWJlcnMgPSBuZXcgV2Vha01hcCgpO1xuICBfY29sbGVjdEFsbE1lbWJlcnNGb3JBbGxUeXBlcyhkZWZzKTtcbiAgcmV0dXJuIGFsbE1lbWJlcnM7XG4gIGZ1bmN0aW9uIF9jb2xsZWN0QWxsTWVtYmVyc0ZvckFsbFR5cGVzKGRlZnMpIHtcbiAgICBTZXEoZGVmcykuZm9yRWFjaChmdW5jdGlvbihkZWYpICB7XG4gICAgICBpZiAoZGVmLmludGVyZmFjZSkge1xuICAgICAgICB2YXIgZ3JvdXBzID0gY29sbGVjdE1lbWJlckdyb3VwcyhkZWYuaW50ZXJmYWNlLCB7XG4gICAgICAgICAgc2hvd0luaGVyaXRlZDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGFsbE1lbWJlcnMuc2V0KFxuICAgICAgICAgIGRlZi5pbnRlcmZhY2UsXG4gICAgICAgICAgU2VxLktleWVkKFxuICAgICAgICAgICAgZ3JvdXBzWycnXS5tYXAoZnVuY3Rpb24obWVtYmVyKSAge3JldHVybiBbbWVtYmVyLm1lbWJlck5hbWUsIG1lbWJlci5tZW1iZXJEZWZdO30pXG4gICAgICAgICAgKS50b09iamVjdCgpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZGVmLm1vZHVsZSkge1xuICAgICAgICBfY29sbGVjdEFsbE1lbWJlcnNGb3JBbGxUeXBlcyhkZWYubW9kdWxlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYWxsTWVtYmVycztcbiAgfVxufVxuXG52YXIgYWxsTWVtYmVycyA9IGNvbGxlY3RBbGxNZW1iZXJzRm9yQWxsVHlwZXMoZGVmcyk7XG5cbi8vIGZ1bmN0aW9ucyBjb21lIGJlZm9yZSBrZXl3b3Jkc1xucHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdrZXl3b3JkJywge1xuICB2YXI6IC9cXGIodGhpcylcXGIvZyxcbiAgJ2Jsb2NrLWtleXdvcmQnOiAvXFxiKGlmfGVsc2V8d2hpbGV8Zm9yfGZ1bmN0aW9uKVxcYi9nLFxuICBwcmltaXRpdmU6IC9cXGIodHJ1ZXxmYWxzZXxudWxsfHVuZGVmaW5lZClcXGIvZyxcbiAgZnVuY3Rpb246IHByaXNtLmxhbmd1YWdlcy5mdW5jdGlvbixcbn0pO1xuXG5wcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0Jywge1xuICBxdWFsaWZpZXI6IC9cXGJbQS1aXVthLXowLTlfXSsvZyxcbn0pO1xuXG5tYXJrZWQuc2V0T3B0aW9ucyh7XG4gIHhodG1sOiB0cnVlLFxuICBoaWdobGlnaHQ6IGZ1bmN0aW9uKGNvZGUpICB7cmV0dXJuIHByaXNtLmhpZ2hsaWdodChjb2RlLCBwcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCk7fSxcbn0pO1xuXG52YXIgcmVuZGVyZXIgPSBuZXcgbWFya2VkLlJlbmRlcmVyKCk7XG5cbmNvbnN0IHJ1bmtpdFJlZ0V4cCA9IC9ePCEtLVxccypydW5raXQ6YWN0aXZhdGUoKC58XFxuKSopLS0+KC58XFxuKSokLztcbmNvbnN0IHJ1bmtpdENvbnRleHQgPSB7IG9wdGlvbnM6ICd7fScsIGFjdGl2YXRlZDogZmFsc2UgfTtcblxucmVuZGVyZXIuaHRtbCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHJ1bmtpdFJlZ0V4cC5leGVjKHRleHQpO1xuXG4gIGlmICghcmVzdWx0KSByZXR1cm4gdGV4dDtcblxuICBydW5raXRDb250ZXh0LmFjdGl2YXRlZCA9IHRydWU7XG4gIHRyeSB7XG4gICAgcnVua2l0Q29udGV4dC5vcHRpb25zID0gcmVzdWx0WzFdID8gSlNPTi5wYXJzZShyZXN1bHRbMV0pIDoge307XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBydW5raXRDb250ZXh0Lm9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4gdGV4dDtcbn07XG5cbnJlbmRlcmVyLmNvZGUgPSBmdW5jdGlvbiAoY29kZSwgbGFuZywgZXNjYXBlZCkge1xuICBpZiAodGhpcy5vcHRpb25zLmhpZ2hsaWdodCkge1xuICAgIHZhciBvdXQgPSB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KGNvZGUsIGxhbmcpO1xuICAgIGlmIChvdXQgIT0gbnVsbCAmJiBvdXQgIT09IGNvZGUpIHtcbiAgICAgIGVzY2FwZWQgPSB0cnVlO1xuICAgICAgY29kZSA9IG91dDtcbiAgICB9XG4gIH1cblxuICBjb25zdCBydW5JdEJ1dHRvbiA9IHJ1bmtpdENvbnRleHQuYWN0aXZhdGVkXG4gICAgPyAnPGEgY2xhc3M9XCJ0cnktaXRcIiBkYXRhLW9wdGlvbnM9XCInICtcbiAgICAgIGVzY2FwZShKU09OLnN0cmluZ2lmeShydW5raXRDb250ZXh0Lm9wdGlvbnMpKSArXG4gICAgICAnXCIgb25DbGljaz1cInJ1bkl0KHRoaXMpXCI+cnVuIGl0PC9hPidcbiAgICA6ICcnO1xuXG4gIHJ1bmtpdENvbnRleHQuYWN0aXZhdGVkID0gZmFsc2U7XG4gIHJ1bmtpdENvbnRleHQub3B0aW9ucyA9ICd7fSc7XG5cbiAgcmV0dXJuIChcbiAgICAnPGNvZGUgY2xhc3M9XCJjb2RlQmxvY2tcIj4nICtcbiAgICAoZXNjYXBlZCA/IGNvZGUgOiBlc2NhcGVDb2RlKGNvZGUsIHRydWUpKSArXG4gICAgcnVuSXRCdXR0b24gK1xuICAgICc8L2NvZGU+J1xuICApO1xufTtcblxudmFyIE1FVEhPRF9SWCA9IC9eKFxcdyspKD86WyMuXShcXHcrKSk/KD86XFwoXFwpKT8kLztcbnZhciBQQVJBTV9SWCA9IC9eXFx3KyQvO1xudmFyIE1ETl9UWVBFUyA9IHtcbiAgQXJyYXk6IHRydWUsXG4gIE9iamVjdDogdHJ1ZSxcbiAgSlNPTjogdHJ1ZSxcbn07XG52YXIgTUROX0JBU0VfVVJMID1cbiAgJ2h0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzLyc7XG5cbnJlbmRlcmVyLmNvZGVzcGFuID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgcmV0dXJuICc8Y29kZT4nICsgZGVjb3JhdGVDb2RlU3Bhbih0ZXh0LCB0aGlzLm9wdGlvbnMpICsgJzwvY29kZT4nO1xufTtcblxuZnVuY3Rpb24gZGVjb3JhdGVDb2RlU3Bhbih0ZXh0LCBvcHRpb25zKSB7XG4gIHZhciBjb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0O1xuXG4gIGlmIChcbiAgICBjb250ZXh0LnNpZ25hdHVyZXMgJiZcbiAgICBQQVJBTV9SWC50ZXN0KHRleHQpICYmXG4gICAgY29udGV4dC5zaWduYXR1cmVzLnNvbWUoXG4gICAgICBmdW5jdGlvbihzaWcpICB7cmV0dXJuIHNpZy5wYXJhbXMgJiYgc2lnLnBhcmFtcy5zb21lKGZ1bmN0aW9uKHBhcmFtKSAge3JldHVybiBwYXJhbS5uYW1lID09PSB0ZXh0O30pO31cbiAgICApXG4gICkge1xuICAgIHJldHVybiAnPHNwYW4gY2xhc3M9XCJ0IHBhcmFtXCI+JyArIHRleHQgKyAnPC9zcGFuPic7XG4gIH1cblxuICB2YXIgbWV0aG9kID0gTUVUSE9EX1JYLmV4ZWModGV4dCk7XG4gIGlmIChtZXRob2QpIHtcbiAgICBtZXRob2QgPSBtZXRob2Quc2xpY2UoMSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGlmIChNRE5fVFlQRVNbbWV0aG9kWzBdXSkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgJzxhIGhyZWY9XCInICsgTUROX0JBU0VfVVJMICsgbWV0aG9kLmpvaW4oJy8nKSArICdcIj4nICsgdGV4dCArICc8L2E+J1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgY29udGV4dC50eXBlUGF0aCAmJlxuICAgICAgIWFyckVuZHNXaXRoKGNvbnRleHQudHlwZVBhdGgsIG1ldGhvZCkgJiZcbiAgICAgICFhcnJFbmRzV2l0aChjb250ZXh0LnR5cGVQYXRoLnNsaWNlKDAsIC0xKSwgbWV0aG9kKVxuICAgICkge1xuICAgICAgdmFyIHBhdGggPSBmaW5kUGF0aChjb250ZXh0LCBtZXRob2QpO1xuICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgdmFyIHJlbFBhdGggPSBjb250ZXh0LnJlbFBhdGggfHwgJyc7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgJzxhIHRhcmdldD1cIl9zZWxmXCIgaHJlZj1cIicgK1xuICAgICAgICAgIHJlbFBhdGggK1xuICAgICAgICAgICcjLycgK1xuICAgICAgICAgIHBhdGguc2xpY2UoMSkuam9pbignLycpICtcbiAgICAgICAgICAnXCI+JyArXG4gICAgICAgICAgdGV4dCArXG4gICAgICAgICAgJzwvYT4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuaGlnaGxpZ2h0KHVuZXNjYXBlQ29kZSh0ZXh0KSwgcHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQpO1xuICB9XG5cbiAgcmV0dXJuIHRleHQ7XG59XG5cbmZ1bmN0aW9uIGFyckVuZHNXaXRoKGFycjEsIGFycjIpIHtcbiAgZm9yICh2YXIgaWkgPSAxOyBpaSA8PSBhcnIyLmxlbmd0aDsgaWkrKykge1xuICAgIGlmIChhcnIyW2FycjIubGVuZ3RoIC0gaWldICE9PSBhcnIxW2FycjEubGVuZ3RoIC0gaWldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmaW5kUGF0aChjb250ZXh0LCBzZWFyY2gpIHtcbiAgdmFyIHJlbGF0aXZlID0gY29udGV4dC50eXBlUGF0aDtcblxuICBmb3IgKHZhciBpaSA9IDA7IGlpIDw9IHJlbGF0aXZlLmxlbmd0aDsgaWkrKykge1xuICAgIHZhciBwYXRoID0gcmVsYXRpdmUuc2xpY2UoMCwgcmVsYXRpdmUubGVuZ3RoIC0gaWkpLmNvbmNhdChzZWFyY2gpO1xuICAgIGlmIChcbiAgICAgIHBhdGgucmVkdWNlKFxuICAgICAgICBmdW5jdGlvbihkZWYsIG5hbWUpIFxuICAgICAgICAgIHtyZXR1cm4gZGVmICYmXG4gICAgICAgICAgKChkZWYubW9kdWxlICYmIGRlZi5tb2R1bGVbbmFtZV0pIHx8XG4gICAgICAgICAgICAoZGVmLmludGVyZmFjZSAmJlxuICAgICAgICAgICAgICBhbGxNZW1iZXJzICYmXG4gICAgICAgICAgICAgIGFsbE1lbWJlcnMuZ2V0KGRlZi5pbnRlcmZhY2UpW25hbWVdKSB8fFxuICAgICAgICAgICAgdW5kZWZpbmVkKTt9LFxuICAgICAgICB7IG1vZHVsZTogZGVmcyB9XG4gICAgICApXG4gICAgKSB7XG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZXNjYXBlQ29kZShjb2RlKSB7XG4gIHJldHVybiBjb2RlXG4gICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcbiAgICAucmVwbGFjZSgvJy9nLCAnJiMzOTsnKTtcbn1cblxuZnVuY3Rpb24gdW5lc2NhcGVDb2RlKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGVcbiAgICAucmVwbGFjZSgvJmx0Oy9nLCAnPCcpXG4gICAgLnJlcGxhY2UoLyZndDsvZywgJz4nKVxuICAgIC5yZXBsYWNlKC8mcXVvdDsvZywgJ1wiJylcbiAgICAucmVwbGFjZSgvJiMzOTsvZywgXCInXCIpXG4gICAgLnJlcGxhY2UoLyZhbXA7L2csICcmJyk7XG59XG5cbmZ1bmN0aW9uIG1hcmtkb3duKGNvbnRlbnQsIGNvbnRleHQpIHtcbiAgY29udGV4dCB8fCAoY29udGV4dCA9IHt9KTtcbiAgcmV0dXJuIGNvbnRlbnQgPyBtYXJrZWQoY29udGVudCwgeyByZW5kZXJlcjpyZW5kZXJlciwgY29udGV4dDpjb250ZXh0IH0pIDogY29udGVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXJrZG93bjtcbiIsInZhciAkX18wPSAgICByZXF1aXJlKCcuLi8uLi8nKSxTZXE9JF9fMC5TZXE7XG52YXIgbWFya2Rvd24gPSByZXF1aXJlKCcuL21hcmtkb3duJyk7XG5cbmZ1bmN0aW9uIG1hcmtkb3duRG9jcyhkZWZzKSB7XG4gIG1hcmtkb3duVHlwZXMoZGVmcywgW10pO1xuXG4gIGZ1bmN0aW9uIG1hcmtkb3duVHlwZXModHlwZURlZnMsIHBhdGgpIHtcbiAgICBTZXEodHlwZURlZnMpLmZvckVhY2goZnVuY3Rpb24odHlwZURlZiwgdHlwZU5hbWUpICB7XG4gICAgICB2YXIgdHlwZVBhdGggPSBwYXRoLmNvbmNhdCh0eXBlTmFtZSk7XG4gICAgICBtYXJrZG93bkRvYyh0eXBlRGVmLmRvYywgeyB0eXBlUGF0aDp0eXBlUGF0aCB9KTtcbiAgICAgIHR5cGVEZWYuY2FsbCAmJlxuICAgICAgICBtYXJrZG93bkRvYyh0eXBlRGVmLmNhbGwuZG9jLCB7XG4gICAgICAgICAgdHlwZVBhdGg6dHlwZVBhdGgsXG4gICAgICAgICAgc2lnbmF0dXJlczogdHlwZURlZi5jYWxsLnNpZ25hdHVyZXMsXG4gICAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVEZWYuaW50ZXJmYWNlKSB7XG4gICAgICAgIG1hcmtkb3duRG9jKHR5cGVEZWYuaW50ZXJmYWNlLmRvYywgeyBkZWZzOmRlZnMsIHR5cGVQYXRoOnR5cGVQYXRoIH0pO1xuICAgICAgICBTZXEodHlwZURlZi5pbnRlcmZhY2UuZ3JvdXBzKS5mb3JFYWNoKGZ1bmN0aW9uKGdyb3VwKSBcbiAgICAgICAgICB7cmV0dXJuIFNlcShncm91cC5tZW1iZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG1lbWJlciwgbWVtYmVyTmFtZSkgXG4gICAgICAgICAgICB7cmV0dXJuIG1hcmtkb3duRG9jKG1lbWJlci5kb2MsIHtcbiAgICAgICAgICAgICAgdHlwZVBhdGg6IHR5cGVQYXRoLmNvbmNhdChtZW1iZXJOYW1lLnNsaWNlKDEpKSxcbiAgICAgICAgICAgICAgc2lnbmF0dXJlczogbWVtYmVyLnNpZ25hdHVyZXMsXG4gICAgICAgICAgICB9KTt9XG4gICAgICAgICAgKTt9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0eXBlRGVmLm1vZHVsZSAmJiBtYXJrZG93blR5cGVzKHR5cGVEZWYubW9kdWxlLCB0eXBlUGF0aCk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya2Rvd25Eb2MoZG9jLCBjb250ZXh0KSB7XG4gIGlmICghZG9jKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGRvYy5zeW5vcHNpcyAmJiAoZG9jLnN5bm9wc2lzID0gbWFya2Rvd24oZG9jLnN5bm9wc2lzLCBjb250ZXh0KSk7XG4gIGRvYy5kZXNjcmlwdGlvbiAmJiAoZG9jLmRlc2NyaXB0aW9uID0gbWFya2Rvd24oZG9jLmRlc2NyaXB0aW9uLCBjb250ZXh0KSk7XG4gIGRvYy5ub3RlcyAmJlxuICAgIGRvYy5ub3Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vdGUpICB7XG4gICAgICBpZiAobm90ZS5uYW1lICE9PSAnYWxpYXMnKSB7XG4gICAgICAgIG5vdGUuYm9keSA9IG1hcmtkb3duKG5vdGUuYm9keSwgY29udGV4dCk7XG4gICAgICB9XG4gICAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFya2Rvd25Eb2NzO1xuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1jb3JlLmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbnNlbGYgPVxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgID8gd2luZG93IC8vIGlmIGluIGJyb3dzZXJcbiAgICA6IHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZVxuICAgID8gc2VsZiAvLyBpZiBpbiB3b3JrZXJcbiAgICA6IHt9OyAvLyBpZiBpbiBub2RlIGpzXG5cbi8qKlxuICogUHJpc206IExpZ2h0d2VpZ2h0LCByb2J1c3QsIGVsZWdhbnQgc3ludGF4IGhpZ2hsaWdodGluZ1xuICogTUlUIGxpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAvXG4gKiBAYXV0aG9yIExlYSBWZXJvdSBodHRwOi8vbGVhLnZlcm91Lm1lXG4gKi9cblxudmFyIFByaXNtID0gKGZ1bmN0aW9uICgpIHtcbiAgLy8gUHJpdmF0ZSBoZWxwZXIgdmFyc1xuICB2YXIgbGFuZyA9IC9cXGJsYW5nKD86dWFnZSk/LSg/IVxcKikoXFx3KylcXGIvaTtcblxuICB2YXIgXyA9IChzZWxmLlByaXNtID0ge1xuICAgIHV0aWw6IHtcbiAgICAgIGVuY29kZTogZnVuY3Rpb24gKHRva2Vucykge1xuICAgICAgICBpZiAodG9rZW5zIGluc3RhbmNlb2YgVG9rZW4pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFRva2VuKFxuICAgICAgICAgICAgdG9rZW5zLnR5cGUsXG4gICAgICAgICAgICBfLnV0aWwuZW5jb2RlKHRva2Vucy5jb250ZW50KSxcbiAgICAgICAgICAgIHRva2Vucy5hbGlhc1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoXy51dGlsLnR5cGUodG9rZW5zKSA9PT0gJ0FycmF5Jykge1xuICAgICAgICAgIHJldHVybiB0b2tlbnMubWFwKF8udXRpbC5lbmNvZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0b2tlbnNcbiAgICAgICAgICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx1MDBhMC9nLCAnICcpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB0eXBlOiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLm1hdGNoKC9cXFtvYmplY3QgKFxcdyspXFxdLylbMV07XG4gICAgICB9LFxuXG4gICAgICAvLyBEZWVwIGNsb25lIGEgbGFuZ3VhZ2UgZGVmaW5pdGlvbiAoZS5nLiB0byBleHRlbmQgaXQpXG4gICAgICBjbG9uZTogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfLnV0aWwudHlwZShvKTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdPYmplY3QnOlxuICAgICAgICAgICAgdmFyIGNsb25lID0ge307XG5cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvKSB7XG4gICAgICAgICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBjbG9uZVtrZXldID0gXy51dGlsLmNsb25lKG9ba2V5XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXG4gICAgICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgICAgICAgcmV0dXJuIG8uc2xpY2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfSxcbiAgICB9LFxuXG4gICAgbGFuZ3VhZ2VzOiB7XG4gICAgICBleHRlbmQ6IGZ1bmN0aW9uIChpZCwgcmVkZWYpIHtcbiAgICAgICAgdmFyIGxhbmcgPSBfLnV0aWwuY2xvbmUoXy5sYW5ndWFnZXNbaWRdKTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcmVkZWYpIHtcbiAgICAgICAgICBsYW5nW2tleV0gPSByZWRlZltrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxhbmc7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEluc2VydCBhIHRva2VuIGJlZm9yZSBhbm90aGVyIHRva2VuIGluIGEgbGFuZ3VhZ2UgbGl0ZXJhbFxuICAgICAgICogQXMgdGhpcyBuZWVkcyB0byByZWNyZWF0ZSB0aGUgb2JqZWN0ICh3ZSBjYW5ub3QgYWN0dWFsbHkgaW5zZXJ0IGJlZm9yZSBrZXlzIGluIG9iamVjdCBsaXRlcmFscyksXG4gICAgICAgKiB3ZSBjYW5ub3QganVzdCBwcm92aWRlIGFuIG9iamVjdCwgd2UgbmVlZCBhbm9iamVjdCBhbmQgYSBrZXkuXG4gICAgICAgKiBAcGFyYW0gaW5zaWRlIFRoZSBrZXkgKG9yIGxhbmd1YWdlIGlkKSBvZiB0aGUgcGFyZW50XG4gICAgICAgKiBAcGFyYW0gYmVmb3JlIFRoZSBrZXkgdG8gaW5zZXJ0IGJlZm9yZS4gSWYgbm90IHByb3ZpZGVkLCB0aGUgZnVuY3Rpb24gYXBwZW5kcyBpbnN0ZWFkLlxuICAgICAgICogQHBhcmFtIGluc2VydCBPYmplY3Qgd2l0aCB0aGUga2V5L3ZhbHVlIHBhaXJzIHRvIGluc2VydFxuICAgICAgICogQHBhcmFtIHJvb3QgVGhlIG9iamVjdCB0aGF0IGNvbnRhaW5zIGBpbnNpZGVgLiBJZiBlcXVhbCB0byBQcmlzbS5sYW5ndWFnZXMsIGl0IGNhbiBiZSBvbWl0dGVkLlxuICAgICAgICovXG4gICAgICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uIChpbnNpZGUsIGJlZm9yZSwgaW5zZXJ0LCByb290KSB7XG4gICAgICAgIHJvb3QgPSByb290IHx8IF8ubGFuZ3VhZ2VzO1xuICAgICAgICB2YXIgZ3JhbW1hciA9IHJvb3RbaW5zaWRlXTtcblxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgaW5zZXJ0ID0gYXJndW1lbnRzWzFdO1xuXG4gICAgICAgICAgZm9yICh2YXIgbmV3VG9rZW4gaW4gaW5zZXJ0KSB7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0Lmhhc093blByb3BlcnR5KG5ld1Rva2VuKSkge1xuICAgICAgICAgICAgICBncmFtbWFyW25ld1Rva2VuXSA9IGluc2VydFtuZXdUb2tlbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGdyYW1tYXI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmV0ID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgdG9rZW4gaW4gZ3JhbW1hcikge1xuICAgICAgICAgIGlmIChncmFtbWFyLmhhc093blByb3BlcnR5KHRva2VuKSkge1xuICAgICAgICAgICAgaWYgKHRva2VuID09IGJlZm9yZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBuZXdUb2tlbiBpbiBpbnNlcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0Lmhhc093blByb3BlcnR5KG5ld1Rva2VuKSkge1xuICAgICAgICAgICAgICAgICAgcmV0W25ld1Rva2VuXSA9IGluc2VydFtuZXdUb2tlbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldFt0b2tlbl0gPSBncmFtbWFyW3Rva2VuXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgcmVmZXJlbmNlcyBpbiBvdGhlciBsYW5ndWFnZSBkZWZpbml0aW9uc1xuICAgICAgICBfLmxhbmd1YWdlcy5ERlMoXy5sYW5ndWFnZXMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSByb290W2luc2lkZV0gJiYga2V5ICE9IGluc2lkZSkge1xuICAgICAgICAgICAgdGhpc1trZXldID0gcmV0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIChyb290W2luc2lkZV0gPSByZXQpO1xuICAgICAgfSxcblxuICAgICAgLy8gVHJhdmVyc2UgYSBsYW5ndWFnZSBkZWZpbml0aW9uIHdpdGggRGVwdGggRmlyc3QgU2VhcmNoXG4gICAgICBERlM6IGZ1bmN0aW9uIChvLCBjYWxsYmFjaywgdHlwZSkge1xuICAgICAgICBmb3IgKHZhciBpIGluIG8pIHtcbiAgICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChvLCBpLCBvW2ldLCB0eXBlIHx8IGkpO1xuXG4gICAgICAgICAgICBpZiAoXy51dGlsLnR5cGUob1tpXSkgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICAgIF8ubGFuZ3VhZ2VzLkRGUyhvW2ldLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF8udXRpbC50eXBlKG9baV0pID09PSAnQXJyYXknKSB7XG4gICAgICAgICAgICAgIF8ubGFuZ3VhZ2VzLkRGUyhvW2ldLCBjYWxsYmFjaywgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0sXG5cbiAgICBoaWdobGlnaHRBbGw6IGZ1bmN0aW9uIChhc3luYywgY2FsbGJhY2spIHtcbiAgICAgIHZhciBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICdjb2RlW2NsYXNzKj1cImxhbmd1YWdlLVwiXSwgW2NsYXNzKj1cImxhbmd1YWdlLVwiXSBjb2RlLCBjb2RlW2NsYXNzKj1cImxhbmctXCJdLCBbY2xhc3MqPVwibGFuZy1cIl0gY29kZSdcbiAgICAgICk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBlbGVtZW50OyAoZWxlbWVudCA9IGVsZW1lbnRzW2krK10pOyApIHtcbiAgICAgICAgXy5oaWdobGlnaHRFbGVtZW50KGVsZW1lbnQsIGFzeW5jID09PSB0cnVlLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGhpZ2hsaWdodEVsZW1lbnQ6IGZ1bmN0aW9uIChlbGVtZW50LCBhc3luYywgY2FsbGJhY2spIHtcbiAgICAgIC8vIEZpbmQgbGFuZ3VhZ2VcbiAgICAgIHZhciBsYW5ndWFnZSxcbiAgICAgICAgZ3JhbW1hcixcbiAgICAgICAgcGFyZW50ID0gZWxlbWVudDtcblxuICAgICAgd2hpbGUgKHBhcmVudCAmJiAhbGFuZy50ZXN0KHBhcmVudC5jbGFzc05hbWUpKSB7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGxhbmd1YWdlID0gKHBhcmVudC5jbGFzc05hbWUubWF0Y2gobGFuZykgfHwgWywgJyddKVsxXTtcbiAgICAgICAgZ3JhbW1hciA9IF8ubGFuZ3VhZ2VzW2xhbmd1YWdlXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFncmFtbWFyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IGxhbmd1YWdlIG9uIHRoZSBlbGVtZW50LCBpZiBub3QgcHJlc2VudFxuICAgICAgZWxlbWVudC5jbGFzc05hbWUgPVxuICAgICAgICBlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKGxhbmcsICcnKS5yZXBsYWNlKC9cXHMrL2csICcgJykgK1xuICAgICAgICAnIGxhbmd1YWdlLScgK1xuICAgICAgICBsYW5ndWFnZTtcblxuICAgICAgLy8gU2V0IGxhbmd1YWdlIG9uIHRoZSBwYXJlbnQsIGZvciBzdHlsaW5nXG4gICAgICBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cbiAgICAgIGlmICgvcHJlL2kudGVzdChwYXJlbnQubm9kZU5hbWUpKSB7XG4gICAgICAgIHBhcmVudC5jbGFzc05hbWUgPVxuICAgICAgICAgIHBhcmVudC5jbGFzc05hbWUucmVwbGFjZShsYW5nLCAnJykucmVwbGFjZSgvXFxzKy9nLCAnICcpICtcbiAgICAgICAgICAnIGxhbmd1YWdlLScgK1xuICAgICAgICAgIGxhbmd1YWdlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29kZSA9IGVsZW1lbnQudGV4dENvbnRlbnQ7XG5cbiAgICAgIGlmICghY29kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBlbnYgPSB7XG4gICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZSxcbiAgICAgICAgZ3JhbW1hcjogZ3JhbW1hcixcbiAgICAgICAgY29kZTogY29kZSxcbiAgICAgIH07XG5cbiAgICAgIF8uaG9va3MucnVuKCdiZWZvcmUtaGlnaGxpZ2h0JywgZW52KTtcblxuICAgICAgaWYgKGFzeW5jICYmIHNlbGYuV29ya2VyKSB7XG4gICAgICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKF8uZmlsZW5hbWUpO1xuXG4gICAgICAgIHdvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgZW52LmhpZ2hsaWdodGVkQ29kZSA9IFRva2VuLnN0cmluZ2lmeShKU09OLnBhcnNlKGV2dC5kYXRhKSwgbGFuZ3VhZ2UpO1xuXG4gICAgICAgICAgXy5ob29rcy5ydW4oJ2JlZm9yZS1pbnNlcnQnLCBlbnYpO1xuXG4gICAgICAgICAgZW52LmVsZW1lbnQuaW5uZXJIVE1MID0gZW52LmhpZ2hsaWdodGVkQ29kZTtcblxuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwoZW52LmVsZW1lbnQpO1xuICAgICAgICAgIF8uaG9va3MucnVuKCdhZnRlci1oaWdobGlnaHQnLCBlbnYpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZShcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBsYW5ndWFnZTogZW52Lmxhbmd1YWdlLFxuICAgICAgICAgICAgY29kZTogZW52LmNvZGUsXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudi5oaWdobGlnaHRlZENvZGUgPSBfLmhpZ2hsaWdodChlbnYuY29kZSwgZW52LmdyYW1tYXIsIGVudi5sYW5ndWFnZSk7XG5cbiAgICAgICAgXy5ob29rcy5ydW4oJ2JlZm9yZS1pbnNlcnQnLCBlbnYpO1xuXG4gICAgICAgIGVudi5lbGVtZW50LmlubmVySFRNTCA9IGVudi5oaWdobGlnaHRlZENvZGU7XG5cbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbChlbGVtZW50KTtcblxuICAgICAgICBfLmhvb2tzLnJ1bignYWZ0ZXItaGlnaGxpZ2h0JywgZW52KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAodGV4dCwgZ3JhbW1hciwgbGFuZ3VhZ2UpIHtcbiAgICAgIHZhciB0b2tlbnMgPSBfLnRva2VuaXplKHRleHQsIGdyYW1tYXIpO1xuICAgICAgcmV0dXJuIFRva2VuLnN0cmluZ2lmeShfLnV0aWwuZW5jb2RlKHRva2VucyksIGxhbmd1YWdlKTtcbiAgICB9LFxuXG4gICAgdG9rZW5pemU6IGZ1bmN0aW9uICh0ZXh0LCBncmFtbWFyLCBsYW5ndWFnZSkge1xuICAgICAgdmFyIFRva2VuID0gXy5Ub2tlbjtcblxuICAgICAgdmFyIHN0cmFyciA9IFt0ZXh0XTtcblxuICAgICAgdmFyIHJlc3QgPSBncmFtbWFyLnJlc3Q7XG5cbiAgICAgIGlmIChyZXN0KSB7XG4gICAgICAgIGZvciAodmFyIHRva2VuIGluIHJlc3QpIHtcbiAgICAgICAgICBncmFtbWFyW3Rva2VuXSA9IHJlc3RbdG9rZW5dO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIGdyYW1tYXIucmVzdDtcbiAgICAgIH1cblxuICAgICAgdG9rZW5sb29wOiBmb3IgKHZhciB0b2tlbiBpbiBncmFtbWFyKSB7XG4gICAgICAgIGlmICghZ3JhbW1hci5oYXNPd25Qcm9wZXJ0eSh0b2tlbikgfHwgIWdyYW1tYXJbdG9rZW5dKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGF0dGVybnMgPSBncmFtbWFyW3Rva2VuXTtcbiAgICAgICAgcGF0dGVybnMgPSBfLnV0aWwudHlwZShwYXR0ZXJucykgPT09ICdBcnJheScgPyBwYXR0ZXJucyA6IFtwYXR0ZXJuc107XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXR0ZXJucy5sZW5ndGg7ICsraikge1xuICAgICAgICAgIHZhciBwYXR0ZXJuID0gcGF0dGVybnNbal0sXG4gICAgICAgICAgICBpbnNpZGUgPSBwYXR0ZXJuLmluc2lkZSxcbiAgICAgICAgICAgIGxvb2tiZWhpbmQgPSAhIXBhdHRlcm4ubG9va2JlaGluZCxcbiAgICAgICAgICAgIGxvb2tiZWhpbmRMZW5ndGggPSAwLFxuICAgICAgICAgICAgYWxpYXMgPSBwYXR0ZXJuLmFsaWFzO1xuXG4gICAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4ucGF0dGVybiB8fCBwYXR0ZXJuO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIERvbuKAmXQgY2FjaGUgbGVuZ3RoIGFzIGl0IGNoYW5nZXMgZHVyaW5nIHRoZSBsb29wXG5cbiAgICAgICAgICAgIHZhciBzdHIgPSBzdHJhcnJbaV07XG5cbiAgICAgICAgICAgIGlmIChzdHJhcnIubGVuZ3RoID4gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIHdlbnQgdGVycmlibHkgd3JvbmcsIEFCT1JULCBBQk9SVCFcbiAgICAgICAgICAgICAgYnJlYWsgdG9rZW5sb29wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RyIGluc3RhbmNlb2YgVG9rZW4pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhdHRlcm4ubGFzdEluZGV4ID0gMDtcblxuICAgICAgICAgICAgdmFyIG1hdGNoID0gcGF0dGVybi5leGVjKHN0cik7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICBpZiAobG9va2JlaGluZCkge1xuICAgICAgICAgICAgICAgIGxvb2tiZWhpbmRMZW5ndGggPSBtYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgZnJvbSA9IG1hdGNoLmluZGV4IC0gMSArIGxvb2tiZWhpbmRMZW5ndGgsXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaFswXS5zbGljZShsb29rYmVoaW5kTGVuZ3RoKSxcbiAgICAgICAgICAgICAgICBsZW4gPSBtYXRjaC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdG8gPSBmcm9tICsgbGVuLFxuICAgICAgICAgICAgICAgIGJlZm9yZSA9IHN0ci5zbGljZSgwLCBmcm9tICsgMSksXG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBzdHIuc2xpY2UodG8gKyAxKTtcblxuICAgICAgICAgICAgICB2YXIgYXJncyA9IFtpLCAxXTtcblxuICAgICAgICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGJlZm9yZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgd3JhcHBlZCA9IG5ldyBUb2tlbihcbiAgICAgICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgICAgICBpbnNpZGUgPyBfLnRva2VuaXplKG1hdGNoLCBpbnNpZGUpIDogbWF0Y2gsXG4gICAgICAgICAgICAgICAgYWxpYXNcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICBhcmdzLnB1c2god3JhcHBlZCk7XG5cbiAgICAgICAgICAgICAgaWYgKGFmdGVyKSB7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGFmdGVyKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkoc3RyYXJyLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cmFycjtcbiAgICB9LFxuXG4gICAgaG9va3M6IHtcbiAgICAgIGFsbDoge30sXG5cbiAgICAgIGFkZDogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBob29rcyA9IF8uaG9va3MuYWxsO1xuXG4gICAgICAgIGhvb2tzW25hbWVdID0gaG9va3NbbmFtZV0gfHwgW107XG5cbiAgICAgICAgaG9va3NbbmFtZV0ucHVzaChjYWxsYmFjayk7XG4gICAgICB9LFxuXG4gICAgICBydW46IGZ1bmN0aW9uIChuYW1lLCBlbnYpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IF8uaG9va3MuYWxsW25hbWVdO1xuXG4gICAgICAgIGlmICghY2FsbGJhY2tzIHx8ICFjYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGNhbGxiYWNrOyAoY2FsbGJhY2sgPSBjYWxsYmFja3NbaSsrXSk7ICkge1xuICAgICAgICAgIGNhbGxiYWNrKGVudik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG5cbiAgdmFyIFRva2VuID0gKF8uVG9rZW4gPSBmdW5jdGlvbiAodHlwZSwgY29udGVudCwgYWxpYXMpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgdGhpcy5hbGlhcyA9IGFsaWFzO1xuICB9KTtcblxuICBUb2tlbi5zdHJpbmdpZnkgPSBmdW5jdGlvbiAobywgbGFuZ3VhZ2UsIHBhcmVudCkge1xuICAgIGlmICh0eXBlb2YgbyA9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG87XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm4gb1xuICAgICAgICAubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIFRva2VuLnN0cmluZ2lmeShlbGVtZW50LCBsYW5ndWFnZSwgbyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKCcnKTtcbiAgICB9XG5cbiAgICB2YXIgZW52ID0ge1xuICAgICAgdHlwZTogby50eXBlLFxuICAgICAgY29udGVudDogVG9rZW4uc3RyaW5naWZ5KG8uY29udGVudCwgbGFuZ3VhZ2UsIHBhcmVudCksXG4gICAgICB0YWc6ICdzcGFuJyxcbiAgICAgIGNsYXNzZXM6IFsndG9rZW4nLCBvLnR5cGVdLFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBsYW5ndWFnZTogbGFuZ3VhZ2UsXG4gICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICB9O1xuXG4gICAgaWYgKGVudi50eXBlID09ICdjb21tZW50Jykge1xuICAgICAgZW52LmF0dHJpYnV0ZXNbJ3NwZWxsY2hlY2snXSA9ICd0cnVlJztcbiAgICB9XG5cbiAgICBpZiAoby5hbGlhcykge1xuICAgICAgdmFyIGFsaWFzZXMgPSBfLnV0aWwudHlwZShvLmFsaWFzKSA9PT0gJ0FycmF5JyA/IG8uYWxpYXMgOiBbby5hbGlhc107XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlbnYuY2xhc3NlcywgYWxpYXNlcyk7XG4gICAgfVxuXG4gICAgXy5ob29rcy5ydW4oJ3dyYXAnLCBlbnYpO1xuXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSAnJztcblxuICAgIGZvciAodmFyIG5hbWUgaW4gZW52LmF0dHJpYnV0ZXMpIHtcbiAgICAgIGF0dHJpYnV0ZXMgKz0gbmFtZSArICc9XCInICsgKGVudi5hdHRyaWJ1dGVzW25hbWVdIHx8ICcnKSArICdcIic7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgICc8JyArXG4gICAgICBlbnYudGFnICtcbiAgICAgICcgY2xhc3M9XCInICtcbiAgICAgIGVudi5jbGFzc2VzLmpvaW4oJyAnKSArXG4gICAgICAnXCIgJyArXG4gICAgICBhdHRyaWJ1dGVzICtcbiAgICAgICc+JyArXG4gICAgICBlbnYuY29udGVudCArXG4gICAgICAnPC8nICtcbiAgICAgIGVudi50YWcgK1xuICAgICAgJz4nXG4gICAgKTtcbiAgfTtcblxuICBpZiAoIXNlbGYuZG9jdW1lbnQpIHtcbiAgICBpZiAoIXNlbGYuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgLy8gaW4gTm9kZS5qc1xuICAgICAgcmV0dXJuIHNlbGYuUHJpc207XG4gICAgfVxuICAgIC8vIEluIHdvcmtlclxuICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICdtZXNzYWdlJyxcbiAgICAgIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBKU09OLnBhcnNlKGV2dC5kYXRhKSxcbiAgICAgICAgICBsYW5nID0gbWVzc2FnZS5sYW5ndWFnZSxcbiAgICAgICAgICBjb2RlID0gbWVzc2FnZS5jb2RlO1xuXG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkoXy51dGlsLmVuY29kZShfLnRva2VuaXplKGNvZGUsIF8ubGFuZ3VhZ2VzW2xhbmddKSkpXG4gICAgICAgICk7XG4gICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgIH0sXG4gICAgICBmYWxzZVxuICAgICk7XG5cbiAgICByZXR1cm4gc2VsZi5QcmlzbTtcbiAgfVxuXG4gIC8vIEdldCBjdXJyZW50IHNjcmlwdCBhbmQgaGlnaGxpZ2h0XG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG5cbiAgc2NyaXB0ID0gc2NyaXB0W3NjcmlwdC5sZW5ndGggLSAxXTtcblxuICBpZiAoc2NyaXB0KSB7XG4gICAgXy5maWxlbmFtZSA9IHNjcmlwdC5zcmM7XG5cbiAgICBpZiAoZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciAmJiAhc2NyaXB0Lmhhc0F0dHJpYnV0ZSgnZGF0YS1tYW51YWwnKSkge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIF8uaGlnaGxpZ2h0QWxsKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VsZi5QcmlzbTtcbn0pKCk7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IFByaXNtO1xufVxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLW1hcmt1cC5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMubWFya3VwID0ge1xuICBjb21tZW50OiAvPCEtLVtcXHdcXFddKj8tLT4vZyxcbiAgcHJvbG9nOiAvPFxcPy4rP1xcPz4vLFxuICBkb2N0eXBlOiAvPCFET0NUWVBFLis/Pi8sXG4gIGNkYXRhOiAvPCFcXFtDREFUQVxcW1tcXHdcXFddKj9dXT4vaSxcbiAgdGFnOiB7XG4gICAgcGF0dGVybjpcbiAgICAgIC88XFwvP1tcXHc6LV0rXFxzKig/OlxccytbXFx3Oi1dKyg/Oj0oPzooXCJ8JykoXFxcXD9bXFx3XFxXXSkqP1xcMXxbXlxccydcIj49XSspKT9cXHMqKSpcXC8/Pi9naSxcbiAgICBpbnNpZGU6IHtcbiAgICAgIHRhZzoge1xuICAgICAgICBwYXR0ZXJuOiAvXjxcXC8/W1xcdzotXSsvaSxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgcHVuY3R1YXRpb246IC9ePFxcLz8vLFxuICAgICAgICAgIG5hbWVzcGFjZTogL15bXFx3LV0rPzovLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgICdhdHRyLXZhbHVlJzoge1xuICAgICAgICBwYXR0ZXJuOiAvPSg/OignfFwiKVtcXHdcXFddKj8oXFwxKXxbXlxccz5dKykvZ2ksXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgIHB1bmN0dWF0aW9uOiAvPXw+fFwiL2csXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgcHVuY3R1YXRpb246IC9cXC8/Pi9nLFxuICAgICAgJ2F0dHItbmFtZSc6IHtcbiAgICAgICAgcGF0dGVybjogL1tcXHc6LV0rL2csXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgIG5hbWVzcGFjZTogL15bXFx3LV0rPzovLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICB9LFxuICBlbnRpdHk6IC9cXCYjP1tcXGRhLXpdezEsOH07L2dpLFxufTtcblxuLy8gUGx1Z2luIHRvIG1ha2UgZW50aXR5IHRpdGxlIHNob3cgdGhlIHJlYWwgZW50aXR5LCBpZGVhIGJ5IFJvbWFuIEtvbWFyb3ZcblByaXNtLmhvb2tzLmFkZCgnd3JhcCcsIGZ1bmN0aW9uIChlbnYpIHtcbiAgaWYgKGVudi50eXBlID09PSAnZW50aXR5Jykge1xuICAgIGVudi5hdHRyaWJ1dGVzWyd0aXRsZSddID0gZW52LmNvbnRlbnQucmVwbGFjZSgvJmFtcDsvLCAnJicpO1xuICB9XG59KTtcblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1jc3MuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuUHJpc20ubGFuZ3VhZ2VzLmNzcyA9IHtcbiAgY29tbWVudDogL1xcL1xcKltcXHdcXFddKj9cXCpcXC8vZyxcbiAgYXRydWxlOiB7XG4gICAgcGF0dGVybjogL0BbXFx3LV0rPy4qPyg7fCg/PVxccyp7KSkvZ2ksXG4gICAgaW5zaWRlOiB7XG4gICAgICBwdW5jdHVhdGlvbjogL1s7Ol0vZyxcbiAgICB9LFxuICB9LFxuICB1cmw6IC91cmxcXCgoW1wiJ10/KS4qP1xcMVxcKS9naSxcbiAgc2VsZWN0b3I6IC9bXlxce1xcfVxcc11bXlxce1xcfTtdKig/PVxccypcXHspL2csXG4gIHByb3BlcnR5OiAvKFxcYnxcXEIpW1xcdy1dKyg/PVxccyo6KS9naSxcbiAgc3RyaW5nOiAvKFwifCcpKFxcXFw/LikqP1xcMS9nLFxuICBpbXBvcnRhbnQ6IC9cXEIhaW1wb3J0YW50XFxiL2dpLFxuICBwdW5jdHVhdGlvbjogL1tcXHtcXH07Ol0vZyxcbiAgZnVuY3Rpb246IC9bLWEtejAtOV0rKD89XFwoKS9naSxcbn07XG5cbmlmIChQcmlzbS5sYW5ndWFnZXMubWFya3VwKSB7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICd0YWcnLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIHBhdHRlcm46IC88c3R5bGVbXFx3XFxXXSo/PltcXHdcXFddKj88XFwvc3R5bGU+L2dpLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgIHRhZzoge1xuICAgICAgICAgIHBhdHRlcm46IC88c3R5bGVbXFx3XFxXXSo/Pnw8XFwvc3R5bGU+L2dpLFxuICAgICAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuaW5zaWRlLFxuICAgICAgICB9LFxuICAgICAgICByZXN0OiBQcmlzbS5sYW5ndWFnZXMuY3NzLFxuICAgICAgfSxcbiAgICAgIGFsaWFzOiAnbGFuZ3VhZ2UtY3NzJyxcbiAgICB9LFxuICB9KTtcblxuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKFxuICAgICdpbnNpZGUnLFxuICAgICdhdHRyLXZhbHVlJyxcbiAgICB7XG4gICAgICAnc3R5bGUtYXR0cic6IHtcbiAgICAgICAgcGF0dGVybjogL1xccypzdHlsZT0oXCJ8JykuKz9cXDEvZ2ksXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgICdhdHRyLW5hbWUnOiB7XG4gICAgICAgICAgICBwYXR0ZXJuOiAvXlxccypzdHlsZS9naSxcbiAgICAgICAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuaW5zaWRlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHVuY3R1YXRpb246IC9eXFxzKj1cXHMqWydcIl18WydcIl1cXHMqJC8sXG4gICAgICAgICAgJ2F0dHItdmFsdWUnOiB7XG4gICAgICAgICAgICBwYXR0ZXJuOiAvLisvZ2ksXG4gICAgICAgICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5jc3MsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgYWxpYXM6ICdsYW5ndWFnZS1jc3MnLFxuICAgICAgfSxcbiAgICB9LFxuICAgIFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnXG4gICk7XG59XG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tY2xpa2UuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuUHJpc20ubGFuZ3VhZ2VzLmNsaWtlID0ge1xuICBjb21tZW50OiBbXG4gICAge1xuICAgICAgcGF0dGVybjogLyhefFteXFxcXF0pXFwvXFwqW1xcd1xcV10qP1xcKlxcLy9nLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICB9LFxuICAgIHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXlxcXFw6XSlcXC9cXC8uKj8oXFxyP1xcbnwkKS9nLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICB9LFxuICBdLFxuICBzdHJpbmc6IC8oXCJ8JykoXFxcXD8uKSo/XFwxL2csXG4gICdjbGFzcy1uYW1lJzoge1xuICAgIHBhdHRlcm46XG4gICAgICAvKCg/Oig/OmNsYXNzfGludGVyZmFjZXxleHRlbmRzfGltcGxlbWVudHN8dHJhaXR8aW5zdGFuY2VvZnxuZXcpXFxzKyl8KD86Y2F0Y2hcXHMrXFwoKSlbYS16MC05X1xcLlxcXFxdKy9naSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgcHVuY3R1YXRpb246IC8oXFwufFxcXFwpLyxcbiAgICB9LFxuICB9LFxuICBrZXl3b3JkOlxuICAgIC9cXGIoaWZ8ZWxzZXx3aGlsZXxkb3xmb3J8cmV0dXJufGlufGluc3RhbmNlb2Z8ZnVuY3Rpb258bmV3fHRyeXx0aHJvd3xjYXRjaHxmaW5hbGx5fG51bGx8YnJlYWt8Y29udGludWUpXFxiL2csXG4gIGJvb2xlYW46IC9cXGIodHJ1ZXxmYWxzZSlcXGIvZyxcbiAgZnVuY3Rpb246IHtcbiAgICBwYXR0ZXJuOiAvW2EtejAtOV9dK1xcKC9naSxcbiAgICBpbnNpZGU6IHtcbiAgICAgIHB1bmN0dWF0aW9uOiAvXFwoLyxcbiAgICB9LFxuICB9LFxuICBudW1iZXI6IC9cXGItPygweFtcXGRBLUZhLWZdK3xcXGQqXFwuP1xcZCsoW0VlXS0/XFxkKyk/KVxcYi9nLFxuICBvcGVyYXRvcjogL1stK117MSwyfXwhfDw9P3w+PT98PXsxLDN9fCZ7MSwyfXxcXHw/XFx8fFxcP3xcXCp8XFwvfFxcfnxcXF58XFwlL2csXG4gIGlnbm9yZTogLyYobHR8Z3R8YW1wKTsvZ2ksXG4gIHB1bmN0dWF0aW9uOiAvW3t9W1xcXTsoKSwuOl0vZyxcbn07XG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tamF2YXNjcmlwdC5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NsaWtlJywge1xuICBrZXl3b3JkOlxuICAgIC9cXGIoYnJlYWt8Y2FzZXxjYXRjaHxjbGFzc3xjb25zdHxjb250aW51ZXxkZWJ1Z2dlcnxkZWZhdWx0fGRlbGV0ZXxkb3xlbHNlfGVudW18ZXhwb3J0fGV4dGVuZHN8ZmFsc2V8ZmluYWxseXxmb3J8ZnVuY3Rpb258Z2V0fGlmfGltcGxlbWVudHN8aW1wb3J0fGlufGluc3RhbmNlb2Z8aW50ZXJmYWNlfGxldHxuZXd8bnVsbHxwYWNrYWdlfHByaXZhdGV8cHJvdGVjdGVkfHB1YmxpY3xyZXR1cm58c2V0fHN0YXRpY3xzdXBlcnxzd2l0Y2h8dGhpc3x0aHJvd3x0cnVlfHRyeXx0eXBlb2Z8dmFyfHZvaWR8d2hpbGV8d2l0aHx5aWVsZClcXGIvZyxcbiAgbnVtYmVyOiAvXFxiLT8oMHhbXFxkQS1GYS1mXSt8XFxkKlxcLj9cXGQrKFtFZV0tP1xcZCspP3xOYU58LT9JbmZpbml0eSlcXGIvZyxcbn0pO1xuXG5QcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ2tleXdvcmQnLCB7XG4gIHJlZ2V4OiB7XG4gICAgcGF0dGVybjpcbiAgICAgIC8oXnxbXi9dKVxcLyg/IVxcLykoXFxbLis/XXxcXFxcLnxbXi9cXHJcXG5dKStcXC9bZ2ltXXswLDN9KD89XFxzKigkfFtcXHJcXG4sLjt9KV0pKS9nLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gIH0sXG59KTtcblxuaWYgKFByaXNtLmxhbmd1YWdlcy5tYXJrdXApIHtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya3VwJywgJ3RhZycsIHtcbiAgICBzY3JpcHQ6IHtcbiAgICAgIHBhdHRlcm46IC88c2NyaXB0W1xcd1xcV10qPz5bXFx3XFxXXSo/PFxcL3NjcmlwdD4vZ2ksXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgdGFnOiB7XG4gICAgICAgICAgcGF0dGVybjogLzxzY3JpcHRbXFx3XFxXXSo/Pnw8XFwvc2NyaXB0Pi9naSxcbiAgICAgICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLmluc2lkZSxcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdDogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQsXG4gICAgICB9LFxuICAgICAgYWxpYXM6ICdsYW5ndWFnZS1qYXZhc2NyaXB0JyxcbiAgICB9LFxuICB9KTtcbn1cblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1maWxlLWhpZ2hsaWdodC5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuICBpZiAoIXNlbGYuUHJpc20gfHwgIXNlbGYuZG9jdW1lbnQgfHwgIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgRXh0ZW5zaW9ucyA9IHtcbiAgICBqczogJ2phdmFzY3JpcHQnLFxuICAgIGh0bWw6ICdtYXJrdXAnLFxuICAgIHN2ZzogJ21hcmt1cCcsXG4gICAgeG1sOiAnbWFya3VwJyxcbiAgICBweTogJ3B5dGhvbicsXG4gICAgcmI6ICdydWJ5JyxcbiAgfTtcblxuICBBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdwcmVbZGF0YS1zcmNdJykpXG4gICAgLmZvckVhY2goZnVuY3Rpb24gKHByZSkge1xuICAgICAgdmFyIHNyYyA9IHByZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3JjJyk7XG4gICAgICB2YXIgZXh0ZW5zaW9uID0gKHNyYy5tYXRjaCgvXFwuKFxcdyspJC8pIHx8IFssICcnXSlbMV07XG4gICAgICB2YXIgbGFuZ3VhZ2UgPSBFeHRlbnNpb25zW2V4dGVuc2lvbl0gfHwgZXh0ZW5zaW9uO1xuXG4gICAgICB2YXIgY29kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvZGUnKTtcbiAgICAgIGNvZGUuY2xhc3NOYW1lID0gJ2xhbmd1YWdlLScgKyBsYW5ndWFnZTtcblxuICAgICAgcHJlLnRleHRDb250ZW50ID0gJyc7XG5cbiAgICAgIGNvZGUudGV4dENvbnRlbnQgPSAnTG9hZGluZ+KApic7XG5cbiAgICAgIHByZS5hcHBlbmRDaGlsZChjb2RlKTtcblxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICB4aHIub3BlbignR0VUJywgc3JjLCB0cnVlKTtcblxuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA8IDQwMCAmJiB4aHIucmVzcG9uc2VUZXh0KSB7XG4gICAgICAgICAgICBjb2RlLnRleHRDb250ZW50ID0geGhyLnJlc3BvbnNlVGV4dDtcblxuICAgICAgICAgICAgUHJpc20uaGlnaGxpZ2h0RWxlbWVudChjb2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHhoci5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgICAgICBjb2RlLnRleHRDb250ZW50ID1cbiAgICAgICAgICAgICAgJ+KcliBFcnJvciAnICtcbiAgICAgICAgICAgICAgeGhyLnN0YXR1cyArXG4gICAgICAgICAgICAgICcgd2hpbGUgZmV0Y2hpbmcgZmlsZTogJyArXG4gICAgICAgICAgICAgIHhoci5zdGF0dXNUZXh0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlLnRleHRDb250ZW50ID0gJ+KcliBFcnJvcjogRmlsZSBkb2VzIG5vdCBleGlzdCBvciBpcyBlbXB0eSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB4aHIuc2VuZChudWxsKTtcbiAgICB9KTtcbn0pKCk7XG4iLCJnbG9iYWwucnVuSXQgPSBmdW5jdGlvbiBydW5JdChidXR0b24pIHtcbiAgaWYgKCFnbG9iYWwuUnVuS2l0KSByZXR1cm47XG5cbiAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2YXIgY29kZUVsZW1lbnQgPSBidXR0b24ucGFyZW50Tm9kZTtcbiAgdmFyIHBhcmVudCA9IGNvZGVFbGVtZW50LnBhcmVudE5vZGU7XG5cbiAgcGFyZW50Lmluc2VydEJlZm9yZShjb250YWluZXIsIGNvZGVFbGVtZW50KTtcbiAgcGFyZW50LnJlbW92ZUNoaWxkKGNvZGVFbGVtZW50KTtcbiAgY29kZUVsZW1lbnQucmVtb3ZlQ2hpbGQoYnV0dG9uKTtcblxuICBjb25zdCBvcHRpb25zID0gSlNPTi5wYXJzZSh1bmVzY2FwZShidXR0b24uZGF0YXNldC5vcHRpb25zKSk7XG5cbiAgZnVuY3Rpb24gd2l0aENvcnJlY3RWZXJzaW9uKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZS5yZXBsYWNlKFxuICAgICAgL3JlcXVpcmVcXCgnaW1tdXRhYmxlJ1xcKS9nLFxuICAgICAgXCJyZXF1aXJlKCdpbW11dGFibGVANC4wLjAtcmMuOScpXCJcbiAgICApO1xuICB9XG5cbiAgZ2xvYmFsLlJ1bktpdC5jcmVhdGVOb3RlYm9vayh7XG4gICAgZWxlbWVudDogY29udGFpbmVyLFxuICAgIG5vZGVWZXJzaW9uOiBvcHRpb25zLm5vZGVWZXJzaW9uIHx8ICcqJyxcbiAgICBwcmVhbWJsZTogd2l0aENvcnJlY3RWZXJzaW9uKFxuICAgICAgJ2NvbnN0IGFzc2VydCA9ICgnICtcbiAgICAgICAgbWFrZUFzc2VydCArXG4gICAgICAgIFwiKShyZXF1aXJlKCdpbW11dGFibGUnKSk7XCIgK1xuICAgICAgICAob3B0aW9ucy5wcmVhbWJsZSB8fCAnJylcbiAgICApLFxuICAgIHNvdXJjZTogd2l0aENvcnJlY3RWZXJzaW9uKFxuICAgICAgY29kZUVsZW1lbnQudGV4dENvbnRlbnQucmVwbGFjZSgvXFxuKD5bXlxcbl0qXFxuPykrJC9nLCAnJylcbiAgICApLFxuICAgIG1pbkhlaWdodDogJzUycHgnLFxuICAgIG9uTG9hZDogZnVuY3Rpb24gKG5vdGVib29rKSB7XG4gICAgICBub3RlYm9vay5ldmFsdWF0ZSgpO1xuICAgIH0sXG4gIH0pO1xufTtcblxuZnVuY3Rpb24gbWFrZUFzc2VydChJKSB7XG4gIHZhciBpc0l0ZXJhYmxlID0gSS5pc0l0ZXJhYmxlIHx8IEkuSXRlcmFibGUuaXNJdGVyYWJsZTtcbiAgdmFyIGh0bWwgPSAoXCJcXG4gICAgPHN0eWxlPlxcbiAgICAgICoge1xcbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xcbiAgICAgICAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTtcXG4gICAgICB9XFxuXFxuICAgICAgY29kZSB7XFxuICAgICAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xcbiAgICAgICAgY29sb3I6ICM0MTgzQzQ7XFxuICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgICBiYWNrZ3JvdW5kOiByZ2JhKDY1LCAxMzEsIDE5NiwgMC4xKTtcXG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gICAgICAgIHBhZGRpbmc6IDJweDtcXG4gICAgfVxcblxcbiAgICAgIC5zdWNjZXNzIHtcXG4gICAgICAgIGNvbG9yOiByZ2JhKDg0LDE4NCw1NCwxLjApO1xcbiAgICAgIH1cXG5cXG4gICAgICAuc3VjY2VzczpiZWZvcmUge1xcbiAgICAgICAgY29udGVudDogXFxcIuKchVxcXCI7XFxuICAgICAgfVxcblxcbiAgICAgIC5mYWlsdXJlIHtcXG4gICAgICAgIGNvbG9yOiByZ2JhKDIyMCw0NywzMywxLjApO1xcbiAgICAgIH1cXG5cXG4gICAgICAuZmFpbHVyZSBpIHtcXG4gICAgICAgIGNvbG9yOiByZ2JhKDIxMCw0NCwzMSwxLjApO1xcbiAgICAgIH1cXG5cXG4gICAgICAuZmFpbHVyZTpiZWZvcmUge1xcbiAgICAgICAgY29udGVudDogXFxcIuKdjFxcXCI7XFxuICAgICAgfVxcbiAgICA8L3N0eWxlPlwiXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuKTtcblxuICBmdW5jdGlvbiBjb21wYXJlKGxocywgcmhzLCBzYW1lLCBpZGVudGljYWwpIHtcbiAgICB2YXIgYm90aCA9ICFpZGVudGljYWwgJiYgaXNJdGVyYWJsZShsaHMpICYmIGlzSXRlcmFibGUocmhzKTtcblxuICAgIGlmIChib3RoKSByZXR1cm4gbGhzLmVxdWFscyhyaHMpO1xuXG4gICAgcmV0dXJuIGxocyA9PT0gcmhzO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVzc2FnZShsaHMsIHJocywgc2FtZSwgaWRlbnRpY2FsKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNvbXBhcmUobGhzLCByaHMsIHNhbWUsIGlkZW50aWNhbCk7XG4gICAgdmFyIGNvbXBhcmlzb24gPSByZXN1bHRcbiAgICAgID8gaWRlbnRpY2FsXG4gICAgICAgID8gJ3N0cmljdCBlcXVhbCB0bydcbiAgICAgICAgOiAnZG9lcyBlcXVhbCdcbiAgICAgIDogaWRlbnRpY2FsXG4gICAgICA/ICdub3Qgc3RyaWN0IGVxdWFsIHRvJ1xuICAgICAgOiAnZG9lcyBub3QgZXF1YWwnO1xuICAgIHZhciBjbGFzc05hbWUgPSByZXN1bHQgPT09IHNhbWUgPyAnc3VjY2VzcycgOiAnZmFpbHVyZSc7XG4gICAgdmFyIGxoc1N0cmluZyA9IGlzSXRlcmFibGUobGhzKSA/IGxocyArICcnIDogSlNPTi5zdHJpbmdpZnkobGhzKTtcbiAgICB2YXIgcmhzU3RyaW5nID0gaXNJdGVyYWJsZShyaHMpID8gcmhzICsgJycgOiBKU09OLnN0cmluZ2lmeShyaHMpO1xuXG4gICAgcmV0dXJuIChodG1sICs9IChcIlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJcIiArIFxuY2xhc3NOYW1lICsgXCJcXFwiPlxcbiAgICAgICAgPGNvZGU+XCIgKyBcbmxoc1N0cmluZyArIFwiPC9jb2RlPlxcbiAgICAgICAgXCIgKyBcbmNvbXBhcmlzb24gKyBcIlxcbiAgICAgICAgPGNvZGU+XCIgKyBcbnJoc1N0cmluZyArIFwiPC9jb2RlPlxcbiAgICAgIDwvc3Bhbj48YnIvPlwiXG4pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVxdWFsKGxocywgcmhzKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UobGhzLCByaHMsIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gbm90RXF1YWwobGhzLCByaHMpIHtcbiAgICByZXR1cm4gbWVzc2FnZShsaHMsIHJocywgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RyaWN0RXF1YWwobGhzLCByaHMpIHtcbiAgICByZXR1cm4gbWVzc2FnZShsaHMsIHJocywgdHJ1ZSwgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChsaHMsIHJocykge1xuICAgIHJldHVybiBtZXNzYWdlKGxocywgcmhzLCBmYWxzZSwgdHJ1ZSk7XG4gIH1cblxuICByZXR1cm4geyBlcXVhbDplcXVhbCwgbm90RXF1YWw6bm90RXF1YWwsIHN0cmljdEVxdWFsOnN0cmljdEVxdWFsLCBub3RTdHJpY3RFcXVhbDpub3RTdHJpY3RFcXVhbCB9O1xufVxuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBDU1NDb3JlID0gcmVxdWlyZSgncmVhY3QvbGliL0NTU0NvcmUnKTtcbnZhciBSb3V0ZXIgPSByZXF1aXJlKCdyZWFjdC1yb3V0ZXInKTtcbnZhciAkX18wPSAgICByZXF1aXJlKCcuLi8uLi8uLi8uLi8nKSxTZXE9JF9fMC5TZXE7XG52YXIgVHlwZUtpbmQgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvVHlwZUtpbmQnKTtcbnZhciBkZWZzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL2dldFR5cGVEZWZzJyk7XG5cbnZhciBJbnRlcmZhY2VEZWYgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiSW50ZXJmYWNlRGVmXCIsXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcbiAgICB2YXIgZGVmID0gdGhpcy5wcm9wcy5kZWY7XG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCBpbnRlcmZhY2VEZWZcIn0sIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7Y2xhc3NOYW1lOiBcInQga2V5d29yZFwifSwgXCJ0eXBlIFwiKSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCB0eXBlTmFtZVwifSwgbmFtZSksIFxuICAgICAgICBkZWYudHlwZVBhcmFtcyAmJiBbXG4gICAgICAgICAgJzwnLFxuICAgICAgICAgIFNlcShkZWYudHlwZVBhcmFtcylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24odCwgaykgIFxuICAgICAgICAgICAgICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCB0eXBlUGFyYW1cIiwga2V5OiBrfSwgXG4gICAgICAgICAgICAgICAgdFxuICAgICAgICAgICAgICApO31cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5pbnRlcnBvc2UoJywgJylcbiAgICAgICAgICAgIC50b0FycmF5KCksXG4gICAgICAgICAgJz4nLFxuICAgICAgICBdLCBcbiAgICAgICAgZGVmLmV4dGVuZHMgJiYgW1xuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCBrZXl3b3JkXCJ9LCBcIiBleHRlbmRzIFwiKSxcbiAgICAgICAgICBTZXEoZGVmLmV4dGVuZHMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGUsIGkpICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVHlwZURlZiwge2tleTogaSwgdHlwZTogZX0pO30pXG4gICAgICAgICAgICAuaW50ZXJwb3NlKCcsICcpXG4gICAgICAgICAgICAudG9BcnJheSgpLFxuICAgICAgICBdLCBcbiAgICAgICAgZGVmLmltcGxlbWVudHMgJiYgW1xuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCBrZXl3b3JkXCJ9LCBcIiBpbXBsZW1lbnRzIFwiKSxcbiAgICAgICAgICBTZXEoZGVmLmltcGxlbWVudHMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGUsIGkpICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVHlwZURlZiwge2tleTogaSwgdHlwZTogZX0pO30pXG4gICAgICAgICAgICAuaW50ZXJwb3NlKCcsICcpXG4gICAgICAgICAgICAudG9BcnJheSgpLFxuICAgICAgICBdXG4gICAgICApXG4gICAgKTtcbiAgfSxcbn0pO1xuXG5leHBvcnRzLkludGVyZmFjZURlZiA9IEludGVyZmFjZURlZjtcblxudmFyIENhbGxTaWdEZWYgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiQ2FsbFNpZ0RlZlwiLFxuICByZW5kZXI6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluZm8gPSB0aGlzLnByb3BzLmluZm87XG4gICAgdmFyIG1vZHVsZSA9IHRoaXMucHJvcHMubW9kdWxlO1xuICAgIHZhciBuYW1lID0gdGhpcy5wcm9wcy5uYW1lO1xuICAgIHZhciBjYWxsU2lnID0gdGhpcy5wcm9wcy5jYWxsU2lnIHx8IHt9O1xuXG4gICAgdmFyIHNob3VsZFdyYXAgPSBjYWxsU2lnTGVuZ3RoKGluZm8sIG1vZHVsZSwgbmFtZSwgY2FsbFNpZykgPiA4MDtcblxuICAgIHJldHVybiAoXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7Y2xhc3NOYW1lOiBcInQgY2FsbFNpZ1wifSwgXG4gICAgICAgIG1vZHVsZSAmJiBbUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogXCJ0IGZuUXVhbGlmaWVyXCJ9LCBtb2R1bGUpLCAnLiddLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogXCJ0IGZuTmFtZVwifSwgbmFtZSksIFxuICAgICAgICBjYWxsU2lnLnR5cGVQYXJhbXMgJiYgW1xuICAgICAgICAgICc8JyxcbiAgICAgICAgICBTZXEoY2FsbFNpZy50eXBlUGFyYW1zKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbih0KSAge3JldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7Y2xhc3NOYW1lOiBcInQgdHlwZVBhcmFtXCJ9LCB0KTt9KVxuICAgICAgICAgICAgLmludGVycG9zZSgnLCAnKVxuICAgICAgICAgICAgLnRvQXJyYXkoKSxcbiAgICAgICAgICAnPicsXG4gICAgICAgIF0sIFxuICAgICAgICAnKCcsIFxuICAgICAgICBjYWxsU2lnICYmIGZ1bmN0aW9uUGFyYW1zKGluZm8sIGNhbGxTaWcucGFyYW1zLCBzaG91bGRXcmFwKSwgXG4gICAgICAgICcpJywgXG4gICAgICAgIGNhbGxTaWcudHlwZSAmJiBbJzogJywgUmVhY3QuY3JlYXRlRWxlbWVudChUeXBlRGVmLCB7aW5mbzogaW5mbywgdHlwZTogY2FsbFNpZy50eXBlfSldXG4gICAgICApXG4gICAgKTtcbiAgfSxcbn0pO1xuXG5leHBvcnRzLkNhbGxTaWdEZWYgPSBDYWxsU2lnRGVmO1xuXG52YXIgVHlwZURlZiA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJUeXBlRGVmXCIsXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5mbyA9IHRoaXMucHJvcHMuaW5mbztcbiAgICB2YXIgdHlwZSA9IHRoaXMucHJvcHMudHlwZTtcbiAgICB2YXIgcHJlZml4ID0gdGhpcy5wcm9wcy5wcmVmaXg7XG4gICAgc3dpdGNoICh0eXBlLmspIHtcbiAgICAgIGNhc2UgVHlwZUtpbmQuTmV2ZXI6XG4gICAgICAgIHJldHVybiB0aGlzLndyYXAoJ3ByaW1pdGl2ZScsICduZXZlcicpO1xuICAgICAgY2FzZSBUeXBlS2luZC5Bbnk6XG4gICAgICAgIHJldHVybiB0aGlzLndyYXAoJ3ByaW1pdGl2ZScsICdhbnknKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuVW5rbm93bjpcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCgncHJpbWl0aXZlJywgJ3Vua25vd24nKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuVGhpczpcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCgncHJpbWl0aXZlJywgJ3RoaXMnKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuVW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdGhpcy53cmFwKCdwcmltaXRpdmUnLCAndW5kZWZpbmVkJyk7XG4gICAgICBjYXNlIFR5cGVLaW5kLkJvb2xlYW46XG4gICAgICAgIHJldHVybiB0aGlzLndyYXAoJ3ByaW1pdGl2ZScsICdib29sZWFuJyk7XG4gICAgICBjYXNlIFR5cGVLaW5kLk51bWJlcjpcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCgncHJpbWl0aXZlJywgJ251bWJlcicpO1xuICAgICAgY2FzZSBUeXBlS2luZC5TdHJpbmc6XG4gICAgICAgIHJldHVybiB0aGlzLndyYXAoJ3ByaW1pdGl2ZScsICdzdHJpbmcnKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuVW5pb246XG4gICAgICAgIHJldHVybiB0aGlzLndyYXAoJ3VuaW9uJywgW1xuICAgICAgICAgIFNlcSh0eXBlLnR5cGVzKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbih0KSAge3JldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHtpbmZvOiBpbmZvLCB0eXBlOiB0fSk7fSlcbiAgICAgICAgICAgIC5pbnRlcnBvc2UoJyB8ICcpXG4gICAgICAgICAgICAudG9BcnJheSgpLFxuICAgICAgICBdKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuSW50ZXJzZWN0aW9uOlxuICAgICAgICByZXR1cm4gdGhpcy53cmFwKCdpbnRlcnNlY3Rpb24nLCBbXG4gICAgICAgICAgU2VxKHR5cGUudHlwZXMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHQpICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVHlwZURlZiwge2luZm86IGluZm8sIHR5cGU6IHR9KTt9KVxuICAgICAgICAgICAgLmludGVycG9zZSgnICYgJylcbiAgICAgICAgICAgIC50b0FycmF5KCksXG4gICAgICAgIF0pO1xuICAgICAgY2FzZSBUeXBlS2luZC5UdXBsZTpcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCgndHVwbGUnLCBbXG4gICAgICAgICAgJ1snLFxuICAgICAgICAgIFNlcSh0eXBlLnR5cGVzKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbih0KSAge3JldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHtpbmZvOiBpbmZvLCB0eXBlOiB0fSk7fSlcbiAgICAgICAgICAgIC5pbnRlcnBvc2UoJywgJylcbiAgICAgICAgICAgIC50b0FycmF5KCksXG4gICAgICAgICAgJ10nLFxuICAgICAgICBdKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuT2JqZWN0OlxuICAgICAgICByZXR1cm4gdGhpcy53cmFwKCdvYmplY3QnLCBbXG4gICAgICAgICAgJ3snLFxuICAgICAgICAgIFNlcSh0eXBlLm1lbWJlcnMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHQpICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtYmVyRGVmLCB7bWVtYmVyOiB0fSk7fSlcbiAgICAgICAgICAgIC5pbnRlcnBvc2UoJywgJylcbiAgICAgICAgICAgIC50b0FycmF5KCksXG4gICAgICAgICAgJ30nLFxuICAgICAgICBdKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuSW5kZXhlZDpcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCgnaW5kZXhlZCcsIFtcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHtpbmZvOiBpbmZvLCB0eXBlOiB0eXBlLnR5cGV9KSxcbiAgICAgICAgICAnWycsXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChUeXBlRGVmLCB7aW5mbzogaW5mbywgdHlwZTogdHlwZS5pbmRleH0pLFxuICAgICAgICAgICddJyxcbiAgICAgICAgXSk7XG4gICAgICBjYXNlIFR5cGVLaW5kLk9wZXJhdG9yOlxuICAgICAgICByZXR1cm4gdGhpcy53cmFwKCdvcGVyYXRvcicsIFtcbiAgICAgICAgICB0aGlzLndyYXAoJ3ByaW1pdGl2ZScsIHR5cGUub3BlcmF0b3IpLFxuICAgICAgICAgICcgJyxcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHtpbmZvOiBpbmZvLCB0eXBlOiB0eXBlLnR5cGV9KSxcbiAgICAgICAgXSk7XG4gICAgICBjYXNlIFR5cGVLaW5kLkFycmF5OlxuICAgICAgICByZXR1cm4gdGhpcy53cmFwKCdhcnJheScsIFtcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHtpbmZvOiBpbmZvLCB0eXBlOiB0eXBlLnR5cGV9KSxcbiAgICAgICAgICAnW10nLFxuICAgICAgICBdKTtcbiAgICAgIGNhc2UgVHlwZUtpbmQuRnVuY3Rpb246XG4gICAgICAgIHZhciBzaG91bGRXcmFwID0gKHByZWZpeCB8fCAwKSArIGZ1bmNMZW5ndGgoaW5mbywgdHlwZSkgPiA3ODtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCgnZnVuY3Rpb24nLCBbXG4gICAgICAgICAgdHlwZS50eXBlUGFyYW1zICYmIFtcbiAgICAgICAgICAgICc8JyxcbiAgICAgICAgICAgIFNlcSh0eXBlLnR5cGVQYXJhbXMpXG4gICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24odCwgaykgIFxuICAgICAgICAgICAgICAgIHtyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogXCJ0IHR5cGVQYXJhbVwiLCBrZXk6IGt9LCBcbiAgICAgICAgICAgICAgICAgIHRcbiAgICAgICAgICAgICAgICApO31cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAuaW50ZXJwb3NlKCcsICcpXG4gICAgICAgICAgICAgIC50b0FycmF5KCksXG4gICAgICAgICAgICAnPicsXG4gICAgICAgICAgXSxcbiAgICAgICAgICAnKCcsXG4gICAgICAgICAgZnVuY3Rpb25QYXJhbXMoaW5mbywgdHlwZS5wYXJhbXMsIHNob3VsZFdyYXApLFxuICAgICAgICAgICcpID0+ICcsXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChUeXBlRGVmLCB7aW5mbzogaW5mbywgdHlwZTogdHlwZS50eXBlfSksXG4gICAgICAgIF0pO1xuICAgICAgY2FzZSBUeXBlS2luZC5QYXJhbTpcbiAgICAgICAgcmV0dXJuIGluZm8gJiYgaW5mby5wcm9wTWFwW2luZm8uZGVmaW5pbmcgKyAnPCcgKyB0eXBlLnBhcmFtXSA/IChcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHt0eXBlOiBpbmZvLnByb3BNYXBbaW5mby5kZWZpbmluZyArICc8JyArIHR5cGUucGFyYW1dfSlcbiAgICAgICAgKSA6IChcbiAgICAgICAgICB0aGlzLndyYXAoJ3R5cGVQYXJhbScsIHR5cGUucGFyYW0pXG4gICAgICAgICk7XG4gICAgICBjYXNlIFR5cGVLaW5kLlR5cGU6XG4gICAgICAgIHZhciBxdWFsaWZpZWRUeXBlID0gKHR5cGUucXVhbGlmaWVyIHx8IFtdKS5jb25jYXQoW3R5cGUubmFtZV0pO1xuICAgICAgICB2YXIgcXVhbGlmaWVkVHlwZU5hbWUgPSBxdWFsaWZpZWRUeXBlLmpvaW4oJy4nKTtcbiAgICAgICAgdmFyIGRlZiA9IHF1YWxpZmllZFR5cGVOYW1lXG4gICAgICAgICAgLnNwbGl0KCcuJylcbiAgICAgICAgICAucmVkdWNlKFxuICAgICAgICAgICAgZnVuY3Rpb24oZGVmLCBuYW1lKSAge3JldHVybiBkZWYgJiYgZGVmLm1vZHVsZSAmJiBkZWYubW9kdWxlW25hbWVdO30sXG4gICAgICAgICAgICBkZWZzLkltbXV0YWJsZVxuICAgICAgICAgICk7XG4gICAgICAgIHZhciB0eXBlTmFtZUVsZW1lbnQgPSBbXG4gICAgICAgICAgdHlwZS5xdWFsaWZpZXIgJiYgW1xuICAgICAgICAgICAgU2VxKHR5cGUucXVhbGlmaWVyKVxuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHEpICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCB0eXBlUXVhbGlmaWVyXCJ9LCBxKTt9KVxuICAgICAgICAgICAgICAuaW50ZXJwb3NlKCcuJylcbiAgICAgICAgICAgICAgLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICcuJyxcbiAgICAgICAgICBdLFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCB0eXBlTmFtZVwifSwgdHlwZS5uYW1lKSxcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKGRlZikge1xuICAgICAgICAgIHR5cGVOYW1lRWxlbWVudCA9IChcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLkxpbmssIHt0bzogJy8nICsgcXVhbGlmaWVkVHlwZU5hbWV9LCBcbiAgICAgICAgICAgICAgdHlwZU5hbWVFbGVtZW50XG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53cmFwKCd0eXBlJywgW1xuICAgICAgICAgIHR5cGVOYW1lRWxlbWVudCxcbiAgICAgICAgICB0eXBlLmFyZ3MgJiYgW1xuICAgICAgICAgICAgJzwnLFxuICAgICAgICAgICAgU2VxKHR5cGUuYXJncylcbiAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihhKSAge3JldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHtpbmZvOiBpbmZvLCB0eXBlOiBhfSk7fSlcbiAgICAgICAgICAgICAgLmludGVycG9zZSgnLCAnKVxuICAgICAgICAgICAgICAudG9BcnJheSgpLFxuICAgICAgICAgICAgJz4nLFxuICAgICAgICAgIF0sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24ga2luZCAnICsgdHlwZS5rKTtcbiAgfSxcblxuICBtb3VzZU92ZXI6ZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBDU1NDb3JlLmFkZENsYXNzKHRoaXMuZ2V0RE9NTm9kZSgpLCAnb3ZlcicpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9LFxuXG4gIG1vdXNlT3V0OmZ1bmN0aW9uKCkge1xuICAgIENTU0NvcmUucmVtb3ZlQ2xhc3ModGhpcy5nZXRET01Ob2RlKCksICdvdmVyJyk7XG4gIH0sXG5cbiAgd3JhcDpmdW5jdGlvbihjbGFzc05hbWUsIGNoaWxkKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndCAnICsgY2xhc3NOYW1lLCBcbiAgICAgICAgb25Nb3VzZU92ZXI6IHRoaXMubW91c2VPdmVyLCBcbiAgICAgICAgb25Gb2N1czogdGhpcy5tb3VzZU92ZXIsIFxuICAgICAgICBvbk1vdXNlT3V0OiB0aGlzLm1vdXNlT3V0LCBcbiAgICAgICAgb25CbHVyOiB0aGlzLm1vdXNlT3V0XG4gICAgICB9LCBcbiAgICAgICAgY2hpbGRcbiAgICAgIClcbiAgICApO1xuICB9LFxufSk7XG5cbmV4cG9ydHMuVHlwZURlZiA9IFR5cGVEZWY7XG5cbnZhciBNZW1iZXJEZWYgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiTWVtYmVyRGVmXCIsXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICB2YXIgbW9kdWxlID0gdGhpcy5wcm9wcy5tb2R1bGU7XG4gICAgdmFyIG1lbWJlciA9IHRoaXMucHJvcHMubWVtYmVyO1xuICAgIHJldHVybiAoXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7Y2xhc3NOYW1lOiBcInQgbWVtYmVyXCJ9LCBcbiAgICAgICAgbW9kdWxlICYmIFtSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7Y2xhc3NOYW1lOiBcInQgZm5RdWFsaWZpZXJcIn0sIG1vZHVsZSksICcuJ10sIFxuICAgICAgICBtZW1iZXIuaW5kZXggPyAoXG4gICAgICAgICAgWydbJywgZnVuY3Rpb25QYXJhbXMobnVsbCwgbWVtYmVyLnBhcmFtcyksICddJ11cbiAgICAgICAgKSA6IChcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7Y2xhc3NOYW1lOiBcInQgbWVtYmVyTmFtZVwifSwgbWVtYmVyLm5hbWUpXG4gICAgICAgICksIFxuICAgICAgICBtZW1iZXIudHlwZSAmJiBbJzogJywgUmVhY3QuY3JlYXRlRWxlbWVudChUeXBlRGVmLCB7dHlwZTogbWVtYmVyLnR5cGV9KV1cbiAgICAgIClcbiAgICApO1xuICB9LFxufSk7XG5cbmV4cG9ydHMuTWVtYmVyRGVmID0gTWVtYmVyRGVmO1xuXG5mdW5jdGlvbiBmdW5jdGlvblBhcmFtcyhpbmZvLCBwYXJhbXMsIHNob3VsZFdyYXApIHtcbiAgdmFyIGVsZW1lbnRzID0gU2VxKHBhcmFtcylcbiAgICAubWFwKGZ1bmN0aW9uKHQpICB7cmV0dXJuIFtcbiAgICAgIHQudmFyQXJncyA/ICcuLi4nIDogbnVsbCxcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IFwidCBwYXJhbVwifSwgdC5uYW1lKSxcbiAgICAgIHQub3B0aW9uYWwgPyAnPzogJyA6ICc6ICcsXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEZWYsIHtcbiAgICAgICAgcHJlZml4OiB0Lm5hbWUubGVuZ3RoICsgKHQudmFyQXJncyA/IDMgOiAwKSArICh0Lm9wdGlvbmFsID8gMyA6IDIpLCBcbiAgICAgICAgaW5mbzogaW5mbywgXG4gICAgICAgIHR5cGU6IHQudHlwZX1cbiAgICAgICksXG4gICAgXTt9KVxuICAgIC5pbnRlcnBvc2Uoc2hvdWxkV3JhcCA/IFsnLCcsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJiclwiLCBudWxsKV0gOiAnLCAnKVxuICAgIC50b0FycmF5KCk7XG4gIHJldHVybiBzaG91bGRXcmFwID8gKFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2NsYXNzTmFtZTogXCJ0IGJsb2NrUGFyYW1zXCJ9LCBlbGVtZW50cylcbiAgKSA6IChcbiAgICBlbGVtZW50c1xuICApO1xufVxuXG5mdW5jdGlvbiBjYWxsU2lnTGVuZ3RoKGluZm8sIG1vZHVsZSwgbmFtZSwgc2lnKSB7XG4gIHJldHVybiAobW9kdWxlID8gbW9kdWxlLmxlbmd0aCArIDEgOiAwKSArIG5hbWUubGVuZ3RoICsgZnVuY0xlbmd0aChpbmZvLCBzaWcpO1xufVxuXG5mdW5jdGlvbiBmdW5jTGVuZ3RoKGluZm8sIHNpZykge1xuICByZXR1cm4gKFxuICAgIChzaWcudHlwZVBhcmFtcyA/IDIgKyBzaWcudHlwZVBhcmFtcy5qb2luKCcsICcpLmxlbmd0aCA6IDApICtcbiAgICAyICtcbiAgICAoc2lnLnBhcmFtcyA/IHBhcmFtTGVuZ3RoKGluZm8sIHNpZy5wYXJhbXMpIDogMCkgK1xuICAgIChzaWcudHlwZSA/IDIgKyB0eXBlTGVuZ3RoKGluZm8sIHNpZy50eXBlKSA6IDApXG4gICk7XG59XG5cbmZ1bmN0aW9uIHBhcmFtTGVuZ3RoKGluZm8sIHBhcmFtcykge1xuICByZXR1cm4gcGFyYW1zLnJlZHVjZShcbiAgICBmdW5jdGlvbihzLCBwKSBcbiAgICAgIHtyZXR1cm4gcyArXG4gICAgICAocC52YXJBcmdzID8gMyA6IDApICtcbiAgICAgIHAubmFtZS5sZW5ndGggK1xuICAgICAgKHAub3B0aW9uYWwgPyAzIDogMikgK1xuICAgICAgdHlwZUxlbmd0aChpbmZvLCBwLnR5cGUpO30sXG4gICAgKHBhcmFtcy5sZW5ndGggLSAxKSAqIDJcbiAgKTtcbn1cblxuZnVuY3Rpb24gbWVtYmVyTGVuZ3RoKGluZm8sIG1lbWJlcnMpIHtcbiAgcmV0dXJuIG1lbWJlcnMucmVkdWNlKFxuICAgIGZ1bmN0aW9uKHMsIG0pIFxuICAgICAge3JldHVybiBzICtcbiAgICAgIChtLmluZGV4ID8gcGFyYW1MZW5ndGgoaW5mbywgbS5wYXJhbXMpICsgNCA6IG0ubmFtZSArIDIpICtcbiAgICAgIHR5cGVMZW5ndGgoaW5mbywgbS50eXBlKTt9LFxuICAgIChtZW1iZXJzLmxlbmd0aCAtIDEpICogMlxuICApO1xufVxuXG5mdW5jdGlvbiB0eXBlTGVuZ3RoKGluZm8sIHR5cGUpIHtcbiAgaWYgKCF0eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0eXBlJyk7XG4gIH1cbiAgc3dpdGNoICh0eXBlLmspIHtcbiAgICBjYXNlIFR5cGVLaW5kLk5ldmVyOlxuICAgICAgcmV0dXJuIDU7XG4gICAgY2FzZSBUeXBlS2luZC5Bbnk6XG4gICAgICByZXR1cm4gMztcbiAgICBjYXNlIFR5cGVLaW5kLlVua25vd246XG4gICAgICByZXR1cm4gNztcbiAgICBjYXNlIFR5cGVLaW5kLlRoaXM6XG4gICAgICByZXR1cm4gNDtcbiAgICBjYXNlIFR5cGVLaW5kLlVuZGVmaW5lZDpcbiAgICAgIHJldHVybiA5O1xuICAgIGNhc2UgVHlwZUtpbmQuQm9vbGVhbjpcbiAgICAgIHJldHVybiA3O1xuICAgIGNhc2UgVHlwZUtpbmQuTnVtYmVyOlxuICAgICAgcmV0dXJuIDY7XG4gICAgY2FzZSBUeXBlS2luZC5TdHJpbmc6XG4gICAgICByZXR1cm4gNjtcbiAgICBjYXNlIFR5cGVLaW5kLlVuaW9uOlxuICAgIGNhc2UgVHlwZUtpbmQuSW50ZXJzZWN0aW9uOlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgdHlwZS50eXBlcy5yZWR1Y2UoZnVuY3Rpb24ocywgdCkgIHtyZXR1cm4gcyArIHR5cGVMZW5ndGgoaW5mbywgdCk7fSwgMCkgK1xuICAgICAgICAodHlwZS50eXBlcy5sZW5ndGggLSAxKSAqIDNcbiAgICAgICk7XG4gICAgY2FzZSBUeXBlS2luZC5UdXBsZTpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDIgK1xuICAgICAgICB0eXBlLnR5cGVzLnJlZHVjZShmdW5jdGlvbihzLCB0KSAge3JldHVybiBzICsgdHlwZUxlbmd0aChpbmZvLCB0KTt9LCAwKSArXG4gICAgICAgICh0eXBlLnR5cGVzLmxlbmd0aCAtIDEpICogMlxuICAgICAgKTtcbiAgICBjYXNlIFR5cGVLaW5kLk9iamVjdDpcbiAgICAgIHJldHVybiAyICsgbWVtYmVyTGVuZ3RoKGluZm8sIHR5cGUubWVtYmVycyk7XG4gICAgY2FzZSBUeXBlS2luZC5JbmRleGVkOlxuICAgICAgcmV0dXJuIDIgKyB0eXBlTGVuZ3RoKGluZm8sIHR5cGUudHlwZSkgKyB0eXBlTGVuZ3RoKGluZm8sIHR5cGUuaW5kZXgpO1xuICAgIGNhc2UgVHlwZUtpbmQuT3BlcmF0b3I6XG4gICAgICByZXR1cm4gMSArIHR5cGUub3BlcmF0b3IubGVuZ3RoICsgdHlwZUxlbmd0aChpbmZvLCB0eXBlLnR5cGUpO1xuICAgIGNhc2UgVHlwZUtpbmQuQXJyYXk6XG4gICAgICByZXR1cm4gdHlwZUxlbmd0aChpbmZvLCB0eXBlLnR5cGUpICsgMjtcbiAgICBjYXNlIFR5cGVLaW5kLkZ1bmN0aW9uOlxuICAgICAgcmV0dXJuIDIgKyBmdW5jTGVuZ3RoKGluZm8sIHR5cGUpO1xuICAgIGNhc2UgVHlwZUtpbmQuUGFyYW06XG4gICAgICByZXR1cm4gaW5mbyAmJiBpbmZvLnByb3BNYXBbaW5mby5kZWZpbmluZyArICc8JyArIHR5cGUucGFyYW1dXG4gICAgICAgID8gdHlwZUxlbmd0aChudWxsLCBpbmZvLnByb3BNYXBbaW5mby5kZWZpbmluZyArICc8JyArIHR5cGUucGFyYW1dKVxuICAgICAgICA6IHR5cGUucGFyYW0ubGVuZ3RoO1xuICAgIGNhc2UgVHlwZUtpbmQuVHlwZTpcbiAgICAgIHJldHVybiAoXG4gICAgICAgICh0eXBlLnF1YWxpZmllciA/IDEgKyB0eXBlLnF1YWxpZmllci5qb2luKCcuJykubGVuZ3RoIDogMCkgK1xuICAgICAgICB0eXBlLm5hbWUubGVuZ3RoICtcbiAgICAgICAgKCF0eXBlLmFyZ3NcbiAgICAgICAgICA/IDBcbiAgICAgICAgICA6IHR5cGUuYXJncy5yZWR1Y2UoXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKHMsIGEpICB7cmV0dXJuIHMgKyB0eXBlTGVuZ3RoKGluZm8sIGEpO30sXG4gICAgICAgICAgICAgIHR5cGUuYXJncy5sZW5ndGggKiAyXG4gICAgICAgICAgICApKVxuICAgICAgKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1R5cGUgd2l0aCB1bmtub3duIGtpbmQgJyArIEpTT04uc3RyaW5naWZ5KHR5cGUpKTtcbn1cbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgU1ZHU2V0ID0gcmVxdWlyZSgnLi4vLi4vc3JjL1NWR1NldCcpO1xudmFyIExvZ28gPSByZXF1aXJlKCcuLi8uLi9zcmMvTG9nbycpO1xudmFyIHBhY2thZ2VKc29uID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vcGFja2FnZS5qc29uJyk7XG5cbnZhciBEb2NIZWFkZXIgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiRG9jSGVhZGVyXCIsXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7Y2xhc3NOYW1lOiBcImhlYWRlclwifSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2NsYXNzTmFtZTogXCJtaW5pSGVhZGVyXCJ9LCBcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtjbGFzc05hbWU6IFwibWluaUhlYWRlckNvbnRlbnRzXCJ9LCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHtocmVmOiBcIi4uL1wiLCB0YXJnZXQ6IFwiX3NlbGZcIiwgY2xhc3NOYW1lOiBcIm1pbmlMb2dvXCJ9LCBcbiAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChTVkdTZXQsIG51bGwsIFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTG9nbywge2NvbG9yOiBcIiNGQzQzNDlcIn0pLCBcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KExvZ28sIHtjb2xvcjogXCIjMkMzRTUwXCIsIGlubGluZTogdHJ1ZX0pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICksIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwge2hyZWY6IFwiLi9cIiwgdGFyZ2V0OiBcIl9zZWxmXCJ9LCBcbiAgICAgICAgICAgICAgXCJEb2NzICh2XCIsIFxuICAgICAgICAgICAgICBwYWNrYWdlSnNvbi52ZXJzaW9uLCBcIilcIlxuICAgICAgICAgICAgKSwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7aHJlZjogXCJodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy90YWdnZWQvaW1tdXRhYmxlLmpzP3NvcnQ9dm90ZXNcIn0sIFxuICAgICAgICAgICAgICBcIlF1ZXN0aW9uc1wiXG4gICAgICAgICAgICApLCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHtocmVmOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9pbW11dGFibGUtanMvaW1tdXRhYmxlLWpzL1wifSwgXCJHaXRodWJcIilcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRG9jSGVhZGVyO1xuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSb3V0ZXIgPSByZXF1aXJlKCdyZWFjdC1yb3V0ZXInKTtcbnZhciAkX18wPSAgICByZXF1aXJlKCcuLi8uLi8uLi8uLi8nKSxTZXE9JF9fMC5TZXE7XG52YXIgTWFya2Rvd24gPSByZXF1aXJlKCcuL01hcmtEb3duJyk7XG5cbnZhciBEb2NPdmVydmlldyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJEb2NPdmVydmlld1wiLFxuICByZW5kZXI6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlZiA9IHRoaXMucHJvcHMuZGVmO1xuICAgIHZhciBkb2MgPSBkZWYuZG9jO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgXG4gICAgICAgIGRvYyAmJiAoXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwgbnVsbCwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1hcmtkb3duLCB7Y29udGVudHM6IGRvYy5zeW5vcHNpc30pLCBcbiAgICAgICAgICAgIGRvYy5kZXNjcmlwdGlvbiAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KE1hcmtkb3duLCB7Y29udGVudHM6IGRvYy5kZXNjcmlwdGlvbn0pXG4gICAgICAgICAgKVxuICAgICAgICApLCBcblxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDRcIiwge2NsYXNzTmFtZTogXCJncm91cFRpdGxlXCJ9LCBcIkFQSVwiKSwgXG5cbiAgICAgICAgU2VxKGRlZi5tb2R1bGUpXG4gICAgICAgICAgLm1hcChmdW5jdGlvbih0LCBuYW1lKSAge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSAhdC5pbnRlcmZhY2UgJiYgIXQubW9kdWxlO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgdCA9IHQuY2FsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIsIHtrZXk6IG5hbWUsIGNsYXNzTmFtZTogXCJpbnRlcmZhY2VNZW1iZXJcIn0sIFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoM1wiLCB7Y2xhc3NOYW1lOiBcIm1lbWJlckxhYmVsXCJ9LCBcbiAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLkxpbmssIHt0bzogJy8nICsgbmFtZX0sIFxuICAgICAgICAgICAgICAgICAgICBuYW1lICsgKGlzRnVuY3Rpb24gPyAnKCknIDogJycpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSwgXG4gICAgICAgICAgICAgICAgdC5kb2MgJiYgKFxuICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChNYXJrZG93biwge2NsYXNzTmFtZTogXCJkZXRhaWxcIiwgY29udGVudHM6IHQuZG9jLnN5bm9wc2lzfSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAudmFsdWVTZXEoKVxuICAgICAgICAgIC50b0FycmF5KClcbiAgICAgIClcbiAgICApO1xuICB9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRG9jT3ZlcnZpZXc7XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgRG9jU2VhcmNoID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiBcIkRvY1NlYXJjaFwiLFxuICBnZXRJbml0aWFsU3RhdGU6ZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHsgZW5hYmxlZDogdHJ1ZSB9O1xuICB9LFxuICBjb21wb25lbnREaWRNb3VudDpmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgdmFyIGZpcnN0U2NyaXB0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuICAgIHNjcmlwdC5zcmMgPVxuICAgICAgJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vZG9jc2VhcmNoLmpzQDIuNS4yL2Rpc3QvY2RuL2RvY3NlYXJjaC5taW4uanMnO1xuICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgJ2xvYWQnLFxuICAgICAgZnVuY3Rpb24oKSAge1xuICAgICAgICAvLyBJbml0aWFsaXplIEFsZ29saWEgc2VhcmNoLlxuICAgICAgICBpZiAod2luZG93LmRvY3NlYXJjaCkge1xuICAgICAgICAgIHdpbmRvdy5kb2NzZWFyY2goe1xuICAgICAgICAgICAgYXBpS2V5OiAnODNmNjFmODY1ZWY0Y2I2ODJlMDQzMjQxMGMyZjc4MDknLFxuICAgICAgICAgICAgaW5kZXhOYW1lOiAnaW1tdXRhYmxlX2pzJyxcbiAgICAgICAgICAgIGlucHV0U2VsZWN0b3I6ICcjYWxnb2xpYS1kb2NzZWFyY2gnLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBlbmFibGVkOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIGZpcnN0U2NyaXB0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgZmlyc3RTY3JpcHQpO1xuXG4gICAgdmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgdmFyIGZpcnN0TGluayA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdsaW5rJylbMF07XG4gICAgbGluay5yZWwgPSAnc3R5bGVzaGVldCc7XG4gICAgbGluay5ocmVmID1cbiAgICAgICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2RvY3NlYXJjaC5qc0AyLjUuMi9kaXN0L2Nkbi9kb2NzZWFyY2gubWluLmNzcyc7XG4gICAgZmlyc3RMaW5rLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGxpbmssIGZpcnN0TGluayk7XG4gIH0sXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5lbmFibGVkID8gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImlucHV0XCIsIHtcbiAgICAgICAgaWQ6IFwiYWxnb2xpYS1kb2NzZWFyY2hcIiwgXG4gICAgICAgIGNsYXNzTmFtZTogXCJkb2NTZWFyY2hcIiwgXG4gICAgICAgIHR5cGU6IFwic2VhcmNoXCIsIFxuICAgICAgICBwbGFjZWhvbGRlcjogXCJTZWFyY2ggSW1tdXRhYmxlLmpzIERvY3VtZW50YXRpb25cIn1cbiAgICAgIClcbiAgICApIDogbnVsbDtcbiAgfSxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERvY1NlYXJjaDtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBNYXJrRG93biA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJNYXJrRG93blwiLFxuICBzaG91bGRDb21wb25lbnRVcGRhdGU6ZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICB2YXIgaHRtbCA9IHRoaXMucHJvcHMuY29udGVudHM7XG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IHRoaXMucHJvcHMuY2xhc3NOYW1lLCBcbiAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHsgX19odG1sOiBodG1sfX1cbiAgICAgIClcbiAgICApO1xuICB9LFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFya0Rvd247XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0VHJhbnNpdGlvbkV2ZW50cyA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdFRyYW5zaXRpb25FdmVudHMnKTtcbnZhciBSb3V0ZXIgPSByZXF1aXJlKCdyZWFjdC1yb3V0ZXInKTtcbnZhciAkX18wPSAgICAgcmVxdWlyZSgnLi9EZWZzJyksQ2FsbFNpZ0RlZj0kX18wLkNhbGxTaWdEZWYsTWVtYmVyRGVmPSRfXzAuTWVtYmVyRGVmO1xudmFyIFBhZ2VEYXRhTWl4aW4gPSByZXF1aXJlKCcuL1BhZ2VEYXRhTWl4aW4nKTtcbnZhciBpc01vYmlsZSA9IHJlcXVpcmUoJy4vaXNNb2JpbGUnKTtcbnZhciBNYXJrRG93biA9IHJlcXVpcmUoJy4vTWFya0Rvd24nKTtcblxudmFyICRfXzE9ICAgIFJlYWN0LmFkZG9ucyxUcmFuc2l0aW9uR3JvdXA9JF9fMS5UcmFuc2l0aW9uR3JvdXA7XG5cbnZhciBNZW1iZXJEb2MgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiTWVtYmVyRG9jXCIsXG4gIG1peGluczogW1BhZ2VEYXRhTWl4aW4sIFJvdXRlci5OYXZpZ2F0aW9uXSxcblxuICBnZXRJbml0aWFsU3RhdGU6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNob3dEZXRhaWwgPSB0aGlzLnByb3BzLnNob3dEZXRhaWw7XG4gICAgcmV0dXJuIHsgZGV0YWlsOiBzaG93RGV0YWlsIH07XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6ZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuc2hvd0RldGFpbCkge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldERPTU5vZGUoKTtcbiAgICAgIHZhciBuYXZUeXBlID0gdGhpcy5nZXRQYWdlRGF0YSgpLnR5cGU7XG4gICAgICBpZiAobmF2VHlwZSA9PT0gJ2luaXQnIHx8IG5hdlR5cGUgPT09ICdwdXNoJykge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8od2luZG93LnNjcm9sbFgsIG9mZnNldFRvcChub2RlKSAtIEZJWEVEX0hFQURFUl9IRUlHSFQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOmZ1bmN0aW9uKG5leHRQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMuc2hvd0RldGFpbCAmJiAhdGhpcy5wcm9wcy5zaG93RGV0YWlsKSB7XG4gICAgICB0aGlzLnNjcm9sbFRvID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBkZXRhaWw6IHRydWUgfSk7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZTpmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zY3JvbGxUbykge1xuICAgICAgdGhpcy5zY3JvbGxUbyA9IGZhbHNlO1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldERPTU5vZGUoKTtcbiAgICAgIHZhciBuYXZUeXBlID0gdGhpcy5nZXRQYWdlRGF0YSgpLnR5cGU7XG4gICAgICBpZiAobmF2VHlwZSA9PT0gJ2luaXQnIHx8IG5hdlR5cGUgPT09ICdwdXNoJykge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8od2luZG93LnNjcm9sbFgsIG9mZnNldFRvcChub2RlKSAtIEZJWEVEX0hFQURFUl9IRUlHSFQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB0b2dnbGVEZXRhaWw6ZnVuY3Rpb24oKSB7XG4gICAgLy8gTm90ZTogcmVtb3ZlZCB0aGlzIGJlY2F1c2UgaXQgZHJvcHMgdGhlIFVSTCBiYXIgb24gbW9iaWxlLCBhbmQgdGhhdCdzXG4gICAgLy8gdGhlIG9ubHkgcGxhY2UgaXQncyBjdXJyZW50bHkgYmVpbmcgdXNlZC5cbiAgICAvLyB2YXIgbWVtYmVyID0gdGhpcy5wcm9wcy5tZW1iZXI7XG4gICAgLy8gdmFyIG5hbWUgPSBtZW1iZXIubWVtYmVyTmFtZTtcbiAgICAvLyB2YXIgdHlwZU5hbWUgPSB0aGlzLnByb3BzLnBhcmVudE5hbWU7XG4gICAgLy8gdmFyIHNob3dEZXRhaWwgPSB0aGlzLnByb3BzLnNob3dEZXRhaWw7XG4gICAgLy8gaWYgKCF0aGlzLnN0YXRlLmRldGFpbCkge1xuICAgIC8vICAgdGhpcy5yZXBsYWNlV2l0aCgnLycgKyAodHlwZU5hbWUgPyB0eXBlTmFtZSArICcvJyA6ICcnKSArIG5hbWUgKTtcbiAgICAvLyB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuZGV0YWlsICYmIHNob3dEZXRhaWwpIHtcbiAgICAvLyAgIHRoaXMucmVwbGFjZVdpdGgoJy8nICsgKHR5cGVOYW1lIHx8ICcnKSApO1xuICAgIC8vIH1cbiAgICB0aGlzLnNldFN0YXRlKHsgZGV0YWlsOiAhdGhpcy5zdGF0ZS5kZXRhaWwgfSk7XG4gIH0sXG5cbiAgcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgIHZhciB0eXBlUHJvcE1hcCA9IHRoaXMucHJvcHMudHlwZVByb3BNYXA7XG4gICAgdmFyIG1lbWJlciA9IHRoaXMucHJvcHMubWVtYmVyO1xuICAgIHZhciBtb2R1bGUgPSBtZW1iZXIuaXNTdGF0aWMgPyB0aGlzLnByb3BzLnBhcmVudE5hbWUgOiBudWxsO1xuICAgIHZhciBuYW1lID0gbWVtYmVyLm1lbWJlck5hbWU7XG4gICAgdmFyIGRlZiA9IG1lbWJlci5tZW1iZXJEZWY7XG4gICAgdmFyIGRvYyA9IGRlZi5kb2MgfHwge307XG4gICAgdmFyIGlzUHJvcCA9ICFkZWYuc2lnbmF0dXJlcztcblxuICAgIHZhciB0eXBlSW5mbyA9IG1lbWJlci5pbmhlcml0ZWQgJiYge1xuICAgICAgcHJvcE1hcDogdHlwZVByb3BNYXAsXG4gICAgICBkZWZpbmluZzogbWVtYmVyLmluaGVyaXRlZC5uYW1lLFxuICAgIH07XG5cbiAgICB2YXIgc2hvd0RldGFpbCA9IGlzTW9iaWxlID8gdGhpcy5zdGF0ZS5kZXRhaWwgOiB0cnVlO1xuXG4gICAgdmFyIG1lbWJlckFuY2hvckxpbmsgPSB0aGlzLnByb3BzLnBhcmVudE5hbWUgKyAnLycgKyBuYW1lO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2NsYXNzTmFtZTogXCJpbnRlcmZhY2VNZW1iZXJcIn0sIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDNcIiwge2NsYXNzTmFtZTogXCJtZW1iZXJMYWJlbFwifSwgXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIuTGluaywge1xuICAgICAgICAgICAgdG86ICcvJyArIG1lbWJlckFuY2hvckxpbmssIFxuICAgICAgICAgICAgb25DbGljazogaXNNb2JpbGUgPyB0aGlzLnRvZ2dsZURldGFpbCA6IG51bGxcbiAgICAgICAgICB9LCBcbiAgICAgICAgICAgIChtb2R1bGUgPyBtb2R1bGUgKyAnLicgOiAnJykgKyBuYW1lICsgKGlzUHJvcCA/ICcnIDogJygpJylcbiAgICAgICAgICApXG4gICAgICAgICksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFRyYW5zaXRpb25Hcm91cCwge2NoaWxkRmFjdG9yeTogbWFrZVNsaWRlRG93bn0sIFxuICAgICAgICAgIHNob3dEZXRhaWwgJiYgKFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7a2V5OiBcImRldGFpbFwiLCBjbGFzc05hbWU6IFwiZGV0YWlsXCJ9LCBcbiAgICAgICAgICAgICAgZG9jLnN5bm9wc2lzICYmIChcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1hcmtEb3duLCB7Y2xhc3NOYW1lOiBcInN5bm9wc2lzXCIsIGNvbnRlbnRzOiBkb2Muc3lub3BzaXN9KVxuICAgICAgICAgICAgICApLCBcbiAgICAgICAgICAgICAgaXNQcm9wID8gKFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIsIHtjbGFzc05hbWU6IFwiY29kZUJsb2NrIG1lbWJlclNpZ25hdHVyZVwifSwgXG4gICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1lbWJlckRlZiwge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGU6IG1vZHVsZSwgXG4gICAgICAgICAgICAgICAgICAgIG1lbWJlcjogeyBuYW1lOm5hbWUsIHR5cGU6IGRlZi50eXBlfX1cbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImNvZGVcIiwge2NsYXNzTmFtZTogXCJjb2RlQmxvY2sgbWVtYmVyU2lnbmF0dXJlXCJ9LCBcbiAgICAgICAgICAgICAgICAgIGRlZi5zaWduYXR1cmVzLm1hcChmdW5jdGlvbihjYWxsU2lnLCBpKSAge3JldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FsbFNpZ0RlZiwge1xuICAgICAgICAgICAgICAgICAgICAgIGtleTogaSwgXG4gICAgICAgICAgICAgICAgICAgICAgaW5mbzogdHlwZUluZm8sIFxuICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZTogbW9kdWxlLCBcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLCBcbiAgICAgICAgICAgICAgICAgICAgICBjYWxsU2lnOiBjYWxsU2lnfVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAnXFxuJyxcbiAgICAgICAgICAgICAgICAgIF07fSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICksIFxuICAgICAgICAgICAgICBtZW1iZXIuaW5oZXJpdGVkICYmIChcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCBudWxsLCBcbiAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImluZm9IZWFkZXJcIn0sIFwiSW5oZXJpdGVkIGZyb21cIiksIFxuICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImNvZGVcIiwgbnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLkxpbmssIHt0bzogJy8nICsgbWVtYmVyLmluaGVyaXRlZC5uYW1lICsgJy8nICsgbmFtZX0sIFxuICAgICAgICAgICAgICAgICAgICAgIG1lbWJlci5pbmhlcml0ZWQubmFtZSArICcjJyArIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKSwgXG4gICAgICAgICAgICAgIG1lbWJlci5vdmVycmlkZXMgJiYgKFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIsIG51bGwsIFxuICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg0XCIsIHtjbGFzc05hbWU6IFwiaW5mb0hlYWRlclwifSwgXCJPdmVycmlkZXNcIiksIFxuICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImNvZGVcIiwgbnVsbCwgXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLkxpbmssIHt0bzogJy8nICsgbWVtYmVyLm92ZXJyaWRlcy5uYW1lICsgJy8nICsgbmFtZX0sIFxuICAgICAgICAgICAgICAgICAgICAgIG1lbWJlci5vdmVycmlkZXMubmFtZSArICcjJyArIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKSwgXG4gICAgICAgICAgICAgIGRvYy5ub3RlcyAmJlxuICAgICAgICAgICAgICAgIGRvYy5ub3Rlcy5tYXAoZnVuY3Rpb24obm90ZSwgaSkgIFxuICAgICAgICAgICAgICAgICAge3JldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCB7a2V5OiBpfSwgXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImluZm9IZWFkZXJcIn0sIG5vdGUubmFtZSksIFxuICAgICAgICAgICAgICAgICAgICBub3RlLm5hbWUgPT09ICdhbGlhcycgPyAoXG4gICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImNvZGVcIiwgbnVsbCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENhbGxTaWdEZWYsIHtuYW1lOiBub3RlLmJvZHl9KVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1hcmtEb3duLCB7Y2xhc3NOYW1lOiBcImRpc2N1c3Npb25cIiwgY29udGVudHM6IG5vdGUuYm9keX0pXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICk7fVxuICAgICAgICAgICAgICAgICksIFxuICAgICAgICAgICAgICBkb2MuZGVzY3JpcHRpb24gJiYgKFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIsIG51bGwsIFxuICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg0XCIsIHtjbGFzc05hbWU6IFwiaW5mb0hlYWRlclwifSwgXG4gICAgICAgICAgICAgICAgICAgIGRvYy5kZXNjcmlwdGlvbi5zdWJzdHIoMCwgNSkgPT09ICc8Y29kZSdcbiAgICAgICAgICAgICAgICAgICAgICA/ICdFeGFtcGxlJ1xuICAgICAgICAgICAgICAgICAgICAgIDogJ0Rpc2N1c3Npb24nXG4gICAgICAgICAgICAgICAgICApLCBcbiAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFya0Rvd24sIHtjbGFzc05hbWU6IFwiZGlzY3Vzc2lvblwiLCBjb250ZW50czogZG9jLmRlc2NyaXB0aW9ufSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9LFxufSk7XG5cbmZ1bmN0aW9uIG1ha2VTbGlkZURvd24oY2hpbGQpIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2xpZGVEb3duLCBudWxsLCBjaGlsZCk7XG59XG5cbnZhciBTbGlkZURvd24gPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiU2xpZGVEb3duXCIsXG4gIGNvbXBvbmVudFdpbGxFbnRlcjpmdW5jdGlvbihkb25lKSB7XG4gICAgdGhpcy5zbGlkZShmYWxzZSwgZG9uZSk7XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbExlYXZlOmZ1bmN0aW9uKGRvbmUpIHtcbiAgICB0aGlzLnNsaWRlKHRydWUsIGRvbmUpO1xuICB9LFxuXG4gIHNsaWRlOmZ1bmN0aW9uKHNsaWRpbmdVcCwgZG9uZSkge1xuICAgIHZhciBub2RlID0gdGhpcy5nZXRET01Ob2RlKCk7XG4gICAgbm9kZS5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgdmFyIGhlaWdodCA9IGdldENvbXB1dGVkU3R5bGUobm9kZSkuaGVpZ2h0O1xuICAgIHZhciBzdGFydCA9IHNsaWRpbmdVcCA/IGhlaWdodCA6IDA7XG4gICAgdmFyIGVuZCA9IHNsaWRpbmdVcCA/IDAgOiBoZWlnaHQ7XG4gICAgbm9kZS5zdHlsZS50cmFuc2l0aW9uID0gJyc7XG4gICAgbm9kZS5zdHlsZS5oZWlnaHQgPSBzdGFydDtcbiAgICBub2RlLnN0eWxlLnRyYW5zaXRpb24gPSAnaGVpZ2h0IDAuMzVzIGVhc2UtaW4tb3V0JztcbiAgICB2YXIgZW5kTGlzdGVuZXIgPSBmdW5jdGlvbigpICB7XG4gICAgICBSZWFjdFRyYW5zaXRpb25FdmVudHMucmVtb3ZlRW5kRXZlbnRMaXN0ZW5lcihub2RlLCBlbmRMaXN0ZW5lcik7XG4gICAgICBkb25lKCk7XG4gICAgfTtcbiAgICBSZWFjdFRyYW5zaXRpb25FdmVudHMuYWRkRW5kRXZlbnRMaXN0ZW5lcihub2RlLCBlbmRMaXN0ZW5lcik7XG4gICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpICB7XG4gICAgICBub2RlLnN0eWxlLmhlaWdodCA9IGVuZDtcbiAgICB9LCAxNyk7XG4gIH0sXG5cbiAgcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICB9LFxufSk7XG5cbnZhciBGSVhFRF9IRUFERVJfSEVJR0hUID0gNzU7XG5cbmZ1bmN0aW9uIG9mZnNldFRvcChub2RlKSB7XG4gIHZhciB0b3AgPSAwO1xuICBkbyB7XG4gICAgdG9wICs9IG5vZGUub2Zmc2V0VG9wO1xuICB9IHdoaWxlICgobm9kZSA9IG5vZGUub2Zmc2V0UGFyZW50KSk7XG4gIHJldHVybiB0b3A7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWVtYmVyRG9jO1xuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbnRleHRUeXBlczoge1xuICAgIGdldFBhZ2VEYXRhOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtb3N0IHJlY2VudCBjaGFuZ2UgZXZlbnQuXG4gICAqL1xuICBnZXRQYWdlRGF0YTpmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0LmdldFBhZ2VEYXRhKCk7XG4gIH0sXG59O1xuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSb3V0ZXIgPSByZXF1aXJlKCdyZWFjdC1yb3V0ZXInKTtcbnZhciAkX18wPSAgICAgcmVxdWlyZSgnLi4vLi4vLi4vLi4vJyksTWFwPSRfXzAuTWFwLFNlcT0kX18wLlNlcTtcbnZhciBkZWZzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL2dldFR5cGVEZWZzJyk7XG5cbnZhciBTaWRlQmFyID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiBcIlNpZGVCYXJcIixcbiAgcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgIHZhciB0eXBlID0gZGVmcy5JbW11dGFibGU7XG5cbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7Y2xhc3NOYW1lOiBcInNpZGVCYXJcIn0sIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtjbGFzc05hbWU6IFwidG9vbEJhclwifSwgXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgICBvbkNsaWNrOiB0aGlzLnByb3BzLnRvZ2dsZVNob3dJbkdyb3VwcywgXG4gICAgICAgICAgICBvbktleVByZXNzOiB0aGlzLnByb3BzLnRvZ2dsZVNob3dJbkdyb3Vwc1xuICAgICAgICAgIH0sIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogdGhpcy5wcm9wcy5zaG93SW5Hcm91cHMgJiYgJ3NlbGVjdGVkJ30sIFxuICAgICAgICAgICAgICBcIkdyb3VwZWRcIlxuICAgICAgICAgICAgKSwgXG4gICAgICAgICAgICAnIOKAoiAnLCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IHRoaXMucHJvcHMuc2hvd0luR3JvdXBzIHx8ICdzZWxlY3RlZCd9LCBcbiAgICAgICAgICAgICAgXCJBbHBoYWJldGl6ZWRcIlxuICAgICAgICAgICAgKVxuICAgICAgICAgICksIFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAgICAgb25DbGljazogdGhpcy5wcm9wcy50b2dnbGVTaG93SW5oZXJpdGVkLCBcbiAgICAgICAgICAgIG9uS2V5UHJlc3M6IHRoaXMucHJvcHMudG9nZ2xlU2hvd0luaGVyaXRlZFxuICAgICAgICAgIH0sIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge2NsYXNzTmFtZTogdGhpcy5wcm9wcy5zaG93SW5oZXJpdGVkICYmICdzZWxlY3RlZCd9LCBcbiAgICAgICAgICAgICAgXCJJbmhlcml0ZWRcIlxuICAgICAgICAgICAgKSwgXG4gICAgICAgICAgICAnIOKAoiAnLCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtjbGFzc05hbWU6IHRoaXMucHJvcHMuc2hvd0luaGVyaXRlZCB8fCAnc2VsZWN0ZWQnfSwgXG4gICAgICAgICAgICAgIFwiRGVmaW5lZFwiXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7Y2xhc3NOYW1lOiBcInNjcm9sbENvbnRlbnRcIn0sIFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImdyb3VwVGl0bGVcIn0sIFwiQVBJXCIpLCBcbiAgICAgICAgICBTZXEodHlwZS5tb2R1bGUpXG4gICAgICAgICAgICAuZmxhdE1hcChmdW5jdGlvbih0LCBuYW1lKSAge3JldHVybiBmbGF0dGVuU3VibW9kdWxlcyhNYXAoKSwgdCwgbmFtZSk7fSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24odCwgbmFtZSkgIHtyZXR1cm4gdGhpcy5yZW5kZXJTaWRlQmFyVHlwZShuYW1lLCB0KTt9LmJpbmQodGhpcykpXG4gICAgICAgICAgICAudmFsdWVTZXEoKVxuICAgICAgICAgICAgLnRvQXJyYXkoKVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfSxcblxuICByZW5kZXJTaWRlQmFyVHlwZTpmdW5jdGlvbih0eXBlTmFtZSwgdHlwZSkge1xuICAgIHZhciBpc0ZvY3VzID0gdGhpcy5wcm9wcy5mb2N1cyA9PT0gdHlwZU5hbWU7XG4gICAgdmFyIGlzRnVuY3Rpb24gPSAhdHlwZS5pbnRlcmZhY2UgJiYgIXR5cGUubW9kdWxlO1xuICAgIHZhciBjYWxsID0gdHlwZS5jYWxsO1xuICAgIHZhciBmdW5jdGlvbnMgPSBTZXEodHlwZS5tb2R1bGUpLmZpbHRlcihmdW5jdGlvbih0KSAge3JldHVybiAhdC5pbnRlcmZhY2UgJiYgIXQubW9kdWxlO30pO1xuXG4gICAgdmFyIGxhYmVsID0gdHlwZU5hbWUgKyAoaXNGdW5jdGlvbiA/ICcoKScgOiAnJyk7XG5cbiAgICBpZiAoIWlzRm9jdXMpIHtcbiAgICAgIGxhYmVsID0gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIuTGluaywge3RvOiAnLycgKyB0eXBlTmFtZX0sIGxhYmVsKTtcbiAgICB9XG5cbiAgICB2YXIgbWVtYmVyR3JvdXBzID0gdGhpcy5wcm9wcy5tZW1iZXJHcm91cHM7XG5cbiAgICB2YXIgbWVtYmVycyA9XG4gICAgICAhaXNGb2N1cyB8fCBpc0Z1bmN0aW9uID8gbnVsbCA6IChcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7Y2xhc3NOYW1lOiBcIm1lbWJlcnNcIn0sIFxuICAgICAgICAgIGNhbGwgJiYgKFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwgbnVsbCwgXG4gICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImdyb3VwVGl0bGVcIn0sIFwiQ29uc3RydWN0aW9uXCIpLCBcbiAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCBcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlci5MaW5rLCB7dG86ICcvJyArIHR5cGVOYW1lICsgJy8nICsgdHlwZU5hbWV9LCBcbiAgICAgICAgICAgICAgICAgIHR5cGVOYW1lICsgJygpJ1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICksIFxuXG4gICAgICAgICAgZnVuY3Rpb25zLmNvdW50KCkgPiAwICYmIChcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIsIG51bGwsIFxuICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDRcIiwge2NsYXNzTmFtZTogXCJncm91cFRpdGxlXCJ9LCBcIlN0YXRpYyBNZXRob2RzXCIpLCBcbiAgICAgICAgICAgICAgZnVuY3Rpb25zXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbih0LCBuYW1lKSAgXG4gICAgICAgICAgICAgICAgICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2tleTogbmFtZX0sIFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlci5MaW5rLCB7dG86ICcvJyArIHR5cGVOYW1lICsgJy8nICsgbmFtZX0sIFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGVOYW1lICsgJy4nICsgbmFtZSArICcoKSdcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKTt9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC52YWx1ZVNlcSgpXG4gICAgICAgICAgICAgICAgLnRvQXJyYXkoKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICksIFxuXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwgbnVsbCwgXG4gICAgICAgICAgICBTZXEobWVtYmVyR3JvdXBzKVxuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKG1lbWJlcnMsIHRpdGxlKSBcbiAgICAgICAgICAgICAgICB7cmV0dXJuIG1lbWJlcnMubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgIDogU2VxKFtcbiAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDRcIiwge2tleTogdGl0bGUgfHwgJ01lbWJlcnMnLCBjbGFzc05hbWU6IFwiZ3JvdXBUaXRsZVwifSwgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSB8fCAnTWVtYmVycydcbiAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgIFNlcShtZW1iZXJzKS5tYXAoZnVuY3Rpb24obWVtYmVyKSAgXG4gICAgICAgICAgICAgICAgICAgICAgICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2tleTogbWVtYmVyLm1lbWJlck5hbWV9LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIuTGluaywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiAnLycgKyB0eXBlTmFtZSArICcvJyArIG1lbWJlci5tZW1iZXJOYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lbWJlci5tZW1iZXJOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtZW1iZXIubWVtYmVyRGVmLnNpZ25hdHVyZXMgPyAnKCknIDogJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICk7fVxuICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIF0pO31cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAuZmxhdHRlbigpXG4gICAgICAgICAgICAgIC52YWx1ZVNlcSgpXG4gICAgICAgICAgICAgIC50b0FycmF5KClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7a2V5OiB0eXBlTmFtZX0sIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDJcIiwgbnVsbCwgbGFiZWwpLCBcbiAgICAgICAgbWVtYmVyc1xuICAgICAgKVxuICAgICk7XG4gIH0sXG59KTtcblxuZnVuY3Rpb24gZmxhdHRlblN1Ym1vZHVsZXMobW9kdWxlcywgdHlwZSwgbmFtZSkge1xuICBtb2R1bGVzID0gbW9kdWxlcy5zZXQobmFtZSwgdHlwZSk7XG4gIHJldHVybiB0eXBlLm1vZHVsZVxuICAgID8gU2VxKHR5cGUubW9kdWxlKVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHQpICB7cmV0dXJuIHQuaW50ZXJmYWNlIHx8IHQubW9kdWxlO30pXG4gICAgICAgIC5yZWR1Y2UoXG4gICAgICAgICAgZnVuY3Rpb24obW9kdWxlcywgc3ViVCwgc3ViTmFtZSkgXG4gICAgICAgICAgICB7cmV0dXJuIGZsYXR0ZW5TdWJtb2R1bGVzKG1vZHVsZXMsIHN1YlQsIG5hbWUgKyAnLicgKyBzdWJOYW1lKTt9LFxuICAgICAgICAgIG1vZHVsZXNcbiAgICAgICAgKVxuICAgIDogbW9kdWxlcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaWRlQmFyO1xuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSb3V0ZXIgPSByZXF1aXJlKCdyZWFjdC1yb3V0ZXInKTtcbnZhciAkX18wPSAgICByZXF1aXJlKCcuLi8uLi8uLi8uLi8nKSxTZXE9JF9fMC5TZXE7XG52YXIgJF9fMT0gICAgIHJlcXVpcmUoJy4vRGVmcycpLEludGVyZmFjZURlZj0kX18xLkludGVyZmFjZURlZixDYWxsU2lnRGVmPSRfXzEuQ2FsbFNpZ0RlZjtcbnZhciBNZW1iZXJEb2MgPSByZXF1aXJlKCcuL01lbWJlckRvYycpO1xudmFyIGlzTW9iaWxlID0gcmVxdWlyZSgnLi9pc01vYmlsZScpO1xudmFyIFNpZGVCYXIgPSByZXF1aXJlKCcuL1NpZGVCYXInKTtcbnZhciBNYXJrRG93biA9IHJlcXVpcmUoJy4vTWFya0Rvd24nKTtcbnZhciBEb2NPdmVydmlldyA9IHJlcXVpcmUoJy4vRG9jT3ZlcnZpZXcnKTtcbnZhciBjb2xsZWN0TWVtYmVyR3JvdXBzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL2NvbGxlY3RNZW1iZXJHcm91cHMnKTtcbnZhciBUeXBlS2luZCA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9UeXBlS2luZCcpO1xudmFyIGRlZnMgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvZ2V0VHlwZURlZnMnKTtcblxudmFyIHR5cGVEZWZVUkwgPVxuICAnaHR0cHM6Ly9naXRodWIuY29tL2ltbXV0YWJsZS1qcy9pbW11dGFibGUtanMvYmxvYi9tYWluL3R5cGUtZGVmaW5pdGlvbnMvSW1tdXRhYmxlLmQudHMnO1xudmFyIGlzc3Vlc1VSTCA9ICdodHRwczovL2dpdGh1Yi5jb20vaW1tdXRhYmxlLWpzL2ltbXV0YWJsZS1qcy9pc3N1ZXMnO1xuXG52YXIgRGlzY2xhaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIChcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCB7Y2xhc3NOYW1lOiBcImRpc2NsYWltZXJcIn0sIFxuICAgICAgXCJUaGlzIGRvY3VtZW50YXRpb24gaXMgZ2VuZXJhdGVkIGZyb21cIiwgJyAnLCBcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHtocmVmOiB0eXBlRGVmVVJMfSwgXCJJbW11dGFibGUuZC50c1wiKSwgXCIuIFB1bGwgcmVxdWVzdHMgYW5kXCIsICcgJywgXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7aHJlZjogaXNzdWVzVVJMfSwgXCJJc3N1ZXNcIiksIFwiIHdlbGNvbWUuXCJcbiAgICApXG4gICk7XG59O1xuXG52YXIgVHlwZURvY3VtZW50YXRpb24gPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiVHlwZURvY3VtZW50YXRpb25cIixcbiAgZ2V0SW5pdGlhbFN0YXRlOmZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzaG93SW5oZXJpdGVkOiB0cnVlLFxuICAgICAgc2hvd0luR3JvdXBzOiB0cnVlLFxuICAgIH07XG4gIH0sXG5cbiAgdG9nZ2xlU2hvd0luR3JvdXBzOmZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBzaG93SW5Hcm91cHM6ICF0aGlzLnN0YXRlLnNob3dJbkdyb3VwcyB9KTtcbiAgfSxcblxuICB0b2dnbGVTaG93SW5oZXJpdGVkOmZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBzaG93SW5oZXJpdGVkOiAhdGhpcy5zdGF0ZS5zaG93SW5oZXJpdGVkIH0pO1xuICB9LFxuXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcbiAgICB2YXIgbWVtYmVyTmFtZSA9IHRoaXMucHJvcHMubWVtYmVyTmFtZTtcbiAgICB2YXIgZGVmID0gdGhpcy5wcm9wcy5kZWY7XG5cbiAgICB2YXIgbWVtYmVyR3JvdXBzID0gY29sbGVjdE1lbWJlckdyb3VwcyhkZWYgJiYgZGVmLmludGVyZmFjZSwge1xuICAgICAgc2hvd0luR3JvdXBzOiB0aGlzLnN0YXRlLnNob3dJbkdyb3VwcyxcbiAgICAgIHNob3dJbmhlcml0ZWQ6IHRoaXMuc3RhdGUuc2hvd0luaGVyaXRlZCxcbiAgICB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwsIFxuICAgICAgICBpc01vYmlsZSB8fCAoXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChTaWRlQmFyLCB7XG4gICAgICAgICAgICBmb2N1czogbmFtZSwgXG4gICAgICAgICAgICBtZW1iZXJHcm91cHM6IG1lbWJlckdyb3VwcywgXG4gICAgICAgICAgICB0b2dnbGVTaG93SW5oZXJpdGVkOiB0aGlzLnRvZ2dsZVNob3dJbmhlcml0ZWQsIFxuICAgICAgICAgICAgdG9nZ2xlU2hvd0luR3JvdXBzOiB0aGlzLnRvZ2dsZVNob3dJbkdyb3VwcywgXG4gICAgICAgICAgICBzaG93SW5Hcm91cHM6IHRoaXMuc3RhdGUuc2hvd0luR3JvdXBzLCBcbiAgICAgICAgICAgIHNob3dJbmhlcml0ZWQ6IHRoaXMuc3RhdGUuc2hvd0luaGVyaXRlZH1cbiAgICAgICAgICApXG4gICAgICAgICksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtrZXk6IG5hbWUsIGNsYXNzTmFtZTogXCJkb2NDb250ZW50c1wifSwgXG4gICAgICAgICAgIWRlZiA/IChcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTm90Rm91bmQsIG51bGwpXG4gICAgICAgICAgKSA6ICFuYW1lID8gKFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEb2NPdmVydmlldywge2RlZjogZGVmfSlcbiAgICAgICAgICApIDogIWRlZi5pbnRlcmZhY2UgJiYgIWRlZi5tb2R1bGUgPyAoXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEZ1bmN0aW9uRG9jLCB7bmFtZTogbmFtZSwgZGVmOiBkZWYuY2FsbH0pXG4gICAgICAgICAgKSA6IChcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVHlwZURvYywge1xuICAgICAgICAgICAgICBuYW1lOiBuYW1lLCBcbiAgICAgICAgICAgICAgZGVmOiBkZWYsIFxuICAgICAgICAgICAgICBtZW1iZXJOYW1lOiBtZW1iZXJOYW1lLCBcbiAgICAgICAgICAgICAgbWVtYmVyR3JvdXBzOiBtZW1iZXJHcm91cHN9XG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfSxcbn0pO1xuXG5mdW5jdGlvbiBOb3RGb3VuZCgpIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgXCJOb3QgZm91bmRcIik7XG59XG5cbnZhciBGdW5jdGlvbkRvYyA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJGdW5jdGlvbkRvY1wiLFxuICByZW5kZXI6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5hbWUgPSB0aGlzLnByb3BzLm5hbWU7XG4gICAgdmFyIGRlZiA9IHRoaXMucHJvcHMuZGVmO1xuICAgIHZhciBkb2MgPSBkZWYuZG9jIHx8IHt9O1xuXG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoMVwiLCB7Y2xhc3NOYW1lOiBcInR5cGVIZWFkZXJcIn0sIG5hbWUgKyAnKCknKSwgXG4gICAgICAgIGRvYy5zeW5vcHNpcyAmJiAoXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChNYXJrRG93biwge2NsYXNzTmFtZTogXCJzeW5vcHNpc1wiLCBjb250ZW50czogZG9jLnN5bm9wc2lzfSlcbiAgICAgICAgKSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIsIHtjbGFzc05hbWU6IFwiY29kZUJsb2NrIG1lbWJlclNpZ25hdHVyZVwifSwgXG4gICAgICAgICAgZGVmLnNpZ25hdHVyZXMubWFwKGZ1bmN0aW9uKGNhbGxTaWcsIGkpICB7cmV0dXJuIFtcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FsbFNpZ0RlZiwge2tleTogaSwgbmFtZTogbmFtZSwgY2FsbFNpZzogY2FsbFNpZ30pLFxuICAgICAgICAgICAgJ1xcbicsXG4gICAgICAgICAgXTt9KVxuICAgICAgICApLCBcbiAgICAgICAgZG9jLm5vdGVzICYmXG4gICAgICAgICAgZG9jLm5vdGVzLm1hcChmdW5jdGlvbihub3RlLCBpKSAgXG4gICAgICAgICAgICB7cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIsIHtrZXk6IGl9LCBcbiAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg0XCIsIHtjbGFzc05hbWU6IFwiaW5mb0hlYWRlclwifSwgbm90ZS5uYW1lKSwgXG4gICAgICAgICAgICAgIG5vdGUubmFtZSA9PT0gJ2FsaWFzJyA/IChcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENhbGxTaWdEZWYsIHtuYW1lOiBub3RlLmJvZHl9KVxuICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgIG5vdGUuYm9keVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO31cbiAgICAgICAgICApLCBcbiAgICAgICAgZG9jLmRlc2NyaXB0aW9uICYmIChcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCBudWxsLCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImluZm9IZWFkZXJcIn0sIFxuICAgICAgICAgICAgICBkb2MuZGVzY3JpcHRpb24uc3Vic3RyKDAsIDUpID09PSAnPGNvZGUnXG4gICAgICAgICAgICAgICAgPyAnRXhhbXBsZSdcbiAgICAgICAgICAgICAgICA6ICdEaXNjdXNzaW9uJ1xuICAgICAgICAgICAgKSwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1hcmtEb3duLCB7Y2xhc3NOYW1lOiBcImRpc2N1c3Npb25cIiwgY29udGVudHM6IGRvYy5kZXNjcmlwdGlvbn0pXG4gICAgICAgICAgKVxuICAgICAgICApLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEaXNjbGFpbWVyLCBudWxsKVxuICAgICAgKVxuICAgICk7XG4gIH0sXG59KTtcblxudmFyIFR5cGVEb2MgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiVHlwZURvY1wiLFxuICByZW5kZXI6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5hbWUgPSB0aGlzLnByb3BzLm5hbWU7XG4gICAgdmFyIGRlZiA9IHRoaXMucHJvcHMuZGVmO1xuICAgIHZhciBtZW1iZXJOYW1lID0gdGhpcy5wcm9wcy5tZW1iZXJOYW1lO1xuICAgIHZhciBtZW1iZXJHcm91cHMgPSB0aGlzLnByb3BzLm1lbWJlckdyb3VwcztcblxuICAgIHZhciBkb2MgPSBkZWYuZG9jIHx8IHt9O1xuICAgIHZhciBjYWxsID0gZGVmLmNhbGw7XG4gICAgdmFyIGZ1bmN0aW9ucyA9IFNlcShkZWYubW9kdWxlKS5maWx0ZXIoZnVuY3Rpb24odCkgIHtyZXR1cm4gIXQuaW50ZXJmYWNlICYmICF0Lm1vZHVsZTt9KTtcbiAgICB2YXIgdHlwZXMgPSBTZXEoZGVmLm1vZHVsZSkuZmlsdGVyKGZ1bmN0aW9uKHQpICB7cmV0dXJuIHQuaW50ZXJmYWNlIHx8IHQubW9kdWxlO30pO1xuICAgIHZhciBpbnRlcmZhY2VEZWYgPSBkZWYuaW50ZXJmYWNlO1xuICAgIHZhciB0eXBlUHJvcE1hcCA9IGdldFR5cGVQcm9wTWFwKGludGVyZmFjZURlZik7XG5cbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImgxXCIsIHtjbGFzc05hbWU6IFwidHlwZUhlYWRlclwifSwgbmFtZSksIFxuICAgICAgICBkb2Muc3lub3BzaXMgJiYgKFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTWFya0Rvd24sIHtjbGFzc05hbWU6IFwic3lub3BzaXNcIiwgY29udGVudHM6IGRvYy5zeW5vcHNpc30pXG4gICAgICAgICksIFxuICAgICAgICBpbnRlcmZhY2VEZWYgJiYgKFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjb2RlXCIsIHtjbGFzc05hbWU6IFwiY29kZUJsb2NrIG1lbWJlclNpZ25hdHVyZVwifSwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEludGVyZmFjZURlZiwge25hbWU6IG5hbWUsIGRlZjogaW50ZXJmYWNlRGVmfSlcbiAgICAgICAgICApXG4gICAgICAgICksIFxuXG4gICAgICAgIGRvYy5ub3RlcyAmJlxuICAgICAgICAgIGRvYy5ub3Rlcy5tYXAoZnVuY3Rpb24obm90ZSwgaSkgIFxuICAgICAgICAgICAge3JldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCB7a2V5OiBpfSwgXG4gICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImluZm9IZWFkZXJcIn0sIG5vdGUubmFtZSksIFxuICAgICAgICAgICAgICBub3RlLm5hbWUgPT09ICdhbGlhcycgPyAoXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDYWxsU2lnRGVmLCB7bmFtZTogbm90ZS5ib2R5fSlcbiAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICBub3RlLmJvZHlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTt9XG4gICAgICAgICAgKSwgXG5cbiAgICAgICAgZG9jLmRlc2NyaXB0aW9uICYmIChcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiLCBudWxsLCBcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNFwiLCB7Y2xhc3NOYW1lOiBcImluZm9IZWFkZXJcIn0sIFxuICAgICAgICAgICAgICBkb2MuZGVzY3JpcHRpb24uc3Vic3RyKDAsIDUpID09PSAnPGNvZGUnXG4gICAgICAgICAgICAgICAgPyAnRXhhbXBsZSdcbiAgICAgICAgICAgICAgICA6ICdEaXNjdXNzaW9uJ1xuICAgICAgICAgICAgKSwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1hcmtEb3duLCB7Y2xhc3NOYW1lOiBcImRpc2N1c3Npb25cIiwgY29udGVudHM6IGRvYy5kZXNjcmlwdGlvbn0pXG4gICAgICAgICAgKVxuICAgICAgICApLCBcblxuICAgICAgICB0eXBlcy5jb3VudCgpID4gMCAmJiAoXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwgbnVsbCwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDRcIiwge2NsYXNzTmFtZTogXCJncm91cFRpdGxlXCJ9LCBcIlN1Yi10eXBlc1wiKSwgXG4gICAgICAgICAgICB0eXBlc1xuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHQsIHR5cGVOYW1lKSAgXG4gICAgICAgICAgICAgICAge3JldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtrZXk6IHR5cGVOYW1lfSwgXG4gICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlci5MaW5rLCB7XG4gICAgICAgICAgICAgICAgICAgIHRvOiAnLycgKyAobmFtZSA/IG5hbWUgKyAnLicgKyB0eXBlTmFtZSA6IHR5cGVOYW1lKVxuICAgICAgICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPyBuYW1lICsgJy4nICsgdHlwZU5hbWUgOiB0eXBlTmFtZVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7fVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIC52YWx1ZVNlcSgpXG4gICAgICAgICAgICAgIC50b0FycmF5KClcbiAgICAgICAgICApXG4gICAgICAgICksIFxuXG4gICAgICAgIGNhbGwgJiYgKFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIsIG51bGwsIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg0XCIsIHtjbGFzc05hbWU6IFwiZ3JvdXBUaXRsZVwifSwgXCJDb25zdHJ1Y3Rpb25cIiksIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChNZW1iZXJEb2MsIHtcbiAgICAgICAgICAgICAgc2hvd0RldGFpbDogbmFtZSA9PT0gbWVtYmVyTmFtZSwgXG4gICAgICAgICAgICAgIHBhcmVudE5hbWU6IG5hbWUsIFxuICAgICAgICAgICAgICBtZW1iZXI6IHtcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIG1lbWJlckRlZjogY2FsbCxcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgICksIFxuXG4gICAgICAgIGZ1bmN0aW9ucy5jb3VudCgpID4gMCAmJiAoXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwgbnVsbCwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDRcIiwge2NsYXNzTmFtZTogXCJncm91cFRpdGxlXCJ9LCBcIlN0YXRpYyBtZXRob2RzXCIpLCBcbiAgICAgICAgICAgIGZ1bmN0aW9uc1xuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHQsIGZuTmFtZSkgIFxuICAgICAgICAgICAgICAgIHtyZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChNZW1iZXJEb2MsIHtcbiAgICAgICAgICAgICAgICAgIGtleTogZm5OYW1lLCBcbiAgICAgICAgICAgICAgICAgIHNob3dEZXRhaWw6IGZuTmFtZSA9PT0gbWVtYmVyTmFtZSwgXG4gICAgICAgICAgICAgICAgICBwYXJlbnROYW1lOiBuYW1lLCBcbiAgICAgICAgICAgICAgICAgIG1lbWJlcjoge1xuICAgICAgICAgICAgICAgICAgICBtZW1iZXJOYW1lOiBmbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG1lbWJlckRlZjogdC5jYWxsLFxuICAgICAgICAgICAgICAgICAgICBpc1N0YXRpYzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgKTt9XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgLnZhbHVlU2VxKClcbiAgICAgICAgICAgICAgLnRvQXJyYXkoKVxuICAgICAgICAgIClcbiAgICAgICAgKSwgXG5cbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNlY3Rpb25cIiwgbnVsbCwgXG4gICAgICAgICAgU2VxKG1lbWJlckdyb3VwcylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24obWVtYmVycywgdGl0bGUpIFxuICAgICAgICAgICAgICB7cmV0dXJuIG1lbWJlcnMubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgOiBTZXEoW1xuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDRcIiwge2tleTogdGl0bGUgfHwgJ01lbWJlcnMnLCBjbGFzc05hbWU6IFwiZ3JvdXBUaXRsZVwifSwgXG4gICAgICAgICAgICAgICAgICAgICAgdGl0bGUgfHwgJ01lbWJlcnMnXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIFNlcShtZW1iZXJzKS5tYXAoZnVuY3Rpb24obWVtYmVyKSAgXG4gICAgICAgICAgICAgICAgICAgICAge3JldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE1lbWJlckRvYywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVByb3BNYXA6IHR5cGVQcm9wTWFwLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogbWVtYmVyLm1lbWJlck5hbWUsIFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0RldGFpbDogbWVtYmVyLm1lbWJlck5hbWUgPT09IG1lbWJlck5hbWUsIFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50TmFtZTogbmFtZSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW1iZXI6IG1lbWJlcn1cbiAgICAgICAgICAgICAgICAgICAgICApO31cbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIF0pO31cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5mbGF0dGVuKClcbiAgICAgICAgICAgIC52YWx1ZVNlcSgpXG4gICAgICAgICAgICAudG9BcnJheSgpXG4gICAgICAgICksIFxuXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRGlzY2xhaW1lciwgbnVsbClcbiAgICAgIClcbiAgICApO1xuICB9LFxufSk7XG5cbi8qKlxuICogR2V0IGEgbWFwIGZyb20gc3VwZXIgdHlwZSBwYXJhbWV0ZXIgdG8gY29uY3JldGUgdHlwZSBkZWZpbml0aW9uLiBUaGlzIGlzXG4gKiB1c2VkIHdoZW4gcmVuZGVyaW5nIGluaGVyaXRlZCB0eXBlIGRlZmluaXRpb25zIHRvIGVuc3VyZSBjb250ZXh0dWFsbHlcbiAqIHJlbGV2YW50IGluZm9ybWF0aW9uLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICB0eXBlIEE8VD4gaW1wbGVtZW50cyBCPG51bWJlciwgVD5cbiAqICAgdHlwZSBCPEssIFY+IGltcGxlbWVudHMgQzxLLCBWLCBWPlxuICogICB0eXBlIEM8WCwgWSwgWj5cbiAqXG4gKiBwYXJzZSBDOlxuICogICB7fVxuICpcbiAqIHBhcnNlIEI6XG4gKiAgIHsgQzxYOiBLXG4gKiAgICAgQzxZOiBWXG4gKiAgICAgQzxaOiBWIH1cbiAqXG4gKiBwYXJzZSBBOlxuICogICB7IEI8SzogbnVtYmVyXG4gKiAgICAgQjxWOiBUXG4gKiAgICAgQzxYOiBudW1iZXJcbiAqICAgICBDPFk6IFRcbiAqICAgICBDPFo6IFQgfVxuICovXG5mdW5jdGlvbiBnZXRUeXBlUHJvcE1hcChkZWYpIHtcbiAgdmFyIG1hcCA9IHt9O1xuICBkZWYgJiZcbiAgICBkZWYuZXh0ZW5kcyAmJlxuICAgIGRlZi5leHRlbmRzLmZvckVhY2goZnVuY3Rpb24oZSkgIHtcbiAgICAgIHZhciBzdXBlck1vZHVsZSA9IGRlZnMuSW1tdXRhYmxlO1xuICAgICAgZS5uYW1lLnNwbGl0KCcuJykuZm9yRWFjaChmdW5jdGlvbihwYXJ0KSAge1xuICAgICAgICBzdXBlck1vZHVsZSA9XG4gICAgICAgICAgc3VwZXJNb2R1bGUgJiYgc3VwZXJNb2R1bGUubW9kdWxlICYmIHN1cGVyTW9kdWxlLm1vZHVsZVtwYXJ0XTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHN1cGVySW50ZXJmYWNlID0gc3VwZXJNb2R1bGUgJiYgc3VwZXJNb2R1bGUuaW50ZXJmYWNlO1xuICAgICAgaWYgKHN1cGVySW50ZXJmYWNlKSB7XG4gICAgICAgIHZhciBpbnRlcmZhY2VNYXAgPSBTZXEoc3VwZXJJbnRlcmZhY2UudHlwZVBhcmFtcylcbiAgICAgICAgICAudG9LZXllZFNlcSgpXG4gICAgICAgICAgLmZsaXAoKVxuICAgICAgICAgIC5tYXAoZnVuY3Rpb24oaSkgIHtyZXR1cm4gZS5hcmdzW2ldO30pXG4gICAgICAgICAgLnRvT2JqZWN0KCk7XG4gICAgICAgIFNlcShpbnRlcmZhY2VNYXApLmZvckVhY2goZnVuY3Rpb24odiwgaykgIHtcbiAgICAgICAgICBtYXBbZS5uYW1lICsgJzwnICsga10gPSB2O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHN1cGVyTWFwID0gZ2V0VHlwZVByb3BNYXAoc3VwZXJJbnRlcmZhY2UpO1xuICAgICAgICBTZXEoc3VwZXJNYXApLmZvckVhY2goZnVuY3Rpb24odiwgaykgIHtcbiAgICAgICAgICBtYXBba10gPSB2LmsgPT09IFR5cGVLaW5kLlBhcmFtID8gaW50ZXJmYWNlTWFwW3YucGFyYW1dIDogdjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIHJldHVybiBtYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZURvY3VtZW50YXRpb247XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9PYmplY3QuYXNzaWduJyk7XG52YXIgUm91dGVyID0gcmVxdWlyZSgncmVhY3Qtcm91dGVyJyk7XG52YXIgRG9jSGVhZGVyID0gcmVxdWlyZSgnLi9Eb2NIZWFkZXInKTtcbnZhciBEb2NTZWFyY2ggPSByZXF1aXJlKCcuL0RvY1NlYXJjaC5qcycpO1xudmFyIFR5cGVEb2N1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9UeXBlRG9jdW1lbnRhdGlvbicpO1xudmFyIGRlZnMgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvZ2V0VHlwZURlZnMnKTtcblxudmFyICRfXzA9ICAgICAgUm91dGVyLFJvdXRlPSRfXzAuUm91dGUsRGVmYXVsdFJvdXRlPSRfXzAuRGVmYXVsdFJvdXRlLFJvdXRlSGFuZGxlcj0kX18wLlJvdXRlSGFuZGxlcjtcblxucmVxdWlyZSgnLi4vLi4vLi4vbGliL3J1bmtpdC1lbWJlZCcpO1xuXG52YXIgRG9jdW1lbnRhdGlvbiA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJEb2N1bWVudGF0aW9uXCIsXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEb2NIZWFkZXIsIG51bGwpLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7Y2xhc3NOYW1lOiBcInBhZ2VCb2R5XCIsIGlkOiBcImJvZHlcIn0sIFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge2NsYXNzTmFtZTogXCJjb250ZW50c1wifSwgXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERvY1NlYXJjaCwgbnVsbCksIFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZUhhbmRsZXIsIG51bGwpXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfSxcbn0pO1xuXG52YXIgRG9jRGV0ZXJtaW5lciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtkaXNwbGF5TmFtZTogXCJEb2NEZXRlcm1pbmVyXCIsXG4gIG1peGluczogW1JvdXRlci5TdGF0ZV0sXG5cbiAgcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgIHZhciAkX18wPSAgICAgIGRldGVybWluZURvYyh0aGlzLmdldFBhdGgoKSksZGVmPSRfXzAuZGVmLG5hbWU9JF9fMC5uYW1lLG1lbWJlck5hbWU9JF9fMC5tZW1iZXJOYW1lO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFR5cGVEb2N1bWVudGF0aW9uLCB7ZGVmOiBkZWYsIG5hbWU6IG5hbWUsIG1lbWJlck5hbWU6IG1lbWJlck5hbWV9KTtcbiAgfSxcbn0pO1xuXG5mdW5jdGlvbiBkZXRlcm1pbmVEb2MocGF0aCkge1xuICB2YXIgJF9fMD0gICAgcGF0aC5zcGxpdCgnLycpLG5hbWU9JF9fMFsxXSxtZW1iZXJOYW1lPSRfXzBbMl07XG5cbiAgdmFyIG5hbWVQYXRoID0gbmFtZSA/IG5hbWUuc3BsaXQoJy4nKSA6IFtdO1xuICB2YXIgZGVmID0gbmFtZVBhdGgucmVkdWNlKFxuICAgIGZ1bmN0aW9uKGRlZiwgc3ViTmFtZSkgIHtyZXR1cm4gZGVmICYmIGRlZi5tb2R1bGUgJiYgZGVmLm1vZHVsZVtzdWJOYW1lXTt9LFxuICAgIGRlZnMuSW1tdXRhYmxlXG4gICk7XG5cbiAgcmV0dXJuIHsgZGVmOmRlZiwgbmFtZTpuYW1lLCBtZW1iZXJOYW1lOm1lbWJlck5hbWUgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzcyh7ZGlzcGxheU5hbWU6IFwiZXhwb3J0c1wiLFxuICBjaGlsZENvbnRleHRUeXBlczoge1xuICAgIGdldFBhZ2VEYXRhOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICB9LFxuXG4gIGdldENoaWxkQ29udGV4dDpmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0UGFnZURhdGE6IHRoaXMuZ2V0UGFnZURhdGEsXG4gICAgfTtcbiAgfSxcblxuICBnZXRQYWdlRGF0YTpmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlRGF0YTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsTW91bnQ6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxvY2F0aW9uO1xuICAgIHZhciBzY3JvbGxCZWhhdmlvcjtcblxuICAgIGlmICh3aW5kb3cuZG9jdW1lbnQpIHtcbiAgICAgIGxvY2F0aW9uID0gUm91dGVyLkhhc2hMb2NhdGlvbjtcbiAgICAgIGxvY2F0aW9uLmFkZENoYW5nZUxpc3RlbmVyKGZ1bmN0aW9uKGNoYW5nZSkgIHtcbiAgICAgICAgdGhpcy5wYWdlRGF0YSA9IGFzc2lnbih7fSwgY2hhbmdlLCBkZXRlcm1pbmVEb2MoY2hhbmdlLnBhdGgpKTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgIHRoaXMucGFnZURhdGEgPSAhd2luZG93LmRvY3VtZW50XG4gICAgICAgID8ge31cbiAgICAgICAgOiBhc3NpZ24oXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHBhdGg6IGxvY2F0aW9uLmdldEN1cnJlbnRQYXRoKCksXG4gICAgICAgICAgICAgIHR5cGU6ICdpbml0JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXRlcm1pbmVEb2MobG9jYXRpb24uZ2V0Q3VycmVudFBhdGgoKSlcbiAgICAgICAgICApO1xuXG4gICAgICBzY3JvbGxCZWhhdmlvciA9IHtcbiAgICAgICAgdXBkYXRlU2Nyb2xsUG9zaXRpb246IGZ1bmN0aW9uKHBvc2l0aW9uLCBhY3Rpb25UeXBlKSAge1xuICAgICAgICAgIHN3aXRjaCAoYWN0aW9uVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAncHVzaCc6XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFBhZ2VEYXRhKCkubWVtYmVyTmFtZVxuICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgIDogd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgICAgICAgICAgY2FzZSAncG9wJzpcbiAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5zY3JvbGxUbyhcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA/IHBvc2l0aW9uLnggOiAwLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID8gcG9zaXRpb24ueSA6IDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgUm91dGVyLmNyZWF0ZSh7XG4gICAgICByb3V0ZXM6IChcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZSwge2hhbmRsZXI6IERvY3VtZW50YXRpb24sIHBhdGg6IFwiL1wifSwgXG4gICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEZWZhdWx0Um91dGUsIHtoYW5kbGVyOiBEb2NEZXRlcm1pbmVyfSksIFxuICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGUsIHtuYW1lOiBcInR5cGVcIiwgcGF0aDogXCIvOm5hbWVcIiwgaGFuZGxlcjogRG9jRGV0ZXJtaW5lcn0pLCBcbiAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlLCB7XG4gICAgICAgICAgICBuYW1lOiBcIm1ldGhvZFwiLCBcbiAgICAgICAgICAgIHBhdGg6IFwiLzpuYW1lLzptZW1iZXJOYW1lXCIsIFxuICAgICAgICAgICAgaGFuZGxlcjogRG9jRGV0ZXJtaW5lcn1cbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICBzY3JvbGxCZWhhdmlvcjogc2Nyb2xsQmVoYXZpb3IsXG4gICAgfSkucnVuKGZ1bmN0aW9uKEhhbmRsZXIpICB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgaGFuZGxlcjogSGFuZGxlciB9KTtcbiAgICAgIGlmICh3aW5kb3cuZG9jdW1lbnQpIHtcbiAgICAgICAgd2luZG93LmRvY3VtZW50LnRpdGxlID0gKHRoaXMucGFnZURhdGEubmFtZSArIFwiIOKAlCBJbW11dGFibGUuanNcIik7XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfSxcblxuICAvLyBUT0RPOiByZXBsYWNlIHRoaXMuIHRoaXMgaXMgaGFja3kgYW5kIHByb2JhYmx5IHdyb25nXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6ZnVuY3Rpb24oKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpICB7XG4gICAgICB0aGlzLnBhZ2VEYXRhLnR5cGUgPSAnJztcbiAgICB9LmJpbmQodGhpcyksIDApO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZTpmdW5jdGlvbigpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgIHtcbiAgICAgIHRoaXMucGFnZURhdGEudHlwZSA9ICcnO1xuICAgIH0uYmluZCh0aGlzKSwgMCk7XG4gIH0sXG5cbiAgcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgIHZhciBIYW5kbGVyID0gdGhpcy5zdGF0ZS5oYW5kbGVyO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEhhbmRsZXIsIG51bGwpO1xuICB9LFxufSk7XG4iLCJ2YXIgaXNNb2JpbGUgPVxuICB3aW5kb3cubWF0Y2hNZWRpYSAmJiB3aW5kb3cubWF0Y2hNZWRpYSgnKG1heC1kZXZpY2Utd2lkdGg6IDY4MHB4KScpO1xubW9kdWxlLmV4cG9ydHMgPSBmYWxzZSAmJiAhIShpc01vYmlsZSAmJiBpc01vYmlsZS5tYXRjaGVzKTtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBMb2dvID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiBcIkxvZ29cIixcbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbiAobmV4dFByb3BzKSB7XG4gICAgcmV0dXJuIG5leHRQcm9wcy5vcGFjaXR5ICE9PSB0aGlzLnByb3BzLm9wYWNpdHk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wYWNpdHkgPSB0aGlzLnByb3BzLm9wYWNpdHk7XG4gICAgaWYgKG9wYWNpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3BhY2l0eSA9IDE7XG4gICAgfVxuICAgIHJldHVybiAhdGhpcy5wcm9wcy5pbmxpbmUgPyAoXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7ZmlsbDogdGhpcy5wcm9wcy5jb2xvciwgc3R5bGU6IHsgb3BhY2l0eTogdGhpcy5wcm9wcy5vcGFjaXR5fX0sIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7ZDogXCJNMCwwbDEzLjksMHY0MS4xSDBMMCwwelwifSksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7ZDogXCJNMTguMiwwTDI5LDBsMTAuNywxNS44TDUwLjQsMGwxMC45LDB2NDEuMUg0OC4xVjI2LjNsLTguNCwxMi4zbC04LjQtMTIuM3YxNC44SDE4LjJWMHpcIn0pLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge2Q6IFwiTTY1LjUsMGwxMC45LDBMODcsMTUuOEw5Ny43LDBsMTAuOSwwdjQxLjFIOTUuNFYyNi4zTDg3LDM4LjdsLTguNC0xMi4zdjE0LjhINjUuNVYwelwifSksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgICAgZDogXCJNMTI4LjYsNDIuMmMtMi42LDAtNC45LTAuMy03LTFjLTIuMS0wLjctMy45LTEuNi01LjQtM2MtMS41LTEuMy0yLjYtMy0zLjQtNWMtMC44LTItMS4yLTQuNC0xLjItNy4xVjBcIiArICcgJyArXG4gICAgICAgICAgXCJsMTMuMSwwdjI1LjZjMCwxLjQsMC4zLDIuNSwwLjksMy4zYzAuNiwwLjgsMS42LDEuMSwzLDEuMWMxLjQsMCwyLjQtMC40LDMtMS4xYzAuNi0wLjgsMC45LTEuOSwwLjktMy4zVjBsMTMuMiwwdjI2LjFcIiArICcgJyArXG4gICAgICAgICAgXCJjMCwyLjctMC40LDUuMS0xLjIsNy4xYy0wLjgsMi0yLDMuNy0zLjUsNWMtMS41LDEuMy0zLjMsMi4zLTUuNCwzQzEzMy41LDQxLjgsMTMxLjIsNDIuMiwxMjguNiw0Mi4yelwifVxuICAgICAgICApLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge2Q6IFwiTTE1NS40LDEwLjhoLTcuNlYwbDI4LjcsMHYxMC44aC03LjZ2MzAuM2gtMTMuNlYxMC44elwifSksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgICAgZDogXCJNMTg2LjQsMGw5LjksMGwxNS42LDQxLjFoLTEyLjlsLTEuNC0zLjdoLTEyLjVsLTEuNCwzLjdoLTEyLjlMMTg2LjQsMHogTTE5NC4xLDI4LjRsLTIuOC03LjJsLTIuOCw3LjJcIiArICcgJyArXG4gICAgICAgICAgXCJIMTk0LjF6XCJ9XG4gICAgICAgICksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgICAgZDogXCJNMjEyLjksMEwyMjksMGMyLjEsMCwzLjksMC4yLDUuNiwwLjdjMS43LDAuNSwzLjIsMS4yLDQuNCwyLjFzMi4yLDIuMSwyLjgsMy41YzAuNywxLjQsMSwzLDEsNC44XCIgKyAnICcgK1xuICAgICAgICAgIFwiYzAsMS4zLTAuMiwyLjQtMC41LDMuNGMtMC4zLDAuOS0wLjcsMS43LTEsMi4zYy0wLjUsMC43LTEsMS40LTEuNSwxLjhjMC45LDAuNiwxLjcsMS4zLDIuNSwyLjJjMC42LDAuOCwxLjIsMS44LDEuNywzXCIgKyAnICcgK1xuICAgICAgICAgIFwiYzAuNSwxLjIsMC44LDIuNywwLjgsNC40YzAsMi0wLjMsMy44LTEsNS40Yy0wLjcsMS42LTEuNywzLTMsNC4xYy0xLjMsMS4xLTIuOSwyLTQuNywyLjZjLTEuOSwwLjYtNCwwLjktNi4zLDAuOWgtMTYuOFYwelwiICsgJyAnICtcbiAgICAgICAgICAgXCJNMjMwLjIsMTIuNWMwLTEuOS0xLTIuOC0zLjEtMi44aC0xLjV2NS43aDEuNUMyMjkuMiwxNS40LDIzMC4yLDE0LjQsMjMwLjIsMTIuNXogTTIyNy4xLDMxLjRjMy4xLDAsNC43LTEuMiw0LjctMy42XCIgKyAnICcgK1xuICAgICAgICAgIFwiYzAtMi40LTEuNi0zLjYtNC43LTMuNmgtMS41djcuMkgyMjcuMXpcIn1cbiAgICAgICAgKSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtkOiBcIk0yNDguMywwTDI2MiwwdjMwLjNoMTEuM3YxMC44aC0yNVYwelwifSksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7ZDogXCJNMjc1LjMsMGwyNC4yLDB2MTAuOGgtMTEuMXY0LjZoMTAuOXYxMC4yaC0xMC45djQuN0gzMDB2MTAuOGgtMjQuN1YwelwifSlcbiAgICAgIClcbiAgICApIDogKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIiwge2ZpbGw6IHRoaXMucHJvcHMuY29sb3IsIHN0eWxlOiB7IG9wYWNpdHk6IHRoaXMucHJvcHMub3BhY2l0eX19LCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge2Q6IFwiTTAsMGwxMy45LDB2NDEuMUgwTDAsMHogTTcuOCwzNi4yVjQuOUg2LjJ2MzEuM0g3Ljh6XCJ9KSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgICAgICBkOiBcIk0xOC4yLDBMMjksMGwxMC43LDE1LjhMNTAuNCwwbDEwLjksMHY0MS4xSDQ4LjFWMjYuM2wtOC40LDEyLjNsLTguNC0xMi4zdjE0LjhIMTguMlYweiBNMjUuOSwzNi4yVjcuOVwiICsgJyAnICtcbiAgICAgICAgICBcIkwzOS43LDI4TDUzLjUsNy45djI4LjNoMS42VjQuOWgtMS42TDM5LjcsMjUuMkwyNS45LDQuOWgtMS42djMxLjNIMjUuOXpcIn1cbiAgICAgICAgKSwgXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgICAgICBkOiBcIk02NS41LDBsMTAuOSwwTDg3LDE1LjhMOTcuNywwbDEwLjksMHY0MS4xSDk1LjRWMjYuM0w4NywzOC43bC04LjQtMTIuM3YxNC44SDY1LjVWMHogTTczLjIsMzYuMlY3LjlcIiArICcgJyArXG4gICAgICAgICAgXCJMODcsMjhsMTMuNy0yMC4xdjI4LjNoMS42VjQuOWgtMS42TDg3LDI1LjJMNzMuMiw0LjloLTEuNnYzMS4zSDczLjJ6XCJ9XG4gICAgICAgICksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgICAgZDogXCJNMTI4LjYsNDIuMmMtMi42LDAtNC45LTAuMy03LTFjLTIuMS0wLjctMy45LTEuNi01LjQtM2MtMS41LTEuMy0yLjYtMy0zLjQtNWMtMC44LTItMS4yLTQuNC0xLjItNy4xVjBcIiArICcgJyArXG4gICAgICAgICAgXCJsMTMuMSwwdjI1LjZjMCwxLjQsMC4zLDIuNSwwLjksMy4zYzAuNiwwLjgsMS42LDEuMSwzLDEuMWMxLjQsMCwyLjQtMC40LDMtMS4xYzAuNi0wLjgsMC45LTEuOSwwLjktMy4zVjBsMTMuMiwwdjI2LjFcIiArICcgJyArXG4gICAgICAgICAgXCJjMCwyLjctMC40LDUuMS0xLjIsNy4xYy0wLjgsMi0yLDMuNy0zLjUsNWMtMS41LDEuMy0zLjMsMi4zLTUuNCwzQzEzMy41LDQxLjgsMTMxLjIsNDIuMiwxMjguNiw0Mi4yeiBNMTI4LjYsMzQuOFwiICsgJyAnICtcbiAgICAgICAgICBcImMtNi4yLDAtOS4yLTMtOS4yLTkuMVY0LjloLTEuNnYyMC44YzAsMy41LDAuOSw2LjEsMi44LDcuOWMxLjksMS44LDQuNiwyLjcsOCwyLjdjMy41LDAsNi4yLTAuOSw4LjEtMi43YzEuOS0xLjgsMi44LTQuNSwyLjgtNy45XCIgKyAnICcgK1xuICAgICAgICAgIFwiVjQuOWgtMS43djIwLjhDMTM3LjgsMzEuNywxMzQuOCwzNC44LDEyOC42LDM0Ljh6XCJ9XG4gICAgICAgICksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7ZDogXCJNMTU1LjQsMTAuOGgtNy42VjBsMjguNywwdjEwLjhoLTcuNnYzMC4zaC0xMy42VjEwLjh6IE0xNjMsMzYuMlY2LjRoOC44VjQuOWgtMTkuMnYxLjVoOC44djI5LjhIMTYzelwifSksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgICAgZDogXCJNMTg2LjQsMGw5LjksMGwxNS42LDQxLjFoLTEyLjlsLTEuNC0zLjdoLTEyLjVsLTEuNCwzLjdoLTEyLjlMMTg2LjQsMHogTTE4MCwzNi4ybDEuMi0zLjFoMjAuM2wxLjIsMy4xXCIgKyAnICcgK1xuICAgICAgICAgIFwiaDEuN0wxOTIuNSw0LjloLTIuM2wtMTEuOSwzMS4zSDE4MHogTTE5MS4zLDYuNGw5LjYsMjUuMmgtMTkuMkwxOTEuMyw2LjR6IE0xOTQuMSwyOC40bC0yLjgtNy4ybC0yLjgsNy4ySDE5NC4xelwifVxuICAgICAgICApLCBcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgICAgICAgIGQ6IFwiTTIxMi45LDBMMjI5LDBjMi4xLDAsMy45LDAuMiw1LjYsMC43YzEuNywwLjUsMy4yLDEuMiw0LjQsMi4xczIuMiwyLjEsMi44LDMuNWMwLjcsMS40LDEsMywxLDQuOFwiICsgJyAnICtcbiAgICAgICAgICBcImMwLDEuMy0wLjIsMi40LTAuNSwzLjRjLTAuMywwLjktMC43LDEuNy0xLDIuM2MtMC41LDAuNy0xLDEuNC0xLjUsMS44YzAuOSwwLjYsMS43LDEuMywyLjUsMi4yYzAuNiwwLjgsMS4yLDEuOCwxLjcsM1wiICsgJyAnICtcbiAgICAgICAgICBcImMwLjUsMS4yLDAuOCwyLjcsMC44LDQuNGMwLDItMC4zLDMuOC0xLDUuNGMtMC43LDEuNi0xLjcsMy0zLDQuMWMtMS4zLDEuMS0yLjksMi00LjcsMi42Yy0xLjksMC42LTQsMC45LTYuMywwLjloLTE2LjhWMHpcIiArICcgJyArXG4gICAgICAgICAgIFwiTTIyOCwzNi4yYzMuNiwwLDYuMy0wLjgsOC0yLjNjMS43LTEuNiwyLjYtMy42LDIuNi02LjJjMC0xLjctMC40LTMtMS4xLTRjLTAuNy0xLTEuNS0xLjgtMi4zLTIuNGMtMS0wLjctMi4yLTEuMS0zLjQtMS40XCIgKyAnICcgK1xuICAgICAgICAgIFwiYzEtMC4zLDEuOS0wLjcsMi43LTEuNGMwLjctMC41LDEuMy0xLjMsMS45LTIuMnMwLjgtMi4xLDAuOC0zLjVjMC0yLjYtMC44LTQuNS0yLjUtNS45Yy0xLjYtMS4zLTMuOS0yLTYuNy0yaC04Ljl2MzEuM0gyMjh6XCIgKyAnICcgK1xuICAgICAgICAgICBcIk0yMjAuNywxOS4xVjYuNGw3LjMsMGMyLjcsMCw0LjYsMC42LDUuOCwxLjhjMS4yLDEuMiwxLjgsMi43LDEuOCw0LjZjMCwxLjktMC42LDMuNC0xLjgsNC42Yy0xLjIsMS4yLTMuMSwxLjgtNS44LDEuOEgyMjAuN3pcIiArICcgJyArXG4gICAgICAgICAgIFwiTTIyMC43LDM0LjdWMjAuNmg3LjJjMS4zLDAsMi41LDAuMSwzLjUsMC40YzEuMSwwLjMsMiwwLjcsMi45LDEuMmMwLjgsMC42LDEuNSwxLjMsMS45LDIuMmMwLjUsMC45LDAuNywyLDAuNywzLjJcIiArICcgJyArXG4gICAgICAgICAgXCJjMCwyLjUtMC44LDQuMy0yLjUsNS40Yy0xLjcsMS4xLTMuOSwxLjctNi42LDEuN0gyMjAuN3ogTTIzMC4yLDEyLjVjMC0xLjktMS0yLjgtMy4xLTIuOGgtMS41djUuN2gxLjVcIiArICcgJyArXG4gICAgICAgICAgXCJDMjI5LjIsMTUuNCwyMzAuMiwxNC40LDIzMC4yLDEyLjV6IE0yMjcuMSwzMS40YzMuMSwwLDQuNy0xLjIsNC43LTMuNmMwLTIuNC0xLjYtMy42LTQuNy0zLjZoLTEuNXY3LjJIMjI3LjF6XCJ9XG4gICAgICAgICksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7ZDogXCJNMjQ4LjMsMEwyNjIsMHYzMC4zaDExLjN2MTAuOGgtMjVWMHogTTI2OS45LDM2LjJ2LTEuNWgtMTMuOFY0LjloLTEuNnYzMS4zSDI2OS45elwifSksIFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgICAgZDogXCJNMjc1LjMsMGwyNC4yLDB2MTAuOGgtMTEuMXY0LjZoMTAuOXYxMC4yaC0xMC45djQuN0gzMDB2MTAuOGgtMjQuN1YweiBNMjk1LjQsMzYuMnYtMS41aC0xMi4zVjIxLjJoMTEuN1wiICsgJyAnICtcbiAgICAgICAgICBcInYtMS41aC0xMS43VjYuNGgxMi4zVjQuOWgtMTMuOXYzMS4zSDI5NS40elwifVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfSxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvZ287XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgU1ZHU2V0ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe2Rpc3BsYXlOYW1lOiBcIlNWR1NldFwiLFxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7Y2xhc3NOYW1lOiBcInN2Z1wiLCBzdHlsZTogdGhpcy5wcm9wcy5zdHlsZSwgdmlld0JveDogXCIwIDAgMzAwIDQyLjJcIn0sIFxuICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgICApXG4gICAgKTtcbiAgfSxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNWR1NldDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLkltbXV0YWJsZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLlJlYWN0O1xuIl19"}